{"body":"I&#39;d like to store a JavaScript object in HTML5 `localStorage`, but my object is apparently being converted to a string.\r\n\r\nI can store and retrieve primitive JavaScript types and arrays using `localStorage`, but objects don&#39;t seem to work.  Should they? \r\n\r\nHere&#39;s my code:\r\n\r\n    var testObject = { &#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3 };\r\n    console.log(&#39;typeof testObject: &#39; + typeof testObject);\r\n    console.log(&#39;testObject properties:&#39;);\r\n    for (var prop in testObject) {\r\n        console.log(&#39;  &#39; + prop + &#39;: &#39; + testObject[prop]);\r\n    }\r\n\r\n    // Put the object into storage\r\n    localStorage.setItem(&#39;testObject&#39;, testObject);\r\n\r\n    // Retrieve the object from storage\r\n    var retrievedObject = localStorage.getItem(&#39;testObject&#39;);\r\n\r\n    console.log(&#39;typeof retrievedObject: &#39; + typeof retrievedObject);\r\n    console.log(&#39;Value of retrievedObject: &#39; + retrievedObject);\r\n\r\nThe console output is\r\n\r\n&lt;!-- language: lang-none --&gt;\r\n\r\n    typeof testObject: object\r\n    testObject properties:\r\n      one: 1\r\n      two: 2\r\n      three: 3\r\n    typeof retrievedObject: string\r\n    Value of retrievedObject: [object Object]\r\n\r\nIt looks to me like the `setItem` method is converting the input to a string before storing it.\r\n\r\nI see this behavior in Safari, Chrome, and Firefox, so I assume it&#39;s my misunderstanding of the [HTML5 Web Storage](http://www.w3.org/TR/webstorage/) spec, not a browser-specific bug or limitation.\r\n\r\nI&#39;ve tried to make sense of the *structured clone* algorithm described in http://www.w3.org/TR/html5/infrastructure.html.  I don&#39;t fully understand what it&#39;s saying, but maybe my problem has to do with my object&#39;s properties not being enumerable (???)  \r\n\r\nIs there an easy workaround?\r\n\r\n----\r\n\r\nUpdate: The W3C eventually changed their minds about the structured-clone specification, and decided to change the spec to match the implementations.  See https://www.w3.org/Bugs/Public/show_bug.cgi?id=12111. So this question is no longer 100% valid, but the answers still may be of interest.","title":"Storing Objects in HTML5 localStorage","answers":[{"score":3310,"body_markdown":"Looking at the [Apple][1], [Mozilla][2] and [Mozilla again][3] documentation, the functionality seems to be limited to handle only string key/value pairs.\r\n\r\nA workaround can be to [*stringify*][4] your object before storing it, and later parse it when you retrieve it:\r\n\r\n\r\n    var testObject = { &#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3 };\r\n    \r\n    // Put the object into storage\r\n    localStorage.setItem(&#39;testObject&#39;, JSON.stringify(testObject));\r\n    \r\n    // Retrieve the object from storage\r\n    var retrievedObject = localStorage.getItem(&#39;testObject&#39;);\r\n    \r\n    console.log(&#39;retrievedObject: &#39;, JSON.parse(retrievedObject));\r\n\r\n\r\n  [1]: https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/SafariJSDatabaseGuide/Name-ValueStorage/Name-ValueStorage.html\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem\r\n  [4]: https://www.w3schools.com/js/js_json_stringify.asp"},{"score":225,"body_markdown":"You might find it useful to extend the Storage object with these handy methods:\r\n\r\n\r\n    Storage.prototype.setObject = function(key, value) {\r\n        this.setItem(key, JSON.stringify(value));\r\n    }\r\n\r\n    Storage.prototype.getObject = function(key) {\r\n        return JSON.parse(this.getItem(key));\r\n    }\r\n\r\nThis way you get the functionality that you really wanted even though underneath the API only supports strings."},{"score":636,"body_markdown":"A minor improvement on a [variant][1]:\r\n\r\n    Storage.prototype.setObject = function(key, value) {\r\n        this.setItem(key, JSON.stringify(value));\r\n    }\r\n    \r\n    Storage.prototype.getObject = function(key) {\r\n        var value = this.getItem(key);\r\n        return value &amp;&amp; JSON.parse(value);\r\n    }\r\n\r\nBecause of [short-circuit evaluation](http://en.wikipedia.org/wiki/Short-circuit_evaluation), `getObject()` will *immediately* return `null` if `key` is not in Storage. It also will not throw a `SyntaxError` exception if `value` is `&quot;&quot;` (the empty string; `JSON.parse()` cannot handle that).\r\n\r\n\r\n  [1]: https://stackoverflow.com/a/2010994/59087"},{"score":75,"body_markdown":"Extending the Storage object is an awesome solution. For my API, I have created a facade for localStorage and then check if it is an object or not while setting and getting.\r\n\r\n    var data = {\r\n      set: function(key, value) {\r\n        if (!key || !value) {return;}\r\n        \r\n        if (typeof value === &quot;object&quot;) {\r\n          value = JSON.stringify(value);\r\n        }\r\n        localStorage.setItem(key, value);\r\n      },\r\n      get: function(key) {\r\n        var value = localStorage.getItem(key);\r\n        \r\n        if (!value) {return;}\r\n    \r\n        // assume it is an object that has been stringified\r\n        if (value[0] === &quot;{&quot;) {\r\n          value = JSON.parse(value);\r\n        }\r\n    \r\n        return value;\r\n      }\r\n    }"},{"score":28,"body_markdown":"In theory, it is possible to store objects with functions:\r\n\r\n    function store (a)\r\n    {\r\n      var c = {f: {}, d: {}};\r\n      for (var k in a)\r\n      {\r\n        if (a.hasOwnProperty(k) &amp;&amp; typeof a[k] === &#39;function&#39;)\r\n        {\r\n          c.f[k] = encodeURIComponent(a[k]);\r\n        }\r\n      }\r\n\r\n      c.d = a;\r\n      var data = JSON.stringify(c);\r\n      window.localStorage.setItem(&#39;CODE&#39;, data);\r\n    }\r\n\r\n    function restore ()\r\n    {\r\n      var data = window.localStorage.getItem(&#39;CODE&#39;);\r\n      data = JSON.parse(data);\r\n      var b = data.d;\r\n\r\n      for (var k in data.f)\r\n      {\r\n        if (data.f.hasOwnProperty(k))\r\n        {\r\n          b[k] = eval(&quot;(&quot; + decodeURIComponent(data.f[k]) + &quot;)&quot;);\r\n        }\r\n      }\r\n\r\n      return b;\r\n    }\r\n\r\n**However, Function serialization/deserialization is unreliable because [it is implementation-dependent](http://ecma-international.org/ecma-262/5.1/#sec-15.3.4).**"},{"score":52,"body_markdown":"There is a great library that wraps many solutions so it even supports older browsers called [jStorage][1]\r\n\r\nYou can set an object\r\n\r\n    $.jStorage.set(key, value)\r\n\r\nAnd retrieve it easily\r\n\r\n    value = $.jStorage.get(key)\r\n    value = $.jStorage.get(key, &quot;default value&quot;)\r\n\r\n\r\n  [1]: https://github.com/andris9/jStorage"},{"score":25,"body_markdown":"I arrived at this post after hitting on another post that has been closed as a duplicate of this - titled &#39;how to store an array in localstorage?&#39;.  Which is fine except neither thread actually provides a full answer as to how you can maintain an array in localStorage - however I have managed to craft a solution based on information contained in both threads.\r\n\r\nSo if anyone else is wanting to be able to push/pop/shift items within an array, and they want that array stored in localStorage or indeed sessionStorage, here you go:\r\n\r\n    Storage.prototype.getArray = function(arrayName) {\r\n      var thisArray = [];\r\n      var fetchArrayObject = this.getItem(arrayName);\r\n      if (typeof fetchArrayObject !== &#39;undefined&#39;) {\r\n        if (fetchArrayObject !== null) { thisArray = JSON.parse(fetchArrayObject); }\r\n      }\r\n      return thisArray;\r\n    }\r\n\r\n    Storage.prototype.pushArrayItem = function(arrayName,arrayItem) {\r\n      var existingArray = this.getArray(arrayName);\r\n      existingArray.push(arrayItem);\r\n      this.setItem(arrayName,JSON.stringify(existingArray));\r\n    }\r\n\r\n    Storage.prototype.popArrayItem = function(arrayName) {\r\n      var arrayItem = {};\r\n      var existingArray = this.getArray(arrayName);\r\n      if (existingArray.length &gt; 0) {\r\n        arrayItem = existingArray.pop();\r\n        this.setItem(arrayName,JSON.stringify(existingArray));\r\n      }\r\n      return arrayItem;\r\n    }\r\n\r\n    Storage.prototype.shiftArrayItem = function(arrayName) {\r\n      var arrayItem = {};\r\n      var existingArray = this.getArray(arrayName);\r\n      if (existingArray.length &gt; 0) {\r\n        arrayItem = existingArray.shift();\r\n        this.setItem(arrayName,JSON.stringify(existingArray));\r\n      }\r\n      return arrayItem;\r\n    }\r\n\r\n    Storage.prototype.unshiftArrayItem = function(arrayName,arrayItem) {\r\n      var existingArray = this.getArray(arrayName);\r\n      existingArray.unshift(arrayItem);\r\n      this.setItem(arrayName,JSON.stringify(existingArray));\r\n    }\r\n\r\n    Storage.prototype.deleteArray = function(arrayName) {\r\n      this.removeItem(arrayName);\r\n    }\r\n\r\n\r\nexample usage - storing simple strings in localStorage array:\r\n\r\n    localStorage.pushArrayItem(&#39;myArray&#39;,&#39;item one&#39;);\r\n    localStorage.pushArrayItem(&#39;myArray&#39;,&#39;item two&#39;);\r\n\r\nexample usage - storing objects in sessionStorage array:\r\n\r\n    var item1 = {}; item1.name = &#39;fred&#39;; item1.age = 48;\r\n    sessionStorage.pushArrayItem(&#39;myArray&#39;,item1);\r\n\r\n    var item2 = {}; item2.name = &#39;dave&#39;; item2.age = 22;\r\n    sessionStorage.pushArrayItem(&#39;myArray&#39;,item2);\r\n\r\ncommon methods to manipulate arrays:\r\n\r\n    .pushArrayItem(arrayName,arrayItem); -&gt; adds an element onto end of named array\r\n    .unshiftArrayItem(arrayName,arrayItem); -&gt; adds an element onto front of named array\r\n    .popArrayItem(arrayName); -&gt; removes &amp; returns last array element\r\n    .shiftArrayItem(arrayName); -&gt; removes &amp; returns first array element\r\n    .getArray(arrayName); -&gt; returns entire array\r\n    .deleteArray(arrayName); -&gt; removes entire array from storage\r\n"},{"score":2,"body_markdown":"https://github.com/adrianmay/rhaboo is a localStorage sugar layer that lets you write things like this:\r\n\r\n    var store = Rhaboo.persistent(&#39;Some name&#39;);\r\n    store.write(&#39;count&#39;, store.count ? store.count+1 : 1);\r\n    store.write(&#39;somethingfancy&#39;, {\r\n      one: [&#39;man&#39;, &#39;went&#39;],\r\n      2: &#39;mow&#39;,\r\n      went: [  2, { mow: [&#39;a&#39;, &#39;meadow&#39; ] }, {}  ]\r\n    });\r\n    store.somethingfancy.went[1].mow.write(1, &#39;lawn&#39;);\r\n\r\nIt doesn&#39;t use JSON.stringify/parse because that would be inaccurate and slow on big objects. Instead, each terminal value has its own localStorage entry.\r\n\r\nYou can probably guess that I might have something to do with rhaboo.\r\n"},{"score":66,"body_markdown":"Stringify doesn&#39;t solve all problems\r\n--------------------------------------\r\nIt seems that the answers here don&#39;t cover all types that are possible in JavaScript, so here are some short examples on how to deal with them correctly: \r\n\r\n    //Objects and Arrays:\r\n        var obj = {key: &quot;value&quot;};\r\n        localStorage.object = JSON.stringify(obj);  //Will ignore private members\r\n        obj = JSON.parse(localStorage.object);\r\n    //Boolean:\r\n        var bool = false;\r\n        localStorage.bool = bool;\r\n        bool = (localStorage.bool === &quot;true&quot;);\r\n    //Numbers:\r\n        var num = 42;\r\n        localStorage.num = num;\r\n        num = +localStorage.num;    //short for &quot;num = parseFloat(localStorage.num);&quot;\r\n    //Dates:\r\n        var date = Date.now();\r\n        localStorage.date = date;\r\n        date = new Date(parseInt(localStorage.date));\r\n    //Regular expressions:\r\n        var regex = /^No\\.[\\d]*$/i;     //usage example: &quot;No.42&quot;.match(regex);\r\n        localStorage.regex = regex;\r\n        var components = localStorage.regex.match(&quot;^/(.*)/([a-z]*)$&quot;);\r\n        regex = new RegExp(components[1], components[2]);\r\n    //Functions (not recommended):\r\n        function func(){}\r\n        localStorage.func = func;\r\n        eval( localStorage.func );      //recreates the function with the name &quot;func&quot;\r\n\r\n**I do not recommend** to store functions because `eval()` is evil can lead to issues regarding security, optimisation and debugging.\r\n        In general, `eval()` should never be used in JavaScript code.\r\n\r\nPrivate members\r\n---------------\r\n\r\nThe problem with using `JSON.stringify()` for storing objects is, that this function can not serialise private members.\r\nThis issue can be solved by overwriting the `.toString()` method (which is called implicitly when storing data in web storage):\r\n\r\n    //Object with private and public members:\r\n        function MyClass(privateContent, publicContent){\r\n            var privateMember = privateContent || &quot;defaultPrivateValue&quot;;\r\n            this.publicMember = publicContent  || &quot;defaultPublicValue&quot;;\r\n    \r\n            this.toString = function(){\r\n                return &#39;{&quot;private&quot;: &quot;&#39; + privateMember + &#39;&quot;, &quot;public&quot;: &quot;&#39; + this.publicMember + &#39;&quot;}&#39;;\r\n            };\r\n        }\r\n        MyClass.fromString = function(serialisedString){\r\n            var properties = JSON.parse(serialisedString || &quot;{}&quot;);\r\n            return new MyClass( properties.private, properties.public );\r\n        };\r\n    //Storing:\r\n        var obj = new MyClass(&quot;invisible&quot;, &quot;visible&quot;);\r\n        localStorage.object = obj;\r\n    //Loading:\r\n        obj = MyClass.fromString(localStorage.object);\r\n\r\nCircular references\r\n-------------------\r\n\r\nAnother problem `stringify` can&#39;t deal with are circular references:\r\n\r\n    var obj = {};\r\n    obj[&quot;circular&quot;] = obj;\r\n    localStorage.object = JSON.stringify(obj);  //Fails\r\n\r\nIn this example, `JSON.stringify()` will throw a `TypeError` *&quot;Converting circular structure to JSON&quot;*.\r\n        If storing circular references should be supported, the second parameter of `JSON.stringify()` might be used:\r\n\r\n    var obj = {id: 1, sub: {}};\r\n    obj.sub[&quot;circular&quot;] = obj;\r\n    localStorage.object = JSON.stringify( obj, function( key, value) {\r\n        if( key == &#39;circular&#39;) {\r\n            return &quot;$ref&quot;+value.id+&quot;$&quot;;\r\n        } else {\r\n            return value;\r\n        }\r\n    });\r\n\r\nHowever, finding an efficient solution for storing circular references highly depends on the tasks that need to be solved, and restoring such data is not trivial either.\r\n\r\nThere are already some question on SO dealing with this problem: https://stackoverflow.com/questions/10392293/stringify-javascript-object-with-circular-reference/12659424#12659424"},{"score":1,"body_markdown":"Here some extented version of the code posted by @danott\r\n\r\n&lt;!-- language: lang-js --&gt;\r\nIt&#39;ll also implement **delete** value from localstorage \r\nand shows how to adds a Getter and Setter layer so instead of\r\n\r\n`localstorage.setItem(preview, true)` \r\n\r\nyou can write\r\n \r\n `config.preview = true`\r\n\r\nOkay here were go:\r\n\r\n\tvar PT=Storage.prototype\r\n\r\n\tif (typeof PT._setItem &gt;=&#39;u&#39;) PT._setItem = PT.setItem;\r\n\tPT.setItem = function(key, value)\r\n\t{\r\n\t  if (typeof value &gt;=&#39;u&#39;)//..ndefined\r\n\t\tthis.removeItem(key)\r\n\t  else\r\n\t\tthis._setItem(key, JSON.stringify(value));\r\n\t}\r\n\r\n\tif (typeof PT._getItem &gt;=&#39;u&#39;) PT._getItem = PT.getItem;\r\n\tPT.getItem = function(key)\r\n\t{  \r\n\t  var ItemData = this._getItem(key)\r\n\t  try\r\n\t  {\r\n\t\treturn JSON.parse(ItemData);\r\n\t  }\r\n\t  catch(e)\r\n\t  {\r\n\t\treturn ItemData;\r\n\t  }\r\n\t}\r\n\r\n\t// Aliases for localStorage.set/getItem \r\n\tget =\tlocalStorage.getItem.bind(localStorage)\r\n\tset =\tlocalStorage.setItem.bind(localStorage)\r\n\r\n\t// Create ConfigWrapperObject\r\n\tvar config = {}\r\n\r\n\t// Helper to create getter &amp; setter\r\n\tfunction configCreate(PropToAdd){\r\n\t\tObject.defineProperty( config, PropToAdd, {\r\n\t\t  get: function ()\t\t{ return (\tget(PropToAdd)\t\t) },\r\n\t\t  set: function (val)\t{ \t\t\tset(PropToAdd,\tval ) }\r\n\t\t})\r\n\t}\r\n\t//------------------------------\r\n\r\n\t// Usage Part\r\n\t// Create properties\r\n\tconfigCreate(&#39;preview&#39;)\r\n\tconfigCreate(&#39;notification&#39;)\r\n\t//...\r\n\r\n\t// Config Data transfer\r\n\t//set\r\n\tconfig.preview = true\r\n\r\n\t//get\r\n\tconfig.preview\r\n\r\n\t// delete\r\n\tconfig.preview = undefined\r\n\r\nWell you may strip the aliases part with &lt;code&gt;.bind(...)&lt;/code&gt;. However I just put it in since it&#39;s really good to know about this. I tooked me hours to find out why a simple &lt;code&gt;get = localStorage.getItem;&lt;/code&gt; don&#39;t work"},{"score":14,"body_markdown":"Recommend using an abstraction library for many of the features discussed here as well as better compatibility. Lots of options:\r\n\r\n* [jStorage][2] or [simpleStorage][3] &lt;&lt; my preference\r\n* [localForage][4]\r\n* [alekseykulikov/storage][1]\r\n* [Lawnchair][5]\r\n* [Store.js][6] &lt;&lt; another good option\r\n* [OMG][7]\r\n\r\n  [1]: https://github.com/alekseykulikov/storage\r\n  [2]: https://github.com/andris9/jStorage\r\n  [3]: https://github.com/andris9/simpleStorage\r\n  [4]: https://github.com/mozilla/localForage\r\n  [5]: https://github.com/brianleroux/lawnchair\r\n  [6]: https://github.com/marcuswestin/store.js\r\n  [7]: https://github.com/aaronagray/omg"},{"score":1,"body_markdown":"I made a thing that doesn&#39;t break the existing Storage objects, but creates a wrapper so you can do what you want. The result is a normal object, no methods, with access like any object.\r\n\r\n[The thing I made.](https://github.com/rudiedirkx/ObjectStorage)\r\n\r\nIf you want 1 `localStorage` property to be magic:\r\n\r\n    var prop = ObjectStorage(localStorage, &#39;prop&#39;);\r\n\r\nIf you need several:\r\n\r\n    var storage = ObjectStorage(localStorage, [&#39;prop&#39;, &#39;more&#39;, &#39;props&#39;]);\r\n\r\nEverything you do to `prop`, or the objects **inside** `storage` will be automatically saved into `localStorage`. You&#39;re always playing with a real object, so you can do stuff like this:\r\n\r\n    storage.data.list.push(&#39;more data&#39;);\r\n    storage.another.list.splice(1, 2, {another: &#39;object&#39;});\r\n\r\nAnd every new object **inside** a tracked object will be automatically tracked.\r\n\r\n**The very big downside:** it depends on `Object.observe()` so it has very limited browser support. And it doesn&#39;t look like it&#39;ll be coming for Firefox or Edge anytime soon."},{"score":0,"body_markdown":"To store an object, you could make a letters that you can use to get an object from a string to an object (may not make sense). For example\r\n\r\n    var obj = {a: &quot;lol&quot;, b: &quot;A&quot;, c: &quot;hello world&quot;};\r\n    function saveObj (key){\r\n        var j = &quot;&quot;;\r\n        for(var i in obj){\r\n            j += (i+&quot;|&quot;+obj[i]+&quot;~&quot;);\r\n        }\r\n        localStorage.setItem(key, j);\r\n    } // Saving Method\r\n    function getObj (key){\r\n        var j = {};\r\n        var k = localStorage.getItem(key).split(&quot;~&quot;);\r\n        for(var l in k){\r\n            var m = k[l].split(&quot;|&quot;);\r\n            j[m[0]] = m[1];\r\n        }\r\n        return j;\r\n    }\r\n    saveObj(&quot;obj&quot;); // undefined\r\n    getObj(&quot;obj&quot;); // {a: &quot;lol&quot;, b: &quot;A&quot;, c: &quot;hello world&quot;}\r\n\r\nThis technique will cause some glitches if you use the letter that you used to split the object, and it&#39;s also very experimental."},{"score":4,"body_markdown":"Another option would be to use an existing plugin.\r\n\r\nFor example [persisto][1] is an open source project that provides an easy interface to localStorage/sessionStorage and automates persistence for form fields (input, radio buttons, and checkboxes).\r\n\r\n[![persisto features][2]][2]\r\n\r\n(Disclaimer: I am the author.)\r\n\r\n\r\n  [1]: https://github.com/mar10/persisto\r\n  [2]: http://i.stack.imgur.com/cU5V0.png"},{"score":4,"body_markdown":"You can use [ejson][1] to store the objects as strings.\r\n\r\n&gt; EJSON is an extension of JSON to support more types. It supports all JSON-safe types, as well as:\r\n&gt; \r\n&gt; - Date (JavaScript `Date`)\r\n&gt; - Binary (JavaScript `Uint8Array` or the result of [EJSON.newBinary][2])\r\n&gt; - User-defined types (see [EJSON.addType][3]. For example, [Mongo.ObjectID][4] is implemented this way.)\r\n&gt; \r\n&gt; All EJSON serializations are also valid JSON. For example an object with a date and a binary buffer would be serialized in EJSON as:\r\n&gt;\r\n&gt;     {\r\n&gt;       &quot;d&quot;: {&quot;$date&quot;: 1358205756553},\r\n&gt;       &quot;b&quot;: {&quot;$binary&quot;: &quot;c3VyZS4=&quot;}\r\n&gt;     }\r\n\r\n\r\nHere is my localStorage wrapper using ejson\r\n\r\nhttps://github.com/UziTech/storage.js\r\n\r\nI added some types to my wrapper including regular expressions and functions\r\n\r\n  [1]: https://docs.meteor.com/api/ejson.html\r\n  [2]: https://docs.meteor.com/api/ejson.html#ejson_new_binary\r\n  [3]: https://docs.meteor.com/api/ejson.html#ejson_add_type\r\n  [4]: https://docs.meteor.com/api/ejson.html#mongo_object_id"},{"score":2,"body_markdown":"I made another minimalistic wrapper with only 20 lines of code to allow using it like it should:\r\n\r\n    localStorage.set(&#39;myKey&#39;,{a:[1,2,5], b: &#39;ok&#39;});\r\n    localStorage.has(&#39;myKey&#39;);   // --&gt; true\r\n    localStorage.get(&#39;myKey&#39;);   // --&gt; {a:[1,2,5], b: &#39;ok&#39;}\r\n    localStorage.keys();         // --&gt; [&#39;myKey&#39;]\r\n    localStorage.remove(&#39;myKey&#39;);\r\n\r\nhttps://github.com/zevero/simpleWebstorage"},{"score":6,"body_markdown":"You can use [localDataStorage][1] to transparently store javascript data types (Array, Boolean, Date, Float, Integer, String and Object). It also provides lightweight data obfuscation, automatically compresses strings, facilitates query by key (name) as well as query by (key) value, and helps to enforce segmented shared storage within the same domain by prefixing keys.\r\n\r\n[DISCLAIMER] I am the author of the utility [/DISCLAIMER]\r\n\r\nExamples:\r\n\r\n    localDataStorage.set( &#39;key1&#39;, &#39;Belgian&#39; )\r\n    localDataStorage.set( &#39;key2&#39;, 1200.0047 )\r\n    localDataStorage.set( &#39;key3&#39;, true )\r\n    localDataStorage.set( &#39;key4&#39;, { &#39;RSK&#39; : [1,&#39;3&#39;,5,&#39;7&#39;,9] } )\r\n    localDataStorage.set( &#39;key5&#39;, null )\r\n    \r\n    localDataStorage.get( &#39;key1&#39; )   --&gt;   &#39;Belgian&#39;\r\n    localDataStorage.get( &#39;key2&#39; )   --&gt;   1200.0047\r\n    localDataStorage.get( &#39;key3&#39; )   --&gt;   true\r\n    localDataStorage.get( &#39;key4&#39; )   --&gt;   Object {RSK: Array(5)}\r\n    localDataStorage.get( &#39;key5&#39; )   --&gt;   null\r\nAs you can see, the primitive values are respected.\r\n\r\n\r\n  [1]: https://github.com/macmcmeans/localDataStorage"},{"score":2,"body_markdown":"For Typescript users willing to set and get typed properties:\r\n\r\n    /**\r\n     * Silly wrapper to be able to type the storage keys\r\n     */\r\n    export class TypedStorage&lt;T&gt; {\r\n    \r\n        public removeItem(key: keyof T): void {\r\n            localStorage.removeItem(key);\r\n        }\r\n    \r\n        public getItem&lt;K extends keyof T&gt;(key: K): T[K] | null {\r\n            const data: string | null =  localStorage.getItem(key);\r\n            return JSON.parse(data);\r\n        }\r\n    \r\n        public setItem&lt;K extends keyof T&gt;(key: K, value: T[K]): void {\r\n            const data: string = JSON.stringify(value);\r\n            localStorage.setItem(key, data);\r\n        }\r\n    }\r\n\r\n[Example usage][1]:\r\n\r\n    // write an interface for the storage\r\n    interface MyStore {\r\n       age: number,\r\n       name: string,\r\n       address: {city:string}\r\n    }\r\n    \r\n    const storage: TypedStorage&lt;MyStore&gt; = new TypedStorage&lt;MyStore&gt;();\r\n    \r\n    storage.setItem(&quot;wrong key&quot;, &quot;&quot;); // error unknown key\r\n    storage.setItem(&quot;age&quot;, &quot;hello&quot;); // error, age should be number\r\n    storage.setItem(&quot;address&quot;, {city:&quot;Here&quot;}); // ok\r\n    \r\n    const address: {city:string} = storage.getItem(&quot;address&quot;);\r\n\r\n\r\n  [1]: http://www.typescriptlang.org/play/#src=%2F**%0D%0A%20*%20Silly%20wrapper%20to%20be%20able%20to%20type%20the%20storage%20keys%0D%0A%20*%2F%0D%0Aexport%20class%20TypedStorage%3CT%3E%20%7B%0D%0A%0D%0A%20%20%20%20public%20removeItem(key%3A%20keyof%20T)%3A%20void%20%7B%0D%0A%20%20%20%20%20%20%20%20localStorage.removeItem(key)%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20public%20getItem%3CK%20extends%20keyof%20T%3E(key%3A%20K)%3A%20T%5BK%5D%20%7C%20null%20%7B%0D%0A%20%20%20%20%20%20%20%20const%20data%3A%20string%20%7C%20null%20%3D%20%20localStorage.getItem(key)%3B%0D%0A%20%20%20%20%20%20%20%20return%20JSON.parse(data)%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20public%20setItem%3CK%20extends%20keyof%20T%3E(key%3A%20K%2C%20value%3A%20T%5BK%5D)%3A%20void%20%7B%0D%0A%20%20%20%20%20%20%20%20const%20data%3A%20string%20%3D%20JSON.stringify(value)%3B%0D%0A%20%20%20%20%20%20%20%20localStorage.setItem(key%2C%20data)%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0A%2F%2F%20write%20an%20interface%20for%20the%20storage%0D%0Ainterface%20MyStore%20%7B%0D%0A%20%20%20age%3A%20number%2C%0D%0A%20%20%20name%3A%20string%2C%0D%0A%20%20%20address%3A%20%7Bcity%3Astring%7D%0D%0A%7D%0D%0A%0D%0Aconst%20storage%3A%20TypedStorage%3CMyStore%3E%20%3D%20new%20TypedStorage%3CMyStore%3E()%3B%0D%0A%0D%0Astorage.setItem(%22wrong%20key%22%2C%20%22%22)%3B%20%2F%2F%20error%20unknown%20key%0D%0Astorage.setItem(%22age%22%2C%20%22hello%22)%3B%20%2F%2F%20error%2C%20age%20should%20be%20number%0D%0Astorage.setItem(%22address%22%2C%20%7Bcity%3A%22Here%22%7D)%3B%20%2F%2F%20ok%0D%0A%0D%0Aconst%20address%3A%20%7Bcity%3Astring%7D%20%3D%20storage.getItem(%22address%22)%3B"},{"score":1,"body_markdown":"I found a way to make it work with objects that have cyclic references.\r\n\r\nLet&#39;s make an object with cyclic references.\r\n\r\n    obj = {\r\n    \tL: {\r\n    \t\tL: { v: &#39;lorem&#39; },\r\n    \t\tR: { v: &#39;ipsum&#39; }\r\n    \t},\r\n    \tR: {\r\n    \t\tL: { v: &#39;dolor&#39; },\r\n    \t\tR: {\r\n    \t\t\tL: { v: &#39;sit&#39; },\r\n    \t\t\tR: { v: &#39;amet&#39; }\r\n    \t\t}\r\n    \t}\r\n    }\r\n    obj.R.L.uncle = obj.L;\r\n    obj.R.R.uncle = obj.L;\r\n    obj.R.R.L.uncle = obj.R.L;\r\n    obj.R.R.R.uncle = obj.R.L;\r\n    obj.L.L.uncle = obj.R;\r\n    obj.L.R.uncle = obj.R;\r\n\r\nWe can&#39;t do `JSON.stringify` here, because of the circular references.\r\n\r\n[![circularUncle][1]][1]\r\n\r\n\r\n`LOCALSTORAGE.CYCLICJSON` has `.stringify` and `.parse` just like normal `JSON`, but works with objects with circular references. (&quot;Works&quot; meaning parse(stringify(obj)) and obj are deep equal AND have identical sets of &#39;inner equalities&#39;)\r\n\r\nBut we can just use the shortcuts:\r\n\r\n    LOCALSTORAGE.setObject(&#39;latinUncles&#39;, obj)\r\n    recovered = LOCALSTORAGE.getObject(&#39;latinUncles&#39;)\r\n\r\nThen, `recovered` will be &quot;the same&quot; to obj, in the following sense:\r\n\r\n    [\r\n    obj.L.L.v === recovered.L.L.v,\r\n    obj.L.R.v === recovered.L.R.v,\r\n    obj.R.L.v === recovered.R.L.v,\r\n    obj.R.R.L.v === recovered.R.R.L.v,\r\n    obj.R.R.R.v === recovered.R.R.R.v,\r\n    obj.R.L.uncle === obj.L,\r\n    obj.R.R.uncle === obj.L,\r\n    obj.R.R.L.uncle === obj.R.L,\r\n    obj.R.R.R.uncle === obj.R.L,\r\n    obj.L.L.uncle === obj.R,\r\n    obj.L.R.uncle === obj.R,\r\n    recovered.R.L.uncle === recovered.L,\r\n    recovered.R.R.uncle === recovered.L,\r\n    recovered.R.R.L.uncle === recovered.R.L,\r\n    recovered.R.R.R.uncle === recovered.R.L,\r\n    recovered.L.L.uncle === recovered.R,\r\n    recovered.L.R.uncle === recovered.R\r\n    ]\r\n\r\nHere is the implementation of `LOCALSTORAGE`\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    LOCALSTORAGE = (function(){\r\n      &quot;use strict&quot;;\r\n      var ignore = [Boolean, Date, Number, RegExp, String];\r\n      function primitive(item){\r\n        if (typeof item === &#39;object&#39;){\r\n          if (item === null) { return true; }\r\n          for (var i=0; i&lt;ignore.length; i++){\r\n            if (item instanceof ignore[i]) { return true; }\r\n          }\r\n          return false;\r\n        } else {\r\n          return true;\r\n        }\r\n      }\r\n      function infant(value){\r\n        return Array.isArray(value) ? [] : {};\r\n      }\r\n      function decycleIntoForest(object, replacer) {\r\n        if (typeof replacer !== &#39;function&#39;){\r\n          replacer = function(x){ return x; }\r\n        }\r\n        object = replacer(object);\r\n        if (primitive(object)) return object;\r\n        var objects = [object];\r\n        var forest  = [infant(object)];\r\n        var bucket  = new WeakMap(); // bucket = inverse of objects \r\n        bucket.set(object, 0);    \r\n        function addToBucket(obj){\r\n          var result = objects.length;\r\n          objects.push(obj);\r\n          bucket.set(obj, result);\r\n          return result;\r\n        }\r\n        function isInBucket(obj){ return bucket.has(obj); }\r\n        function processNode(source, target){\r\n          Object.keys(source).forEach(function(key){\r\n            var value = replacer(source[key]);\r\n            if (primitive(value)){\r\n              target[key] = {value: value};\r\n            } else {\r\n              var ptr;\r\n              if (isInBucket(value)){\r\n                ptr = bucket.get(value);\r\n              } else {\r\n                ptr = addToBucket(value);\r\n                var newTree = infant(value);\r\n                forest.push(newTree);\r\n                processNode(value, newTree);\r\n              }\r\n              target[key] = {pointer: ptr};\r\n            }\r\n          });\r\n        }\r\n        processNode(object, forest[0]);\r\n        return forest;\r\n      };\r\n      function deForestIntoCycle(forest) {\r\n        var objects = [];\r\n        var objectRequested = [];\r\n        var todo = [];\r\n        function processTree(idx) {\r\n          if (idx in objects) return objects[idx];\r\n          if (objectRequested[idx]) return null;\r\n          objectRequested[idx] = true;\r\n          var tree = forest[idx];\r\n          var node = Array.isArray(tree) ? [] : {};\r\n          for (var key in tree) {\r\n            var o = tree[key];\r\n            if (&#39;pointer&#39; in o) {\r\n              var ptr = o.pointer;\r\n              var value = processTree(ptr);\r\n              if (value === null) {\r\n                todo.push({\r\n                  node: node,\r\n                  key: key,\r\n                  idx: ptr\r\n                });\r\n              } else {\r\n                node[key] = value;\r\n              }\r\n            } else {\r\n              if (&#39;value&#39; in o) {\r\n                node[key] = o.value;\r\n              } else {\r\n                throw new Error(&#39;unexpected&#39;)\r\n              }\r\n            }\r\n          }\r\n          objects[idx] = node;\r\n          return node;\r\n        }\r\n        var result = processTree(0);\r\n        for (var i = 0; i &lt; todo.length; i++) {\r\n          var item = todo[i];\r\n          item.node[item.key] = objects[item.idx];\r\n        }\r\n        return result;\r\n      };\r\n      var console = {\r\n        log: function(x){\r\n          var the = document.getElementById(&#39;the&#39;);\r\n          the.textContent = the.textContent + &#39;\\n&#39; + x;\r\n    \t},\r\n    \tdelimiter: function(){\r\n          var the = document.getElementById(&#39;the&#39;);\r\n          the.textContent = the.textContent +\r\n    \t\t&#39;\\n*******************************************&#39;;\r\n    \t}\r\n      }\r\n      function logCyclicObjectToConsole(root) {\r\n        var cycleFree = decycleIntoForest(root);\r\n        var shown = cycleFree.map(function(tree, idx) {\r\n          return false;\r\n        });\r\n        var indentIncrement = 4;\r\n        function showItem(nodeSlot, indent, label) {\r\n          var leadingSpaces = &#39; &#39;.repeat(indent);\r\n          var leadingSpacesPlus = &#39; &#39;.repeat(indent + indentIncrement);\r\n          if (shown[nodeSlot]) {\r\n            console.log(leadingSpaces + label + &#39; ... see above (object #&#39; + nodeSlot + &#39;)&#39;);\r\n          } else {\r\n            console.log(leadingSpaces + label + &#39; object#&#39; + nodeSlot);\r\n            var tree = cycleFree[nodeSlot];\r\n            shown[nodeSlot] = true;\r\n            Object.keys(tree).forEach(function(key) {\r\n              var entry = tree[key];\r\n              if (&#39;value&#39; in entry) {\r\n                console.log(leadingSpacesPlus + key + &quot;: &quot; + entry.value);\r\n              } else {\r\n                if (&#39;pointer&#39; in entry) {\r\n                  showItem(entry.pointer, indent + indentIncrement, key);\r\n                }\r\n              }\r\n            });\r\n          }\r\n        }\r\n    \tconsole.delimiter();\r\n        showItem(0, 0, &#39;root&#39;);\r\n      };\r\n      function stringify(obj){\r\n        return JSON.stringify(decycleIntoForest(obj));\r\n      }\r\n      function parse(str){\r\n        return deForestIntoCycle(JSON.parse(str));\r\n      }\r\n      var CYCLICJSON = {\r\n        decycleIntoForest: decycleIntoForest,\r\n        deForestIntoCycle : deForestIntoCycle,\r\n        logCyclicObjectToConsole: logCyclicObjectToConsole,\r\n        stringify : stringify,\r\n        parse : parse\r\n      }\r\n      function setObject(name, object){\r\n        var str = stringify(object);\r\n        localStorage.setItem(name, str);\r\n      }\r\n      function getObject(name){\r\n        var str = localStorage.getItem(name);\r\n        if (str===null) return null;\r\n        return parse(str);\r\n      }\r\n      return {\r\n        CYCLICJSON : CYCLICJSON,\r\n        setObject  : setObject,\r\n        getObject  : getObject\r\n      }\r\n    })();\r\n    obj = {\r\n    \tL: {\r\n    \t\tL: { v: &#39;lorem&#39; },\r\n    \t\tR: { v: &#39;ipsum&#39; }\r\n    \t},\r\n    \tR: {\r\n    \t\tL: { v: &#39;dolor&#39; },\r\n    \t\tR: {\r\n    \t\t\tL: { v: &#39;sit&#39; },\r\n    \t\t\tR: { v: &#39;amet&#39; }\r\n    \t\t}\r\n    \t}\r\n    }\r\n    obj.R.L.uncle = obj.L;\r\n    obj.R.R.uncle = obj.L;\r\n    obj.R.R.L.uncle = obj.R.L;\r\n    obj.R.R.R.uncle = obj.R.L;\r\n    obj.L.L.uncle = obj.R;\r\n    obj.L.R.uncle = obj.R;\r\n\r\n    // LOCALSTORAGE.setObject(&#39;latinUncles&#39;, obj)\r\n    // recovered = LOCALSTORAGE.getObject(&#39;latinUncles&#39;)\r\n    // localStorage not available inside fiddle ):\r\n    LOCALSTORAGE.CYCLICJSON.logCyclicObjectToConsole(obj)\r\n    putIntoLS = LOCALSTORAGE.CYCLICJSON.stringify(obj);\r\n    recovered = LOCALSTORAGE.CYCLICJSON.parse(putIntoLS);\r\n    LOCALSTORAGE.CYCLICJSON.logCyclicObjectToConsole(recovered);\r\n\r\n    var the = document.getElementById(&#39;the&#39;);\r\n    the.textContent = the.textContent + &#39;\\n\\n&#39; +\r\n    JSON.stringify(\r\n    [\r\n    obj.L.L.v === recovered.L.L.v,\r\n    obj.L.R.v === recovered.L.R.v,\r\n    obj.R.L.v === recovered.R.L.v,\r\n    obj.R.R.L.v === recovered.R.R.L.v,\r\n    obj.R.R.R.v === recovered.R.R.R.v,\r\n    obj.R.L.uncle === obj.L,\r\n    obj.R.R.uncle === obj.L,\r\n    obj.R.R.L.uncle === obj.R.L,\r\n    obj.R.R.R.uncle === obj.R.L,\r\n    obj.L.L.uncle === obj.R,\r\n    obj.L.R.uncle === obj.R,\r\n    recovered.R.L.uncle === recovered.L,\r\n    recovered.R.R.uncle === recovered.L,\r\n    recovered.R.R.L.uncle === recovered.R.L,\r\n    recovered.R.R.R.uncle === recovered.R.L,\r\n    recovered.L.L.uncle === recovered.R,\r\n    recovered.L.R.uncle === recovered.R\r\n    ]\r\n    )\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;pre id=&#39;the&#39;&gt;&lt;/pre&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/4taQx.png"},{"score":3,"body_markdown":"You cannot store key value without **String** Format.\r\n\r\n**LocalStorage** only support String format for key/value.\r\n\r\nThat is why you should convert your data to string whatever it is *Array* or *Object*.\r\n\r\nTo Store data in localStorage first of all stringify it using **JSON.stringify()** method.\r\n    \r\n    var myObj = [{name:&quot;test&quot;, time:&quot;Date 2017-02-03T08:38:04.449Z&quot;}];\r\n    localStorage.setItem(&#39;item&#39;, JSON.stringify(myObj));\r\n\r\nThen when you want to retrieve data , you need to parse the String to Object again.\r\n\r\n    var getObj = JSON.parse(localStorage.getItem(&#39;item&#39;));\r\n\r\nHope it helps."},{"score":-2,"body_markdown":"localStorage.setItem(&#39;user&#39;, JSON.stringify(user));\r\n\r\nThen to retrieve it from the store and convert to an object again:\r\n\r\nvar user = JSON.parse(localStorage.getItem(&#39;user&#39;));\r\n\r\nIf we need to delete all entries of the store we can simply do:\r\n\r\nlocalStorage.clear();"},{"score":0,"body_markdown":"# Circular References\r\n\r\nIn this answer I focus on data-only objects (without functions etc.) with circular references and develop ideas mention by [maja](https://stackoverflow.com/a/27013704/860099) and [mathheadinclouds](https://stackoverflow.com/a/58825573/860099) (I use his test case and \r\nmy code is several times shorter). Actually we can use JSON.stringify with proper [replacer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) - if source object contains multi-references to some object, or contains circular references then we reference it by special path-string (similar to [JSONPath](https://jsonpath.com/)) \r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // JSON.strigify replacer for objects with circ ref\r\n    function refReplacer() {\r\n      let m = new Map(), v= new Map(), init = null;\r\n\r\n      return function(field, value) {\r\n        let p= m.get(this) + (Array.isArray(this) ? `[${field}]` : &#39;.&#39; + field); \r\n        let isComplex= value===Object(value)\r\n        \r\n        if (isComplex) m.set(value, p);  \r\n        \r\n        let pp = v.get(value)||&#39;&#39;;\r\n        let path = p.replace(/undefined\\.\\.?/,&#39;&#39;);\r\n        let val = pp ? `#REF:${pp[0]==&#39;[&#39; ? &#39;$&#39;:&#39;$.&#39;}${pp}` : value;\r\n        \r\n        !init ? (init=value) : (val===init ? val=&quot;#REF:$&quot; : 0);\r\n        if(!pp &amp;&amp; isComplex) v.set(value, path);\r\n       \r\n        return val;\r\n      }\r\n    }\r\n\r\n\r\n    // ---------------\r\n    // TEST\r\n    // ---------------\r\n\r\n    // gen obj with duplicate/circular references\r\n    let obj = {\r\n        L: {\r\n            L: { v: &#39;lorem&#39; },\r\n            R: { v: &#39;ipsum&#39; }\r\n        },\r\n        R: {\r\n            L: { v: &#39;dolor&#39; },\r\n            R: {\r\n                L: { v: &#39;sit&#39; },\r\n                R: { v: &#39;amet&#39; }\r\n            }\r\n        }\r\n    }\r\n    obj.R.L.uncle = obj.L;\r\n    obj.R.R.uncle = obj.L;\r\n    obj.R.R.L.uncle = obj.R.L;\r\n    obj.R.R.R.uncle = obj.R.L;\r\n    obj.L.L.uncle = obj.R;\r\n    obj.L.R.uncle = obj.R;\r\n    testObject = obj;\r\n\r\n    let json = JSON.stringify(testObject, refReplacer(), 4);\r\n\r\n    console.log(&quot;Test Object\\n&quot;, testObject);\r\n    console.log(&quot;JSON with JSONpath references\\n&quot;,json);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\nParse such json with JSONpath-like references\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // parse json with JSONpath references to object\r\n    function parseRefJSON(json) {\r\n      let objToPath = new Map();\r\n      let pathToObj = new Map();\r\n      let o = JSON.parse(json);\r\n      \r\n      let traverse = (parent, field) =&gt; {\r\n        let obj = parent;\r\n        let path = &#39;#REF:$&#39;;\r\n\r\n        if (field !== undefined) {\r\n          obj = parent[field];\r\n          path = objToPath.get(parent) + (Array.isArray(parent) ? `[${field}]` : `${field?&#39;.&#39;+field:&#39;&#39;}`);\r\n        }\r\n\r\n        objToPath.set(obj, path);\r\n        pathToObj.set(path, obj);\r\n        \r\n        let ref = pathToObj.get(obj);\r\n        if (ref) parent[field] = ref;\r\n\r\n        for (let f in obj) if (obj === Object(obj)) traverse(obj, f);\r\n      }\r\n      \r\n      traverse(o);\r\n      return o;\r\n    }\r\n\r\n\r\n    // ---------------\r\n    // TEST 1\r\n    // ---------------\r\n\r\n    let json = `\r\n    {\r\n        &quot;L&quot;: {\r\n            &quot;L&quot;: {\r\n                &quot;v&quot;: &quot;lorem&quot;,\r\n                &quot;uncle&quot;: {\r\n                    &quot;L&quot;: {\r\n                        &quot;v&quot;: &quot;dolor&quot;,\r\n                        &quot;uncle&quot;: &quot;#REF:$.L&quot;\r\n                    },\r\n                    &quot;R&quot;: {\r\n                        &quot;L&quot;: {\r\n                            &quot;v&quot;: &quot;sit&quot;,\r\n                            &quot;uncle&quot;: &quot;#REF:$.L.L.uncle.L&quot;\r\n                        },\r\n                        &quot;R&quot;: {\r\n                            &quot;v&quot;: &quot;amet&quot;,\r\n                            &quot;uncle&quot;: &quot;#REF:$.L.L.uncle.L&quot;\r\n                        },\r\n                        &quot;uncle&quot;: &quot;#REF:$.L&quot;\r\n                    }\r\n                }\r\n            },\r\n            &quot;R&quot;: {\r\n                &quot;v&quot;: &quot;ipsum&quot;,\r\n                &quot;uncle&quot;: &quot;#REF:$.L.L.uncle&quot;\r\n            }\r\n        },\r\n        &quot;R&quot;: &quot;#REF:$.L.L.uncle&quot;\r\n    }`;\r\n\r\n    let testObject = parseRefJSON(json);\r\n\r\n    console.log(&quot;Test Object\\n&quot;, testObject);\r\n\r\n\r\n    // ---------------\r\n    // TEST 2\r\n    // ---------------\r\n\r\n    console.log(&#39;Tests from mathheadinclouds anser:&#39;);\r\n\r\n    let recovered = testObject;\r\n\r\n    let obj = { // original object\r\n        L: {\r\n            L: { v: &#39;lorem&#39; },\r\n            R: { v: &#39;ipsum&#39; }\r\n        },\r\n        R: {\r\n            L: { v: &#39;dolor&#39; },\r\n            R: {\r\n                L: { v: &#39;sit&#39; },\r\n                R: { v: &#39;amet&#39; }\r\n            }\r\n        }\r\n    }\r\n    obj.R.L.uncle = obj.L;\r\n    obj.R.R.uncle = obj.L;\r\n    obj.R.R.L.uncle = obj.R.L;\r\n    obj.R.R.R.uncle = obj.R.L;\r\n    obj.L.L.uncle = obj.R;\r\n    obj.L.R.uncle = obj.R;\r\n\r\n    [\r\n      obj.L.L.v === recovered.L.L.v,\r\n      obj.L.R.v === recovered.L.R.v,\r\n      obj.R.L.v === recovered.R.L.v,\r\n      obj.R.R.L.v === recovered.R.R.L.v,\r\n      obj.R.R.R.v === recovered.R.R.R.v,\r\n      obj.R.L.uncle === obj.L,\r\n      obj.R.R.uncle === obj.L,\r\n      obj.R.R.L.uncle === obj.R.L,\r\n      obj.R.R.R.uncle === obj.R.L,\r\n      obj.L.L.uncle === obj.R,\r\n      obj.L.R.uncle === obj.R,\r\n      recovered.R.L.uncle === recovered.L,\r\n      recovered.R.R.uncle === recovered.L,\r\n      recovered.R.R.L.uncle === recovered.R.L,\r\n      recovered.R.R.R.uncle === recovered.R.L,\r\n      recovered.L.L.uncle === recovered.R,\r\n      recovered.L.R.uncle === recovered.R\r\n    ].forEach(x=&gt; console.log(&#39;test pass: &#39;+x));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nTo load/save result json into storage use following code\r\n\r\n    localStorage.myObject = JSON.stringify(testObject, refReplacer());  // save\r\n    testObject = parseRefJSON(localStorage.myObject);                   // load"}],"score":2627}