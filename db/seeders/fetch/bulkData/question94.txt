{"body":"How does data binding work in the `AngularJS` framework?\r\n\r\nI haven&#39;t found technical details on [their site][1]. It&#39;s more or less clear how it works when data is propagated from view to model. But how does AngularJS track changes of model properties without setters and getters?\r\n\r\nI found that there are [JavaScript watchers][2] that may do this work. But they are not supported in [Internet&amp;nbsp;Explorer&amp;nbsp;6][3] and [Internet&amp;nbsp;Explorer&amp;nbsp;7][4]. So how does AngularJS know that I changed for example the following and reflected this change on a view?\r\n\r\n    myobject.myproperty=&quot;new value&quot;;\r\n\r\n  [1]: http://angularjs.org\r\n  [2]: https://stackoverflow.com/questions/1029241/javascript-object-watch-for-all-browsers\r\n  [3]: http://en.wikipedia.org/wiki/Internet_Explorer_6\r\n  [4]: http://en.wikipedia.org/wiki/Internet_Explorer_7\r\n","title":"How does data binding work in AngularJS?","answers":[{"score":82,"body_markdown":"This is my basic understanding. It may well be wrong!\r\n\r\n 1. Items are watched by passing a function (returning the thing to be\r\n    watched) to the `$watch` method.\r\n 2. Changes to watched items must be made within a block of code\r\n    wrapped by the `$apply` method.\r\n 3. At the end of the `$apply` the `$digest` method is invoked which goes\r\n    through each of the watches and checks to see if they changed since\r\n    last time the `$digest` ran.\r\n 4. If any changes are found then the digest is invoked again until all changes stabilize.\r\n\r\nIn normal development, data-binding syntax in the HTML tells the AngularJS compiler to create the watches for you and controller methods are run inside `$apply` already. So to the application developer it is all transparent.\r\n"},{"score":2752,"body_markdown":"AngularJS remembers the value and compares it to a previous value. This is basic dirty-checking. If there is a change in value, then it fires the change event.\r\n\r\nThe `$apply()` method, which is what you call when you are transitioning from a non-AngularJS world into an AngularJS world, calls `$digest()`. A digest is just plain old dirty-checking. It works on all browsers and is totally predictable.\r\n\r\nTo contrast dirty-checking (AngularJS) vs change listeners ([KnockoutJS][1] and [Backbone.js][2]): While dirty-checking may seem simple, and even inefficient (I will address that later), it turns out that it is semantically correct all the time, while change listeners have lots of weird corner cases and need things like dependency tracking to make it more semantically correct. KnockoutJS dependency tracking is a clever feature for a problem which AngularJS does not have.\r\n\r\n# Issues with change listeners:\r\n\r\n  * The syntax is atrocious, since browsers do not support it natively. Yes, there are proxies, but they are not semantically correct in all cases, and of course there are no proxies on old browsers. The bottom line is that dirty-checking allows you to do [POJO][3], whereas KnockoutJS and Backbone.js force you to inherit from their classes, and access your data through accessors.\r\n  * Change coalescence. Suppose you have an array of items. Say you want to add items into an array, as you are looping to add, each time you add you are firing events on change, which is rendering the UI. This is very bad for performance. What you want is to update the UI only once, at the end. The change events are too fine-grained.\r\n  * Change listeners fire immediately on a setter, which is a problem, since the change listener can further change data, which fires more change events. This is bad since on your stack you may have several change events happening at once. Suppose you have two arrays which need to be kept in sync for whatever reason. You can only add to one or the other, but each time you add you fire a change event, which now has an inconsistent view of the world. This is a very similar problem to thread locking, which JavaScript avoids since each callback executes exclusively and to completion. Change events break this since setters can have far-reaching consequences which are not intended and non obvious, which creates the thread problem all over again. It turns out that what you want to do is to delay the listener execution, and guarantee, that only one listener runs at a time, hence any code is free to change data, and it knows that no other code runs while it is doing so.\r\n\r\n# What about performance?\r\n\r\nSo it may seem that we are slow, since dirty-checking is inefficient. This is where we need to look at real numbers rather than just have theoretical arguments, but first let&#39;s define some constraints.\r\n\r\nHumans are:\r\n\r\n * *Slow* — Anything faster than 50&amp;nbsp;ms is imperceptible to humans and thus can be considered as &quot;instant&quot;.\r\n\r\n * *Limited* — You can&#39;t really show more than about 2000 pieces of information to a human on a single page. Anything more than that is really bad UI, and humans can&#39;t process this anyway.\r\n\r\nSo the real question is this: How many comparisons can you do on a browser in 50&amp;nbsp;ms? This is a hard question to answer as many factors come into play, but here is a test case: http://jsperf.com/angularjs-digest/6 which creates 10,000 watchers. On a modern browser this takes just under 6&amp;nbsp;ms. On [Internet&amp;nbsp;Explorer&amp;nbsp;8][4] it takes about 40&amp;nbsp;ms. As you can see, this is not an issue even on slow browsers these days. There is a caveat: The comparisons need to be simple to fit into the time limit... Unfortunately it is way too easy to add a slow comparison into AngularJS, so it is easy to build slow applications when you don&#39;t know what you are doing. But we hope to have an answer by providing an instrumentation module, which would show you which are the slow comparisons.\r\n\r\nIt turns out that video games and GPUs use the dirty-checking approach, specifically because it is consistent. As long as they get over the monitor refresh rate (typically 50-60 Hz, or every 16.6-20 ms), any performance over that is a waste, so you&#39;re better off drawing more stuff, than getting FPS higher.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/KnockoutJS\r\n  [2]: https://en.wikipedia.org/wiki/Backbone.js\r\n  [3]: http://en.wikipedia.org/wiki/Plain_Old_Java_Object\r\n  [4]: http://en.wikipedia.org/wiki/Internet_Explorer_8\r\n"},{"score":63,"body_markdown":"I wondered this myself for a while. Without setters how does `AngularJS` notice changes to the `$scope` object? Does it poll them?\r\n\r\nWhat it actually does is this: Any &quot;normal&quot; place you modify the model was already called from the guts of `AngularJS`, so it automatically calls `$apply` for you after your code runs. Say your controller has a method that&#39;s hooked up to `ng-click` on some element. Because `AngularJS` wires the calling of that method together for you, it has a chance to do an `$apply` in the appropriate place. Likewise, for expressions that appear right in the views, those are executed by `AngularJS` so it does the `$apply`.\r\n\r\nWhen the documentation talks about having to call `$apply` manually for code _outside of `AngularJS`_, it&#39;s talking about code which, when run, doesn&#39;t stem from `AngularJS` itself in the call stack.\r\n"},{"score":325,"body_markdown":"Misko already gave an excellent description of how the data bindings work, but I would like to add my view on the performance issue with the data binding.\r\n\r\nAs Misko stated, around 2000 bindings are where you start to see problems, but you shouldn&#39;t have more than 2000 pieces of information on a page anyway. This may be true, but not every data-binding is visible to the user. Once you start building any sort of widget or data grid with two-way binding you can *easily* hit 2000 bindings, without having a bad UX.\r\n\r\nConsider, for example, a combo box where you can type text to filter the available options. This sort of control could have ~150 items and still be highly usable. If it has some extra feature (for example a specific class on the currently selected option) you start to get 3-5 bindings per option. Put three of these widgets on a page (e.g. one to select a country, the other to select a city in the said country, and the third to select a hotel) and you are somewhere between 1000 and 2000 bindings already.\r\n\r\nOr consider a data-grid in a corporate web application. 50 rows per page is not unreasonable, each of which could have 10-20 columns. If you build this with ng-repeats, and/or have information in some cells which uses some bindings, you could be approaching 2000 bindings with this grid alone.\r\n\r\nI find this to be a **huge** problem when working with AngularJS, and the only solution I&#39;ve been able to find so far is to construct widgets without using two-way binding, instead of using ngOnce, deregistering watchers and similar tricks, or construct directives which build the DOM with jQuery and DOM manipulation. I feel this defeats the purpose of using Angular in the first place.\r\n\r\nI would love to hear suggestions on other ways to handle this, but then maybe I should write my own question. I wanted to put this in a comment, but it turned out to be way too long for that...\r\n\r\n**TL;DR** &lt;br /&gt;\r\nThe data binding can cause performance issues on complex pages."},{"score":7,"body_markdown":"It happened that I needed to link a data model of a person with a form, what I did was a direct mapping of the data with the form.\r\n\r\nFor example if the model had something like:\r\n\r\n    $scope.model.people.name\r\n\r\nThe control input of the form:\r\n\r\n    &lt;input type=&quot;text&quot; name=&quot;namePeople&quot; model=&quot;model.people.name&quot;&gt;\r\n\r\nThat way if you modify the value of the object controller, this will be reflected automatically in the view.\r\n\r\nAn example where I passed the model is updated from server data is when you ask for a zip code and zip code based on written loads a list of colonies and cities associated with that view, and by default set the first value with the user. And this I worked very well, what does happen, is that `angularJS` sometimes takes a few seconds to refresh the model, to do this you can put a spinner while displaying the data."},{"score":161,"body_markdown":"## By dirty checking the `$scope` object\n\nAngular maintains a simple `array` of watchers in the `$scope` objects. If you inspect any `$scope` you will find that it contains an `array` called `$$watchers`. \n\nEach watcher is an `object` that contains among other things\n\n1. An expression which the watcher is monitoring. This might just be an `attribute` name, or something more complicated.\n2. A last known value of the expression. This can be checked against the current computed value of the expression. If the values differ the watcher will trigger the function and mark the `$scope` as dirty.\n3. A function which will be executed if the watcher is dirty.\n\n## How watchers are defined\n\nThere are many different ways of defining a watcher in AngularJS. \n\n* You can explicitly `$watch` an `attribute` on `$scope`. \n\n        $scope.$watch(&#39;person.username&#39;, validateUnique);\n\n* You can place a `{{}}` interpolation in your template (a watcher will be created for you on the current `$scope`). \n\n        &lt;p&gt;username: {{person.username}}&lt;/p&gt;\n\n* You can ask a directive such as `ng-model` to define the watcher for you.\n\n        &lt;input ng-model=&quot;person.username&quot; /&gt;\n\n## The `$digest` cycle checks all watchers against their last value\n\nWhen we interact with AngularJS through the normal channels (ng-model, ng-repeat, etc) a digest cycle will be triggered by the directive.\n\n\nA digest cycle is a **depth-first traversal of `$scope` and all its children**. For each `$scope` `object`, we iterate over its `$$watchers` `array` and evaluate all the expressions. If the new expression value is different from the last known value, the watcher&#39;s function is called. This function might recompile part of the DOM, recompute a value on `$scope`, trigger an `AJAX` `request`, anything you need it to do.\n\nEvery scope is traversed and every watch expression evaluated and checked against the last value.\n\n## If a watcher is triggered, the `$scope` is dirty\n\nIf a watcher is triggered, the app knows something has changed, and the `$scope` is marked as dirty.\n\nWatcher functions can change other attributes on `$scope` or on a parent `$scope`. If one `$watcher` function has been triggered, we can&#39;t guarantee that our other `$scope`s are still clean, and so we execute the entire digest cycle again.\n\nThis is because AngularJS has two-way binding, so data can be passed back up the `$scope` tree. We may change a value on a higher `$scope` that has already been digested. Perhaps we change a value on the `$rootScope`.\n\n## If the `$digest` is dirty, we execute the entire `$digest` cycle again\n\nWe continually loop through the `$digest` cycle until either the digest cycle comes up clean (all `$watch` expressions have the same value as they had in the previous cycle), or we reach the digest limit. By default, this limit is set at 10.\n\nIf we reach the digest limit AngularJS will raise an error in the console:\n\n    10 $digest() iterations reached. Aborting!\n\n## The digest is hard on the machine but easy on the developer\n\nAs you can see, every time something changes in an AngularJS app, AngularJS will check every single watcher in the `$scope` hierarchy to see how to respond. For a developer this is a massive productivity boon, as you now need to write almost no wiring code, AngularJS will just notice if a value has changed, and make the rest of the app consistent with the change.\n\nFrom the perspective of the machine though this is wildly inefficient and will slow our app down if we create too many watchers. Misko has quoted a figure of about 4000 watchers before your app will feel slow on older browsers.\n\nThis limit is easy to reach if you `ng-repeat` over a large `JSON` `array` for example. You can mitigate against this using features like one-time binding to compile a template without creating watchers.\n\n## How to avoid creating too many watchers\n\nEach time your user interacts with your app, every single watcher in your app will be evaluated at least once. A big part of optimising an AngularJS app is reducing the number of watchers in your `$scope` tree. One easy way to do this is with *one time binding*.\n\nIf you have data which will rarely change, you can bind it only once using the :: syntax, like so:\n\n    &lt;p&gt;{{::person.username}}&lt;/p&gt;\n\nor\n\n    &lt;p ng-bind=&quot;::person.username&quot;&gt;&lt;/p&gt;\n\nThe binding will only be triggered when the containing template is rendered and the data loaded into `$scope`.\n\nThis is especially important when you have an `ng-repeat` with many items.\n\n    &lt;div ng-repeat=&quot;person in people track by username&quot;&gt;\n      {{::person.username}}\n    &lt;/div&gt;"},{"score":5,"body_markdown":"Here is an example of data binding with AngularJS, using an input field. I will explain later\r\n\r\n**HTML Code**\r\n\r\n    &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot; class=&quot;formInput&quot;&gt;\r\n         &lt;input type=&quot;text&quot; ng-model=&quot;watchInput&quot; Placeholder=&quot;type something&quot;/&gt;\r\n         &lt;p&gt;{{watchInput}}&lt;/p&gt; \r\n    &lt;/div&gt;\r\n\r\n**AngularJS Code**\r\n\r\n    myApp = angular.module (&quot;myApp&quot;, []);\r\n    myApp.controller(&quot;myCtrl&quot;, [&quot;$scope&quot;, function($scope){\r\n      //Your Controller code goes here\r\n    }]);\r\n\r\nAs you can see in the example above, **AngularJS** uses `ng-model` to listen and watch what happens on HTML elements, especially on `input` fields. When something happens, do something. In our case, `ng-model` is bind to our view, using the mustache notation `{{}}`. Whatever is typed inside the input field is displayed on the screen instantly. And that&#39;s the beauty of data binding, using AngularJS in its simplest form.\r\n\r\nHope this helps.\r\n\r\nSee a working example here on\r\n[Codepen][1]\r\n\r\n\r\n  [1]: http://codepen.io/chrisN/pen/YqEmOO"},{"score":16,"body_markdown":"AngularJS handle data-binding mechanism with the help of three powerful functions :      [$watch()][1],[$digest()][2]and [$apply()][3]. Most of the time AngularJS will call the $scope.$watch() and $scope.$digest(), but\r\nin some cases you may have to call these functions manually to update with new values.\r\n\r\n**$watch()** :- \r\n\r\n&gt; This function is used to observe changes in a variable on the $scope.\r\n&gt; It accepts three parameters: expression, listener and equality object,\r\n&gt; where listener and equality object are optional parameters.\r\n\r\n**$digest()** - \r\n\r\n&gt; This function iterates through all the watches in the $scope object,\r\n&gt; and its child $scope objects                                                \r\n   (if it has any). When $digest() iterates\r\n&gt; over the watches, it checks if the value of the expression has\r\n&gt; changed. If the value has changed, AngularJS calls the listener with\r\n&gt; new value and old value. The $digest() function is called\r\n&gt; whenever AngularJS thinks it is necessary. For example, after a button\r\n&gt; click, or after an AJAX call. You may have some cases where AngularJS\r\n&gt; does not call the $digest() function for you. In that case you have to\r\n&gt; call it yourself.\r\n\r\n**$apply()** - \r\n\r\n&gt; Angular do auto-magically updates only those model changes which are\r\n&gt; inside AngularJS context. When you do change in any model outside of\r\n&gt; the Angular context (like browser DOM events, setTimeout, XHR or third\r\n&gt; party libraries), then you need to inform Angular of the changes by\r\n&gt; calling $apply() manually. When the $apply() function call finishes\r\n&gt; AngularJS calls $digest() internally, so all data bindings are\r\n&gt; updated.\r\n\r\n\r\n  [1]: https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$watch\r\n  [2]: https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest\r\n  [3]: https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply"},{"score":33,"body_markdown":"Explaining with Pictures : \r\n\r\n\r\n## Data-Binding needs a mapping\r\n\r\nThe reference in the scope is not exactly the reference   in the template. When you data-bind two objects, you need a third one that listen to the first and modify the other.\r\n\r\n[![enter image description here][1]][1]\r\n\r\nHere, when you modify the `&lt;input&gt;`, you touch the **data-ref3**. And the classic data-bind mecanism will change **data-ref4**. So how the other `{{data}}` expressions will move ?\r\n\r\n## Events leads to $digest()\r\n\r\n[![enter image description here][2]][2]\r\n\r\nAngular maintains a `oldValue` and `newValue` of every binding. And after every *Angular event*, the famous `$digest()` loop will check the WatchList to see if something changed. These *Angular events* are `ng-click`, `ng-change`, `$http` completed ...  The `$digest()` will loop as long as any `oldValue` differs from the `newValue`.\r\n\r\nIn the previous picture, it will notice that data-ref1 and data-ref2 has changed.\r\n\r\n\r\n## Conclusions\r\n\r\nIt&#39;s a little like the Egg and Chicken. You never know who starts, but hopefully it works most of the time as expected. \r\n\r\nThe other point is that you can understand easily the impact deep of a simple binding on the memory and the CPU. Hopefully Desktops are fat enough to handle this. Mobile phones are not that strong.\r\n\r\n\r\n  [1]: http://i.stack.imgur.com/zcMvf.png\r\n  [2]: http://i.stack.imgur.com/IYRLT.png"},{"score":22,"body_markdown":"Obviously there is no periodic checking of `Scope` whether there is any change in the Objects attached to it. Not all the objects attached to scope are watched . Scope prototypically maintains a **$$watchers** . `Scope` only iterates through this `$$watchers` when `$digest` is called . \r\n\r\nAngular adds a watcher to the $$watchers for each of these \r\n\r\n&gt; 1. {{expression}} — In your templates (and anywhere else where there’s an expression) or when we define ng-model. &lt;br&gt;\r\n&gt; 2. $scope.$watch(‘expression/function’) — In your JavaScript we can just attach a scope object for angular to watch. \r\n\r\n**$watch** function takes in three parameters:&lt;br&gt;\r\n&gt; 1. First one is a watcher function which just returns the object or we can just add an expression. &lt;br&gt;\r\n\r\n&gt; 2. Second one is a listener function which will be called when there is a change in the object. All the things like DOM changes will be implemented in this function.&lt;br&gt;\r\n\r\n&gt; 3. The third being an optional parameter which takes in a boolean . If its true , angular deep watches the object &amp; if its false Angular just does a reference watching on the object.\r\n      Rough Implementation of $watch looks like this \r\n \r\n\r\n    Scope.prototype.$watch = function(watchFn, listenerFn) {\r\n       var watcher = {\r\n           watchFn: watchFn,\r\n           listenerFn: listenerFn || function() { },\r\n           last: initWatchVal  // initWatchVal is typically undefined\r\n       };\r\n       this.$$watchers.push(watcher); // pushing the Watcher Object to Watchers  \r\n    };\r\n\r\nThere is an interesting thing in Angular called Digest Cycle. The $digest cycle starts as a result of a call to $scope.$digest(). Assume that you change a $scope model in a handler function through the ng-click directive. In that case AngularJS automatically triggers a $digest cycle by calling $digest().In addition to ng-click, there are several other built-in directives/services that let you change models (e.g. ng-model, $timeout, etc) and automatically trigger a $digest cycle.  The rough implementation of $digest looks like this.\r\n\r\n    Scope.prototype.$digest = function() {\r\n          var dirty;\r\n          do {\r\n              dirty = this.$$digestOnce();\r\n          } while (dirty);\r\n    }\r\n    Scope.prototype.$$digestOnce = function() {\r\n       var self = this;\r\n       var newValue, oldValue, dirty;\r\n       _.forEach(this.$$watchers, function(watcher) {\r\n              newValue = watcher.watchFn(self);\r\n              oldValue = watcher.last;   // It just remembers the last value for dirty checking\r\n              if (newValue !== oldValue) { //Dirty checking of References \r\n       // For Deep checking the object , code of Value     \r\n       // based checking of Object should be implemented here\r\n                 watcher.last = newValue;\r\n                 watcher.listenerFn(newValue,\r\n                      (oldValue === initWatchVal ? newValue : oldValue),\r\n                       self);\r\n              dirty = true;\r\n              }\r\n         });\r\n       return dirty;\r\n     };\r\n\r\nIf we use JavaScript’s **setTimeout()** function to update a scope model, Angular has no way of knowing what you might change. In this case it’s our responsibility to call $apply() manually, which triggers a $digest cycle. Similarly, if you have a directive that sets up a DOM event listener and changes some models inside the handler function, you need to call $apply() to ensure the changes take effect. The big idea of $apply is that we can execute some code that isn&#39;t aware of Angular, that code may still change things on the scope. If we wrap that code in $apply , it will take care of calling $digest(). Rough implementation of $apply().\r\n\r\n    Scope.prototype.$apply = function(expr) {\r\n           try {\r\n             return this.$eval(expr); //Evaluating code in the context of Scope\r\n           } finally {\r\n             this.$digest();\r\n           }\r\n    };"},{"score":5,"body_markdown":"AngularJs supports **Two way data-binding**.  \r\nMeans you can access data **View -&gt; Controller** &amp; **Controller -&gt; View**\r\n\r\n**For Ex.**\r\n\r\n**1)**\r\n\r\n    // If $scope have some value in Controller. \r\n    $scope.name = &quot;Peter&quot;;\r\n\r\n    // HTML\r\n    &lt;div&gt; {{ name }} &lt;/div&gt;\r\n\r\n**O/P**\r\n\r\n\r\n    Peter\r\n\r\nYou can bind data in `ng-model` Like:-  \r\n**2)**\r\n\r\n    &lt;input ng-model=&quot;name&quot; /&gt;\r\n\r\n    &lt;div&gt; {{ name }} &lt;/div&gt;\r\n\r\nHere in above example whatever input user will give, It will be visible in `&lt;div&gt;` tag.\r\n\r\nIf want to bind input from html to controller:-  \r\n**3)**\r\n\r\n    &lt;form name=&quot;myForm&quot; ng-submit=&quot;registration()&quot;&gt;\r\n       &lt;label&gt; Name &lt;/lbel&gt;\r\n       &lt;input ng-model=&quot;name&quot; /&gt;\r\n    &lt;/form&gt;\r\n\r\nHere if you want to use input `name` in the controller then,\r\n\r\n    $scope.name = {};\r\n\r\n    $scope.registration = function() {\r\n       console.log(&quot;You will get the name here &quot;, $scope.name);\r\n    };\r\n\r\n`ng-model` binds our view and render it in expression `{{ }}`.  \r\n`ng-model` is the data which is shown to the user in the view and with which the user interacts.  \r\nSo it is easy to bind data in AngularJs."},{"score":4,"body_markdown":"Angular.js creates a watcher for every model we create in view. Whenever a model is changed, an &quot;ng-dirty&quot; class is appeneded to the model, so the watcher will observe all models which have the class &quot;ng-dirty&quot; &amp; update their values in the controller &amp; vice versa."},{"score":6,"body_markdown":"1. The one-way data binding is an approach where a value is taken from the data model and inserted into an HTML element. There is no way to update model from view. It is used in classical template systems. These systems bind data in only one direction.\r\n\r\n2. Data-binding in Angular apps is the automatic synchronisation of data between the model and view components.\r\n\r\nData binding lets you treat the model as the single-source-of-truth in your application. The view is a projection of the model at all times. If the model is changed, the view reflects the change and vice versa.\r\n\r\n"},{"score":3,"body_markdown":"**data binding:**\r\n\r\n***What is data binding?***\r\n\r\nWhenever the user changes the data in the view , there occurs an update of that change in the scope model, and viceversa.\r\n\r\n**How is it possible?**\r\n\r\n**Short answer :**\r\nWith the help of digest cycle.\r\n\r\n**Description :**\r\nAngular js sets the watcher on the scope model, which fires the listener function if there is a change in the model.\r\n\r\n    $scope.$watch(&#39;modelVar&#39; , function(newValue,oldValue){\r\n//Dom update code with new value\r\n\r\n});\r\n\r\n**So When and How is the watcher function called?**\r\n\r\nWatcher function is called as part of the digest cycle.\r\n\r\nDigest cycle is called automatically triggered as part of angular js built in directives/services like ng-model , ng-bind , $timeout, ng-click and others.. that let you trigger the digest cycle.\r\n\r\nDigest cycle function:\r\n\r\n    $scope.$digest() -&gt; digest cycle against the current scope.\r\n    $scope.$apply() -&gt; digest cycle against the parent scope \r\ni.e`$rootScope.$apply()`\r\n\r\n\r\n\r\n\r\n\r\nNote:\r\n$apply() is equal to $rootScope.$digest() this  means the dirty checking starts right from the root or top or the parent scope down to all the child $scopes in the angular js application.\r\n\r\n\r\nThe above features work in the browsers IE for the mentioned versions also just by making sure your application is angular js application which means you are using the angularjs framework script file referenced in the script tag.\r\n\r\nThank you.\r\n\r\n"}],"score":1976}