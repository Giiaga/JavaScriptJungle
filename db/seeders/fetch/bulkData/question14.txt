{"body":"### ECMAScript 6 introduced [the `let` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let). \r\n\r\nI&#39;ve heard it that it&#39;s described as a `local` variable, but I&#39;m still not quite sure how it behaves differently than the `var` keyword.\r\n\r\nWhat are the differences? When should `let` be used instead of `var`?","title":"What&#39;s the difference between using &quot;let&quot; and &quot;var&quot;?","answers":[{"score":152,"body_markdown":"Here&#39;s an [explanation of the `let` keyword][1] with some examples.\r\n\r\n&gt; `let` works very much like `var`. The main difference is that the scope of a `var` variable is the entire enclosing function\r\n\r\n[This table][2] on Wikipedia shows which browsers support Javascript 1.7.\r\n\r\nNote that only Mozilla and Chrome browsers support it. IE, Safari, and potentially others don&#39;t.\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let\r\n  [2]: http://en.wikipedia.org/wiki/JavaScript#Version_history"},{"score":53,"body_markdown":"There are some subtle differences &amp;mdash; `let` scoping behaves more like variable scoping does in more or less any other languages. \r\n\r\ne.g. It scopes to the enclosing block, They don&#39;t exist before they&#39;re declared, etc.\r\n\r\nHowever it&#39;s worth noting that `let` is only a part of newer Javascript implementations and has varying degrees of [browser support][1].\r\n\r\n\r\n  [1]: http://caniuse.com/#search=let"},{"score":6405,"body_markdown":"# Scoping rules\r\n\r\nMain difference is scoping rules. Variables declared by `var` keyword are scoped to the immediate function body (hence the function scope) while `let` variables are scoped to the immediate *enclosing* block denoted by `{ }` (hence the block scope).\r\n\r\n    function run() {\r\n      var foo = &quot;Foo&quot;;\r\n      let bar = &quot;Bar&quot;;\r\n    \r\n      console.log(foo, bar); // Foo Bar\r\n    \r\n      {\r\n        let baz = &quot;Bazz&quot;;\r\n        console.log(baz); // Bazz\r\n      }\r\n    \r\n      console.log(baz); // ReferenceError\r\n    }\r\n    \r\n    run();\r\n\r\nThe reason why `let` keyword was introduced to the language was function scope is confusing and was one of the main sources of bugs in JavaScript.\r\n\r\nTake a look at this example from [another stackoverflow question][1]:\r\n\r\n    var funcs = [];\r\n    // let&#39;s create 3 functions\r\n    for (var i = 0; i &lt; 3; i++) {\r\n      // and store them in funcs\r\n      funcs[i] = function() {\r\n        // each should log its value.\r\n        console.log(&quot;My value: &quot; + i);\r\n      };\r\n    }\r\n    for (var j = 0; j &lt; 3; j++) {\r\n      // and now let&#39;s run each one to see\r\n      funcs[j]();\r\n    }\r\n\r\n`My value: 3` was output to console each time `funcs[j]();` was invoked since anonymous functions were bound to the same variable.\r\n\r\nPeople had to create immediately invoked functions to capture correct value from the loops but that was also hairy.\r\n\r\n# Hoisting\r\n\r\nWhile variables declared with `var` keyword are [hoisted](https://dev.to/godcrampy/the-secret-of-hoisting-in-javascript-egi) (initialized with `undefined` before the code is run) which means they are accessible in their enclosing scope even before they are declared:\r\n\r\n```javascript\r\nfunction run() {\r\n  console.log(foo); // undefined\r\n  var foo = &quot;Foo&quot;;\r\n  console.log(foo); // Foo\r\n}\r\n\r\nrun();\r\n```\r\n\r\n`let` variables are not initialized until their definition is evaluated. Accessing them before the initialization results in a `ReferenceError`. Variable said to be in &quot;temporal dead zone&quot; from the start of the block until the initialization is processed.\r\n\r\n    function checkHoisting() {\r\n      console.log(foo); // ReferenceError\r\n      let foo = &quot;Foo&quot;;\r\n      console.log(foo); // Foo\r\n    }\r\n    \r\n    checkHoisting();\r\n\r\n# Creating global object property\r\n\r\nAt the top level, `let`, unlike `var`, does not create a property on the global object:\r\n\r\n    var foo = &quot;Foo&quot;;  // globally scoped\r\n    let bar = &quot;Bar&quot;; // globally scoped\r\n\r\n    console.log(window.foo); // Foo\r\n    console.log(window.bar); // undefined\r\n\r\n# Redeclaration\r\n\r\nIn strict mode, `var` will let you re-declare the same variable in the same scope while `let` raises a SyntaxError.\r\n\r\n    &#39;use strict&#39;;\r\n    var foo = &quot;foo1&quot;;\r\n    var foo = &quot;foo2&quot;; // No problem, &#39;foo&#39; is replaced.\r\n\r\n    let bar = &quot;bar1&quot;;\r\n    let bar = &quot;bar2&quot;; // SyntaxError: Identifier &#39;bar&#39; has already been declared\r\n\r\n\r\n  [1]: https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example"},{"score":20,"body_markdown":"Here&#39;s an example to add on to what others have already written. Suppose you want to make an array of functions, `adderFunctions`, where each function takes a single Number argument and returns the sum of the argument and the function&#39;s index in the array. Trying to generate `adderFunctions` with a loop using the `var` keyword won&#39;t work the way someone might na&#239;vely expect:\r\n\r\n    // An array of adder functions.\r\n    var adderFunctions = [];\r\n\r\n    for (var i = 0; i &lt; 1000; i++) {\r\n      // We want the function at index i to add the index to its argument.\r\n      adderFunctions[i] = function(x) {\r\n        // What is i bound to here?\r\n        return x + i;\r\n      };\r\n    }\r\n\r\n    var add12 = adderFunctions[12];\r\n\r\n    // Uh oh. The function is bound to i in the outer scope, which is currently 1000.\r\n    console.log(add12(8) === 20); // =&gt; false\r\n    console.log(add12(8) === 1008); // =&gt; true\r\n    console.log(i); // =&gt; 1000\r\n\r\n    // It gets worse.\r\n    i = -8;\r\n    console.log(add12(8) === 0); // =&gt; true\r\n\r\nThe process above doesn&#39;t generate the desired array of functions because `i`&#39;s scope extends beyond the iteration of the `for` block in which each function was created. Instead, at the end of the loop, the `i` in each function&#39;s closure refers to `i`&#39;s value at the end of the loop (1000) for every anonymous function in `adderFunctions`. This isn&#39;t what we wanted at all: we now have an array of 1000 different functions in memory with exactly the same behavior. And if we subsequently update the value of `i`, the mutation will affect all the `adderFunctions`.\r\n\r\nHowever, we can try again using the `let` keyword:\r\n\r\n    // Let&#39;s try this again.\r\n    // NOTE: We&#39;re using another ES6 keyword, const, for values that won&#39;t\r\n    // be reassigned. const and let have similar scoping behavior.\r\n    const adderFunctions = [];\r\n\r\n    for (let i = 0; i &lt; 1000; i++) {\r\n      // NOTE: We&#39;re using the newer arrow function syntax this time, but \r\n      // using the &quot;function(x) { ...&quot; syntax from the previous example \r\n      // here would not change the behavior shown.\r\n      adderFunctions[i] = x =&gt; x + i;\r\n    }\r\n\r\n    const add12 = adderFunctions[12];\r\n\r\n    // Yay! The behavior is as expected. \r\n    console.log(add12(8) === 20); // =&gt; true\r\n\r\n    // i&#39;s scope doesn&#39;t extend outside the for loop.\r\n    console.log(i); // =&gt; ReferenceError: i is not defined\r\n\r\nThis time, `i` is rebound on each iteration of the `for` loop. Each function now keeps the value of `i` at the time of the function&#39;s creation, and `adderFunctions` behaves as expected.\r\n\r\nNow, image mixing the two behaviors and you&#39;ll probably see why it&#39;s not recommended to mix the newer `let` and `const` with the older `var` in the same script. Doing so can result is some spectacularly confusing code.\r\n\r\n    const doubleAdderFunctions = [];\r\n\r\n    for (var i = 0; i &lt; 1000; i++) {\r\n        const j = i;\r\n        doubleAdderFunctions[i] = x =&gt; x + i + j;\r\n    }\r\n\r\n    const add18 = doubleAdderFunctions[9];\r\n    const add24 = doubleAdderFunctions[12];\r\n\r\n    // It&#39;s not fun debugging situations like this, especially when the\r\n    // code is more complex than in this example.\r\n    console.log(add18(24) === 42); // =&gt; false\r\n    console.log(add24(18) === 42); // =&gt; false\r\n    console.log(add18(24) === add24(18)); // =&gt; false\r\n    console.log(add18(24) === 2018); // =&gt; false\r\n    console.log(add24(18) === 2018); // =&gt; false\r\n    console.log(add18(24) === 1033); // =&gt; true\r\n    console.log(add24(18) === 1030); // =&gt; true\r\n\r\nDon&#39;t let this happen to you. Use a linter.\r\n\r\n&gt; **NOTE:** This is a teaching example intended to demonstrate the `var`/`let` behavior in loops and with function closures that would also be easy to understand. This would be a terrible way to add numbers. But the general technique of capturing data in anonymous function closures might be encountered in the real world in other contexts. YMMV."},{"score":53,"body_markdown":"Here is an example for the difference between the two (support just started for chrome):  \r\n![enter image description here][1]\r\n\r\nAs you can see the `var j` variable is still having a value outside of the for loop scope (Block Scope), but the `let i` variable is undefined outside of the for loop scope.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    &quot;use strict&quot;;\r\n    console.log(&quot;var:&quot;);\r\n    for (var j = 0; j &lt; 2; j++) {\r\n      console.log(j);\r\n    }\r\n\r\n    console.log(j);\r\n\r\n    console.log(&quot;let:&quot;);\r\n    for (let i = 0; i &lt; 2; i++) {\r\n      console.log(i);\r\n    }\r\n\r\n    console.log(i);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n  [1]: http://i.stack.imgur.com/dqNYW.png"},{"score":667,"body_markdown":"`let` can also be used to avoid problems with closures. It binds fresh value rather than keeping an old reference as shown in examples below.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    for(var i=1; i&lt;6; i++) {\r\n      $(&quot;#div&quot; + i).click(function () { console.log(i); });\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;p&gt;Clicking on each number will log to console:&lt;/p&gt; \r\n    &lt;div id=&quot;div1&quot;&gt;1&lt;/div&gt;\r\n    &lt;div id=&quot;div2&quot;&gt;2&lt;/div&gt;\r\n    &lt;div id=&quot;div3&quot;&gt;3&lt;/div&gt;\r\n    &lt;div id=&quot;div4&quot;&gt;4&lt;/div&gt;\r\n    &lt;div id=&quot;div5&quot;&gt;5&lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nCode above demonstrates a classic JavaScript closure problem. Reference to the `i` variable is being stored in the click handler closure, rather than the actual value of `i`.\r\n\r\nEvery single click handler will refer to the same object because there’s only one counter object which holds 6 so you get six on each click.\r\n\r\nA general workaround is to wrap this in an anonymous function and pass `i` as an argument. Such issues can also be avoided now by using `let` instead `var` as shown in the code below.\r\n\r\n&lt;sub&gt;(Tested in Chrome and Firefox 50)&lt;/sub&gt;\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    for(let i=1; i&lt;6; i++) {\r\n      $(&quot;#div&quot; + i).click(function () { console.log(i); });\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;p&gt;Clicking on each number will log to console:&lt;/p&gt; \r\n    &lt;div id=&quot;div1&quot;&gt;1&lt;/div&gt;\r\n    &lt;div id=&quot;div2&quot;&gt;2&lt;/div&gt;\r\n    &lt;div id=&quot;div3&quot;&gt;3&lt;/div&gt;\r\n    &lt;div id=&quot;div4&quot;&gt;4&lt;/div&gt;\r\n    &lt;div id=&quot;div5&quot;&gt;5&lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;"},{"score":122,"body_markdown":"The accepted answer is missing a point:\r\n\r\n    {\r\n      let a = 123;\r\n    };\r\n    \r\n    console.log(a); // ReferenceError: a is not defined"},{"score":12,"body_markdown":"It also appears that, at least in Visual Studio 2015, TypeScript 1.5, &quot;var&quot; allows multiple declarations of the same variable name in a block, and &quot;let&quot; doesn&#39;t.\r\n\r\nThis won&#39;t generate a compile error:\r\n\r\n    var x = 1;\r\n    var x = 2;\r\n\r\nThis will:\r\n\r\n    let x = 1;\r\n    let x = 2;\r\n"},{"score":17,"body_markdown":"May the following two functions show the difference:\r\n\r\n    function varTest() {\r\n        var x = 31;\r\n        if (true) {\r\n            var x = 71;  // Same variable!\r\n            console.log(x);  // 71\r\n        }\r\n        console.log(x);  // 71\r\n    }\r\n\r\n    function letTest() {\r\n        let x = 31;\r\n        if (true) {\r\n            let x = 71;  // Different variable\r\n            console.log(x);  // 71\r\n        }\r\n        console.log(x);  // 31\r\n    }\r\n"},{"score":26,"body_markdown":"- &lt;del&gt;**Variable Not Hoisting**&lt;/del&gt;\r\n\r\n  &lt;del&gt;`let` will **not hoist** to the entire scope of the block they appear in. By contrast, `var` could hoist as below.&lt;/del&gt;\r\n\r\n        {\r\n           console.log(cc); // undefined. Caused by hoisting\r\n           var cc = 23;\r\n        }\r\n    \r\n        {\r\n           console.log(bb); // ReferenceError: bb is not defined\r\n           let bb = 23;\r\n        }\r\n   Actually, Per @Bergi, [Both `var` and `let` are hoisted](https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6).\r\n\r\n- **Garbage Collection**\r\n\r\n  Block scope of `let` is useful relates to closures and garbage collection to reclaim memory. Consider,\r\n\r\n        function process(data) {\r\n            //...\r\n        }\r\n    \r\n        var hugeData = { .. };\r\n    \r\n        process(hugeData);\r\n    \r\n        var btn = document.getElementById(&quot;mybutton&quot;);\r\n        btn.addEventListener( &quot;click&quot;, function click(evt){\r\n            //....\r\n        });\r\n\r\n  The `click` handler callback does not need the `hugeData` variable at all. Theoretically, after `process(..)` runs, the huge data structure `hugeData` could be garbage collected. However, it&#39;s possible that some JS engine will still have to keep this huge structure, since the `click` function has a closure over the entire scope.\r\n\r\n  However, the block scope can make this huge data structure to garbage collected.\r\n\r\n        function process(data) {\r\n            //...\r\n        }\r\n    \r\n        { // anything declared inside this block can be garbage collected\r\n            let hugeData = { .. };\r\n            process(hugeData);\r\n        }\r\n    \r\n        var btn = document.getElementById(&quot;mybutton&quot;);\r\n        btn.addEventListener( &quot;click&quot;, function click(evt){\r\n            //....\r\n        });\r\n\r\n- **`let` loops**\r\n\r\n  `let` in the loop can **re-binds it** to each iteration of the loop, making sure to re-assign it the value from the end of the previous loop iteration. Consider,\r\n\r\n        // print &#39;5&#39; 5 times\r\n        for (var i = 0; i &lt; 5; ++i) {\r\n            setTimeout(function () {\r\n                console.log(i);\r\n            }, 1000);  \r\n        }\r\n\r\n  However, replace `var` with `let`\r\n\r\n        // print 1, 2, 3, 4, 5. now\r\n        for (let i = 0; i &lt; 5; ++i) {\r\n            setTimeout(function () {\r\n                console.log(i);\r\n            }, 1000);  \r\n        }\r\n\r\n  Because `let` create a new lexical environment with those names for a) the initialiser expression b) each iteration (previosly to evaluating the increment expression), more details are [here](https://stackoverflow.com/a/30900289/3011380)."},{"score":1,"body_markdown":"Previously there were only two scopes in JavaScript, i.e. functional and global. With &#39;`let`&#39; keyword JavaScript has now introduced `block-level` variables.\r\n\r\nTo have a complete understanding of the &#39;let&#39; keyword, *[\r\nES6: ‘let’ keyword to declare variable in JavaScript][1]* will help.\r\n\r\n  [1]: http://www.codingeek.com/tutorials/javascript/es6-let-keyword-to-declare-variable-in-javascript/\r\n"},{"score":236,"body_markdown":"### What&#39;s the difference between `let` and `var`?\n\n- A variable defined using a `var` statement is known throughout [**the function**][1] it is defined in, from the start of the function. *(\\*)*\n- A variable defined using a `let` statement is only known in [**the block**][2] it is defined in, from the moment it is defined onward. *(\\*\\*)*\n\nTo understand the difference, consider the following code:\n\n    // i IS NOT known here\n    // j IS NOT known here\n    // k IS known here, but undefined\n    // l IS NOT known here\n\n    function loop(arr) {\n        // i IS known here, but undefined\n        // j IS NOT known here\n        // k IS known here, but has a value only the second time loop is called\n        // l IS NOT known here\n\n        for( var i = 0; i &lt; arr.length; i++ ) {\n            // i IS known here, and has a value\n            // j IS NOT known here\n            // k IS known here, but has a value only the second time loop is called\n            // l IS NOT known here\n        };\n\n        // i IS known here, and has a value\n        // j IS NOT known here\n        // k IS known here, but has a value only the second time loop is called\n        // l IS NOT known here\n\n        for( let j = 0; j &lt; arr.length; j++ ) {\n            // i IS known here, and has a value\n            // j IS known here, and has a value\n            // k IS known here, but has a value only the second time loop is called\n            // l IS NOT known here\n        };\n\n        // i IS known here, and has a value\n        // j IS NOT known here\n        // k IS known here, but has a value only the second time loop is called\n        // l IS NOT known here\n    }\n\n    loop([1,2,3,4]);\n\n    for( var k = 0; k &lt; arr.length; k++ ) {\n        // i IS NOT known here\n        // j IS NOT known here\n        // k IS known here, and has a value\n        // l IS NOT known here\n    };\n\n    for( let l = 0; l &lt; arr.length; l++ ) {\n        // i IS NOT known here\n        // j IS NOT known here\n        // k IS known here, and has a value\n        // l IS known here, and has a value\n    };\n\n    loop([1,2,3,4]);\n\n    // i IS NOT known here\n    // j IS NOT known here\n    // k IS known here, and has a value\n    // l IS NOT known here\n\nHere, we can see that our variable `j` is only known in the first for loop, but not before and after. Yet, our variable `i` is known in the entire function.\n\nAlso, consider that block scoped variables are not known before they are declared because they are not hoisted. You&#39;re also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.\n\n------\n\n### Is it safe to use `let` today?\n\nSome people would argue that in the future we&#39;ll ONLY use let statements and that var statements will become obsolete. JavaScript guru [**Kyle Simpson**][3] wrote [**a very elaborate article on why he believes that won&#39;t be the case**][4].\n\nToday, however, that is definitely not the case. In fact, we need actually to ask ourselves whether it&#39;s safe to use the `let` statement. The answer to that question depends on your environment:\n\n- If you&#39;re writing server-side JavaScript code ([**Node.js**][5]), you can safely use the `let` statement.\n\n- If you&#39;re writing client-side JavaScript code and use a browser based transpiler (like [**Traceur**][6] or [**babel-standalone**][10]), you can safely use the `let` statement, however your code is likely to be anything but optimal with respect to performance.\n\n- If you&#39;re writing client-side JavaScript code and use a Node based transpiler (like the [**traceur shell script**][11] or [**Babel**][12]), you can safely use the `let` statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.\n\n- If you&#39;re writing client-side JavaScript code and don&#39;t use a transpiler, you need to consider browser support.\n\n    There are still some browsers that don&#39;t support `let` at all :\n    \n[![enter image description here][7]][7]\n\n------\n\n### How to keep track of browser support\n\nFor an up-to-date overview of which browsers support the `let` statement at the time of your reading this answer, see [**this `Can I Use` page**][8].\n\n------\n\n*(\\*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are [**hoisted**][9].* This means that declarations are always much to the top of the scope.\n\n*(\\*\\*) Block scoped variables are not hoisted*\n\n\n  [1]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function\n  [2]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block\n  [3]: https://twitter.com/getify\n  [4]: https://davidwalsh.name/for-and-against-let\n  [5]: https://nodejs.org/en/\n  [6]: https://github.com/google/traceur-compiler\n  [7]: https://i.stack.imgur.com/J9kEC.png\n  [8]: http://caniuse.com/#search=let\n  [9]: https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\n  [10]: https://github.com/babel/babel-standalone\n  [11]: https://github.com/google/traceur-compiler/wiki/Compiling-Offline\n  [12]: https://babeljs.io/"},{"score":-1,"body_markdown":"[ECMAScript 6][1] added one more keyword to declare variables other the &quot;const&quot; other than &quot;let&quot;.\r\n\r\nThe primary goal of introduction of &quot;let&quot; and &quot;const&quot; over &quot;var&quot; is to have block scoping instead of traditional lexical scoping.\r\n[This article explains very briefly difference between &quot;var&quot; and &quot;let&quot; and it also covers the discussion on &quot;const&quot;][2].\r\n\r\n  [1]: https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015\r\n  [2]: https://medium.com/@charan4u/ecmascript-6-beginner-guide-part-3-block-level-bindings-2b3cd5c5d408#.ev9gwp2jb\r\n"},{"score":2,"body_markdown":"Now I think there is better scoping of variables to a block of statements using `let`:\r\n\r\n    function printnums()\r\n    {\r\n        // i is not accessible here\r\n        for(let i = 0; i &lt;10; i+=)\r\n        {\r\n           console.log(i);\r\n        }\r\n        // i is not accessible here\r\n    \r\n        // j is accessible here\r\n        for(var j = 0; j &lt;10; j++)\r\n        {\r\n           console.log(j);\r\n        }\r\n        // j is accessible here\r\n    }\r\n\r\nI think people will start using let here after so that they will have similar scoping in JavaScript like other languages, Java, C#, etc.\r\n\r\nPeople with not a clear understanding about scoping in JavaScript used to make the mistake earlier.\r\n\r\nHoisting is not supported using `let`.\r\n\r\nWith this approach errors present in JavaScript are getting removed. \r\n\r\nRefer to *[ES6 In Depth: let and const][1]* to understand it better.\r\n\r\n  [1]: https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/\r\n"},{"score":14,"body_markdown":"`let` is interesting, because it allows us to do something like this:\r\n\r\n    (() =&gt; {\r\n        var count = 0;\r\n\r\n        for (let i = 0; i &lt; 2; ++i) {\r\n            for (let i = 0; i &lt; 2; ++i) {\r\n                for (let i = 0; i &lt; 2; ++i) {\r\n                    console.log(count++);\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\r\nWhich results in counting [0, 7].\r\n\r\nWhereas\r\n\r\n    (() =&gt; {\r\n        var count = 0;\r\n\r\n        for (var i = 0; i &lt; 2; ++i) {\r\n            for (var i = 0; i &lt; 2; ++i) {\r\n                for (var i = 0; i &lt; 2; ++i) {\r\n                    console.log(count++);\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\r\nOnly counts [0, 1].\r\n"},{"score":7,"body_markdown":"Some hacks with `let`:\r\n\r\n1.\r\n\r\n        let statistics = [16, 170, 10];\r\n        let [age, height, grade] = statistics;\r\n\r\n        console.log(height)\r\n\r\n  2.\r\n\r\n        let x = 120,\r\n        y = 12;\r\n        [x, y] = [y, x];\r\n        console.log(`x: ${x} y: ${y}`);\r\n\r\n  3.\r\n\r\n        let node = {\r\n                       type: &quot;Identifier&quot;,\r\n                       name: &quot;foo&quot;\r\n                   };\r\n\r\n        let { type, name, value } = node;\r\n\r\n        console.log(type);      // &quot;Identifier&quot;\r\n        console.log(name);      // &quot;foo&quot;\r\n        console.log(value);     // undefined\r\n\r\n        let node = {\r\n            type: &quot;Identifier&quot;\r\n        };\r\n\r\n        let { type: localType, name: localName = &quot;bar&quot; } = node;\r\n\r\n        console.log(localType);     // &quot;Identifier&quot;\r\n        console.log(localName);     // &quot;bar&quot;\r\n\r\n###Getter and setter with `let`:\r\n\r\n    let jar = {\r\n        numberOfCookies: 10,\r\n        get cookies() {\r\n            return this.numberOfCookies;\r\n        },\r\n        set cookies(value) {\r\n            this.numberOfCookies = value;\r\n        }\r\n    };\r\n\r\n    console.log(jar.cookies)\r\n    jar.cookies = 7;\r\n\r\n    console.log(jar.cookies)\r\n"},{"score":8,"body_markdown":"If I read the specs right then `let` **thankfully** can also be leveraged to avoid [self invoking functions][1] used to simulate private only members - *a popular design pattern that decreases code readability, complicates debugging, that adds no real code protection or other benefit - except maybe satisfying someone&#39;s desire for semantics, so stop using it. /rant*\r\n\r\n    var SomeConstructor;\r\n    \r\n    {\r\n        let privateScope = {};\r\n    \r\n        SomeConstructor = function SomeConstructor () {\r\n            this.someProperty = &quot;foo&quot;;\r\n            privateScope.hiddenProperty = &quot;bar&quot;;\r\n        }\r\n    \r\n        SomeConstructor.prototype.showPublic = function () {\r\n            console.log(this.someProperty); // foo\r\n        }\r\n    \r\n        SomeConstructor.prototype.showPrivate = function () {\r\n            console.log(privateScope.hiddenProperty); // bar\r\n        }\r\n    \r\n    }\r\n    \r\n    var myInstance = new SomeConstructor();\r\n    \r\n    myInstance.showPublic();\r\n    myInstance.showPrivate();\r\n    \r\n    console.log(privateScope.hiddenProperty); // error\r\n\r\nSee &#39;[Emulating private interfaces][2]&#39;\r\n\r\n\r\n  [1]: https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414\r\n  [2]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces"},{"score":94,"body_markdown":"# `let`\r\n\r\n## Block scope\r\n\r\nVariables declared using the `let` keyword are block-scoped, which means that they are available only in the [block](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block) in which they were declared.\r\n\r\n### At the top level (outside of a function)\r\n\r\nAt the top level, variables declared using `let` don&#39;t create properties on the global object.\r\n\r\n    var globalVariable = 42;\r\n    let blockScopedVariable = 43;\r\n    \r\n    console.log(globalVariable); // 42\r\n    console.log(blockScopedVariable); // 43\r\n    \r\n    console.log(this.globalVariable); // 42\r\n    console.log(this.blockScopedVariable); // undefined\r\n\r\n### Inside a function\r\n\r\nInside a function (but outside of a block), `let` has the same scope as `var`.\r\n\r\n    (() =&gt; {\r\n      var functionScopedVariable = 42;\r\n      let blockScopedVariable = 43;\r\n    \r\n      console.log(functionScopedVariable); // 42\r\n      console.log(blockScopedVariable); // 43\r\n    })();\r\n    \r\n    console.log(functionScopedVariable); // ReferenceError: functionScopedVariable is not defined\r\n    console.log(blockScopedVariable); // ReferenceError: blockScopedVariable is not defined\r\n\r\n### Inside a block\r\n\r\nVariables declared using `let` inside a block can&#39;t be accessed outside that block.\r\n\r\n    {\r\n      var globalVariable = 42;\r\n      let blockScopedVariable = 43;\r\n      console.log(globalVariable); // 42\r\n      console.log(blockScopedVariable); // 43\r\n    }\r\n    \r\n    console.log(globalVariable); // 42\r\n    console.log(blockScopedVariable); // ReferenceError: blockScopedVariable is not defined\r\n\r\n### Inside a loop\r\n\r\nVariables declared with `let` in loops can be referenced only inside that loop.\r\n\r\n    for (var i = 0; i &lt; 3; i++) {\r\n      var j = i * 2;\r\n    }\r\n    console.log(i); // 3\r\n    console.log(j); // 4\r\n    \r\n    for (let k = 0; k &lt; 3; k++) {\r\n      let l = k * 2;\r\n    }\r\n    console.log(typeof k); // undefined\r\n    console.log(typeof l); // undefined\r\n    // Trying to do console.log(k) or console.log(l) here would throw a ReferenceError.\r\n\r\n### Loops with closures\r\n\r\nIf you use `let` instead of `var` in a loop, with each iteration you get a new variable. That means that you can safely use a closure inside a loop.\r\n\r\n    // Logs 3 thrice, not what we meant.\r\n    for (var i = 0; i &lt; 3; i++) {\r\n      setTimeout(() =&gt; console.log(i), 0);\r\n    }\r\n    \r\n    // Logs 0, 1 and 2, as expected.\r\n    for (let j = 0; j &lt; 3; j++) {\r\n      setTimeout(() =&gt; console.log(j), 0);\r\n    }\r\n\r\n## Temporal dead zone\r\n\r\nBecause of [the temporal dead zone](https://stackoverflow.com/q/33198849/3853934), variables declared using `let` can&#39;t be accessed before they are declared. Attempting to do so throws an error.\r\n\r\n    console.log(noTDZ); // undefined\r\n    var noTDZ = 43;\r\n    console.log(hasTDZ); // ReferenceError: hasTDZ is not defined\r\n    let hasTDZ = 42;\r\n\r\n## No re-declaring\r\n\r\nYou can&#39;t declare the same variable multiple times using `let`. You also can&#39;t declare a variable using `let` with the same identifier as another variable which was declared using `var`.\r\n\r\n    var a;\r\n    var a; // Works fine.\r\n    \r\n    let b;\r\n    let b; // SyntaxError: Identifier &#39;b&#39; has already been declared\r\n\r\n    var c;\r\n    let c; // SyntaxError: Identifier &#39;c&#39; has already been declared\r\n\r\n# `const`\r\n\r\n`const` is quite similar to `let`—it&#39;s block-scoped and has TDZ. There are, however, two things which are different.\r\n\r\n## No re-assigning\r\n\r\nVariable declared using `const` can&#39;t be re-assigned.\r\n\r\n    const a = 42;\r\n    a = 43; // TypeError: Assignment to constant variable.\r\n\r\nNote that it doesn&#39;t mean that the value is immutable. Its properties still can be changed.\r\n\r\n    const obj = {};\r\n    obj.a = 42;\r\n    console.log(obj.a); // 42\r\n\r\nIf you want to have an immutable object, you should use [`Object.freeze()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze).\r\n\r\n## Initializer is required \r\n\r\nYou always must specify a value when declaring a variable using `const`.\r\n\r\n    const a; // SyntaxError: Missing initializer in const declaration"},{"score":2,"body_markdown":"This article clearly defines the difference between var, let and const\r\n\r\n&gt; `const` is a signal that the identifier won’t be reassigned.\r\n&gt; \r\n&gt; `let`, is a signal that the variable may be reassigned, such as a\r\n&gt; counter in a loop, or a value swap in an algorithm. It also signals\r\n&gt; that the variable will be used only in the block it’s defined in,\r\n&gt; which is not always the entire containing function.\r\n&gt; \r\n&gt; `var` is now the weakest signal available when you define a variable\r\n&gt; in JavaScript. The variable may or may not be reassigned, and the\r\n&gt; variable may or may not be used for an entire function, or just for\r\n&gt; the purpose of a block or loop.\r\n\r\nhttps://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75#.esmkpbg9b"},{"score":52,"body_markdown":"The main difference is the **scope** difference, while **let** can be only available inside the **scope** it&#39;s declared, like in for loop, **var** can be accessed outside the loop for example. From the documentation in [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let) (examples also from MDN):\r\n\r\n&gt;**let** allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. This is unlike the **var** keyword, which defines a variable globally, or locally to an entire function regardless of block scope.\r\n\r\n&gt; Variables declared by **let** have as their scope the block in which they are defined, as well as in any contained sub-blocks. In this way, **let** works very much like **var**. The main difference is that the scope of a **var** variable is the entire enclosing function:\r\n\r\n    function varTest() {\r\n      var x = 1;\r\n      if (true) {\r\n        var x = 2;  // same variable!\r\n        console.log(x);  // 2\r\n      }\r\n      console.log(x);  // 2\r\n    }\r\n    \r\n    function letTest() {\r\n      let x = 1;\r\n      if (true) {\r\n        let x = 2;  // different variable\r\n        console.log(x);  // 2\r\n      }\r\n      console.log(x);  // 1\r\n    }`\r\n\r\n&gt; At the top level of programs and functions, **let**, unlike **var**, does not create a property on the global object. For example:\r\n\r\n    var x = &#39;global&#39;;\r\n    let y = &#39;global&#39;;\r\n    console.log(this.x); // &quot;global&quot;\r\n    console.log(this.y); // undefined\r\n\r\n&gt; When used inside a block, let limits the variable&#39;s scope to that block. Note the difference between **var** whose scope is inside the function where it is declared.\r\n\r\n    var a = 1;\r\n    var b = 2;\r\n    \r\n    if (a === 1) {\r\n      var a = 11; // the scope is global\r\n      let b = 22; // the scope is inside the if-block\r\n    \r\n      console.log(a);  // 11\r\n      console.log(b);  // 22\r\n    } \r\n    \r\n    console.log(a); // 11\r\n    console.log(b); // 2\r\n\r\nAlso don&#39;t forget it&#39;s ECMA6 feature, so it&#39;s not fully supported yet, so it&#39;s better always transpiles it to ECMA5 using Babel etc... for more info about visit [babel website][1]\r\n\r\n\r\n  [1]: https://babeljs.io"},{"score":20,"body_markdown":"The difference is in the [scope](https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent) of the variables declared with each.\r\n\r\nIn practice, there are a number of useful consequences of the difference in scope:\r\n\r\n1. `let` variables are only visible in their *nearest enclosing* block (`{ ... }`).\r\n2. `let` variables are only usable in lines of code that occur *after* the variable is declared (even though [they are hoisted](/questions/33198849)!).\r\n3. `let` variables may not be redeclared by a subsequent `var` or `let`.\r\n4. Global `let` variables are not added to the global `window` object.\r\n5. `let` variables are *easy to use* with closures (they do not cause [race conditions](https://en.wikipedia.org/wiki/Race_condition#Software)).\r\n\r\nThe restrictions imposed by `let` reduce the visibility of the variables and increase the likelihood that unexpected name collisions will be found early.  This makes it easier to track and reason about variables, including their [reachability](https://en.wikipedia.org/wiki/Unreachable_memory)(helping with reclaiming unused memory).\r\n\r\nConsequently, `let` variables are less likely to cause problems when used in large programs or when independently-developed frameworks are combined in new and unexpected ways.\r\n\r\n`var` may still be useful if you are sure you want the single-binding effect when using a closure in a loop (#5) or for declaring externally-visible global variables in your code (#4).  Use of `var` for exports may be supplanted if [`export`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) migrates out of transpiler space and into the core language.\r\n\r\n#Examples\r\n\r\n**1. No use outside nearest enclosing block:**\r\nThis block of code will throw a reference error because the second use of `x` occurs outside of the block where it is declared with `let`:\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    {\r\n        let x = 1;\r\n    }\r\n    console.log(`x is ${x}`);  // ReferenceError during parsing: &quot;x is not defined&quot;.\r\n\r\nIn contrast, the same example with `var` works.\r\n\r\n**2. No use before declaration:**  \r\nThis block of code will throw a `ReferenceError` before the code can be run because `x` is used before it is declared: &lt;!-- language: lang-js --&gt;\r\n\r\n    {\r\n        x = x + 1;  // ReferenceError during parsing: &quot;x is not defined&quot;.\r\n        let x;\r\n        console.log(`x is ${x}`);  // Never runs.\r\n    }\r\n\r\nIn contrast, the same example with `var` parses and runs without throwing any exceptions.\r\n\r\n**3. No redeclaration:**\r\nThe following code demonstrates that a variable declared with `let` may not be redeclared later: &lt;!-- language: lang-js --&gt;\r\n\r\n    let x = 1;\r\n    let x = 2;  // SyntaxError: Identifier &#39;x&#39; has already been declared\r\n\r\n**4. Globals not attached to `window`:**\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var button = &quot;I cause accidents because my name is too common.&quot;;\r\n    let link = &quot;Though my name is common, I am harder to access from other JS files.&quot;;\r\n    console.log(link);  // OK\r\n    console.log(window.link);  // undefined (GOOD!)\r\n    console.log(window.button);  // OK\r\n\r\n**5. Easy use with closures:**\r\nVariables declared with `var` do not work well with closures inside loops.  Here is a simple loop that outputs the sequence of values that the variable `i` has at different points in time: &lt;!-- language: lang-js --&gt;\r\n\r\n    for (let i = 0; i &lt; 5; i++) {\r\n        console.log(`i is ${i}`), 125/*ms*/);\r\n    }\r\n\r\nSpecifically, this outputs:\r\n\r\n    i is 0\r\n    i is 1\r\n    i is 2\r\n    i is 3\r\n    i is 4\r\n\r\nIn JavaScript we often use variables at a significantly later time than when they are created.  When we demonstrate this by delaying the output with a closure passed to `setTimeout`: &lt;!-- language: lang-js --&gt;\r\n\r\n    for (let i = 0; i &lt; 5; i++) {\r\n        setTimeout(_ =&gt; console.log(`i is ${i}`), 125/*ms*/);\r\n    }\r\n\r\n... the output remains unchanged as long as we stick with `let`.  In contrast, if we had used `var i` instead: &lt;!-- language: lang-js --&gt;\r\n\r\n    for (var i = 0; i &lt; 5; i++) {\r\n        setTimeout(_ =&gt; console.log(`i is ${i}`), 125/*ms*/);\r\n    }\r\n\r\n... the loop unexpectedly outputs &quot;i is 5&quot; five times:\r\n\r\n    i is 5\r\n    i is 5\r\n    i is 5\r\n    i is 5\r\n    i is 5\r\n"},{"score":11,"body_markdown":"`var` is global scope (hoist-able) variable.\r\n\r\n`let` and `const` is block scope.\r\n\r\n&gt; test.js\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    {\r\n        let l = &#39;let&#39;;\r\n        const c = &#39;const&#39;;\r\n        var v = &#39;var&#39;;\r\n        v2 = &#39;var 2&#39;;\r\n    }\r\n\r\n    console.log(v, this.v);\r\n    console.log(v2, this.v2);\r\n    console.log(l); // ReferenceError: l is not defined\r\n    console.log(c); // ReferenceError: c is not defined\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n  \r\n\r\n"},{"score":5,"body_markdown":"let is a part of es6. These functions will explain the difference in easy way.\r\n\r\n    function varTest() {\r\n      var x = 1;\r\n      if (true) {\r\n        var x = 2;  // same variable!\r\n        console.log(x);  // 2\r\n      }\r\n      console.log(x);  // 2\r\n    }\r\n\r\n    function letTest() {\r\n      let x = 1;\r\n      if (true) {\r\n        let x = 2;  // different variable\r\n        console.log(x);  // 2\r\n      }\r\n      console.log(x);  // 1\r\n    }"},{"score":-1,"body_markdown":"Check this link in\r\n[MDN][1]\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let\r\n\r\n    let x = 1;\r\n\r\n    if (x === 1) {\r\n    let x = 2;\r\n\r\n    console.log(x);\r\n    // expected output: 2\r\n    }\r\n\r\n    console.log(x);\r\n    // expected output: 1"},{"score":9,"body_markdown":"**When Using `let`**\r\n\r\nThe `let` keyword attaches the variable declaration to the scope of whatever block (commonly a `{ .. }` pair) it&#39;s contained in. In other words,`let` implicitly hijacks any block&#39;s scope for its variable declaration.\r\n\r\n`let` variables cannot be accessed in the `window` object because they cannot be globally accessed.\r\n\r\n\tfunction a(){\r\n\t\t{ // this is the Max Scope for let variable\r\n\t\t\tlet x = 12;\r\n\t\t}\r\n\t\tconsole.log(x);\r\n\t}\r\n\ta(); // Uncaught ReferenceError: x is not defined\r\n\r\n**When Using `var`**\r\n\r\n`var` and variables in ES5 has scopes in functions meaning the variables are valid within the function and not outside the function itself.\r\n\r\n`var` variables can be accessed in the `window` object because they cannot be globally accessed.\r\n\r\n\tfunction a(){ // this is the Max Scope for var variable\r\n\t\t{ \r\n\t\t\tvar x = 12;\r\n\t\t}\r\n\t\tconsole.log(x);\r\n\t}\r\n\ta(); // 12\r\n\r\n**If you want to know more continue reading below**\r\n\r\none of the most famous interview questions on scope also can suffice the exact use of `let` and `var` as below;\r\n\r\n**When using `let`**\r\n\r\n\tfor (let i = 0; i &lt; 10 ; i++) {\r\n\t\tsetTimeout(\r\n\t\t\tfunction a() {\r\n\t\t\t\tconsole.log(i); //print 0 to 9, that is literally AWW!!!\r\n\t\t\t}, \r\n\t\t\t100 * i);\r\n\t}\r\n\r\nThis is because when using `let`, for every loop iteration the variable is scoped and has its own copy.\r\n\r\n**When using `var`**\r\n\r\n\tfor (var i = 0; i &lt; 10 ; i++) {\r\n\t\tsetTimeout(\r\n\t\t\tfunction a() {\r\n\t\t\t\tconsole.log(i); //print 10 times 10\r\n\t\t\t}, \r\n\t\t\t100 * i);\r\n\t}\r\n\r\nThis is because when using `var`, for every loop iteration the variable is scoped and has shared copy."},{"score":3,"body_markdown":"As mentioned above:\r\n\r\n \r\n&gt; \r\n&gt; The difference is scoping. `var` is scoped to the nearest **function\r\n&gt; block** and `let` is scoped to the **nearest enclosing block**, which\r\n&gt; can be smaller than a function block. Both are global if outside any\r\n&gt; block.Lets see an example:\r\n\r\n**Example1:**\r\n\r\nIn my both examples I have a function `myfunc`. `myfunc` contains a variable `myvar` equals to 10. \r\nIn my first example  I check   if `myvar` equals to 10 (`myvar==10`) . If yes, I agian declare  a variable  `myvar` (now I have two myvar variables)using `var` keyword and assign it a new value (20). In next line I  print its value on my console.  After the conditional block I again print the value of `myvar` on my console. If you look at the output of `myfunc`,   `myvar` has value equals to 20. \r\n\r\n\r\n[![let keyword][1]][1]\r\n\r\n\r\n**Example2:**\r\nIn my second example  instead of using `var` keyword in my conditional block I declare `myvar` using `let` keyword . Now when I call `myfunc`  I get two different outputs: `myvar=20` and `myvar=10`.\r\n\r\nSo the difference is very simple i.e its scope. \r\n\r\n\r\n  [1]: https://i.stack.imgur.com/sWpnR.png"},{"score":14,"body_markdown":"Function VS block scope:\r\n------------------------\r\n\r\nThe main difference between `var` and `let` is that variables declared with `var` are **function scoped**. Whereas functions declared with `let` are **block scoped**. For example:\r\n\r\n    function testVar () {\r\n      if(true) {\r\n        var foo = &#39;foo&#39;;\r\n      }\r\n      \r\n      console.log(foo);\r\n    }\r\n    \r\n    testVar();  \r\n    // logs &#39;foo&#39;\r\n    \r\n    \r\n    function testLet () {\r\n      if(true) {\r\n        let bar = &#39;bar&#39;;\r\n      }\r\n      \r\n      console.log(bar);\r\n    }\r\n    \r\n    testLet(); \r\n    // reference error\r\n    // bar is scoped to the block of the if statement \r\n\r\n**variables with `var`:**\r\n\r\nWhen the first function `testVar` gets called the variable foo, declared with `var`, is still accessible outside the `if` statement. This variable `foo` would be available **everywhere** within the scope of the `testVar` **function**.\r\n\r\n**variables with `let`:**\r\n\r\nWhen the second function `testLet` gets called the variable bar, declared with `let`, is only accessible inside the `if` statement. Because variables declared with `let` are **block scoped** (where a block is the code between curly brackets e.g `if{}` , `for{}`, `function{}`). \r\n\r\n## `let` variables don&#39;t get hoisted: ##\r\n\r\nAnother difference between `var` and `let` is variables with declared with `let` **don&#39;t get hoisted**. An example is the best way to illustrate this behavior:\r\n\r\nvariables with `let` **don&#39;t** get hoisted:\r\n\r\n    console.log(letVar);\r\n    \r\n    let letVar = 10;\r\n    // referenceError, the variable doesn&#39;t get hoisted\r\n\r\nvariables with `var` **do** get hoisted:\r\n\r\n    console.log(varVar);\r\n    \r\n    var varVar = 10;\r\n    // logs undefined, the variable gets hoisted\r\n\r\nGlobal `let` doesn&#39;t get attached to `window`:\r\n-----------------------------------------------\r\n\r\nA variable declared with `let` in the global scope (which is code that is not in a function) doesn&#39;t get added as a property on the global `window` object. For example (this code is in global scope):\r\n\r\n    var bar = 5;\r\n    let foo  = 10;\r\n    \r\n    console.log(bar); // logs 5\r\n    console.log(foo); // logs 10\r\n    \r\n    console.log(window.bar);  \r\n    // logs 5, variable added to window object\r\n    \r\n    console.log(window.foo);\r\n    // logs undefined, variable not added to window object\r\n\r\n&lt;br&gt;\r\n\r\n&gt;  **When should `let` be used over `var`?**\r\n\r\nUse `let` over `var` whenever you can because it is simply scoped more specific. This reduces potential naming conflicts which can occur when dealing with a large number of variables. `var` can be used when you want a global variable explicitly to be on the `window` object (always consider carefully if this is really necessary). \r\n"},{"score":2,"body_markdown":"I want to link these keywords to the Execution Context, because the Execution Context is important in all of this. The Execution Context has two phases: a Creation Phase and Execution Phase. In addition, each Execution Context has a Variable Environment and Outer Environment (its Lexical Environment). \r\n\r\nDuring the Creation Phase of an Execution Context, var, let and const will still store its variable in memory with an undefined value in the Variable Environment of the given Execution Context. The difference is in the Execution Phase. If you use reference a variable defined with var before it is assigned a value, it will just be undefined. No exception will be raised. \r\n\r\nHowever, you cannot reference the variable declared with let or const until it is declared. If you try to use it before it is declared, then an exception will be raised during the Execution Phase of the Execution Context. Now the variable will still be in memory, courtesy of the Creation Phase of the Execution Context, but the Engine will not allow you to use it:\r\n\r\n    function a(){\r\n        b;\r\n        let b;\r\n    }\r\n    a();\r\n    &gt; Uncaught ReferenceError: b is not defined\r\n\r\nWith a variable defined with var, if the Engine cannot find the variable in the current Execution Context&#39;s Variable Environment, then it will go up the scope chain (the Outer Environment) and check the Outer Environment&#39;s Variable Environment for the variable. If it cannot find it there, it will continue searching the Scope Chain. This is not the case with let and const. \r\n\r\nThe second feature of let is it introduces block scope. Blocks are defined by curly braces. Examples include function blocks, if blocks, for blocks, etc. When you declare a variable with let inside of a block, the variable is only available inside of the block. In fact, each time the block is run, such as within a for loop, it will create a new variable in memory.\r\n\r\nES6 also introduces the const keyword for declaring variables. const is also block scoped. The difference between let and const is that const variables need to be declared using an initializer, or it will generate an error.\r\n\r\nAnd, finally, when it comes to the Execution Context, variables defined with var will be attached to the &#39;this&#39; object. In the global Execution Context, that will be the window object in browsers. This is not the case for let or const.\r\n\r\n\r\n\r\n\r\n"},{"score":1,"body_markdown":"[![enter image description here][1]][1]\r\n\r\nTake a look at this image, I created one very simple example for demonstration of `const` and `let` variables. As you can see, when you try to change `const` variable, you will get the error (**Attempting to override &#39;name&#39; which is constant&#39;**), but take a look at `let` variable... \r\n\r\nFirst we declare `let age = 33`, and later assign some other value `age = 34;`, which is ok, we dont have any errors when we try to change `let` variable\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/sEh8Y.png"},{"score":2,"body_markdown":"As I am currently trying to get an in depth understanding of JavaScript I will share my brief research which contains some of the great pieces already discussed plus some other details in a different perspective.\r\n\r\nUnderstanding the difference between **var** and **let** can be easier if we understand the difference between *function* and *block scope*.\r\n\r\nLet&#39;s consider the following cases:\r\n\r\n    (function timer() {\r\n    \tfor(var i = 0; i &lt;= 5; i++) {\r\n    \t\tsetTimeout(function notime() { console.log(i); }, i * 1000);\r\n    \t}\r\n    })();\r\n\r\n\r\n       Stack\t\t    VariableEnvironment //one VariablEnvironment for timer();\r\n                                           // when the timer is out - the value will be the same value for each call\r\n    5. [setTimeout, i]\t[i=5] \r\n    4. [setTimeout, i]\t\r\n    3. [setTimeout, i]\r\n    2. [setTimeout, i]\r\n    1. [setTimeout, i]\r\n    0. [setTimeout, i]\r\n\r\n    ####################    \r\n\r\n    (function timer() {\r\n    \tfor (let i = 0; i &lt;= 5; i++) {\r\n    \t\tsetTimeout(function notime() { console.log(i); }, i * 1000);\r\n    \t}\r\n    })();\r\n\r\n       Stack\t\t   LexicalEnvironment - each iteration has a new lexical environment\r\n    5. [setTimeout, i]\t[i=5] \t\t\r\n    \t\t\t          LexicalEnvironment \r\n    4. [setTimeout, i]\t  [i=4]\t\t\r\n    \t\t\t            LexicalEnvironment \r\n    3. [setTimeout, i]\t    [i=3]\t\t\r\n    \t\t\t             LexicalEnvironment \r\n    2. [setTimeout, i]\t     [i=2]\r\n    \t\t\t               LexicalEnvironment \r\n    1. [setTimeout, i]\t       [i=1]\r\n    \t\t\t                 LexicalEnvironment \r\n    0. [setTimeout, i]\t         [i=0]\r\n\r\nwhen `timer()` gets called an **ExecutionContext** is created which will contain both the **VariableEnvironment** and all the **LexicalEnvironments** corresponding to each iteration.\r\n\r\n \r\nAnd a simpler example\r\n\r\nFunction Scope\r\n\r\n    function test() {\r\n    \tfor(var z = 0; z &lt; 69; z++) {\r\n    \t\t//todo\r\n    \t}\r\n    \t//z is visible outside the loop\r\n    }\r\n\r\nBlock Scope\r\n\r\n    function test() {\r\n    \tfor(let z = 0; z &lt; 69; z++) {\r\n    \t\t//todo\r\n    \t}\r\n    \t//z is not defined :(\r\n    }\r\n\r\n"},{"score":5,"body_markdown":"let vs var. It&#39;s all about **scope**. \r\n\r\n**var variables are global** and can be accessed basically everywhere, while **let variables are not global** and only exist until a closing parenthesis kills them. \r\n\r\nSee my example below, and note how the lion (let) variable acts differently in the two console.logs; it becomes out of scope in the 2nd console.log.\r\n\r\n    var cat = &quot;cat&quot;;\r\n    let dog = &quot;dog&quot;;\r\n    \r\n    var animals = () =&gt; {\r\n        var giraffe = &quot;giraffe&quot;;\r\n        let lion = &quot;lion&quot;;\r\n    \r\n        console.log(cat);  //will print &#39;cat&#39;.\r\n        console.log(dog);  //will print &#39;dog&#39;, because dog was declared outside this function (like var cat).\r\n        \r\n        console.log(giraffe); //will print &#39;giraffe&#39;.\r\n        console.log(lion); //will print &#39;lion&#39;, as lion is within scope.\r\n    }\r\n    \r\n    console.log(giraffe); //will print &#39;giraffe&#39;, as giraffe is a global variable (var).\r\n    console.log(lion); //will print UNDEFINED, as lion is a &#39;let&#39; variable and is now out of scope.\r\n\r\n"},{"score":2,"body_markdown":"I think the terms and most of the examples are a bit overwhelming,\r\nThe main issue i had personally with the difference is understanding what a &quot;Block&quot; is.\r\nAt some point i realized, a block would be any curly brackets except for `IF` statement.\r\nan opening bracket `{` of a function or loop will define a new block, anything defined with `let` within it, will not be available after the closing bracket `}` of the same thing (function or loop);\r\nWith that in mind, it was easier to understand:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let msg = &quot;Hello World&quot;;\r\n\r\n    function doWork() { // msg will be available since it was defined above this opening bracket!\r\n      let friends = 0;\r\n      console.log(msg);\r\n\r\n      // with VAR though:\r\n      for (var iCount2 = 0; iCount2 &lt; 5; iCount2++) {} // iCount2 will be available after this closing bracket!\r\n      console.log(iCount2);\r\n      \r\n        for (let iCount1 = 0; iCount1 &lt; 5; iCount1++) {} // iCount1 will not be available behind this closing bracket, it will return undefined\r\n      console.log(iCount1);\r\n      \r\n    } // friends will no be available after this closing bracket!\r\n    doWork();\r\n    console.log(friends);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":6,"body_markdown":"The below shows how &#39;let&#39; and &#39;var&#39; are different in the scope:\r\n\r\n    let gfoo = 123;\r\n    if (true) {\r\n        let gfoo = 456;\r\n    }\r\n    console.log(gfoo); // 123\r\n    \r\n    var hfoo = 123;\r\n    if (true) {\r\n        var hfoo = 456;\r\n    }\r\n    console.log(hfoo); // 456\r\n\r\nThe `gfoo`, defined by `let` initially is in the **global scope**, and when we declare `gfoo` again inside the `if clause` its ***scope changed*** and when a new value is assigned to the variable inside that scope it **does not affect** the global scope.\r\n\r\nWhereas `hfoo`, defined by `var` is initially in the **global scope**, but again when we declare it inside the `if clause`, it considers the global scope hfoo, although var has been used again to declare it. And when we re-assign its value we see that the global scope hfoo is also affected. This is the primary difference."},{"score":7,"body_markdown":"&gt; ES6 introduced two new keyword(**let** and **const**) alternate to **var**.\r\n&gt; \r\n&gt; When you need a block level deceleration you can go with let and const\r\n&gt; instead of var.\r\n&gt; \r\n&gt; The below table summarize the difference between var, let and const\r\n\r\n[![enter image description here][1]][1]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/GBn5a.jpg"},{"score":47,"body_markdown":"In most basic terms,\r\n--------------------\r\n\r\n    for (let i = 0; i &lt; 5; i++) {\r\n      // i accessible ✔️\r\n    }\r\n    // i not accessible ❌\r\n\r\n---\r\n\r\n    for (var i = 0; i &lt; 5; i++) {\r\n      // i accessible ✔️\r\n    }\r\n    // i accessible ✔️\r\n\r\n---\r\n\r\n\r\n⚡️ Sandbox to play around &amp;darr;\r\n\r\n[![Edit let vs var](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/let-vs-var-emzh5?fontsize=14&amp;hidenavigation=1&amp;theme=dark)"},{"score":0,"body_markdown":"That makes a lot of easy understanding by understanding Why Let use in JavaScript. This is the [Link][1] Where you Find More Helpful information about **Let** keyword in **JavaScript**.\r\n\r\nAs per the Definition, the **let** allows you to declare variables that are limited to the scope of a block statement, or expression on which it is used, unlike the var keyword, which defines a variable globally, or locally to an entire function regardless of block scope. The other difference between var and let is that the latter is initialized to value only when a parser evaluates it (see below).\r\n\r\nJust like const, the let does not create properties of the window object when declared globally (in the top-most scope).\r\n\r\nAs below example:-  let statement declares a block-scoped local variable, optionally initializing it to a value.\r\n\r\n    let x = 1;\r\n\r\n    if (x === 1) {\r\n     let x = 2;\r\n\r\n     console.log(x);\r\n     // expected output: 2\r\n    }\r\n\r\n      console.log(x);\r\n      // expected output: 1\r\n\r\nVariables declared by **let** have their scope in the block for which they are defined, as well as in any contained sub-blocks. In this way, let work very much like var. **The main difference is that the scope of a var variable is the entire enclosing function:**\r\nWe can understand it by this example:-\r\n\r\n    function varTest() {\r\n     var x = 1;\r\n     {\r\n      var x = 2;  // same variable!\r\n      console.log(x);  // 2\r\n     }\r\n      console.log(x);  // 2\r\n    }\r\n\r\n    function letTest() {\r\n     let x = 1;\r\n     {\r\n      let x = 2;  // different variable\r\n      console.log(x);  // 2\r\n     }\r\n      console.log(x);  // 1\r\n    }\r\n\r\nAt the top level of programs and functions, **let**, unlike **var**, does not create a property on the global object. **For example:**\r\n\r\n    var x = &#39;global&#39;;\r\n    let y = &#39;global&#39;;\r\n    console.log(this.x); // &quot;global&quot;\r\n    console.log(this.y); // undefined\r\nIn dealing with constructors it is possible to use the let bindings to share one or more private members without using closures: Example:-\r\n\r\n    var Thing;\r\n     {\r\n          let privateScope = new WeakMap();\r\n          let counter = 0;\r\n        \r\n          Thing = function() {\r\n            this.someProperty = &#39;foo&#39;;\r\n            \r\n            privateScope.set(this, {\r\n              hidden: ++counter,\r\n            });\r\n          };\r\n        \r\n          Thing.prototype.showPublic = function() {\r\n            return this.someProperty;\r\n          };\r\n        \r\n          Thing.prototype.showPrivate = function() {\r\n            return privateScope.get(this).hidden;\r\n          };\r\n        }\r\n        \r\n        console.log(typeof privateScope);\r\n        // &quot;undefined&quot;\r\n        \r\n        var thing = new Thing();\r\n        \r\n        console.log(thing);\r\n        // Thing {someProperty: &quot;foo&quot;}\r\n        \r\n        thing.showPublic();\r\n        // &quot;foo&quot;\r\n        \r\n        thing.showPrivate();\r\n        // 1\r\nThe same privacy pattern with closures over local variables can be created with var, but those need a function scope (typically an IIFE in the module pattern) instead of just a block scope like in the example above.\r\n\r\n**&#39;let&#39;** chosen for block-scoped variable declarations in **JavaScript**? That is undefined in Global Scope.\r\n\r\n**JavaScript** has had var from the beginning, so they just needed another keyword, and just borrowed from dozens of other languages that use let already as a traditional keyword as close to var as possible, although in JavaScript let creates block scope local variable instead.\r\n\r\nIt does exactly what the **var** does with a scope difference. Now it can not take the name **var** since that is already taken.\r\n\r\nSo it looks that it has taken the next best name which has a semantic in an interesting English language construct.\r\n\r\n      let mySon = &#39;Peter&#39;;\r\nIn English, it says &quot;Let my Son name is Peter&quot;.\r\n\r\nThat&#39;s why the **JavaScript** use the let keyword for more flexibility with other language programmers. It uses to upgrade the language. \r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let\r\n"},{"score":1,"body_markdown":"I just came across one use case that I had to use `var` over `let` to introduce new variable. Here&#39;s a case:\r\n\r\nI want to create a new variable with dynamic variable names. \r\n\r\n```\r\nlet variableName = &#39;a&#39;;\r\neval(&quot;let &quot; + variableName + &#39;= 10;&#39;);\r\nconsole.log(a);   // this doesn&#39;t work\r\n```\r\n\r\n```\r\nlet variableName = &#39;a&#39;;\r\neval(&quot;var &quot; + variableName + &#39;= 10;&#39;);\r\nconsole.log(a);   // this works\r\n```\r\n\r\nThe above code doesn&#39;t work because `eval` introduces a new block of code. The declaration using `var` will declare a variable outside of this block of code since `var` declares a variable in the function scope.\r\n\r\n`let`, on the other hand, declares a variable in a block scope. So, `a` variable will only be visible in `eval` block."}],"score":4830}