{"body":"I am trying to print an integer in [JavaScript][1] with commas as thousands separators. For example, I want to show the number 1234567 as &quot;1,234,567&quot;. How would I go about doing this? \r\n\r\nHere is how I am doing it:\r\n\r\n    function numberWithCommas(x) {\r\n        x = x.toString();\r\n        var pattern = /(-?\\d+)(\\d{3})/;\r\n        while (pattern.test(x))\r\n            x = x.replace(pattern, &quot;$1,$2&quot;);\r\n        return x;\r\n    }\r\n\r\nIs there a simpler or more elegant way to do it? It would be nice if it works with floats also, but that is not necessary. It does not need to be locale-specific to decide between periods and commas. \r\n\r\n  [1]: http://en.wikipedia.org/wiki/JavaScript\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                 \r\n","title":"How to print a number with commas as thousands separators in JavaScript","answers":[{"score":117,"body_markdown":"I suggest using phpjs.org &#39;s [number_format()](http://phpjs.org/functions/number_format:481)\r\n\r\n    function number_format(number, decimals, dec_point, thousands_sep) {\r\n        // http://kevin.vanzonneveld.net\r\n        // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\r\n        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n        // +     bugfix by: Michael White (http://getsprink.com)\r\n        // +     bugfix by: Benjamin Lupton\r\n        // +     bugfix by: Allan Jensen (http://www.winternet.no)\r\n        // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\r\n        // +     bugfix by: Howard Yeend\r\n        // +    revised by: Luke Smith (http://lucassmith.name)\r\n        // +     bugfix by: Diogo Resende\r\n        // +     bugfix by: Rival\r\n        // +      input by: Kheang Hok Chin (http://www.distantia.ca/)\r\n        // +   improved by: davook\r\n        // +   improved by: Brett Zamir (http://brett-zamir.me)\r\n        // +      input by: Jay Klehr\r\n        // +   improved by: Brett Zamir (http://brett-zamir.me)\r\n        // +      input by: Amir Habibi (http://www.residence-mixte.com/)\r\n        // +     bugfix by: Brett Zamir (http://brett-zamir.me)\r\n        // +   improved by: Theriault\r\n        // +   improved by: Drew Noakes\r\n        // *     example 1: number_format(1234.56);\r\n        // *     returns 1: &#39;1,235&#39;\r\n        // *     example 2: number_format(1234.56, 2, &#39;,&#39;, &#39; &#39;);\r\n        // *     returns 2: &#39;1 234,56&#39;\r\n        // *     example 3: number_format(1234.5678, 2, &#39;.&#39;, &#39;&#39;);\r\n        // *     returns 3: &#39;1234.57&#39;\r\n        // *     example 4: number_format(67, 2, &#39;,&#39;, &#39;.&#39;);\r\n        // *     returns 4: &#39;67,00&#39;\r\n        // *     example 5: number_format(1000);\r\n        // *     returns 5: &#39;1,000&#39;\r\n        // *     example 6: number_format(67.311, 2);\r\n        // *     returns 6: &#39;67.31&#39;\r\n        // *     example 7: number_format(1000.55, 1);\r\n        // *     returns 7: &#39;1,000.6&#39;\r\n        // *     example 8: number_format(67000, 5, &#39;,&#39;, &#39;.&#39;);\r\n        // *     returns 8: &#39;67.000,00000&#39;\r\n        // *     example 9: number_format(0.9, 0);\r\n        // *     returns 9: &#39;1&#39;\r\n        // *    example 10: number_format(&#39;1.20&#39;, 2);\r\n        // *    returns 10: &#39;1.20&#39;\r\n        // *    example 11: number_format(&#39;1.20&#39;, 4);\r\n        // *    returns 11: &#39;1.2000&#39;\r\n        // *    example 12: number_format(&#39;1.2000&#39;, 3);\r\n        // *    returns 12: &#39;1.200&#39;\r\n        var n = !isFinite(+number) ? 0 : +number, \r\n            prec = !isFinite(+decimals) ? 0 : Math.abs(decimals),\r\n            sep = (typeof thousands_sep === &#39;undefined&#39;) ? &#39;,&#39; : thousands_sep,\r\n            dec = (typeof dec_point === &#39;undefined&#39;) ? &#39;.&#39; : dec_point,\r\n            toFixedFix = function (n, prec) {\r\n                // Fix for IE parseFloat(0.55).toFixed(0) = 0;\r\n                var k = Math.pow(10, prec);\r\n                return Math.round(n * k) / k;\r\n            },\r\n            s = (prec ? toFixedFix(n, prec) : Math.round(n)).toString().split(&#39;.&#39;);\r\n        if (s[0].length &gt; 3) {\r\n            s[0] = s[0].replace(/\\B(?=(?:\\d{3})+(?!\\d))/g, sep);\r\n        }\r\n        if ((s[1] || &#39;&#39;).length &lt; prec) {\r\n            s[1] = s[1] || &#39;&#39;;\r\n            s[1] += new Array(prec - s[1].length + 1).join(&#39;0&#39;);\r\n        }\r\n        return s.join(dec);\r\n    }\r\n\r\n\r\n---\r\n\r\n**UPDATE 02/13/14**\r\n\r\nPeople have been reporting this doesn&#39;t work as expected, so I did a [JS Fiddle](http://jsfiddle.net/drewnoakes/xc3qh35z/) that includes automated tests.\r\n\r\n**Update 26/11/2017**\r\n\r\nHere&#39;s that fiddle as a Stack Snippet with slightly modified output:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function number_format(number, decimals, dec_point, thousands_sep) {\r\n        // http://kevin.vanzonneveld.net\r\n        // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\r\n        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n        // +     bugfix by: Michael White (http://getsprink.com)\r\n        // +     bugfix by: Benjamin Lupton\r\n        // +     bugfix by: Allan Jensen (http://www.winternet.no)\r\n        // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\r\n        // +     bugfix by: Howard Yeend\r\n        // +    revised by: Luke Smith (http://lucassmith.name)\r\n        // +     bugfix by: Diogo Resende\r\n        // +     bugfix by: Rival\r\n        // +      input by: Kheang Hok Chin (http://www.distantia.ca/)\r\n        // +   improved by: davook\r\n        // +   improved by: Brett Zamir (http://brett-zamir.me)\r\n        // +      input by: Jay Klehr\r\n        // +   improved by: Brett Zamir (http://brett-zamir.me)\r\n        // +      input by: Amir Habibi (http://www.residence-mixte.com/)\r\n        // +     bugfix by: Brett Zamir (http://brett-zamir.me)\r\n        // +   improved by: Theriault\r\n        // +   improved by: Drew Noakes\r\n        // *     example 1: number_format(1234.56);\r\n        // *     returns 1: &#39;1,235&#39;\r\n        // *     example 2: number_format(1234.56, 2, &#39;,&#39;, &#39; &#39;);\r\n        // *     returns 2: &#39;1 234,56&#39;\r\n        // *     example 3: number_format(1234.5678, 2, &#39;.&#39;, &#39;&#39;);\r\n        // *     returns 3: &#39;1234.57&#39;\r\n        // *     example 4: number_format(67, 2, &#39;,&#39;, &#39;.&#39;);\r\n        // *     returns 4: &#39;67,00&#39;\r\n        // *     example 5: number_format(1000);\r\n        // *     returns 5: &#39;1,000&#39;\r\n        // *     example 6: number_format(67.311, 2);\r\n        // *     returns 6: &#39;67.31&#39;\r\n        // *     example 7: number_format(1000.55, 1);\r\n        // *     returns 7: &#39;1,000.6&#39;\r\n        // *     example 8: number_format(67000, 5, &#39;,&#39;, &#39;.&#39;);\r\n        // *     returns 8: &#39;67.000,00000&#39;\r\n        // *     example 9: number_format(0.9, 0);\r\n        // *     returns 9: &#39;1&#39;\r\n        // *    example 10: number_format(&#39;1.20&#39;, 2);\r\n        // *    returns 10: &#39;1.20&#39;\r\n        // *    example 11: number_format(&#39;1.20&#39;, 4);\r\n        // *    returns 11: &#39;1.2000&#39;\r\n        // *    example 12: number_format(&#39;1.2000&#39;, 3);\r\n        // *    returns 12: &#39;1.200&#39;\r\n        var n = !isFinite(+number) ? 0 : +number, \r\n            prec = !isFinite(+decimals) ? 0 : Math.abs(decimals),\r\n            sep = (typeof thousands_sep === &#39;undefined&#39;) ? &#39;,&#39; : thousands_sep,\r\n            dec = (typeof dec_point === &#39;undefined&#39;) ? &#39;.&#39; : dec_point,\r\n            toFixedFix = function (n, prec) {\r\n                // Fix for IE parseFloat(0.55).toFixed(0) = 0;\r\n                var k = Math.pow(10, prec);\r\n                return Math.round(n * k) / k;\r\n            },\r\n            s = (prec ? toFixedFix(n, prec) : Math.round(n)).toString().split(&#39;.&#39;);\r\n        if (s[0].length &gt; 3) {\r\n            s[0] = s[0].replace(/\\B(?=(?:\\d{3})+(?!\\d))/g, sep);\r\n        }\r\n        if ((s[1] || &#39;&#39;).length &lt; prec) {\r\n            s[1] = s[1] || &#39;&#39;;\r\n            s[1] += new Array(prec - s[1].length + 1).join(&#39;0&#39;);\r\n        }\r\n        return s.join(dec);\r\n    }\r\n\r\n    var exampleNumber = 1;\r\n    function test(expected, number, decimals, dec_point, thousands_sep)\r\n    {\r\n        var actual = number_format(number, decimals, dec_point, thousands_sep);\r\n        console.log(\r\n            &#39;Test case &#39; + exampleNumber + &#39;: &#39; +\r\n            &#39;(decimals: &#39; + (typeof decimals === &#39;undefined&#39; ? &#39;(default)&#39; : decimals) +\r\n            &#39;, dec_point: &quot;&#39; + (typeof dec_point === &#39;undefined&#39; ? &#39;(default)&#39; : dec_point) + &#39;&quot;&#39; +\r\n            &#39;, thousands_sep: &quot;&#39; + (typeof thousands_sep === &#39;undefined&#39; ? &#39;(default)&#39; : thousands_sep) + &#39;&quot;)&#39;\r\n        );\r\n        console.log(&#39;  =&gt; &#39; + (actual === expected ? &#39;Passed&#39; : &#39;FAILED&#39;) + &#39;, got &quot;&#39; + actual + &#39;&quot;, expected &quot;&#39; + expected + &#39;&quot;.&#39;);\r\n        exampleNumber++;\r\n    }\r\n\r\n    test(&#39;1,235&#39;,    1234.56);\r\n    test(&#39;1 234,56&#39;, 1234.56, 2, &#39;,&#39;, &#39; &#39;);\r\n    test(&#39;1234.57&#39;,  1234.5678, 2, &#39;.&#39;, &#39;&#39;);\r\n    test(&#39;67,00&#39;,    67, 2, &#39;,&#39;, &#39;.&#39;);\r\n    test(&#39;1,000&#39;,    1000);\r\n    test(&#39;67.31&#39;,    67.311, 2);\r\n    test(&#39;1,000.6&#39;,  1000.55, 1);\r\n    test(&#39;67.000,00000&#39;, 67000, 5, &#39;,&#39;, &#39;.&#39;);\r\n    test(&#39;1&#39;,        0.9, 0);\r\n    test(&#39;1.20&#39;,     &#39;1.20&#39;, 2);\r\n    test(&#39;1.2000&#39;,   &#39;1.20&#39;, 4);\r\n    test(&#39;1.200&#39;,    &#39;1.2000&#39;, 3);\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n      max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":3,"body_markdown":"I think your solution is one of the shorter ones I&#39;ve seen for this. I don&#39;t think there are any standard JavaScript functions to do this sort of thing, so you&#39;re probably on your own.\r\n\r\nI checked the CSS 3 specifications to see whether it&#39;s possible to do this in CSS, but unless you want every digit in its own `&lt;span&gt;`, I don&#39;t think that&#39;s possible.\r\n\r\nI did find one project on [Google Code][1] that looked promising: [flexible-js-formatting][2]. I haven&#39;t used it, but it looks pretty flexible and has unit tests using [JsUnit][3]. The developer also has a lot of posts (though old) about this topic.\r\n\r\nBe sure to consider international users: lots of nations use a space as the separator and use the comma for separating the decimal from the integral part of the number. \r\n\r\n  [1]: http://en.wikipedia.org/wiki/Google_Code\r\n  [2]: http://code.google.com/p/flexible-js-formatting/\r\n  [3]: https://github.com/pivotal/jsunit"},{"score":3044,"body_markdown":"I used the idea from Kerry&#39;s answer, but simplified it since I was just looking for something simple for my specific purpose. Here is what I did:\r\n\r\n    function numberWithCommas(x) {\r\n        return x.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, &quot;,&quot;);\r\n    }\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function numberWithCommas(x) {\r\n        return x.toString().replace(/\\B(?&lt;!\\.\\d*)(?=(\\d{3})+(?!\\d))/g, &quot;,&quot;);\r\n    }\r\n\r\n    function test(x, expect) {\r\n        const result = numberWithCommas(x);\r\n        const pass = result === expect;\r\n        console.log(`${pass ? &quot;✓&quot; : &quot;ERROR ====&gt;&quot;} ${x} =&gt; ${result}`);\r\n        return pass;\r\n    }\r\n\r\n    let failures = 0;\r\n    failures += !test(0,        &quot;0&quot;);\r\n    failures += !test(100,      &quot;100&quot;);\r\n    failures += !test(1000,     &quot;1,000&quot;);\r\n    failures += !test(10000,    &quot;10,000&quot;);\r\n    failures += !test(100000,   &quot;100,000&quot;);\r\n    failures += !test(1000000,  &quot;1,000,000&quot;);\r\n    failures += !test(10000000, &quot;10,000,000&quot;);\r\n    if (failures) {\r\n        console.log(`${failures} test(s) failed`);\r\n    } else {\r\n        console.log(&quot;All tests passed&quot;);\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n        max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n---\r\nThe regex uses 2 lookahead assertions: \r\n\r\n- a positive one to look for any point in the string that has a multiple of 3 digits in a row after it, \r\n- a negative assertion to make sure that point only has exactly a multiple of 3 digits. The replacement expression puts a comma there.\r\n\r\nFor example, if you pass it `123456789.01`, the positive assertion will match every spot to the left of the 7 (since `789` is a multiple of 3 digits, `678` is a multiple of 3 digits, `567`, etc.). The negative assertion checks that the multiple of 3 digits does not have any digits after it. `789` has a period after it so it is exactly a multiple of 3 digits, so a comma goes there. `678` is a multiple of 3 digits but it has a `9` after it, so those 3 digits are part of a group of 4, and a comma does not go there. Similarly for `567`. `456789` is 6 digits, which is a multiple of 3, so a comma goes before that. `345678` is a multiple of 3, but it has a `9` after it, so no comma goes there. And so on. The `\\B` keeps the regex from putting a comma at the beginning of the string.\r\n\r\n@[neu-rah][1] mentioned that this function adds commas in undesirable places if there are more than 3 digits after the decimal point. If this is a problem, you can use this function:\r\n\r\n    function numberWithCommas(x) {\r\n        var parts = x.toString().split(&quot;.&quot;);\r\n        parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, &quot;,&quot;);\r\n        return parts.join(&quot;.&quot;);\r\n    }\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function numberWithCommas(x) {\r\n        var parts = x.toString().split(&quot;.&quot;);\r\n        parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, &quot;,&quot;);\r\n        return parts.join(&quot;.&quot;);\r\n    }\r\n\r\n    function test(x, expect) {\r\n        const result = numberWithCommas(x);\r\n        const pass = result === expect;\r\n        console.log(`${pass ? &quot;✓&quot; : &quot;ERROR ====&gt;&quot;} ${x} =&gt; ${result}`);\r\n        return pass;\r\n    }\r\n\r\n    let failures = 0;\r\n    failures += !test(0              , &quot;0&quot;);\r\n    failures += !test(0.123456       , &quot;0.123456&quot;);\r\n    failures += !test(100            , &quot;100&quot;);\r\n    failures += !test(100.123456     , &quot;100.123456&quot;);\r\n    failures += !test(1000           , &quot;1,000&quot;);\r\n    failures += !test(1000.123456    , &quot;1,000.123456&quot;);\r\n    failures += !test(10000          , &quot;10,000&quot;);\r\n    failures += !test(10000.123456   , &quot;10,000.123456&quot;);\r\n    failures += !test(100000         , &quot;100,000&quot;);\r\n    failures += !test(100000.123456  , &quot;100,000.123456&quot;);\r\n    failures += !test(1000000        , &quot;1,000,000&quot;);\r\n    failures += !test(1000000.123456 , &quot;1,000,000.123456&quot;);\r\n    failures += !test(10000000       , &quot;10,000,000&quot;);\r\n    failures += !test(10000000.123456, &quot;10,000,000.123456&quot;);\r\n    if (failures) {\r\n        console.log(`${failures} test(s) failed`);\r\n    } else {\r\n        console.log(&quot;All tests passed&quot;);\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n        max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n@[t.j.crowder][2] pointed out that now that JavaScript has lookbehind ([support info](https://caniuse.com/#feat=js-regexp-lookbehind)), it can be solved in the regular expression itself:\r\n\r\n    function numberWithCommas(x) {\r\n        return x.toString().replace(/\\B(?&lt;!\\.\\d*)(?=(\\d{3})+(?!\\d))/g, &quot;,&quot;);\r\n    }\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function numberWithCommas(x) {\r\n        return x.toString().replace(/\\B(?&lt;!\\.\\d*)(?=(\\d{3})+(?!\\d))/g, &quot;,&quot;);\r\n    }\r\n\r\n    function test(x, expect) {\r\n        const result = numberWithCommas(x);\r\n        const pass = result === expect;\r\n        console.log(`${pass ? &quot;✓&quot; : &quot;ERROR ====&gt;&quot;} ${x} =&gt; ${result}`);\r\n        return pass;\r\n    }\r\n\r\n    let failures = 0;\r\n    failures += !test(0,               &quot;0&quot;);\r\n    failures += !test(0.123456,        &quot;0.123456&quot;);\r\n    failures += !test(100,             &quot;100&quot;);\r\n    failures += !test(100.123456,      &quot;100.123456&quot;);\r\n    failures += !test(1000,            &quot;1,000&quot;);\r\n    failures += !test(1000.123456,     &quot;1,000.123456&quot;);\r\n    failures += !test(10000,           &quot;10,000&quot;);\r\n    failures += !test(10000.123456,    &quot;10,000.123456&quot;);\r\n    failures += !test(100000,          &quot;100,000&quot;);\r\n    failures += !test(100000.123456,   &quot;100,000.123456&quot;);\r\n    failures += !test(1000000,         &quot;1,000,000&quot;);\r\n    failures += !test(1000000.123456,  &quot;1,000,000.123456&quot;);\r\n    failures += !test(10000000,        &quot;10,000,000&quot;);\r\n    failures += !test(10000000.123456, &quot;10,000,000.123456&quot;);\r\n    if (failures) {\r\n        console.log(`${failures} test(s) failed`);\r\n    } else {\r\n        console.log(&quot;All tests passed&quot;);\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n        max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n`(?&lt;!\\.\\d*)` is a negative lookbehind that says the match can&#39;t be preceded by a `.` followed by zero or more digits. The negative lookbehind is faster than the `split` and `join` solution ([comparison](http://jsben.ch/umq99)), at least in V8.\r\n\r\n\r\n  [1]: https://stackoverflow.com/users/1329075/neu-rah\r\n  [2]: https://stackoverflow.com/users/157247/t-j-crowder"},{"score":13,"body_markdown":"Here&#39;s a simple function that inserts commas for thousand separators.  It uses array functions rather than a RegEx.\r\n\r\n    /**\r\n     * Format a number as a string with commas separating the thousands.\r\n     * @param num - The number to be formatted (e.g. 10000)\r\n     * @return A string representing the formatted number (e.g. &quot;10,000&quot;)\r\n     */\r\n    var formatNumber = function(num) {\r\n\t    var array = num.toString().split(&#39;&#39;);\r\n\t    var index = -3;\r\n\t    while (array.length + index &gt; 0) {\r\n\t\t    array.splice(index, 0, &#39;,&#39;);\r\n\t\t    // Decrement by 4 since we just added another unit to the array.\r\n\t\t    index -= 4;\r\n\t    }\r\n\t    return array.join(&#39;&#39;);\r\n    };\r\n\r\nCodeSandbox link with examples: https://codesandbox.io/s/p38k63w0vq"},{"score":78,"body_markdown":"This is a variation of @mikez302&#39;s answer, but modified to support numbers with decimals (per @neu-rah&#39;s feedback that numberWithCommas(12345.6789) -&gt; &quot;12,345.6,789&quot; instead of &quot;12,345.6789&quot;\r\n\r\n    function numberWithCommas(n) {\r\n    \tvar parts=n.toString().split(&quot;.&quot;);\r\n    \treturn parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, &quot;,&quot;) + (parts[1] ? &quot;.&quot; + parts[1] : &quot;&quot;);\r\n    }\r\n\r\n\r\n\r\n"},{"score":35,"body_markdown":"Thanks to everyone for their replies. I have built off of some of the answers to make a more &quot;one-size-fits-all&quot; solution. \r\n\r\nThe first snippet adds a function that mimics [PHP][1]&#39;s `number_format()` to the Number prototype. If I am formatting a number, I usually want decimal places so the function takes in the number of decimal places to show. Some countries use commas as the decimal and decimals as the thousands separator so the function allows these separators to be set.\r\n\r\n    Number.prototype.numberFormat = function(decimals, dec_point, thousands_sep) {\r\n        dec_point = typeof dec_point !== &#39;undefined&#39; ? dec_point : &#39;.&#39;;\r\n        thousands_sep = typeof thousands_sep !== &#39;undefined&#39; ? thousands_sep : &#39;,&#39;;\r\n        \r\n        var parts = this.toFixed(decimals).split(&#39;.&#39;);\r\n        parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousands_sep);\r\n\r\n        return parts.join(dec_point);\r\n    }\r\n\r\nYou would use this as follows:\r\n\r\n    var foo = 5000;\r\n    console.log(foo.numberFormat(2)); // us format: 5,000.00\r\n    console.log(foo.numberFormat(2, &#39;,&#39;, &#39;.&#39;)); // european format: 5.000,00\r\n\r\nI found that I often needed to get the number back for math operations, but parseFloat converts 5,000 to 5, simply taking the first sequence of integer values. So I created my own float conversion function and added it to the String prototype.\r\n\r\n    String.prototype.getFloat = function(dec_point, thousands_sep) {\r\n        dec_point = typeof dec_point !== &#39;undefined&#39; ? dec_point : &#39;.&#39;;\r\n        thousands_sep = typeof thousands_sep !== &#39;undefined&#39; ? thousands_sep : &#39;,&#39;;\r\n\r\n        var parts = this.split(dec_point);\r\n        var re = new RegExp(&quot;[&quot; + thousands_sep + &quot;]&quot;);\r\n        parts[0] = parts[0].replace(re, &#39;&#39;);\r\n\r\n        return parseFloat(parts.join(dec_point));\r\n    }\r\n\r\nNow you can use both functions as follows:\r\n\r\n    var foo = 5000;\r\n    var fooString = foo.numberFormat(2); // The string 5,000.00\r\n    var fooFloat = fooString.getFloat(); // The number 5000;\r\n\r\n    console.log((fooString.getFloat() + 1).numberFormat(2)); // The string 5,001.00\r\n\r\n  [1]: http://en.wikipedia.org/wiki/PHP\r\n"},{"score":3,"body_markdown":"I added tofixed to **Aki143S**&#39;s solution.\r\nThis solution uses dots for thousands separators and comma for the precision.\r\n\r\n\tfunction formatNumber( num, fixed ) { \r\n\t \tvar decimalPart;\r\n\r\n \t\tvar array = Math.floor(num).toString().split(&#39;&#39;);\r\n \t\tvar index = -3; \r\n \t\twhile ( array.length + index &gt; 0 ) { \r\n \t\t\tarray.splice( index, 0, &#39;.&#39; );  \t\t\t\r\n \t\t\tindex -= 4;\r\n \t\t}\r\n\r\n\t\tif(fixed &gt; 0){\r\n\t \t\tdecimalPart = num.toFixed(fixed).split(&quot;.&quot;)[1];\r\n\t \t\treturn array.join(&#39;&#39;) + &quot;,&quot; + decimalPart; \r\n\t \t}\r\n\t \treturn array.join(&#39;&#39;); \r\n\t};\r\n\r\nExamples;\r\n\r\n    formatNumber(17347, 0)  = 17.347\r\n    formatNumber(17347, 3)  = 17.347,000\r\n    formatNumber(1234563.4545, 3)  = 1.234.563,454"},{"score":4,"body_markdown":"I think this function will take care of all the issues related to this problem.\r\n\r\n    function commaFormat(inputString) {\r\n        inputString = inputString.toString();\r\n        var decimalPart = &quot;&quot;;\r\n        if (inputString.indexOf(&#39;.&#39;) != -1) {\r\n            //alert(&quot;decimal number&quot;);\r\n            inputString = inputString.split(&quot;.&quot;);\r\n            decimalPart = &quot;.&quot; + inputString[1];\r\n            inputString = inputString[0];\r\n            //alert(inputString);\r\n            //alert(decimalPart);\r\n\r\n        }\r\n        var outputString = &quot;&quot;;\r\n        var count = 0;\r\n        for (var i = inputString.length - 1; i &gt;= 0 &amp;&amp; inputString.charAt(i) != &#39;-&#39;; i--) {\r\n            //alert(&quot;inside for&quot; + inputString.charAt(i) + &quot;and count=&quot; + count + &quot; and outputString=&quot; + outputString);\r\n            if (count == 3) {\r\n                outputString += &quot;,&quot;;\r\n                count = 0;\r\n            }\r\n            outputString += inputString.charAt(i);\r\n            count++;\r\n        }\r\n        if (inputString.charAt(0) == &#39;-&#39;) {\r\n            outputString += &quot;-&quot;;\r\n        }\r\n        //alert(outputString);\r\n        //alert(outputString.split(&quot;&quot;).reverse().join(&quot;&quot;));\r\n        return outputString.split(&quot;&quot;).reverse().join(&quot;&quot;) + decimalPart;\r\n    }"},{"score":0,"body_markdown":"For Integers I used a very simple method:\r\n\r\n    var myNumber = 99999,\r\n        myString = myNumber + &quot;&quot;;\r\n\r\n    myString.length &gt; 3 ? return myString.substring(0, myString.length - 3) + &quot;,&quot; + \r\n        myString.substring(myString.length - 3) : return myString;"},{"score":2,"body_markdown":"The solution from @user1437663 is great.\r\n\r\nWho really understands the solution is being prepared to understand complex regular expressions.\r\n\r\nA small improvement to make it more readable:\r\n\r\n    function numberWithCommas(x) {\r\n        var parts = x.toString().split(&quot;.&quot;);\r\n        return parts[0].replace(/\\B(?=(\\d{3})+(?=$))/g, &quot;,&quot;) + (parts[1] ? &quot;.&quot; + parts[1] : &quot;&quot;);\r\n    }\r\n\r\nThe pattern starts with **\\B** to avoid use comma at the beginning of a word. Interestingly, the pattern is returned empty because **\\B** does not advance the &quot;cursor&quot; (the same applies to **$**).\r\n\r\nO **\\B** is followed by a less known resources but is a powerful feature from Perl&#39;s regular expressions.\r\n\r\n                Pattern1 (? = (Pattern2) ).\r\n\r\nThe magic is that what is in parentheses (*Pattern2*) is a pattern that follows the previous pattern (*Pattern1*) but without advancing the cursor and also is not part of the pattern returned. It is a kind of future pattern. This is similar when someone looks forward but really doesn&#39;t walk! \r\n\r\nIn this case *pattern2* is     \r\n             \r\n\r\n    \\d{3})+(?=$)\r\n\r\nIt means 3 digits (one or more times) followed by the end of the string ($)\r\n\r\nFinally, **Replace** method changes all occurrences of the pattern found (empty string) for comma. This only happens in cases where the remaining piece is a multiple of 3 digits \r\n(such cases where future cursor reach the end of the origin)."},{"score":2015,"body_markdown":"I&#39;m surprised nobody mentioned [Number.prototype.toLocaleString][1].\r\nIt&#39;s implemented in JavaScript 1.5 (which was introduced in 1999) so it&#39;s basically supported across all major browsers.\r\n\r\n```js\r\nvar n = 34523453.345\r\nn.toLocaleString()\r\n&quot;34,523,453.345&quot;\r\n```\r\n\r\nIt also works in Node.js as of v0.12 via inclusion of [Intl][3]\r\n\r\nJust pay attention that this function returns a string, not a number.\r\n\r\nIf you want something different, [Numeral.js][2] might be interesting.\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\r\n  [2]: http://numeraljs.com/\r\n  [3]: https://github.com/andyearnshaw/Intl.js"},{"score":13,"body_markdown":"The following code uses char scan, so there&#39;s no regex. \r\n\r\n    function commafy( num){\r\n      var parts = (&#39;&#39;+(num&lt;0?-num:num)).split(&quot;.&quot;), s=parts[0], L, i=L= s.length, o=&#39;&#39;;\r\n      while(i--){ o = (i===0?&#39;&#39;:((L-i)%3?&#39;&#39;:&#39;,&#39;)) \r\n                      +s.charAt(i) +o }\r\n      return (num&lt;0?&#39;-&#39;:&#39;&#39;) + o + (parts[1] ? &#39;.&#39; + parts[1] : &#39;&#39;); \r\n    }\r\n\r\n\r\nIt shows promising performance: [http://jsperf.com/number-formatting-with-commas/5][1]\r\n\r\n2015.4.26: Minor fix to resolve issue when num&lt;0. See https://jsfiddle.net/runsun/p5tqqvs3/\r\n\r\n  [1]: http://jsperf.com/number-formatting-with-commas/5"},{"score":-1,"body_markdown":"Yet another..(for int&#39;s as the question asks)\r\n\r\n    function insertCommas(str)\r\n    {\r\n        var a = str.split(&quot;&quot;);\r\n     \ta.reverse();\r\n\t\r\n        var t, i = 0, arr = Array();\r\n        \r\n        while (t = a.shift())\r\n        {\r\n           if (((i++ % 3) == 0) &amp;&amp; arr.length &gt; 0)\r\n               arr.unshift(&quot;,&quot;);\r\n           arr.unshift(t);\r\n        }\r\n        \r\n        return arr.join(&quot;&quot;);\r\n    }"},{"score":3,"body_markdown":"Lots of good answers already. Here&#39;s another, just for fun:\r\n\r\n    function format(num, fix) {\r\n        var p = num.toFixed(fix).split(&quot;.&quot;);\r\n        return p[0].split(&quot;&quot;).reduceRight(function(acc, num, i, orig) {\r\n            if (&quot;-&quot; === num &amp;&amp; 0 === i) {\r\n                return num + acc;\r\n            }\r\n            var pos = orig.length - i - 1\r\n            return  num + (pos &amp;&amp; !(pos % 3) ? &quot;,&quot; : &quot;&quot;) + acc;\r\n        }, &quot;&quot;) + (p[1] ? &quot;.&quot; + p[1] : &quot;&quot;);\r\n    }\r\n\r\nSome examples:\r\n\r\n    format(77.03453, 2); // &quot;77.03&quot;\r\n    format(78436589374); // &quot;78,436,589,374&quot;\r\n    format(784, 4);      // &quot;784.0000&quot;\r\n    format(-123456);     // &quot;-123,456&quot;"},{"score":14,"body_markdown":"if you are dealing with currency values and formatting a lot then it might be worth to add tiny [accounting.js][1] which handles lot of edge cases and localization:\r\n\r\n    // Default usage:\r\n    accounting.formatMoney(12345678); // $12,345,678.00\r\n    \r\n    // European formatting (custom symbol and separators), could also use options object as second param:\r\n    accounting.formatMoney(4999.99, &quot;€&quot;, 2, &quot;.&quot;, &quot;,&quot;); // €4.999,99\r\n    \r\n    // Negative values are formatted nicely, too:\r\n    accounting.formatMoney(-500000, &quot;&#163; &quot;, 0); // &#163; -500,000\r\n    \r\n    // Simple `format` string allows control of symbol position [%v = value, %s = symbol]:\r\n    accounting.formatMoney(5318008, { symbol: &quot;GBP&quot;,  format: &quot;%v %s&quot; }); // 5,318,008.00 GBP\r\n\r\n\r\n  [1]: http://josscrowcroft.github.io/accounting.js/"},{"score":0,"body_markdown":"Here is good solution with less coding...\r\n\r\n    var y = &quot;&quot;;\r\n    var arr = x.toString().split(&quot;&quot;);\r\n    for(var i=0; i&lt;arr.length; i++)\r\n    {\r\n        y += arr[i];\r\n        if((arr.length-i-1)%3==0 &amp;&amp; i&lt;arr.length-1) y += &quot;,&quot;;\r\n    }"},{"score":18,"body_markdown":"The thousands separator can be inserted in an international-friendly manner using the browser&#39;s `Intl` object:\r\n\r\n    Intl.NumberFormat().format(1234);\r\n    // returns &quot;1,234&quot; if the user&#39;s locale is en_US, for example\r\n\r\nSee [MDN&#39;s article on NumberFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) for more, you can specify locale behavior or default to the user&#39;s. This is a little more foolproof because it respects local differences; many countries use periods to separate digits while a comma denotes the decimals.\r\n\r\nIntl.NumberFormat isn&#39;t available in all browsers yet, but it works in latest Chrome, Opera, &amp; IE. Firefox&#39;s next release should support it. Webkit doesn&#39;t seem to have a timeline for implementation."},{"score":-7,"body_markdown":"You could just use the `printf`-way, for example:\r\n\r\n    double number = 1234567;\r\n    System.out.printf(&quot;%,.2f&quot; , number);"},{"score":0,"body_markdown":"For indian numeric system\r\n\r\n    var number = &quot;323483.85&quot;\r\n    var decimal = number.split(&quot;.&quot;);\r\n    var res = (decimal[0].length&gt;3? numberWithCommas(decimal[0].substring(0,decimal[0].length-3))+ &#39;,&#39; :decimal[0]) + (decimal[0].length&gt;3?decimal[0].substring(decimal[0].length-3,decimal[0].length):&#39;&#39;) + &#39;.&#39; + decimal[1];\r\n\r\nOutput: 3,23,483.85"},{"score":5,"body_markdown":"An alternative way, supporting decimals, different separators and negatives.\r\n\r\n&lt;!-- language: javasript --&gt;\r\n\r\n\tvar number_format = function(number, decimal_pos, decimal_sep, thousand_sep) {\r\n\t\tvar ts \t\t= ( thousand_sep == null ? &#39;,&#39; : thousand_sep )\r\n\t\t\t, ds \t= ( decimal_sep  == null ? &#39;.&#39; : decimal_sep )\r\n\t\t\t, dp    = ( decimal_pos  == null ? 2   : decimal_pos )\r\n\r\n\t\t\t, n     = Math.floor(Math.abs(number)).toString()\r\n\r\n\t\t\t, i     = n.length % 3 \r\n\t\t\t, f     = ((number &lt; 0) ? &#39;-&#39; : &#39;&#39;) + n.substr(0, i)\r\n\t\t;\r\n\r\n\t\tfor(;i&lt;n.length;i+=3) {\r\n\t\t\tif(i!=0) f+=ts;\r\n\t\t\tf+=n.substr(i,3);\r\n\t\t}\r\n\r\n\t\tif(dp &gt; 0) \r\n\t\t\tf += ds + parseFloat(number).toFixed(dp).split(&#39;.&#39;)[1]\r\n\r\n\t\treturn f;\r\n\t}\r\n\r\n\r\nSome corrections by @Jignesh Sanghani, don&#39;t forget to upvote his comment."},{"score":73,"body_markdown":"    function formatNumber (num) {\r\n        return num.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, &quot;$1,&quot;)\r\n    }\r\n\r\n    print(formatNumber(2665));      // 2,665\r\n    print(formatNumber(102665));    // 102,665\r\n    print(formatNumber(111102665)); // 111,102,665"},{"score":7,"body_markdown":"I Wrote this one before stumbling on this post. No regex and you can actually understand the code.\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $(function(){\r\n      \r\n      function insertCommas(s) {\r\n\r\n        // get stuff before the dot\r\n        var d = s.indexOf(&#39;.&#39;);\r\n        var s2 = d === -1 ? s : s.slice(0, d);\r\n\r\n        // insert commas every 3 digits from the right\r\n        for (var i = s2.length - 3; i &gt; 0; i -= 3)\r\n          s2 = s2.slice(0, i) + &#39;,&#39; + s2.slice(i);\r\n\r\n        // append fractional part\r\n        if (d !== -1)\r\n          s2 += s.slice(d);\r\n\r\n        return s2;\r\n\r\n      }\r\n      \r\n      \r\n      $(&#39;#theDudeAbides&#39;).text( insertCommas(&#39;1234567.89012&#39; ) );\r\n      \r\n      \r\n    });\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n\r\n    &lt;div id=&quot;theDudeAbides&quot;&gt;&lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":5,"body_markdown":"Let me try to improve [uKolka][1]&#39;s [answer][2] and maybe help others save some time.\r\n\r\nUse [Numeral.js][3].\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    document.body.textContent = numeral(1234567).format(&#39;0,0&#39;);\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/numeral.js/1.4.5/numeral.min.js&quot;&gt;&lt;/script&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nYou should go with [Number.prototype.toLocaleString&amp;#40;&amp;#41;][4] only if its [browser compatibilty][5] is not an issue.\r\n\r\n\r\n  [1]: https://stackoverflow.com/users/1286601/ukolka &quot;uKolka&quot;\r\n  [2]: https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript/17663871#17663871 &quot;answer&quot;\r\n  [3]: http://numeraljs.com/ &quot;Numeral.js&quot;\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString &quot;Number.prototype.toLocaleString&amp;#40;&amp;#41;&quot;\r\n  [5]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString#AutoCompatibilityTable &quot;browser compatibilty&quot;"},{"score":23,"body_markdown":"I think this is the shortest regular expression that does it:\r\n\r\n    /\\B(?=(\\d{3})+\\b)/g\r\n    \r\n    &quot;123456&quot;.replace(/\\B(?=(\\d{3})+\\b)/g, &quot;,&quot;)\r\n\r\nI checked it on a few numbers and it worked."},{"score":1,"body_markdown":"I&#39;ve adapted your code to work in TextBox (Input type=&quot;text&quot;) so we can enter and delete digits in real time without losing cursor. It&#39;s works also if you select range when you delete. And you can use arrows and home/end buttons freely.&lt;br/&gt;\r\nThanks for saving my time!\r\n\r\n    //function controls number format as &quot;1,532,162.3264321&quot;\r\n    function numberWithCommas(x) {\r\n        var e = e || window.event;\r\n       \tif (e.keyCode &gt;= &#39;35&#39; &amp;&amp; e.keyCode &lt;= &#39;40&#39;) return; //skip arrow-keys\r\n        var selStart = x.selectionStart, selEnd = x.selectionEnd; //save cursor positions\r\n        var parts = x.value.toString().split(&quot;.&quot;);\r\n        var part0len = parts[0].length; //old length to check if new &#39;,&#39; would be added. Need for correcting new cursor position (+1 to right).\r\n    \r\n        //if user deleted &#39;,&#39; - remove previous number instead (without selection)\r\n        if (x.selectionLength == 0 &amp;&amp; (e.keyCode == 8 || e.keyCode == 46)) {//if pressed 8-backspace or 46-delete button\r\n            var delPos = parts[0].search(/\\d{4}/);\r\n            if (delPos != -1) {//if found 4 digits in a row (&#39;,&#39; is deleted)\r\n                if (e.keyCode == 8) {//if backspace flag\r\n    \t\t\t\tparts[0] = parts[0].slice(0, selStart - 1) + parts[0].slice(selEnd, parts[0].length);\r\n                    selEnd--;\r\n                    if (selStart &gt; selEnd) selStart = selEnd;\r\n                } else {\r\n                    parts[0] = parts[0].slice(0, selStart) + parts[0].slice(selEnd + 1, parts[0].length);\r\n                    selStart++;\r\n                    if (selEnd &lt; selStart) selEnd = selStart;\r\n                }\r\n            }\r\n        }\r\n\r\n       var hasMinus = parts[0][0] == &#39;-&#39;;\r\n       parts[0] = (hasMinus ? &#39;-&#39; : &#39;&#39;) + parts[0].replace(/[^\\d]*/g, &quot;&quot;); //I&#39;d like to clear old &#39;,&#39; to avoid things like 1,2,3,5,634.443216\r\n       parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, &quot;,&quot;); //sets &#39;,&#39; between each 3 digits\r\n       if (part0len &lt; parts[0].length) { //move cursor to right if added new &#39;,&#39;\r\n           selStart++;\r\n           selEnd++;\r\n       } else if (part0len &gt; parts[0].length) { //..or if removed last one &#39;,&#39;\r\n           selStart--;\r\n           selEnd--;\r\n       }\r\n       x.value = parts.join(&quot;.&quot;);\r\n       x.setSelectionRange(selStart, selEnd); //restoring cursor position\r\n    }\r\n    function saveSelectionLength(x) {\r\n        x.selectionLength = x.selectionEnd - x.selectionStart;\r\n    }\r\n\r\nTo use this just added two events - onKeyUp and onKeyDown\r\n\r\n    &lt;asp:TextBox runat=&quot;server&quot; ID=&quot;val&quot; Width=&quot;180px&quot; onKeyUp=&quot;numberWithCommas(this);&quot; onKeyDown=&quot;saveSelectionLength(this);&quot;/&gt;"},{"score":285,"body_markdown":"Below are two different browser APIs that can transform *Numbers* into structured *Strings*. Keep in mind that not all users&#39; machines have a [**locale** that uses commas in numbers][1]. To enforce commas to the output, any &quot;western&quot; *locale* may be used, such as `en-US`\r\n\r\n    var number = 1234567890; // Example number to be converted\r\n⚠️ Mind that javascript has a [maximum integer][2] value of `9007199254740991`\r\n\r\n---\r\n\r\n## [toLocaleString][3]\r\n\r\n    // default behaviour on a machine with a local that uses commas for numbers\r\n    number.toLocaleString(); // &quot;1,234,567,890&quot;\r\n\r\n    // With custom settings, forcing a &quot;US&quot; locale to guarantee commas in output\r\n    var number2 = 1234.56789; // floating point example\r\n    number2.toLocaleString(&#39;en-US&#39;, {maximumFractionDigits:2}) // &quot;1,234.57&quot;\r\n\r\n\r\n\r\n## [NumberFormat][4] \r\n\r\n    var nf = new Intl.NumberFormat();\r\n    nf.format(number); // &quot;1,234,567,890&quot;\r\n\r\n-----\r\nFrom what I checked (Firefox at least) they are both more or less same regarding performance.\r\n\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Decimal_separator\r\n  [2]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER\r\n  [3]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat"},{"score":0,"body_markdown":"I thought I&#39;d share a little trick which I&#39;m using for large number formatting.\r\nInstead of inserting commas or spaces, I insert an empty but visible span in between the &quot;thousands&quot;. This makes thousands easily visible, but it allows to copy/paste the input in the original format, without commas/spaces.\r\n\r\n    // This function accepts an integer, and produces a piece of HTML that shows it nicely with \r\n    // some empty space at &quot;thousand&quot; markers. \r\n    // Note, these space are not spaces, if you copy paste, they will not be visible.\r\n    function valPrettyPrint(orgVal) {\r\n      // Save after-comma text, if present\r\n      var period = orgVal.indexOf(&quot;.&quot;);\r\n      var frac = period &gt;= 0 ? orgVal.substr(period) : &quot;&quot;;\r\n      // Work on input as an integer\r\n      var val = &quot;&quot; + Math.trunc(orgVal);\r\n      var res = &quot;&quot;;\r\n      while (val.length &gt; 0) {\r\n        res = val.substr(Math.max(0, val.length - 3), 3) + res;\r\n        val = val.substr(0, val.length - 3);\r\n        if (val.length &gt; 0) {\r\n        \tres = &quot;&lt;span class=&#39;thousandsSeparator&#39;&gt;&lt;/span&gt;&quot; + res;\r\n        }\r\n      }\r\n      // Add the saved after-period information\r\n      res += frac;\r\n      return res;\r\n    }\r\n\r\nWith this CSS:\r\n\r\n    .thousandsSeparator {\r\n      display : inline;\r\n      padding-left : 4px;\r\n    }\r\n\r\nSee an example [JSFiddle.][1] \r\n\r\n\r\n  [1]: https://jsfiddle.net/marcinzukowski/ovfd83py/"},{"score":21,"body_markdown":"`Number.prototype.toLocaleString()` would have been awesome if it was provided natively by all browsers _(Safari)_. \r\n\r\nI checked all other answers but noone seemed to polyfill it. Here is a poc towards that, which is actually a combination of first two answers; if `toLocaleString` works it uses it, if it doesn&#39;t it uses a custom function.\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var putThousandsSeparators;\r\n\r\n    putThousandsSeparators = function(value, sep) {\r\n      if (sep == null) {\r\n        sep = &#39;,&#39;;\r\n      }\r\n      // check if it needs formatting\r\n      if (value.toString() === value.toLocaleString()) {\r\n        // split decimals\r\n        var parts = value.toString().split(&#39;.&#39;)\r\n        // format whole numbers\r\n        parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, sep);\r\n        // put them back together\r\n        value = parts[1] ? parts.join(&#39;.&#39;) : parts[0];\r\n      } else {\r\n        value = value.toLocaleString();\r\n      }\r\n      return value;\r\n    };\r\n\r\n    alert(putThousandsSeparators(1234567.890));\r\n\r\n&lt;!-- end snippet --&gt;"},{"score":1,"body_markdown":"If you happen to be using AngularJS, there&#39;s this currency filter that may definitely help: http://www.w3schools.com/angular/ng_filter_currency.asp"},{"score":-2,"body_markdown":"   This should work now ... edited to add decimal places if the number is a decimal.\r\n   \r\n\r\n    &lt;script&gt;\r\n      function makedollars(mynumber)\r\n          {\r\n           mynumber = mynumber.toString();\r\n        var numberend=&quot;&quot;;\r\n\r\n      if(mynumber.split(&#39;.&#39;).length&gt;1){\r\n           var mynumbersplit = mynumber.split(&#39;.&#39;);\r\n         mynumber = mynumbersplit[0];\r\n       numberend= mynumbersplit[1];\r\n    \r\n      }\r\n           \r\n          var  mn = mynumber.length;\r\n\r\n          if (mn &lt;= 3) { return mynumber + numberend; }\r\n          var grps = [];\r\n\r\n            while (mn &gt; 3)\r\n            {  \r\n                grps.push(mynumber.substring(mn,mn - 3));\r\n                mn = mn - 3;\r\n            }\r\n            grps.push(mynumber.substring(mn,mn - 3));\r\n          grps.reverse();\r\n\r\n            grps.join(&quot;,&quot;);\r\n            if(numberend!=&quot;&quot;){ grps =  grps +&quot;.&quot;+numberend;}\r\n           \r\n            return grps; \r\n                  }\r\n\r\n\r\n     &lt;/script&gt;"},{"score":7,"body_markdown":"    var formatNumber = function (number) {\r\n      var splitNum;\r\n      number = Math.abs(number);\r\n      number = number.toFixed(2);\r\n      splitNum = number.split(&#39;.&#39;);\r\n      splitNum[0] = splitNum[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, &quot;,&quot;);\r\n      return splitNum.join(&quot;.&quot;);\r\n    }\r\n\r\nEDIT:\r\nThe function only work with positive number. for exmaple:\r\n\r\n    var number = -123123231232;\r\n    formatNumber(number)\r\n\r\nOutput: &quot;123,123,231,232&quot;\r\n\r\nBut to answer the question above `toLocaleString()` method just solves the problem.\r\n\r\n    var number = 123123231232;\r\n        number.toLocaleString()\r\n\r\nOutput: &quot;123,123,231,232&quot;\r\n\r\nCheer!"},{"score":0,"body_markdown":"Here&#39;s my try:\r\n\r\nEDIT: Added in decimals\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function splitMille(n, separator = &#39;,&#39;) {\r\n      // Cast to string\r\n      let num = (n + &#39;&#39;)\r\n\r\n      // Test for and get any decimals (the later operations won&#39;t support them)\r\n      let decimals = &#39;&#39;\r\n      if (/\\./.test(num)) {\r\n        // This regex grabs the decimal point as well as the decimal numbers\r\n        decimals = num.replace(/^.*(\\..*)$/, &#39;$1&#39;)\r\n      }\r\n      \r\n      // Remove decimals from the number string\r\n      num = num.replace(decimals, &#39;&#39;)\r\n        // Reverse the number string through Array functions\r\n        .split(&#39;&#39;).reverse().join(&#39;&#39;)\r\n        // Split into groups of 1-3 characters (with optional supported character &quot;-&quot; for negative numbers)\r\n        .match(/[0-9]{1,3}-?/g)\r\n        // Add in the mille separator character and reverse back\r\n        .join(separator).split(&#39;&#39;).reverse().join(&#39;&#39;)\r\n\r\n      // Put the decimals back and output the formatted number\r\n      return `${num}${decimals}`\r\n    }\r\n\r\n    let testA = splitMille(1234)\r\n    let testB = splitMille(-1234)\r\n    let testC = splitMille(123456.789)\r\n    let testD = splitMille(9007199254740991)\r\n    let testE = splitMille(1000.0001)\r\n\r\n    console.log(&#39;Results!\\n\\tA: %s\\n\\tB: %s\\n\\tC: %s\\n\\tD: %s\\n\\tE: %s&#39;, testA, testB, testC, testD, testE)\r\n\r\n&lt;!-- end snippet --&gt;"},{"score":0,"body_markdown":"Here is a one line function with int &amp; decimal support. I left some code in to convert the number to a string as well.\r\n\r\n        function numberWithCommas(x) {\r\n\t\t\treturn (x=x+&#39;&#39;).replace(new RegExp(&#39;\\\\B(?=(\\\\d{3})+&#39;+(~x.indexOf(&#39;.&#39;)?&#39;\\\\.&#39;:&#39;$&#39;)+&#39;)&#39;,&#39;g&#39;),&#39;,&#39;);\r\n\t\t}"},{"score":42,"body_markdown":"[Intl.NumberFormat][1]\r\n\r\nNative JS function. Supported by IE11, Edge, latest Safari, Chrome, Firefox, Opera, Safari on iOS and Chrome on Android.\r\n\r\n    var number = 3500;\r\n    \r\n    console.log(new Intl.NumberFormat().format(number));\r\n    // → &#39;3,500&#39; if in US English locale\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat"},{"score":18,"body_markdown":"You can either use this procedure to format your currency needing.\r\n\r\n    var nf = new Intl.NumberFormat(&#39;en-US&#39;, {\r\n      style: &#39;currency&#39;,\r\n      currency: &#39;USD&#39;,\r\n      minimumFractionDigits: 2,\r\n      maximumFractionDigits: 2\r\n    });\r\n    nf.format(123456.789); // ‘$123,456.79’\r\n\r\nFor more info you can access this link.\r\n\r\nhttps://www.justinmccandless.com/post/formatting-currency-in-javascript/"},{"score":-2,"body_markdown":"&gt; \r\n\r\n    function addCommas(nStr) {\r\n        nStr += &#39;&#39;;\r\n        var x = nStr.split(&#39;.&#39;);\r\n        var x1 = x[0];\r\n        var x2 = x.length &gt; 1 ? &#39;.&#39; + x[1] : &#39;&#39;;\r\n        var rgx = /(\\d+)(\\d{3})/;\r\n        while (rgx.test(x1)) {\r\n                x1 = x1.replace(rgx, &#39;$1&#39; + &#39;,&#39; + &#39;$2&#39;);\r\n        }\r\n        return x1 + x2;\r\n    }\r\n\r\n    addCommas(parseFloat(&quot;1099920.23232&quot;).toFixed(2)); //Output  1,099,920.23\r\n\r\n"},{"score":1,"body_markdown":"After not finding a modern and comprehensive solution here, I have written an arrow function (without regex) to solve the formatting problem and it allows the caller to provide number of **fraction digits** as well as the **period and thousand separator** for Europe and rest of the world.\r\n\r\n&gt; Examples:\r\n&gt; \r\n&gt;     numberFormatter(1234567890.123456) =&gt; 1,234,567,890\r\n&gt;     numberFormatter(1234567890.123456, 4) =&gt; 1,234,567,890.1235\r\n&gt;     numberFormatter(1234567890.123456, 4, &#39;.&#39;, &#39;,&#39;) =&gt; 1.234.567.890,1235 Europe\r\n\r\nHere is the function written in **ES6** (modern syntax):\r\n\r\n    const numberFormatter = (number, fractionDigits = 0, thousandSeperator = &#39;,&#39;, fractionSeperator = &#39;.&#39;) =&gt; {\r\n        if (number!==0 &amp;&amp; !number || !Number.isFinite(number)) return number\r\n        const frDigits = Number.isFinite(fractionDigits)? Math.min(Math.max(fractionDigits, 0), 7) : 0\r\n        const num = number.toFixed(frDigits).toString()\r\n    \r\n        const parts = num.split(&#39;.&#39;)\r\n        let digits = parts[0].split(&#39;&#39;).reverse()\r\n        let sign = &#39;&#39;\r\n        if (num &lt; 0) {sign = digits.pop()}\r\n        let final = []\r\n        let pos = 0\r\n    \r\n        while (digits.length &gt; 1) {\r\n            final.push(digits.shift())\r\n            pos++\r\n            if (pos % 3 === 0) {final.push(thousandSeperator)}\r\n        }\r\n        final.push(digits.shift())\r\n        return `${sign}${final.reverse().join(&#39;&#39;)}${frDigits &gt; 0 ? fractionSeperator : &#39;&#39;}${frDigits &gt; 0 &amp;&amp; parts[1] ? parts[1] : &#39;&#39;}`\r\n    }\r\nIt has been **tested for negative, bad input and NaN cases**. If the input is **NaN** then it simply returns it."},{"score":-2,"body_markdown":"You can use for loops to add commas to the number\r\n\r\n\r\n    function convertNumber(){\r\n        var _cash = cash.toString()\r\n        var _formattedCash = &#39;&#39;\r\n        var count = 0\r\n    \r\n        for (let i = _cash.length; i &gt;= 0; i--) {\r\n            _formattedCash += _cash.substring(i,i+1)\r\n    \r\n            if(count == 3 &amp;&amp; i &gt; 0){\r\n                _formattedCash += &#39;,&#39;\r\n                count = 0\r\n            }\r\n            count++\r\n        }\r\n            \r\n        var _format = &#39;&#39;\r\n    \r\n        for (let i = _formattedCash.length; i &gt;= 0; i--) {\r\n            _format += _formattedCash.substring(i, i + 1)\r\n        }\r\n    \r\n        return &#39;Ksh &#39; + _format;\r\n    }"},{"score":1,"body_markdown":"I&#39;ve found an approach that works in every situation. [CodeSandbox example](https://codesandbox.io/s/zmvxjpj6x)\r\n\r\n    function commas(n) {\r\n      if (n &lt; 1000) {\r\n        return n + &#39;&#39;\r\n      } else {\r\n        // Convert to string.\r\n        n += &#39;&#39;\r\n\r\n        // Skip scientific notation.\r\n        if (n.indexOf(&#39;e&#39;) !== -1) {\r\n          return n\r\n        }\r\n\r\n        // Support fractions.\r\n        let i = n.indexOf(&#39;.&#39;)\r\n        let f = i == -1 ? &#39;&#39; : n.slice(i)\r\n        if (f) n = n.slice(0, i)\r\n\r\n        // Add commas.\r\n        i = n.length\r\n        n = n.split(&#39;&#39;)\r\n        while (i &gt; 3) n.splice((i -= 3), 0, &#39;,&#39;)\r\n        return n.join(&#39;&#39;) + f\r\n      }\r\n    }\r\n\r\nThis is like [Noah Freitas&#39; answer](https://stackoverflow.com/a/10418247/2228559), but with support for **fractions** and **scientific notation**.\r\n\r\nI think `toLocaleString` is the best choice, if performance is not a concern.\r\n\r\n**edit:** Here&#39;s a CodeSandbox with some examples: https://codesandbox.io/s/zmvxjpj6x"},{"score":55,"body_markdown":"**Using Regular expression**\r\n\r\n    function toCommas(value) {\r\n        return value.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, &quot;,&quot;);\r\n    }\r\n    console.log(toCommas(123456789)); // 123,456,789\r\n\r\n    console.log(toCommas(1234567890)); // 1,234,567,890\r\n    console.log(toCommas(1234)); // 1,234\r\n\r\n**Using toLocaleString()**\r\n\r\n\r\n    var number = 123456.789;\r\n  \r\n    // request a currency format\r\n    console.log(number.toLocaleString(&#39;de-DE&#39;, { style: &#39;currency&#39;, currency: &#39;EUR&#39; }));\r\n    // → 123.456,79 €\r\n\r\n    // the Japanese yen doesn&#39;t use a minor unit\r\n    console.log(number.toLocaleString(&#39;ja-JP&#39;, { style: &#39;currency&#39;, currency: &#39;JPY&#39; }))\r\n    // → ￥123,457\r\n    \r\n    // limit to three significant digits\r\n    console.log(number.toLocaleString(&#39;en-IN&#39;, { maximumSignificantDigits: 3 }));\r\n    // → 1,23,000\r\n\r\n   \r\nref [MDN:Number.prototype.toLocaleString()][1]\r\n\r\n**Using Intl.NumberFormat()**\r\n\r\n    var number = 123456.789;\r\n    \r\n    console.log(new Intl.NumberFormat(&#39;de-DE&#39;, { style: &#39;currency&#39;, currency: &#39;EUR&#39; }).format(number));\r\n    // expected output: &quot;123.456,79 €&quot;\r\n    \r\n    // the Japanese yen doesn&#39;t use a minor unit\r\n    console.log(new Intl.NumberFormat(&#39;ja-JP&#39;, { style: &#39;currency&#39;, currency: &#39;JPY&#39; }).format(number));\r\n    // expected output: &quot;￥123,457&quot;\r\n    \r\n    // limit to three significant digits\r\n    console.log(new Intl.NumberFormat(&#39;en-IN&#39;, { maximumSignificantDigits: 3 }).format(number));\r\n\r\n    // expected output: &quot;1,23,000&quot;\r\n\r\nref [Intl.NumberFormat][2]\r\n\r\n\r\n**DEMO AT HERE**\r\n&lt;script \r\n\r\n&lt;!-- begin snippet: js hide: false console: false babel: false --&gt;\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n      // Using Regular expression\r\n      function toCommas(value) {\r\n        return value.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, &quot;,&quot;);\r\n      }\r\n\r\n      function commas() {\r\n        var num1 = document.myform.number1.value;\r\n\r\n        // Using Regular expression\r\n        document.getElementById(&#39;result1&#39;).value = toCommas(parseInt(num1));\r\n        // Using toLocaleString()\r\n\r\n        document.getElementById(&#39;result2&#39;).value = parseInt(num1).toLocaleString(&#39;ja-JP&#39;, {\r\n          style: &#39;currency&#39;,\r\n          currency: &#39;JPY&#39;\r\n        });\r\n\r\n        // Using Intl.NumberFormat()\r\n        document.getElementById(&#39;result3&#39;).value = new Intl.NumberFormat(&#39;ja-JP&#39;, {\r\n          style: &#39;currency&#39;,\r\n          currency: &#39;JPY&#39;\r\n        }).format(num1);\r\n      }\r\n    &lt;/script&gt;\r\n    &lt;FORM NAME=&quot;myform&quot;&gt;\r\n      &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;number1&quot; VALUE=&quot;123456789&quot;&gt;\r\n      &lt;br&gt;\r\n      &lt;INPUT TYPE=&quot;button&quot; NAME=&quot;button&quot; Value=&quot;=&gt;&quot; onClick=&quot;commas()&quot;&gt;\r\n      &lt;br&gt;Using Regular expression\r\n      &lt;br&gt;\r\n      &lt;INPUT TYPE=&quot;text&quot; ID=&quot;result1&quot; NAME=&quot;result1&quot; VALUE=&quot;&quot;&gt;\r\n      &lt;br&gt;Using toLocaleString()\r\n      &lt;br&gt;\r\n      &lt;INPUT TYPE=&quot;text&quot; ID=&quot;result2&quot; NAME=&quot;result2&quot; VALUE=&quot;&quot;&gt;\r\n      &lt;br&gt;Using Intl.NumberFormat()\r\n      &lt;br&gt;\r\n      &lt;INPUT TYPE=&quot;text&quot; ID=&quot;result3&quot; NAME=&quot;result3&quot; VALUE=&quot;&quot;&gt;\r\n\r\n    &lt;/FORM&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**Performance** \r\n\r\n[![Performance][3]][3]\r\nhttp://jsben.ch/sifRd\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat\r\n  [3]: https://i.stack.imgur.com/K9gnJ.png"},{"score":13,"body_markdown":"Use This code to handle currency format for india. Country code can be changed to handle other country currency.\r\n\r\n    let amount =350256.95\r\n    var formatter = new Intl.NumberFormat(&#39;en-IN&#39;, {\r\n      minimumFractionDigits: 2,\r\n    });\r\n    \r\n    // Use it.\r\n    \r\n    formatter.format(amount);\r\n\r\noutput:\r\n\r\n    \r\n    3,50,256.95\r\n\r\n\r\n"},{"score":4,"body_markdown":"Just for future Googlers (or not necessarily &#39;Googlers&#39;):\r\n\r\nAll of solutions mentioned above are wonderful, however, RegExp might be awfully bad thing to use in a situation like that.\r\n\r\nSo, yes, you might use some of the options proposed or even write something primitive yet useful like:\r\n\r\n    const strToNum = str =&gt; {\r\n\r\n       //Find 1-3 digits followed by exactly 3 digits &amp; a comma or end of string\r\n\t   let regx = /(\\d{1,3})(\\d{3}(?:,|$))/;\r\n\t   let currStr;\r\n\r\n\t   do {\r\n  \t\t   currStr = (currStr || str.split(`.`)[0])\r\n  \t\t\t   .replace( regx, `$1,$2`)\r\n\t   } while (currStr.match(regx)) //Stop when there&#39;s no match &amp; null&#39;s returned\r\n\t\r\n\t   return ( str.split(`.`)[1] ) ?\r\n\t\t\t   currStr.concat(`.`, str.split(`.`)[1]) :\r\n\t\t\t   currStr;\r\n\r\n    };\r\n\r\n    strToNum(`123`) // =&gt; 123\r\n    strToNum(`123456`) // =&gt; 123,456\r\n    strToNum(`-1234567.0987`) // =&gt; -1,234,567.0987\r\n\r\nThe regexp that&#39;s used here is fairly simple and the loop will go precisely the number of times it takes to get the job done.\r\n\r\nAnd you might optimize it far better, &quot;DRYify&quot; code &amp; so on.\r\n\r\nYet, \r\n\r\n    (-1234567.0987).toLocaleString();\r\n\r\n(in most situations) would be a far better choice.\r\n\r\nThe point is not in the speed of execution or in cross-browser compatibility.\r\n\r\nIn situations when you&#39;d like to show the resulting number to user, .toLocaleString() method gives you superpower to speak the same language with the user of your website or app (whatever her/his language is).\r\n\r\nThis method according to ECMAScript documentation was introduced in 1999, and I believe that the reason for that was the hope that the Internet at some point will connect people all around the world, so, some &quot;internalization&quot; tools were needed.\r\n\r\nToday the Internet does connect all of us, so, it is important to remember that the world is a way more complex that we might imagine &amp; that (/almost) **all of us are here**, in the Internet.\r\n\r\nObviously, considering the diversity of people, it is impossible to guarantee perfect UX for everybody because we speak different languages, value different things, etc. And exactly because of this, it is even more important to try to localize things as much as it&#39;s possible.\r\n\r\nSo, considering that there&#39;re some particular standards for representation of date, time, numbers, etc. &amp; that we have a tool to display those things in the format preferred by the final user, isn&#39;t that rare and almost irresponsible not to use that tool (especially in situations when we want to display this data to the user)?\r\n\r\nFor me, using RegExp instead of .toLocaleString() in situation like that sounds a little bit like creating a clock app with JavaScript &amp; hard-coding it in such a way so it&#39;ll display Prague time only (which would be quite useless for people who don&#39;t live in Prague) even though the default behaviour of\r\n\r\n    new Date();\r\n\r\nis to return the data according to final user&#39;s clock."},{"score":3,"body_markdown":"# My **“_true_”** regular-expressions-only solution &lt;sub&gt;for those love one-liners&lt;/sub&gt;\r\n\r\n You see those enthusiastic players above? Maybe you can golf out of it. Here’s my stroke.\r\n\r\n    n =&gt; `${n}`.replace(/(?&lt;!\\.\\d+)\\B(?=(\\d{3})+\\b)/g, &quot; &quot;).replace(/(?&lt;=\\.(\\d{3})+)\\B/g, &quot; &quot;)\r\n\r\n&lt;sub&gt;Uses a ` `&lt;sub&gt;THIN SPACE&lt;/sub&gt; (U+2009) for a thousands separator, as the _International System of Units_ said to do in [the eighth edition&lt;sub&gt;(2006)&lt;/sub&gt; of their publication “_SI Brochure: The International System of Units (SI)_”](https://www.bipm.org/utils/common/pdf/si_brochure_8.pdf) (See &#167;5.3.4.). [The ninth edition&lt;sub&gt;(2019)&lt;/sub&gt;](https://www.bipm.org/utils/common/pdf/si-brochure/SI-Brochure-9.pdf) suggests to use a _space_ for it (See &#167;5.4.4.). You can use whatever you want, including a comma.&lt;/sub&gt;\r\n\r\n-----\r\n\r\n## See.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n&lt;!-- language: lang-js --&gt;\r\n    const integer_part_only = n =&gt; `${n}`.replace(/(?&lt;!\\.\\d+)\\B(?=(\\d{3})+\\b)/g, &quot; I &quot;);\r\n    const fractional_part_only = n =&gt; `${n}`.replace(/(?&lt;=\\.(\\d{3})+)\\B/g, &quot; F &quot;);\r\n    const both = n =&gt; fractional_part_only(integer_part_only(n));\r\n\r\n    function demo(number) { // I’m using Chrome 74.\r\n    \tconsole.log(`${number}\r\n    \t\t→ &quot;${integer_part_only(number)}&quot; (integer part only)\r\n    \t\t→ &quot;${fractional_part_only(number)}&quot; (fractional part only)\r\n    \t\t→ &quot;${both(number)}&quot; (both)\r\n    \t`);\r\n    }\r\n    demo(Math.random() * 10e5);\r\n    demo(123456789.01234567);\r\n    demo(123456789);\r\n    demo(0.0123456789);\r\n&lt;!-- end snippet --&gt;\r\n\r\n-----\r\n\r\n## How does it work?\r\n\r\n### For an integer part\r\n\r\n    .replace(/(?&lt;!\\.\\d+)\\B(?=(\\d{3})+\\b)/g, &quot; I &quot;)\r\n\r\n- `.replace(……, &quot; I &quot;)` Put “ I ”\r\n\t- `/……/g` at each of\r\n\t\t- `\\B` the in-between of two adjacent digits\r\n\t\t\t- `(?=……)`&lt;sub&gt;POSITIVE LOOKAHEAD&lt;/sub&gt; whose right part is\r\n\t\t\t\t- `(\\d{3})+` one or more three-digit chunks\r\n\t\t\t\t- `\\b` followed by a non-digit, such as, a period, the ending of the string, et cetera,\r\n\t\t\t- `(?&lt;!……)`&lt;sub&gt;NEGATIVE LOOKBEHIND&lt;/sub&gt; excluding ones whose left part\r\n\t\t\t\t- `\\.\\d+` is a dot followed by digits (“has a decimal separator”).\r\n\r\n### For a decimal part\r\n\r\n    .replace(/(?&lt;=\\.(\\d{3})+)\\B/g, &quot; F &quot;)\r\n\r\n- `.replace(……, &quot; F &quot;)` Put “ F ”\r\n\t- `/……/g` at each of\r\n\t\t- `\\B` the in-between of two adjacent digits\r\n\t\t\t- `(?&lt;=……)`&lt;sub&gt;POSITIVE LOOKBEHIND&lt;/sub&gt; whose left part is\r\n\t\t\t\t- `\\.` a decimal separator\r\n\t\t\t\t- `(\\d{3})+` followed by one or more three-digit chunks.\r\n\r\n-----\r\n\r\n## [Character classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes) and [boundaries](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Boundaries)\r\n\r\n&gt; ### `\\d`\r\n&gt;\r\n&gt;  Matches any digit (Arabic numeral). Equivalent to `[0-9]`.\r\n&gt;\r\n&gt;  For example,\r\n&gt;\r\n&gt; - `/\\d/` or `/[0-9]/` matches `2` in `B2 is the suite number`.\r\n\r\n&gt; ### `\\b`\r\n&gt;\r\n&gt;  Matches a **word boundary**. This is the position where a word character is not followed or preceded by another word-character, such as between a letter and a space. Note that a matched word boundary is not included in the match. In other words, the length of a matched word boundary is zero.\r\n&gt;\r\n&gt;  Examples:\r\n&gt;\r\n&gt; - `/\\bm/` matches the `m` in `moon` ;\r\n&gt; - `/oo\\b/` does not match the `oo` in `moon`, because `oo` is followed by `n` which is a word character;\r\n&gt; - `/oon\\b/` matches the `oon` in `moon`, because `oon` is the end of the string, thus not followed by a word character;\r\n&gt; - `/\\w\\b\\w/` will never match anything, because a word character can never be followed by both a non-word and a word character.\r\n\r\n&gt; ### `\\B`\r\n&gt;\r\n&gt;  Matches a **non-word boundary**. This is a position where the previous and next character are of the same type: either both must be words, or both must be non-words. Such as between two letters or between two spaces. The beginning and end of a string are considered non-words. Same as the matched word boundary, the matched non-word boundary is also not included in the match.\r\n&gt;\r\n&gt;  For example,\r\n&gt;\r\n&gt; - `/\\Bon/` matches `on` in `at noon`;\r\n&gt; - `/ye\\B/` matches `ye` in `possibly yesterday`.\r\n&gt;\r\n\r\n-----\r\n\r\n## Browser compatibility\r\n\r\n- https://caniuse.com/#feat=js-regexp-lookbehind\r\n"},{"score":11,"body_markdown":"You can also use the [Intl.NumberFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) constructor. Here is how you can do it. \r\n\r\n```JS\r\n resultNumber = new Intl.NumberFormat(&#39;en-IN&#39;, { maximumSignificantDigits: 3 }).format(yourNumber); \r\n```\r\n\r\n"},{"score":8,"body_markdown":"My answer is the only answer that completely replaces jQuery with a much more sensible alternative:\r\n\r\n    function $(dollarAmount)\r\n    {\r\n    \tconst locale = &#39;en-US&#39;;\r\n    \tconst options = { style: &#39;currency&#39;, currency: &#39;USD&#39; };\r\n    \treturn Intl.NumberFormat(locale, options).format(dollarAmount);\r\n    }\r\n\r\nThis solution not only adds commas, but it also rounds to the nearest penny in the event that you input an amount like `$(1000.9999)` you&#39;ll get $1,001.00. Additionally, the value you input can safely be a number or a string; it doesn&#39;t matter.\r\n\r\nIf you&#39;re dealing with money, but don&#39;t want a leading dollar sign shown on the amount, you can also add this function, which uses the previous function but removes the `$`:\r\n\r\n    function no$(dollarAmount)\r\n    {\r\n        return $(dollarAmount).replace(&#39;$&#39;,&#39;&#39;);\r\n    }\r\n\r\nIf you&#39;re **not** dealing with money, and have varying decimal formatting requirements, here&#39;s a more versatile function:\r\n\r\n    function addCommas(number, minDecimalPlaces = 0, maxDecimalPlaces = Math.max(3,minDecimalPlaces))\r\n    {\r\n    \tconst options = {};\r\n    \toptions.maximumFractionDigits = maxDecimalPlaces;\r\n    \toptions.minimumFractionDigits = minDecimalPlaces;\r\n    \treturn Intl.NumberFormat(&#39;en-US&#39;,options).format(number);\r\n    }\r\n\r\nOh, and by the way, the fact that this code does not work in some old version of Internet Explorer is completely intentional. I try to break IE anytime that I can catch it not supporting modern standards.\r\n\r\nPlease remember that excessive praise, in the comment section, is considered off-topic. Instead, just shower me with up-votes."},{"score":2,"body_markdown":"**A general fast function** that will react well:\r\n\r\n- If the value is number or string\r\n- If the the number have not english digit\r\n- If the the number have decimal or not\r\n- [Optional] If NOT sticked from behind but sticked from end like : 50000Kg\r\n- If a few number separated in a string\r\n\r\nA minified function for fast, safe and low weight with:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function sepNum(r,e){return e=e||&quot;,&quot;,r=String(r).replace(/[\\u0660-\\u0669\\u06f0-\\u06f9]/g,function(r){return 15&amp;r.charCodeAt(0)}).replace(/(?:[^\\.]|^)\\b(\\d+)/g,function(r){return r=r.replace(/\\B(?=(\\d{3})+\\b)/g,e)})}\r\n\r\n    Text=&#39;1000000 and .0002 5000.1234 with 500000Kg but not V10012.231&#39;;\r\n    console.log(sepNum(Text));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n+\r\nExplain:\r\n```\r\nfunction thousandSeparatorAllNonDecimal (x,sep) { \r\n\t\tif(!sep) sep=&#39;,&#39;; //seprator by defualt is comma but can be changed\r\n\tx=String(x) // Making Sure the X is String, because RegEx will work just with strings\r\n  .replace(/[\\u0660-\\u0669\\u06f0-\\u06f9]/g, // [Optional] RegEx for Finding all non English Digit (like [&quot;١&quot;, &quot;٢&quot;, &quot;٣&quot;, &quot;٤&quot;, &quot;٥&quot;, &quot;٦&quot;, &quot;٧&quot;, &quot;٨&quot;, &quot;٩&quot;, &quot;٠&quot;]\r\n  function (c) { return c.charCodeAt(0) &amp; 0xf; }) // return of the function of the Regex =&gt; Replacing all with the same Englsih Digit (possible some android keyboards just type non english digit)\r\n  .replace(/(?:[^\\.]|^)\\b(\\d+)/g, // Finding all numbers that are not started by dot by the RegEx :\r\n  // 0) (?:) : any that\r\n  // 1) [^\\.] : not same to dot\r\n  // 2) |^ or any thing else that\r\n  // 3) \\b : not sticked to any word from behind [Optional] (it can have another \\b in end to check if not sticked from front to any word too, or no any \\b too, but we want it take some numbers like 50000Kg)\r\n  // +5) \r\n  function(x){ // Process them one by one separated, by this function\r\n  x=x.replace(/\\B(?=(\\d{3})+\\b)/g, // Now by this RegEx replacing any 3 by 3 digit\r\n  sep); // now using separator in the RegEx replace\r\n  return x;} // now return the result to main function\r\n  );return x // and returning the main result out\r\n}\r\n```\r\nAnd the fastest regex can be JUST for both Non-decimal and decimals  :\r\n\r\n&gt; /\\B(?=(\\d{3})+\\b)/g\r\n\r\n\r\n\r\n\r\nBut i think still as @uKolka said, the right idea for a single value, with some prefixing [Optional : parseFloat] and postfixing [Optional : Replacing &#39;.00&#39;] is:\r\n```\r\nNum=parseFloat(Num).toLocaleString(&#39;en-US&#39;,{minimumFractionDigits:2,maximumFractionDigits:2,useGrouping:true}).replace(&#39;.00&#39;,&#39;&#39;);\r\n```\r\n\r\nas the full example here:\r\nhttps://jsfiddle.net/PAPIONbit/198xL3te/"},{"score":32,"body_markdown":"I am quite impressed by the number of answers this question has got. I like the answer by *uKolka*:\r\n\r\n    n.toLocaleString()\r\n\r\nBut unfortunately, in some locales like Spanish, it does not work (IMHO) as expected for numbers below 10,000:\r\n\r\n    Number(1000).toLocaleString(&#39;ES-es&#39;)\r\n\r\nGives `1000` and not `1.000`.\r\n\r\nSee https://stackoverflow.com/questions/57628055/tolocalestring-not-working-on-numbers-less-than-10000-in-all-browsers to know why.\r\n\r\nSo I had to use the answer by *Elias Zamaria* choosing the right thousands separator character:\r\n\r\n    n.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, Number(10000).toLocaleString().substring(2, 3))\r\n\r\nThis one works well as a one-liner for both locales that use `,` or `.` as the thousands separator and starts working from 1,000 in all cases.\r\n\r\n    Number(1000).toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, Number(10000).toLocaleString().substring(2, 3))\r\n\r\nGives `1.000` with a Spanish locale context.\r\n\r\nShould you want to have absolute control over the way a number is formatted, you may also try the following:\r\n\r\n    let number   = 1234.567\r\n    let decimals = 2\r\n    let decpoint = &#39;.&#39; // Or Number(0.1).toLocaleString().substring(1, 2)\r\n    let thousand = &#39;,&#39; // Or Number(10000).toLocaleString().substring(2, 3)\r\n\r\n    let n = Math.abs(number).toFixed(decimals).split(&#39;.&#39;)\r\n    n[0] = n[0].split(&#39;&#39;).reverse().map((c, i, a) =&gt;\r\n      i &gt; 0 &amp;&amp; i &lt; a.length &amp;&amp; i % 3 == 0 ? c + thousand : c\r\n    ).reverse().join(&#39;&#39;)\r\n    let final = (Math.sign(number) &lt; 0 ? &#39;-&#39; : &#39;&#39;) + n.join(decpoint)\r\n\r\n    console.log(final)\r\n\r\nGives `1,234.57`.\r\n\r\nThis one does not need a regular expression. It works by adjusting the number to the desired amount of decimals with `toFixed` first, then dividing it around the decimal point `.` if there is one. The left side is then turned into an array of digits which is reversed. Then a thousands separator is added every three digits from the start and the result reversed again. The final result is the union of the two parts. The sign of the input number is removed with `Math.abs` first and then put back if necessary.\r\n\r\nIt is not a one-liner but not much longer and easily turned into a function. Variables have been added for clarity, but those may be substituted by their desired values if known in advance. You may use the expressions that use `toLocaleString` as a way to find out the right characters for the decimal point and the thousands separator for the current locale (bear in mind that those require a more modern Javascript.)"},{"score":4,"body_markdown":"For anyone who likes 1-liners and a single regex, but *doesn&#39;t* want to use split(), here is an enhanced version of the regex from other answers that handles (ignores) decimal places:\r\n```\r\n    var formatted = (x+&#39;&#39;).replace(/(\\..*)$|(\\d)(?=(\\d{3})+(?!\\d))/g, (digit, fract) =&gt; fract || digit + &#39;,&#39;);\r\n```\r\nThe regex *first* matches a substring starting with a literal &quot;.&quot; and replaces it with itself (&quot;fract&quot;), and *then* matches any digit followed by multiples of 3 digits and puts &quot;,&quot; after it.\r\n\r\nFor example, *x* = 12345678.12345678 will give *formatted* = &#39;12,345,678.12345678&#39;."},{"score":0,"body_markdown":"You can create a function on the Number prototype\r\n\r\n```javascript\r\nNumber.prototype.format = function (s, d) {\r\n  return (\r\n    this.toString()\r\n      .split(&quot;.&quot;)\r\n      .map((n, i) =&gt;\r\n        i\r\n          ? n\r\n          : n\r\n              .split(&quot;&quot;)\r\n              .map((n, i) =&gt; (i % 3 || !i ? n : s + n))\r\n              .join(&quot;&quot;)\r\n      )\r\n      .join(d)\r\n  );\r\n};\r\n\r\nconsole.log((8800.00).format(&#39;,&#39;, &#39;.&#39;))\r\n// 8,880.00\r\n\r\n// French notation\r\nconsole.log((8800.00).format(&#39; &#39;, &#39;,&#39;))\r\n// 8 880,00\r\n```"}],"score":1934}