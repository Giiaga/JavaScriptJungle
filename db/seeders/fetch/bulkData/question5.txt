{"body":"How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?\r\n\r\nI have seen [the Scheme example][1] given on Wikipedia, but unfortunately it did not help.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Scheme_%28programming_language%29\r\n","title":"How do JavaScript closures work?","answers":[{"score":7588,"body_markdown":"A closure is a pairing of:\r\n\r\n1. A function, and\r\n2. A reference to that function&#39;s outer scope (lexical environment)\r\n\r\nA lexical environment is part of every execution context (stack frame), and is a map between identifiers (ie. local variable names) and values.\r\n\r\nEvery function in JavaScript maintains a reference to its outer lexical environment. This reference is used to configure the execution context created when a function is invoked. This reference enables code inside the function to &quot;see&quot; variables declared outside the function, regardless of when and where the function is called.\r\n\r\nIf a function was called by a function, which in turn was called by another function, then a chain of references to outer lexical environments is created. This chain is called the scope chain.\r\n\r\nIn the following code, `inner` forms a closure with the lexical environment of the execution context created when `foo` is invoked, *closing over* variable `secret`:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function foo() {\r\n      const secret = Math.trunc(Math.random()*100)\r\n      return function inner() {\r\n        console.log(`The secret number is ${secret}.`)\r\n      }\r\n    }\r\n    const f = foo() // `secret` is not directly accessible from outside `foo`\r\n    f() // The only way to retrieve `secret`, is to invoke `f`\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIn other words: in JavaScript, functions carry a reference to a private &quot;box of state&quot;, to which only they (and any other functions declared within the same lexical environment) have access. This box of state is invisible to the caller of the function, delivering an excellent mechanism for data-hiding and encapsulation.\r\n\r\nAnd remember: functions in JavaScript can be passed around like variables (first-class functions), meaning these pairings of functionality and state can be passed around your program: similar to how you might pass an instance of a class around in C++.\r\n\r\nIf JavaScript did not have closures, then more state would have to be passed between functions _explicitly_, making parameter lists longer and code noisier.\r\n\r\nSo, if you want a function to always have access to a private piece of state, you can use a closure. \r\n\r\n...and frequently we *do* want to associate state with a function. For example, in Java or C++, when you add a private instance variable and a method to a class, you are associating state with functionality.\r\n\r\nIn C and most other common languages, after a function returns, all the local variables are no longer accessible because the stack-frame is destroyed. In JavaScript, if you declare a function within another function, then the local variables of the outer function can remain accessible after returning from it. In this way, in the code above, `secret` remains available to the function object `inner`, *after* it has been returned from `foo`.\r\n\r\n## Uses of Closures\r\n\r\nClosures are useful whenever you need private state associated with a function. This is a very common scenario - and remember: JavaScript did not have a class syntax until 2015, and it still does not have a private field syntax. Closures meet this need.\r\n\r\n### Private Instance Variables\r\n\r\nIn the following code, function `toString` closes over the details of the car.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function Car(manufacturer, model, year, color) {\r\n      return {\r\n        toString() {\r\n          return `${manufacturer} ${model} (${year}, ${color})`\r\n        }\r\n      }\r\n    }\r\n    const car = new Car(&#39;Aston Martin&#39;,&#39;V8 Vantage&#39;,&#39;2012&#39;,&#39;Quantum Silver&#39;)\r\n    console.log(car.toString())\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n### Functional Programming\r\n\r\nIn the following code, function `inner` closes over both `fn` and `args`.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function curry(fn) {\r\n      const args = []\r\n      return function inner(arg) {\r\n        if(args.length === fn.length) return fn(...args)\r\n        args.push(arg)\r\n        return inner\r\n      }\r\n    }\r\n\r\n    function add(a, b) {\r\n      return a + b\r\n    }\r\n\r\n    const curriedAdd = curry(add)\r\n    console.log(curriedAdd(2)(3)()) // 5\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n### Event-Oriented Programming\r\n\r\nIn the following code, function `onClick` closes over variable `BACKGROUND_COLOR`.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const $ = document.querySelector.bind(document)\r\n    const BACKGROUND_COLOR = &#39;rgba(200,200,242,1)&#39;\r\n\r\n    function onClick() {\r\n      $(&#39;body&#39;).style.background = BACKGROUND_COLOR\r\n    }\r\n\r\n    $(&#39;button&#39;).addEventListener(&#39;click&#39;, onClick)\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;button&gt;Set background color&lt;/button&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n### Modularization\r\n\r\nIn the following example, all the implementation details are hidden inside an immediately executed function expression. The functions `tick` and `toString` close over the private state and functions they need to complete their work. Closures have enabled us to modularise and encapsulate our code.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let namespace = {};\r\n\r\n    (function foo(n) {\r\n      let numbers = []\r\n      function format(n) {\r\n        return Math.trunc(n)\r\n      }\r\n      function tick() {\r\n        numbers.push(Math.random() * 100)\r\n      }\r\n      function toString() {\r\n        return numbers.map(format)\r\n      }\r\n      n.counter = {\r\n        tick,\r\n        toString\r\n      }\r\n    }(namespace))\r\n\r\n    const counter = namespace.counter\r\n    counter.tick()\r\n    counter.tick()\r\n    console.log(counter.toString())\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n## Examples\r\n\r\n### Example 1\r\nThis example shows that the local variables are not copied in the closure: the closure maintains a reference to the original variables *themselves*. It is as though the stack-frame stays alive in memory even after the outer function exits.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function foo() {\r\n      let x = 42\r\n      let inner  = function() { console.log(x) }\r\n      x = x+1\r\n      return inner\r\n    }\r\n    var f = foo()\r\n    f() // logs 43\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n### Example 2\r\nIn the following code, three methods `log`, `increment` and `update` all close over the same lexical environment.\r\n\r\nAnd every time `createObject` is called, a new execution context (stack frame) is created and a completely new variable `x`, and a new set of functions (`log` etc.) are created, that close over this new variable.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function createObject() {\r\n      let x = 42;\r\n      return {\r\n        log() { console.log(x) },\r\n        increment() { x++ },\r\n        update(value) { x = value }\r\n      }\r\n    }\r\n\r\n    const o = createObject()\r\n    o.increment()\r\n    o.log() // 43\r\n    o.update(5)\r\n    o.log() // 5\r\n    const p = createObject()\r\n    p.log() // 42\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n### Example 3\r\nIf you are using variables declared using `var`, be careful you understand which variable you are closing over. Variables declared using `var` are hoisted. This is much less of a problem in modern JavaScript due to the introduction of `let` and `const`.\r\n\r\nIn the following code, each time around the loop, a new function `inner` is created, which closes over `i`. But because `var i` is hoisted outside the loop, all of these inner functions close over the same variable, meaning that the final value of `i` (3) is printed, three times.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function foo() {\r\n      var result = []\r\n      for (var i = 0; i &lt; 3; i++) {\r\n        result.push(function inner() { console.log(i) } )\r\n      }\r\n      return result\r\n    }\r\n\r\n    const result = foo()\r\n    // The following will print `3`, three times...\r\n    for (var i = 0; i &lt; 3; i++) {\r\n      result[i]() \r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n## Final points:\r\n* Whenever a function is declared in JavaScript a closure is created.\r\n* Returning a `function` from inside another function is the classic example of a closure, because the state inside the outer function is implicitly available to the returned inner function, even after the outer function has completed execution.\r\n* Whenever you use `eval()` inside a function, a closure is used. The text you `eval` can reference local variables of the function, and in non-strict mode you can even create new local variables by using `eval(&#39;var foo = …&#39;)`.\r\n* When you use `new Function(…)` (the [Function constructor][1]) inside a function, it does not close over its lexical environment: it closes over the global context instead. The new function cannot reference the local variables of the outer function.\r\n* A closure in JavaScript is like keeping a reference (**NOT** a copy) to the scope at the point of function declaration, which in turn keeps a reference to its outer scope, and so on, all the way to the global object at the top of the scope chain.\r\n* A closure is created when a function is declared; this closure is used to configure the execution context when the function is invoked.\r\n* A new set of local variables is created every time a function is called.\r\n\r\n## Links\r\n* Douglas Crockford&#39;s simulated [private attributes and private methods][2] for an object, using closures.\r\n* A great explanation of how closures can [cause memory leaks in IE][3] if you are not careful.\r\n* MDN documentation on [JavaScript Closures][4].\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\r\n  [2]: http://www.crockford.com/javascript/private.html\r\n  [3]: https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"},{"score":386,"body_markdown":"**TLDR**\r\n\r\nA closure is a link between a function and its outer lexical (ie. as-written) environment, such that the identifiers (variables, parameters, function declarations etc) defined within that environment are visible from within the function, regardless of when or from where the function is invoked.\r\n\r\n**Details**\r\n\r\nIn the terminology of the ECMAScript specification, a closure can be said to be implemented by the [`[[Environment]]`][1] reference of every function-object, which points to the [lexical environment][2] within which the function is defined.\r\n\r\nWhen a function is invoked via the internal [`[[Call]]`][3] method, the [`[[Environment]]`][1] reference on the function-object is copied into the *outer environment reference* of the [environment record][4] of the newly-created [execution context][5] (stack frame).\r\n\r\nIn the following example, function `f` closes over the lexical environment of the global execution context:\r\n\r\n    function f() {}\r\n\r\nIn the following example, function `h` closes over the lexical environment of function `g`, which, in turn, closes over the lexical environment of the global execution context.\r\n\r\n    function g() {\r\n        function h() {}\r\n    }\r\n\r\nIf an inner function is returned by an outer, then the outer lexical environment will persist after the outer function has returned. This is because the outer lexical environment needs to be available if the inner function is eventually invoked.\r\n\r\nIn the following example, function `j` closes over the lexical environment of function `i`, meaning that variable `x` is visible from inside function `j`, long after function `i` has completed execution:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function i() {\r\n        var x = &#39;mochacchino&#39;\r\n        return function j() {\r\n            console.log(&#39;Printing the value of x, from within function j: &#39;, x)\r\n        }\r\n    } \r\n\r\n    const k = i()\r\n    setTimeout(k, 500) // invoke k (which is j) after 500ms\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIn a closure, the variables in the outer lexical environment *themselves* are available, *not* copies.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function l() {\r\n      var y = &#39;vanilla&#39;;\r\n\r\n      return {\r\n        setY: function(value) {\r\n          y = value;\r\n        },\r\n        logY: function(value) {\r\n          console.log(&#39;The value of y is: &#39;, y);\r\n        }\r\n      }\r\n    }\r\n\r\n    const o = l()\r\n    o.logY() // The value of y is: vanilla\r\n    o.setY(&#39;chocolate&#39;)\r\n    o.logY() // The value of y is: chocolate\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe chain of lexical environments, linked between execution contexts via outer environment references, forms a *scope chain* and defines the identifiers visible from any given function.\r\n\r\n**Please note that in an attempt to improve clarity and accuracy, this answer has been substantially changed from the original.**\r\n\r\n\r\n  [1]: https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize\r\n  [2]: https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments\r\n  [3]: https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist\r\n  [4]: https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records\r\n  [5]: https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts"},{"score":505,"body_markdown":"Closures are hard to explain because they are used to make some behaviour work that everybody intuitively expects to work anyway. I find the best way to explain them (and the way that *I* learned what they do) is to imagine the situation without them:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const makePlus = function(x) {\r\n        return function(y) { return x + y; };\r\n    }\r\n    \r\n    const plus5 = makePlus(5);\r\n    console.log(plus5(3));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nWhat would happen here if JavaScript *didn&#39;t* know closures? Just replace the call in the last line by its method body (which is basically what function calls do) and you get:\r\n\r\n    console.log(x + 3);\r\n\r\nNow, where&#39;s the definition of `x`? We didn&#39;t define it in the current scope. The only solution is to let `plus5` *carry* its scope (or rather, its parent&#39;s scope) around. This way, `x` is well-defined and it is bound to the value 5.\r\n"},{"score":4023,"body_markdown":"Every function in JavaScript maintains a link to its outer lexical environment. A lexical environment is a map of all the names (eg. variables, parameters) within a scope, with their values.\r\n\r\nSo, whenever you see the `function` keyword, code inside that function has access to variables declared outside the function.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function foo(x) {\r\n      var tmp = 3;\r\n\r\n      function bar(y) {\r\n        console.log(x + y + (++tmp)); // will log 16\r\n      }\r\n\r\n      bar(10);\r\n    }\r\n\r\n    foo(2);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThis will log `16` because function `bar` closes over the parameter `x` and the variable `tmp`, both of which exist in the lexical environment of outer function `foo`.\r\n\r\nFunction `bar`, together with its link with the lexical environment of function `foo` is a closure. \r\n\r\nA function doesn&#39;t have to *return* in order to create a closure. Simply by virtue of its declaration, every function closes over its enclosing lexical environment, forming a closure.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function foo(x) {\r\n      var tmp = 3;\r\n\r\n      return function (y) {\r\n        console.log(x + y + (++tmp)); // will also log 16\r\n      }\r\n    }\r\n\r\n    var bar = foo(2);\r\n    bar(10); // 16\r\n    bar(10); // 17\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe above function will also log 16, because the code inside `bar` can still refer to argument `x` and variable `tmp`, even though they are no longer directly in scope.\r\n\r\nHowever, since `tmp` is still hanging around inside `bar`&#39;s closure, it is available to be incremented. It will be incremented each time you call `bar`.\r\n\r\nThe simplest example of a closure is this:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var a = 10;\r\n\r\n    function test() {\r\n      console.log(a); // will output 10\r\n      console.log(b); // will output 6\r\n    }\r\n    var b = 6;\r\n    test();\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nWhen a JavaScript function is invoked, a new execution context `ec` is created. Together with the function arguments and the target object, this execution context also receives a link to the lexical environment of the calling execution context, meaning the variables declared in the outer lexical environment (in the above example, both `a` and `b`) are available from `ec`.\r\n\r\nEvery function creates a closure because every function has a link to its outer lexical environment. \r\n\r\nNote that variables *themselves* are visible from within a closure, *not* copies."},{"score":91,"body_markdown":"A closure is where an inner function has access to variables in its outer function. That&#39;s probably the simplest one-line explanation you can get for closures.\r\n"},{"score":367,"body_markdown":"This is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers.\r\n\r\n - **A closure is not only created when you return an inner function.** In fact, the enclosing function *does not need to return at all* in order for its closure to be created. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be called immediately or any time later. Therefore, the closure of the enclosing function is probably created *as soon as the enclosing function is called* since any inner function has access to that closure whenever the inner function is called, before or after the enclosing function returns. \r\n - **A closure does not reference a copy of the *old values* of variables in its scope.** The variables themselves are part of the closure, and so the value seen when accessing one of those variables is the latest value at the time it is accessed. This is why inner functions created inside of loops can be tricky, since each one has access to the same outer variables rather than grabbing a copy of the variables at the time the function is created or called.\r\n - **The &quot;variables&quot; in a closure include any named functions** declared within the function. They also include arguments of the function. A closure also has access to its containing closure&#39;s variables, all the way up to the global scope.\r\n - **Closures use memory, but they don&#39;t cause memory leaks** since JavaScript by itself cleans up its own circular structures that are not referenced. Internet&amp;nbsp;Explorer memory leaks involving closures are created when it fails to disconnect DOM attribute values that reference closures, thus maintaining references to possibly circular structures.\r\n"},{"score":93,"body_markdown":"Example for the first point by dlaliberte:\r\n\r\n&gt; A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be used immediately. Therefore, the closure of the enclosing function probably already exists at the time that enclosing function was called since any inner function has access to it as soon as it is called.\r\n\r\n    var i;\r\n    function foo(x) {\r\n        var tmp = 3;\r\n        i = function (y) {\r\n            console.log(x + y + (++tmp));\r\n        }\r\n    }\r\n    foo(2);\r\n    i(3);"},{"score":201,"body_markdown":"## [Can you explain closures to a 5-year-old?*][1] ##\n\nI still think [Google&#39;s explanation][2] works very well and is concise:\n\n    /*\n    *    When a function is defined in another function and it\n    *    has access to the outer function&#39;s context even after\n    *    the outer function returns.\n    *\n    * An important concept to learn in JavaScript.\n    */\n\n    function outerFunction(someNum) {\n        var someString = &#39;Hey!&#39;;\n        var content = document.getElementById(&#39;content&#39;);\n        function innerFunction() {\n            content.innerHTML = someNum + &#39;: &#39; + someString;\n            content = null; // Internet Explorer memory leak for DOM reference\n        }\n        innerFunction();\n    }\n\n    outerFunction(1);​\n\n![Proof that this example creates a closure even if the inner function doesn&#39;t return][3]\n\n&lt;sub&gt;*A C# question&lt;/sub&gt;\n\n  [1]: https://stackoverflow.com/questions/1700514/how-do-you-explain-closure-to-a-5-year-old/1700627#1700627\n  [2]: http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple\n  [3]: http://i.stack.imgur.com/N0mn0.png\n"},{"score":237,"body_markdown":"I wrote a blog post a while back explaining closures. Here&#39;s what I said about closures in terms of **why** you&#39;d want one.\r\n\r\n&gt; Closures are a way to let a function\r\n&gt; have **persistent, private variables** -\r\n&gt; that is, variables that only one\r\n&gt; function knows about, where it can\r\n&gt; keep track of info from previous times\r\n&gt; that it was run.\r\n\r\nIn that sense, they let a function act a bit like an object with private attributes.\r\n\r\nFull post:\r\n\r\n[So what are these closure thingys?](http://sleeplessgeek.blogspot.com/2009/12/so-what-are-these-closure-thingys.html)"},{"score":78,"body_markdown":"JavaScript functions can access their:\r\n\r\n 1. Arguments\r\n 2. Locals (that is, their local variables and local functions)\r\n 3. Environment, which includes:\r\n - globals, including the DOM\r\n - anything in outer functions\r\n\r\nIf a function accesses its environment, then the function is a closure.\r\n\r\nNote that outer functions are not required, though they do offer benefits I don&#39;t discuss here. By accessing data in its environment, a closure keeps that data alive. In the subcase of outer/inner functions, an outer function can create local data and eventually exit, and yet, if any inner function(s) survive after the outer function exits, then the inner function(s) keep the outer function&#39;s local data alive.\r\n\r\nExample of a closure that uses the global environment:\r\n\r\nImagine that the Stack Overflow Vote-Up and Vote-Down button events are implemented as closures, voteUp_click and voteDown_click, that have access to external variables isVotedUp and isVotedDown, which are defined globally. (For simplicity&#39;s sake, I am referring to StackOverflow&#39;s Question Vote buttons, not the array of Answer Vote buttons.)\r\n\r\nWhen the user clicks the VoteUp button, the voteUp_click function checks whether isVotedDown == true to determine whether to vote up or merely cancel a down vote. Function voteUp_click is a closure because it is accessing its environment.\r\n\r\n    var isVotedUp = false;\r\n    var isVotedDown = false;\r\n    \r\n    function voteUp_click() {\r\n      if (isVotedUp)\r\n        return;\r\n      else if (isVotedDown)\r\n        SetDownVote(false);\r\n      else\r\n        SetUpVote(true);\r\n    }\r\n    \r\n    function voteDown_click() {\r\n      if (isVotedDown)\r\n        return;\r\n      else if (isVotedUp)\r\n        SetUpVote(false);\r\n      else\r\n        SetDownVote(true);\r\n    }\r\n    \r\n    function SetUpVote(status) {\r\n      isVotedUp = status;\r\n      // Do some CSS stuff to Vote-Up button\r\n    }\r\n    \r\n    function SetDownVote(status) {\r\n      isVotedDown = status;\r\n      // Do some CSS stuff to Vote-Down button\r\n    }\r\n    \r\nAll four of these functions are closures as they all access their environment.\r\n"},{"score":2477,"body_markdown":"FOREWORD: this answer was written when the question was:\r\n\r\n&gt; Like the old Albert said : &quot;If you can&#39;t explain it to a six-year old, you really don&#39;t understand it yourself.”. Well I tried to explain JS closures to a 27 years old friend and completely failed.\r\n&gt; \r\n&gt; Can anybody consider that I am 6 and strangely interested in that subject ?\r\n\r\nI&#39;m pretty sure I was one of the only people that attempted to take the initial question literally. Since then, the question has mutated several times, so my answer may now seem incredibly silly &amp; out of place. Hopefully the general idea of the story remains fun for some.\r\n\r\n---------\r\n\r\nI&#39;m a big fan of analogy and metaphor when explaining difficult concepts, so let me try my hand with a story.\r\n\r\n**Once upon a time:**\r\n\r\nThere was a princess...\r\n\r\n    function princess() {\r\n\r\nShe lived in a wonderful world full of adventures. She met her Prince Charming, rode around her world on a unicorn, battled dragons, encountered talking animals, and many other fantastical things.\r\n\r\n        var adventures = [];\r\n\r\n        function princeCharming() { /* ... */ }\r\n\r\n        var unicorn = { /* ... */ },\r\n            dragons = [ /* ... */ ],\r\n            squirrel = &quot;Hello!&quot;;\r\n\r\n        /* ... */\r\n    \r\nBut she would always have to return back to her dull world of chores and grown-ups.\r\n\r\n        return {\r\n\r\nAnd she would often tell them of her latest amazing adventure as a princess.\r\n\r\n            story: function() {\r\n                return adventures[adventures.length - 1];\r\n            }\r\n        };\r\n    }\r\n\r\nBut all they would see is a little girl...\r\n\r\n    var littleGirl = princess();\r\n\r\n...telling stories about magic and fantasy.\r\n\r\n    littleGirl.story();\r\n\r\nAnd even though the grown-ups knew of real princesses, they would never believe in the unicorns or dragons because they could never see them. The grown-ups said that they only existed inside the little girl&#39;s imagination.\r\n\r\nBut we know the real truth; that the little girl with the princess inside...\r\n\r\n...is really a princess with a little girl inside."},{"score":82,"body_markdown":"You&#39;re having a sleep over and you invite Dan.\r\nYou tell Dan to bring one XBox controller.\r\n\r\nDan invites Paul.\r\nDan asks Paul to bring one controller. How many controllers were brought to the party?\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n    \r\n    function sleepOver(howManyControllersToBring) {\r\n\r\n        var numberOfDansControllers = howManyControllersToBring;\r\n \r\n        return function danInvitedPaul(numberOfPaulsControllers) {\r\n            var totalControllers = numberOfDansControllers + numberOfPaulsControllers;\r\n            return totalControllers;\r\n        }\r\n    }\r\n \r\n    var howManyControllersToBring = 1;\r\n \r\n    var inviteDan = sleepOver(howManyControllersToBring);\r\n \r\n    // The only reason Paul was invited is because Dan was invited. \r\n    // So we set Paul&#39;s invitation = Dan&#39;s invitation.\r\n\r\n    var danInvitedPaul = inviteDan(howManyControllersToBring);\r\n \r\n    alert(&quot;There were &quot; + danInvitedPaul + &quot; controllers brought to the party.&quot;);"},{"score":136,"body_markdown":"I put together an interactive JavaScript tutorial to explain how closures work.\r\n[What&#39;s a Closure?](http://nathansjslessons.appspot.com)\r\n\r\nHere&#39;s one of the examples:\r\n\r\n    var create = function (x) {\r\n        var f = function () {\r\n            return x; // We can refer to x here!\r\n        };\r\n        return f;\r\n    };\r\n    // &#39;create&#39; takes one argument, creates a function\r\n    \r\n    var g = create(42);\r\n    // g is a function that takes no arguments now\r\n    \r\n    var y = g();\r\n    // y is 42 here\r\n"},{"score":165,"body_markdown":"[Wikipedia on closures](http://en.wikipedia.org/wiki/Closure_(computer_science)):\r\n\r\n&gt; In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.\r\n\r\nTechnically, in [JavaScript][1], **every function is a closure**. It always has an access to variables defined in the surrounding scope.\r\n    \r\nSince **scope-defining construction in JavaScript is a function**, not a code block like in many other languages, **what we usually mean by *closure* in JavaScript** is a **function working with nonlocal variables defined in already executed surrounding function**.\r\n\r\nClosures are often used for creating functions with some hidden private data (but it&#39;s not always the case).\r\n\r\n    var db = (function() {\r\n        // Create a hidden object, which will hold the data\r\n        // it&#39;s inaccessible from the outside.\r\n        var data = {};\r\n\r\n        // Make a function, which will provide some access to the data.\r\n        return function(key, val) {\r\n            if (val === undefined) { return data[key] } // Get\r\n            else { return data[key] = val } // Set\r\n        }\r\n        // We are calling the anonymous surrounding function,\r\n        // returning the above inner function, which is a closure.\r\n    })();\r\n\r\n    db(&#39;x&#39;)    // -&gt; undefined\r\n    db(&#39;x&#39;, 1) // Set x to 1\r\n    db(&#39;x&#39;)    // -&gt; 1\r\n    // It&#39;s impossible to access the data object itself.\r\n    // We are able to get or set individual it.\r\nems\r\n\r\nThe example above is using an anonymous function, which was executed once. But it does not have to be. It can be named (e.g. `mkdb`) and executed later, generating a database function each time it is invoked. Every generated function will have its own hidden database object. Another usage example of closures is when we don&#39;t return a function, but an object containing multiple functions for different purposes, each of those function having access to the same data.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/JavaScript\r\n"},{"score":766,"body_markdown":"Taking the question seriously, we should find out what a typical 6-year-old is capable of cognitively, though admittedly, one who is interested in JavaScript is not so typical.  \r\n\r\nOn  [Childhood Development: 5 to 7 Years ](http://www.howkidsdevelop.com/5-7years.html) it says:\r\n\r\n&gt; Your child will be able to follow two-step directions. For example, if you say to your child, &quot;Go to the kitchen and get me a trash bag&quot; they will be able to remember that direction.\r\n\r\nWe can use this example to explain closures, as follows:\r\n\r\n&gt; The kitchen is a closure that has a local variable, called `trashBags`.  There is a function inside the kitchen called `getTrashBag` that gets one trash bag and returns it.\r\n\r\nWe can code this in JavaScript like this:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function makeKitchen() {\r\n      var trashBags = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; // only 3 at first\r\n\r\n      return {\r\n        getTrashBag: function() {\r\n          return trashBags.pop();\r\n        }\r\n      };\r\n    }\r\n\r\n    var kitchen = makeKitchen();\r\n\r\n    console.log(kitchen.getTrashBag()); // returns trash bag C\r\n    console.log(kitchen.getTrashBag()); // returns trash bag B\r\n    console.log(kitchen.getTrashBag()); // returns trash bag A\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nFurther points that explain why closures are interesting:\r\n\r\n - Each time `makeKitchen()` is called, a new closure is created with its own separate `trashBags`.\r\n - The `trashBags` variable is local to the inside of each kitchen and is not accessible outside, but the inner function on the `getTrashBag` property does have access to it.  \r\n - Every function call creates a closure, but there would be no need to keep the closure around unless an inner function, which has access to the inside of the closure, can be called from outside the closure.  Returning the object with the `getTrashBag` function does that here."},{"score":86,"body_markdown":"I know there are plenty of solutions already, but I guess that this small and simple script can be useful to demonstrate the concept:\r\n\r\n    // makeSequencer will return a &quot;sequencer&quot; function\r\n    var makeSequencer = function() {\r\n        var _count = 0; // not accessible outside this function\r\n        var sequencer = function () {\r\n            return _count++;\r\n        }\r\n        return sequencer;\r\n    }\r\n    \r\n    var fnext = makeSequencer();\r\n    var v0 = fnext();     // v0 = 0;\r\n    var v1 = fnext();     // v1 = 1;\r\n    var vz = fnext._count // vz = undefined"},{"score":14,"body_markdown":"After a function is invoked, it goes out of scope. If that function contains something like a callback function, then that callback function is still in scope. If the callback function references some local variable in the immediate environment of the parent function, then naturally you&#39;d expect that variable to be inaccessible to the callback function and return undefined.\r\n\r\nClosures ensure that any property that is referenced by the callback function is available for use by that function, even when its parent function may have gone out of scope.\r\n"},{"score":20,"body_markdown":"From a personal [blog post][1]:\r\n\r\nBy default, JavaScript knows two types of scopes: global and local.\r\n\r\n    var a = 1;\r\n     \r\n    function b(x) {\r\n        var c = 2;\r\n        return x * c;\r\n    }\r\n\r\nIn the above code, variable a and function b are available from anywhere in the code (that is, globally). Variable `c` is only available within the `b` function scope (that is, local). Most software developers won&#39;t be happy with this lack of scope flexibility, especially in large programs.\r\n\r\nJavaScript closures help solving that issue by tying a function with a context:\r\n\r\n    function a(x) {\r\n        return function b(y) {\r\n            return x + y;\r\n        }\r\n    }\r\n\r\nHere, function `a` returns a function called `b`. Since `b` is defined within `a`, it automatically has access to whatever is defined in `a`, that is, `x` in this example. This is why `b` can return `x` + `y` without declaring `x`.\r\n\r\n    var c = a(3);\r\n\r\nVariable `c` is assigned the result of a call to a with parameter 3. That is, an instance of function `b` where `x` = 3. In other words, `c` is now a function equivalent to:\r\n\r\n    var c = function b(y) {\r\n        return 3 + y;\r\n    }\r\n\r\nFunction `b` remembers that `x` = 3 in its context. Therefore:\r\n\r\n    var d = c(4);\r\n\r\nwill assign the value 3 + 4 to `d`, that is 7.\r\n\r\n**Remark**: If someone modifies the value of `x` (say `x` = 22) after the instance of function `b` has been created, this will be reflected in `b` too. Hence a later call to `c`(4) would return 22 + 4, that is 26.\r\n\r\nClosures can also be used to limit the scope of variables and methods declared globally:\r\n\r\n    (function () {\r\n        var f = &quot;Some message&quot;;\r\n        alert(f);\r\n    })();\r\n\r\nThe above is a closure where the function has no name, no argument and is called immediately. The highlighted code, which declares a global variable `f`, limits the scopes of `f` to the closure.\r\n\r\nNow, there is a common JavaScript caveat where closures can help:\r\n\r\n    var a = new Array();\r\n\r\n    for (var i=0; i&lt;2; i++) {\r\n        a[i]= function(x) { return x + i ; }\r\n    }\r\n\r\nFrom the above, most would assume that array `a` would be initialized as follows:\r\n\r\n    a[0] = function (x) { return x + 0 ; }\r\n    a[1] = function (x) { return x + 1 ; }\r\n    a[2] = function (x) { return x + 2 ; }\r\n\r\nIn reality, this is how a is initialized, since the last value of `i` in the context is 2:\r\n\r\n    a[0] = function (x) { return x + 2 ; }\r\n    a[1] = function (x) { return x + 2 ; }\r\n    a[2] = function (x) { return x + 2 ; }\r\n\r\nThe solution is:\r\n\r\n    var a = new Array();\r\n     \r\n    for (var i=0; i&lt;2; i++) {\r\n        a[i]= function(tmp) {\r\n            return function (x) { return x + tmp ; }\r\n        } (i);\r\n    }\r\n\r\nThe argument/variable `tmp` holds a local copy of the changing value of `i` when creating function instances.\r\n\r\n  [1]: http://tshikatshikaaa.blogspot.nl/2012/08/purpose-of-javascript-closure.html\r\n"},{"score":50,"body_markdown":"A function in JavaScript is not just a reference to a set of instructions (as in C language), but it also includes a hidden data structure which is composed of references to all nonlocal variables it uses (captured variables). Such two-piece functions are called closures. Every function in JavaScript can be considered a closure.\r\n\r\nClosures are functions with a state. It is somewhat similar to &quot;this&quot; in the sense that &quot;this&quot; also provides state for a function but function and &quot;this&quot; are separate objects (&quot;this&quot; is just a fancy parameter, and the only way to bind it permanently to a function is to create a closure). While &quot;this&quot; and function always live separately, a function cannot be separated from its closure and the language provides no means to access captured variables.\r\n\r\nBecause all these external variables referenced by a lexically nested function are actually local variables in the chain of its lexically enclosing functions (global variables can be assumed to be local variables of some root function), and every single execution of a function creates new instances of its local variables, it follows that every execution of a function returning (or otherwise transferring it out, such as registering it as a callback) a nested function creates a new closure (with its own potentially unique set of referenced nonlocal variables which represent its execution context).\r\n\r\nAlso, it must be understood that local variables in JavaScript are created not on the stack frame, but on the heap and destroyed only when no one is referencing them. When a function returns, references to its local variables are decremented, but they can still be non-null if during the current execution they became part of a closure and are still referenced by its lexically nested functions (which can happen only if the references to these nested functions were returned or otherwise transferred to some external code).\r\n\r\nAn example:\r\n\r\n    function foo (initValue) {\r\n       //This variable is not destroyed when the foo function exits.\r\n       //It is &#39;captured&#39; by the two nested functions returned below.\r\n       var value = initValue;\r\n\r\n       //Note that the two returned functions are created right now.\r\n       //If the foo function is called again, it will return\r\n       //new functions referencing a different &#39;value&#39; variable.\r\n       return {\r\n           getValue: function () { return value; },\r\n           setValue: function (newValue) { value = newValue; }\r\n       }\r\n    }\r\n\r\n    function bar () {\r\n        //foo sets its local variable &#39;value&#39; to 5 and returns an object with\r\n        //two functions still referencing that local variable\r\n        var obj = foo(5);\r\n\r\n        //Extracting functions just to show that no &#39;this&#39; is involved here\r\n        var getValue = obj.getValue;\r\n        var setValue = obj.setValue;\r\n\r\n        alert(getValue()); //Displays 5\r\n        setValue(10);\r\n        alert(getValue()); //Displays 10\r\n\r\n        //At this point getValue and setValue functions are destroyed\r\n        //(in reality they are destroyed at the next iteration of the garbage collector).\r\n        //The local variable &#39;value&#39; in the foo is no longer referenced by\r\n        //anything and is destroyed too.\r\n    }\r\n\r\n    bar();\r\n"},{"score":14,"body_markdown":"Closures are a means through which inner functions can refer to the variables present in their outer enclosing function after their parent functions have already terminated.\r\n\r\n    // A function that generates a new function for adding numbers.\r\n    function addGenerator( num ) {\r\n        // Return a simple function for adding two numbers\r\n        // with the first number borrowed from the generator\r\n        return function( toAdd ) {\r\n            return num + toAdd\r\n        };\r\n    }\r\n\r\n    // addFive now contains a function that takes one argument,\r\n    // adds five to it, and returns the resulting number.\r\n    var addFive = addGenerator( 5 );\r\n    // We can see here that the result of the addFive function is 9,\r\n    // when passed an argument of 4.\r\n    alert( addFive( 4 ) == 9 );\r\n"},{"score":595,"body_markdown":"# The Straw Man\n\nI need to know how many times a button has been clicked and do something on every third click...\n\n## Fairly Obvious Solution\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    // Declare counter outside event handler&#39;s scope\n    var counter = 0;\n    var element = document.getElementById(&#39;button&#39;);\n\n    element.addEventListener(&quot;click&quot;, function() {\n      // Increment outside counter\n      counter++;\n\n      if (counter === 3) {\n        // Do something every third time\n        console.log(&quot;Third time&#39;s the charm!&quot;);\n\n        // Reset counter\n        counter = 0;\n      }\n    });\n\n&lt;!-- language: lang-html --&gt;\n\n    &lt;button id=&quot;button&quot;&gt;Click Me!&lt;/button&gt;\n\n&lt;!-- end snippet --&gt;\n\nNow this will work, but it does encroach into the outer scope by adding a variable, whose sole purpose is to keep track of the count. In some situations, this would be preferable as your outer application might need access to this information. But in this case, we are only changing every third click&#39;s behavior, so it is preferable to **enclose this functionality inside the event handler**.\n\n## Consider this option\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    var element = document.getElementById(&#39;button&#39;);\n\n    element.addEventListener(&quot;click&quot;, (function() {\n      // init the count to 0\n      var count = 0;\n\n      return function(e) { // &lt;- This function becomes the click handler\n        count++; //    and will retain access to the above `count`\n\n        if (count === 3) {\n          // Do something every third time\n          console.log(&quot;Third time&#39;s the charm!&quot;);\n\n          //Reset counter\n          count = 0;\n        }\n      };\n    })());\n\n&lt;!-- language: lang-html --&gt;\n\n    &lt;button id=&quot;button&quot;&gt;Click Me!&lt;/button&gt;\n\n&lt;!-- end snippet --&gt;\n\nNotice a few things here.\n\nIn the above example, I am using the closure behavior of JavaScript. **This behavior allows any function to have access to the scope in which it was created, indefinitely.** To practically apply this, I immediately invoke a function that returns another function, and because the function I&#39;m returning has access to the internal count variable (because of the closure behavior explained above) this results in a private scope for usage by the resulting function... Not so simple? Let&#39;s dilute it down...\n\n**A simple one-line closure**\n\n    //          _______________________Immediately invoked______________________\n    //         |                                                                |\n    //         |        Scope retained for use      ___Returned as the____      |\n    //         |       only by returned function   |    value of func     |     |\n    //         |             |            |        |                      |     |\n    //         v             v            v        v                      v     v\n    var func = (function() { var a = &#39;val&#39;; return function() { alert(a); }; })();\n\nAll variables outside the returned function are available to the returned function, but they are not directly available to the returned function object...\n\n    func();  // Alerts &quot;val&quot;\n    func.a;  // Undefined\n\nGet it? So in our primary example, the count variable is contained within the closure and always available to the event handler, so it retains its state from click to click.\n\nAlso, this private variable state is **fully** accessible, for both readings and assigning to its private scoped variables.\n\nThere you go; you&#39;re now fully encapsulating this behavior.\n\n**[Full Blog Post][1]** (including jQuery considerations)\n\n  [1]: http://jondavidjohn.com/javascript-closure-explained-using-events/\n"},{"score":57,"body_markdown":"Okay, talking with a 6-year old child, I would possibly use following associations.\r\n\r\n&gt; Imagine - you are playing with your little brothers and sisters in the entire house, and you are moving around with your toys and brought some of them into your older brother&#39;s room. After a while your brother returned from the school and went to his room, and he locked inside it, so now you could not access toys left there anymore in a direct way. But you could knock the door and ask your brother for that toys. This is called toy&#39;s *closure*; your brother made it up for you, and he is now into outer *scope*.\r\n\r\nCompare with a situation when a door was locked by draft and nobody inside (general function execution), and then some local fire occur and burn down the room (garbage collector:D), and then a new room was build and now you may leave another toys there (new function instance), but never get the same toys which were left in the first room instance.\r\n\r\nFor an advanced child I would put something like the following. It is not perfect, but it makes you feel about what it is:\r\n\r\n\tfunction playingInBrothersRoom (withToys) {\r\n\t  // We closure toys which we played in the brother&#39;s room. When he come back and lock the door\r\n\t  // your brother is supposed to be into the outer [[scope]] object now. Thanks god you could communicate with him.\r\n\t  var closureToys = withToys || [],\r\n\t\t  returnToy, countIt, toy; // Just another closure helpers, for brother&#39;s inner use.\r\n\t  \r\n\t  var brotherGivesToyBack = function (toy) {\r\n\t\t// New request. There is not yet closureToys on brother&#39;s hand yet. Give him a time.\r\n\t\treturnToy = null;\r\n\t\tif (toy &amp;&amp; closureToys.length &gt; 0) { // If we ask for a specific toy, the brother is going to search for it.\r\n\t\t  \r\n\t\t  for ( countIt = closureToys.length; countIt; countIt--) {\r\n\t\t\tif (closureToys[countIt - 1] == toy) {\r\n\t\t\t  returnToy = &#39;Take your &#39; + closureToys.splice(countIt - 1, 1) + &#39;, little boy!&#39;;\r\n              break;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  returnToy = returnToy || &#39;Hey, I could not find any &#39; + toy + &#39; here. Look for it in another room.&#39;;\r\n\t\t}\r\n\t\telse if (closureToys.length &gt; 0) { // Otherwise, just give back everything he has in the room.\r\n\t\t  returnToy = &#39;Behold! &#39; + closureToys.join(&#39;, &#39;) + &#39;.&#39;;\r\n\t\t  closureToys = [];\r\n\t\t}\r\n\t\telse {\r\n\t\t  returnToy = &#39;Hey, lil shrimp, I gave you everything!&#39;;\r\n\t\t}\r\n\t\tconsole.log(returnToy);\r\n\t  }\r\n\t  return brotherGivesToyBack;\r\n\t}\r\n\t// You are playing in the house, including the brother&#39;s room.\r\n\tvar toys = [&#39;teddybear&#39;, &#39;car&#39;, &#39;jumpingrope&#39;],\r\n\t\taskBrotherForClosuredToy = playingInBrothersRoom(toys);\r\n\r\n\t// The door is locked, and the brother came from the school. You could not cheat and take it out directly.\r\n\tconsole.log(askBrotherForClosuredToy.closureToys); // Undefined\r\n\r\n\t// But you could ask your brother politely, to give it back.\r\n\taskBrotherForClosuredToy(&#39;teddybear&#39;); // Hooray, here it is, teddybear\r\n\taskBrotherForClosuredToy(&#39;ball&#39;); // The brother would not be able to find it.\r\n\taskBrotherForClosuredToy(); // The brother gives you all the rest\r\n\taskBrotherForClosuredToy(); // Nothing left in there\r\n\r\nAs you can see, the toys left in the room are still accessible via the brother and no matter if the room is locked. Here is [a jsbin](http://jsbin.com/ubakor/9/edit) to play around with it.\r\n"},{"score":46,"body_markdown":"I&#39;d simply point them to the [Mozilla Closures page][1]. It&#39;s the best, most **concise and simple explanation** of closure basics and practical usage that I&#39;ve found. It is highly recommended to anyone learning JavaScript.\r\n\r\nAnd yes, I&#39;d even recommend it to a 6-year old -- if the 6-year old is learning about closures, then it&#39;s logical they&#39;re ready to comprehend the *concise and simple explanation* provided in the article.\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures\r\n"},{"score":15,"body_markdown":"If you want to explain it to a six-year old child then you must find something very much simpler and NO code.\r\n\r\nJust tell the child that he is &quot;open&quot;, which says that he is able to have relations with some others, his friends. At some point in time, he has determined friends (we can know the names of his friends), that is a closure. If you take a picture of him and his friends then he is &quot;closed&quot; relatively to his friendship ability. But in general, he is &quot;open&quot;. During his whole life he will have many different sets of friends. One of these sets is a closure.\r\n"},{"score":17,"body_markdown":"I found very clear chapter 8 section 6, &quot;Closures,&quot; of *JavaScript: The Definitive Guide* by David Flanagan, 6th edition, O&#39;Reilly, 2011. I&#39;ll try to paraphrase.  \r\n\r\n1. When a function is invoked, a new object is created to hold the local variables for that invocation.  \r\n\r\n2. A function&#39;s scope depends on its declaration location, not its execution location.\r\n\r\nNow, assume an inner function declared within an outer function and referring to variables of that outer function. Further assume the outer function returns the inner function, as a function. Now there is an external reference to whatever values were in the inner function&#39;s scope (which, by our assumptions, includes values from the outer function).\r\n\r\nJavaScript will preserve those values, as they have remained in scope of the current execution thanks to being passed out of the completed outer function. All functions are closures, but the closures of interest are the inner functions which, in our assumed scenario, preserve outer function values within their &quot;enclosure&quot; (I hope I&#39;m using language correctly here) when they (the inner functions) are returned from outer functions. I know this doesn&#39;t meet the six-year-old requirement, but hopefully it is still helpful.\r\n"},{"score":20,"body_markdown":"A function is executed in the scope of the object/function in which it is defined. The said function can access the variables defined in the object/function where it has been defined while it is executing.\r\n\r\nAnd just take it literally.... as the code is written :P"},{"score":30,"body_markdown":"For a six-year-old?\r\n\r\nYou and your family live in the mythical town of Ann Ville. You have a friend who lives next door, so you call them and ask them to come out and play. You dial:\r\n    \r\n&gt; 000001 (jamiesHouse)\r\n    \r\nAfter a month, you and your family move out of Ann Ville to the next town, but you and your friend still keep in touch, so now you have to dial the area code for the town that your friend lives in, before dialling their &#39;proper&#39; number:\r\n    \r\n&gt;001 000001 (annVille.jamiesHouse)\r\n    \r\nA year after that, your parents move to a whole new country, but you and your friend still keep in touch, so after bugging your parents to let you make international rate calls, you now dial:\r\n    \r\n&gt;01 001 000001 (myOldCountry.annVille.jamiesHouse)\r\n    \r\nStrangely though, after moving to your new country, you and your family just so happen to move to a new town called Ann Ville... and you just so happen to make friends with some new person called Jamie... You give them a call...\r\n    \r\n&gt; 000001 (jamiesHouse)\r\n    \r\nSpooky...\r\n    \r\nSo spooky in fact, that you tell Jamie from your old country about it... You have a good laugh about it. So one day, you and your family take a holiday back to the old country. You visit your old town (Ann Ville), and go to visit Jamie...\r\n    \r\n- &quot;Really? Another Jamie? In Ann Ville? In your new country!!?&quot;\r\n- &quot;Yeah... Let&#39;s call them...&quot;\r\n\r\n&gt; 02 001 000001 (myNewCountry.annVille.jamiesHouse)\r\n\r\nOpinions?\r\n\r\n*What&#39;s more, I have a load of questions about the patience of a modern six-year-old...*\r\n"},{"score":50,"body_markdown":"An answer for a six-year-old (assuming he knows what a function is and what a variable is, and what data is):\r\n\r\nFunctions can return data. One kind of data you can return from a function is another function. When that new function gets returned, all the variables and arguments used in the function that created it don&#39;t go away. Instead, that parent function &quot;closes.&quot; In other words, nothing can look inside of it and see the variables it used except for the function it returned. That new function has a special ability to look back inside the function that created it and see the data inside of it.\r\n\r\n    function the_closure() {\r\n      var x = 4;\r\n      return function () {\r\n        return x; // Here, we look back inside the_closure for the value of x\r\n      }\r\n    }\r\n\r\n    var myFn = the_closure();\r\n    myFn(); //=&gt; 4\r\n\r\nAnother really simple way to explain it is in terms of scope:\r\n\r\nAny time you create a smaller scope inside of a larger scope, the smaller scope will always be able to see what is in the larger scope.\r\n"},{"score":15,"body_markdown":"I&#39;m sure, [Einstein][1] didn&#39;t say it with a direct expectation for us to pick any esoteric brainstormer thing and run over six-year-olds with futile attempts to get those &#39;crazy&#39; (and what is even worse for them-boring) things to their childish minds :) If I were six years old I wouldn&#39;t like to have such parents or wouldn&#39;t make friendship with such boring philanthropists, sorry :)\r\n\r\nAnyway, for babies, **closure** is simply a **hug**, I guess, whatever way you try to explain :) And when you hug a friend of yours then you both kind of share anything you guys have at the moment. It&#39;s a rite of passage, once you&#39;ve hugged somebody you&#39;re showing her trust and willingness to let her do with you a lot of things you don&#39;t allow and would hide from others. It&#39;s an act of friendship :).\r\n\r\nI really don&#39;t know how to explain it to 5-6 years old babies. I neither think they will appreciate any JavaScript code snippets like:\r\n\r\n    function Baby(){\r\n        this.iTrustYou = true;\r\n    }\r\n\r\n    Baby.prototype.hug = function (baby) {\r\n        var smiles = 0;\r\n\r\n        if (baby.iTrustYou) {\r\n            return function() {\r\n                smiles++;\r\n                alert(smiles);\r\n            };\r\n        }\r\n    };\r\n\r\n    var\r\n       arman = new Baby(&quot;Arman&quot;),\r\n       morgan = new Baby(&quot;Morgana&quot;);\r\n\r\n    var hug = arman.hug(morgan);\r\n    hug();\r\n    hug();\r\n\r\nFor children only:\r\n\r\n**Closure** is **hug**\r\n\r\n**Bug** is **fly**\r\n\r\n**KISS** is **smooch!** :)\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Albert_Einstein\r\n"},{"score":384,"body_markdown":"OK, 6-year-old closures fan. Do you want to hear the simplest example of closure?\r\n\r\nLet&#39;s imagine the next situation: a driver is sitting in a car. That car is inside a plane. Plane is in the airport. The ability of driver to access things outside his car, but inside the plane, even if that plane leaves an airport, is a closure. That&#39;s it. When you turn 27, look at the [more detailed explanation][1] or at the example below.\r\n\r\nHere is how I can convert my plane story into the code.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var plane = function(defaultAirport) {\r\n\r\n      var lastAirportLeft = defaultAirport;\r\n\r\n      var car = {\r\n        driver: {\r\n          startAccessPlaneInfo: function() {\r\n            setInterval(function() {\r\n              console.log(&quot;Last airport was &quot; + lastAirportLeft);\r\n            }, 2000);\r\n          }\r\n        }\r\n      };\r\n      car.driver.startAccessPlaneInfo();\r\n\r\n      return {\r\n        leaveTheAirport: function(airPortName) {\r\n          lastAirportLeft = airPortName;\r\n        }\r\n      }\r\n    }(&quot;Boryspil International Airport&quot;);\r\n\r\n    plane.leaveTheAirport(&quot;John F. Kennedy&quot;);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://stackoverflow.com/a/111200/1393791\r\n"},{"score":178,"body_markdown":"I tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together [a jsFiddle](http://jsfiddle.net/KMQZK/) that does a comparison and tries to boil down the differences to the simplest explanations I could come up with.\n\n## Closures done right:\n\n    console.log(&#39;CLOSURES DONE RIGHT&#39;);\n\n    var arr = [];\n\n    function createClosure(n) {\n        return function () {\n            return &#39;n = &#39; + n;\n        }\n    }\n\n    for (var index = 0; index &lt; 10; index++) {\n        arr[index] = createClosure(index);\n    }\n\n    for (var index in arr) {\n        console.log(arr[index]());\n    }\n\n- In the above code `createClosure(n)` is invoked in every iteration of the loop. Note that I named the variable `n` to highlight that it is a **new** variable created in a new function scope and is not the same variable as `index` which is bound to the outer scope.\n     \n- This creates a new scope and `n` is bound to that scope; this means we have 10 separate scopes, one for each iteration.\n  \n- `createClosure(n)` returns a function that returns the n within that scope.\n        \n- Within each scope `n` is bound to whatever value it had when `createClosure(n)` was invoked so the nested function that gets returned will always return the value of `n` that it had when `createClosure(n)` was invoked.\n\n## Closures done wrong:\n\n    console.log(&#39;CLOSURES DONE WRONG&#39;);\n\n    function createClosureArray() {\n        var badArr = [];\n\n        for (var index = 0; index &lt; 10; index++) {\n            badArr[index] = function () {\n                return &#39;n = &#39; + index;\n            };\n        }\n        return badArr;\n    }\n\n    var badArr = createClosureArray();\n\n    for (var index in badArr) {\n        console.log(badArr[index]());\n    }\n\n- In the above code the loop was moved within the `createClosureArray()` function and the function now just returns the completed array, which at first glance seems more intuitive.\n        \n- What might not be obvious is that since `createClosureArray()` is only invoked once only one scope is created for this function instead of one for every iteration of the loop.\n        \n- Within this function a variable named `index` is defined. The loop runs and adds functions to the array that return `index`. Note that `index` is defined within the `createClosureArray` function which only ever gets invoked one time.\n        \n- Because there was only one scope within the `createClosureArray()` function, `index` is only bound to a value within that scope. In other words, each time the loop changes the value of `index`, it changes it for everything that references it within that scope.\n        \n- All of the functions added to the array return the SAME `index` variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope.\n        \n- After the loop finished and `index` was done being modified the end value was 10, therefore every function added to the array returns the value of the single `index` variable which is now set to 10.\n\n## Result\n\n&gt;CLOSURES DONE RIGHT  \n&gt;n = 0  \n&gt;n = 1  \n&gt;n = 2  \n&gt;n = 3  \n&gt;n = 4  \n&gt;n = 5  \n&gt;n = 6  \n&gt;n = 7  \n&gt;n = 8  \n&gt;n = 9  \n&gt;\n&gt;CLOSURES DONE WRONG  \n&gt;n = 10  \n&gt;n = 10  \n&gt;n = 10  \n&gt;n = 10  \n&gt;n = 10  \n&gt;n = 10  \n&gt;n = 10  \n&gt;n = 10  \n&gt;n = 10  \n&gt;n = 10  \n"},{"score":22,"body_markdown":"Given the following function\r\n--------------------------\r\n\r\n    function person(name, age){\r\n\r\n        var name = name;\r\n        var age = age;\r\n\r\n        function introduce(){\r\n        \talert(&quot;My name is &quot;+name+&quot;, and I&#39;m &quot;+age);\r\n        }\r\n\r\n        return introduce;\r\n    }\r\n\r\n    var a = person(&quot;Jack&quot;,12);\r\n    var b = person(&quot;Matt&quot;,14);\r\n\r\nEverytime the function `person` is called a new closure is created. While variables `a` and `b` have the same `introduce` function, it is linked to different closures. And that closure will still exist even after the function `person` finishes execution.\r\n\r\n![Enter image description here][1]\r\n\r\n    a(); //My name is Jack, and I&#39;m 12\r\n    b(); //My name is Matt, and I&#39;m 14\r\n\r\nAn abstract closures could be represented to something like this:\r\n\r\n    closure a = {\r\n    \tname: &quot;Jack&quot;,\r\n    \tage: 12,\r\n    \tcall: function introduce(){\r\n        \talert(&quot;My name is &quot;+name+&quot;, and I&#39;m &quot;+age);\r\n        }\r\n    }\r\n\r\n    closure b = {\r\n    \tname: &quot;Matt&quot;,\r\n    \tage: 14,\r\n    \tcall: function introduce(){\r\n        \talert(&quot;My name is &quot;+name+&quot;, and I&#39;m &quot;+age);\r\n        }\r\n    }\r\n\r\n----\r\n\r\nAssuming you know how a `class` in another language work, I will make an analogy.\r\n\r\nThink like\r\n\r\n - JavaScript `function` as a `constructor`\r\n - `local variables` as `instance properties`\r\n - these `properties` are private\r\n - `inner functions` as `instance methods`\r\n\r\nEverytime a `function` is called\r\n\r\n- A new `object` containing all local variables will be created.\r\n- Methods of this object have access to `&quot;properties&quot;` of that instance object.\r\n\r\n  [1]: http://i.stack.imgur.com/LDEhE.png\r\n"},{"score":10,"body_markdown":"Considering the question is about explaining it simply as if to a **6-year-old**, my answer would be:\r\n\r\n**&quot;When you declare a function in JavaScript it has forever access to all the variables and functions that were available in the line before that function declaration. The function and all the outer variables and functions that it has access to is what we call a closure.&quot;**\r\n"},{"score":216,"body_markdown":"**Closures are simple:**\r\n-------------\r\n\r\nThe following simple example covers all the main points of JavaScript closures.&lt;sup&gt;*&lt;/sup&gt;\r\n&amp;nbsp;\r\n\r\nHere is a factory that produces calculators that can add and multiply:\r\n\r\n    function make_calculator() {\r\n      var n = 0; // this calculator stores a single number n\r\n      return {\r\n        add: function(a) {\r\n          n += a;\r\n          return n;\r\n        },\r\n        multiply: function(a) {\r\n          n *= a;\r\n          return n;\r\n        }\r\n      };\r\n    }\r\n    \r\n    first_calculator = make_calculator();\r\n    second_calculator = make_calculator();\r\n    \r\n    first_calculator.add(3); // returns 3\r\n    second_calculator.add(400); // returns 400\r\n    \r\n    first_calculator.multiply(11); // returns 33\r\n    second_calculator.multiply(10); // returns 4000\r\n    \r\n**The key point:** Each call to `make_calculator` creates a new local variable `n`, which continues to be usable by that calculator&#39;s `add` and `multiply` functions long after `make_calculator` returns.\r\n\r\n*If you are familiar with stack frames, these calculators seem strange: How can they keep accessing `n` after `make_calculator` returns?  The answer is to imagine that JavaScript doesn&#39;t use &quot;stack frames&quot;, but instead uses &quot;heap frames&quot;, which can persist after the function call that made them returns.*\r\n\r\nInner functions like `add` and `multiply`, which access variables declared in an outer function&lt;sup&gt;**&lt;/sup&gt;, are called *closures*.\r\n\r\n**That is pretty much all there is to closures.**\r\n\r\n&lt;br&gt;\r\n\r\n---\r\n\r\n&lt;sup&gt;&lt;sup&gt;*&lt;/sup&gt; For example, it covers all the points in the &quot;Closures for Dummies&quot; article given in [another answer](https://stackoverflow.com/a/111111/706054), except example 6, which simply shows that variables can be used before they are declared, a nice fact to know but completely unrelated to closures. It also covers all the points in [the accepted answer](https://stackoverflow.com/a/111200/706054), except for the points (1) that functions copy their arguments into local variables (the named function arguments), and (2) that copying numbers creates a new number, but copying an object reference gives you another reference to the same object. These are also good to know but again completely unrelated to closures. It is also very similar to the example in [this answer](https://stackoverflow.com/a/111114/706054) but a bit shorter and less abstract. It does not cover the point of [this answer](https://stackoverflow.com/a/17200991/706054) or [this comment](https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111), which is that JavaScript makes it difficult to plug the *current* value of a loop variable into your inner function: The &quot;plugging in&quot; step can only be done with a helper function that encloses your inner function and is invoked on each loop iteration. (Strictly speaking, the inner function accesses the helper function&#39;s copy of the variable, rather than having anything plugged in.) Again, very useful when creating closures, but not part of what a closure is or how it works. There is additional confusion due to closures working differently in functional languages like ML, where variables are bound to values rather than to storage space, providing a constant stream of people who understand closures in a way (namely the &quot;plugging in&quot; way) that is simply incorrect for JavaScript, where variables are always bound to storage space, and never to values. &lt;/sup&gt;\r\n\r\n&lt;sup&gt;&lt;sup&gt;**&lt;/sup&gt; Any outer function, if several are nested, or even in the global context, as [this answer](https://stackoverflow.com/a/5099447/706054) points out clearly.&lt;/sup&gt;"},{"score":6,"body_markdown":"A closure is basically creating two things :\r\n- a function\r\n- a private scope that only that function can access\r\n\r\nIt is like putting some coating around a function.\r\n\r\nSo to a 6-years-old, it could be explained by giving an analogy. Let&#39;s say I build a robot. That robot can do many things. Among those things, I programmed it to count the number of birds he sees in the sky. Each time he has seen 25 birds, he should tell me how many birds he has seen since the beginning.\r\n\r\nI don&#39;t know how many birds he has seen unless he has told me. Only he knows. That&#39;s the private scope. That&#39;s basically the robot&#39;s memory. Let&#39;s say I gave him 4&amp;nbsp;GB.\r\n\r\nTelling me how many birds he has seen is the returned function. I also created that.\r\n\r\nThat analogy is a bit sucky, but someone could improve it I guess.\r\n"},{"score":6,"body_markdown":"The word *closure* simply refers to being able to access *objects* (six-year-old: things) that are *closed* (six-year-old: private) within a *function* (six-year-old: box). Even if the *function* (six-year-old: box) is out of *scope* (six-year-old: sent far away).\r\n"},{"score":22,"body_markdown":"The more I think about closure the more I see it as a 2-step process: **init - action**\r\n\r\n    init: pass first what&#39;s needed...\r\n    action: in order to achieve something for later execution.\r\n\r\nTo a 6-year old, I&#39;d emphasize on the *practical aspect* of closure:\r\n\r\n    Daddy: Listen. Could you bring mum some milk (2).\r\n    Tom: No problem.\r\n    Daddy: Take a look at the map that Daddy has just made: mum is there and daddy is here.\r\n    Daddy: But get ready first. And bring the map with you (1), it may come in handy\r\n    Daddy: Then off you go (3). Ok?\r\n    Tom: A piece of cake!\r\n\r\n**Example**: *Bring some milk to mum (=action). First get ready and bring the map (=init).*\r\n\r\n    function getReady(map) {\r\n        var cleverBoy = &#39;I examine the &#39; + map;\r\n        return function(what, who) {\r\n            return &#39;I bring &#39; + what + &#39; to &#39; + who + &#39;because + &#39; cleverBoy; //I can access the map\r\n        }\r\n    }\r\n    var offYouGo = getReady(&#39;daddy-map&#39;);\r\n    offYouGo(&#39;milk&#39;, &#39;mum&#39;);\r\n\r\nBecause if you bring with you a very important piece of information (the map), you&#39;re knowledgeable enough to execute other similar actions:\r\n\r\n    offYouGo(&#39;potatoes&#39;, &#39;great mum&#39;);\r\n\r\nTo a developer I&#39;d make a parallel between closures and [OOP][1].\r\nThe **init phase** is similar to passing arguments to a constructor in a traditional OO language; the **action phase** is ultimately the method you call to achieve what you want. And the method has access these init arguments using a mechanism called *closure*.\r\n\r\nSee my another answer illustrating the parallelism between OO and closures:\r\n\r\n*https://stackoverflow.com/questions/1595611/how-to-properly-create-a-custom-object-in-javascript/21352366#21352366*\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Object-oriented_programming\r\n"},{"score":205,"body_markdown":"How I&#39;d explain it to a six-year-old:\r\n\r\nYou know how grown-ups can own a house, and they call it home? When a mom has a child, the child doesn&#39;t really own anything, right? But its parents own a house, so whenever someone asks the child &quot;Where&#39;s your home?&quot;, he/she can answer &quot;that house!&quot;, and point to the house of its parents. A &quot;Closure&quot; is the ability of the child to always (even if abroad) be able to say it has a home, even though it&#39;s really the parent&#39;s who own the house.\r\n"},{"score":4,"body_markdown":"# The simplest, shortest, most-easy-to-understand answer:\n\nA closure is a block of code where each line can reference the same set of variables with the same variable names. \n\nIf &quot;this&quot; means something different than it does somewhere else, then you know it is two different closures.\n"},{"score":13,"body_markdown":"If you understand it well you can explain it simple. And the simplest way is abstracting it from the context. Code aside, even programming aside. A metaphor example will do it better.\r\n\r\nLet&#39;s imagine that a function is a room whose walls are of glass, but they are special glass, like the ones in an interrogation room. From outside they are opaque, from inside they are transparent. It can be rooms inside other rooms, and the only way of contact is a phone.\r\n\r\nIf you call from the outside, you don&#39;t know what is in it, but you know that the people inside will do a task if you give them certain information. They can see outside, so they can ask you for stuff that are outside and make changes to that stuff, but you can&#39;t change what it is inside from the outside, you don&#39;t even see (know) what it is inside. The people inside that room you are calling see what it is outside, but not what it is inside the rooms in that room, so they interact with them the way you are doing from outside. The people inside the most inner rooms can see many things, but the people of the most outer room  don&#39;t even know about the most inner rooms&#39; existence.\r\n\r\nFor each call to an inner room, the people in that room keeps a record of the information about that specific call, and they are so good doing that that they never mistake one call stuff with other call stuff.\r\n\r\nRooms are functions, visibility is scope, people doing task is statements, stuff are objects, phone calls are function calls, phone call information is arguments, call records are scope instances, the most outer room is the global object.\r\n"},{"score":21,"body_markdown":"Even though many beautiful definitions of JavaScript closures exists on the Internet, I am trying to start explaining my six-year-old friend with my favourite definitions of closure which helped me to understand the closure much better.\r\n\r\n**What is a Closure?**\r\n\r\nA closure is an inner function that has access to the outer (enclosing) function’s variables—scope chain. The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function’s variables, and it has access to the global variables.\r\n\r\nA closure is the local variables for a function - kept alive after the function has returned.\r\n\r\nClosures are functions that refer to independent (free) variables. In other words, the function defined in the closure &#39;remembers&#39; the environment in which it was created in.\r\n\r\nClosures are an extension of the concept of scope. With closures, functions have access to variables that were available in the scope where the function was created.\r\n\r\nA closure is a stack-frame which is not deallocated when the function returns. (As if a &#39;stack-frame&#39; were malloc&#39;ed instead of being on the stack!)\r\n\r\nLanguages such as Java provide the ability to declare methods private, meaning that they can only be called by other methods in the same class. JavaScript does not provide a native way of doing this, but it is possible to emulate private methods using closures.\r\n\r\nA &quot;closure&quot; is an expression (typically a function) that can have free variables together with an environment that binds those variables (that &quot;closes&quot; the expression).\r\n\r\nClosures are an abstraction mechanism that allow you to separate concerns very cleanly.\r\n\r\n**Uses of Closures:**\r\n\r\nClosures are useful in hiding the implementation of functionality while still revealing the interface.\r\n\r\nYou can emulate the encapsulation concept in JavaScript using closures.\r\n\r\nClosures are used extensively in [jQuery][1] and [Node.js][2].\r\n\r\nWhile object literals are certainly easy to create and convenient for storing data, closures are often a better choice for creating static singleton namespaces in a large web application.\r\n\r\n**Example of Closures:**\r\n\r\nAssuming my 6-year-old friend get to know addition very recently in his primary school, I felt this example of adding the two numbers would be the simplest and apt for the six-year-old to learn the closure.\r\n\r\n**Example 1: Closure is achieved here by returning a function.**\r\n\r\n    function makeAdder(x) {\r\n        return function(y) {\r\n            return x + y;\r\n        };\r\n    }\r\n\r\n    var add5 = makeAdder(5);\r\n    var add10 = makeAdder(10);\r\n\r\n    console.log(add5(2));  // 7\r\n    console.log(add10(2)); // 12\r\n\r\n**Example 2: Closure is achieved here by returning an object literal.**\r\n\r\n    function makeAdder(x) {\r\n        return {\r\n            add: function(y){\r\n                return x + y;\r\n            }\r\n        }\r\n    }\r\n\r\n    var add5 = makeAdder(5);\r\n    console.log(add5.add(2));//7\r\n\r\n    var add10 = makeAdder(10);\r\n    console.log(add10.add(2));//12\r\n\r\n**Example 3: Closures in jQuery**\r\n\r\n    $(function(){\r\n        var name=&quot;Closure is easy&quot;;\r\n        $(&#39;div&#39;).click(function(){\r\n            $(&#39;p&#39;).text(name);\r\n        });\r\n    });\r\n\r\n**Useful Links:**\r\n\r\n * *[Closures][3]* (Mozilla Developer Network)\r\n * *[Understand JavaScript Closures With Ease][4]*\r\n\r\nThanks to the above links which helps me to understand and explain closure better.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/JQuery\r\n  [2]: http://en.wikipedia.org/wiki/Node.js\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures\r\n  [4]: http://javascriptissexy.com/understand-javascript-closures-with-ease/\r\n\r\n"},{"score":6,"body_markdown":"I have read all of these before in the past, and they are all very informative. Some come very close to getting the simple explanation and then get complex or remain abstract, defeating the purpose and failing to show a very simple real world use. \r\n\r\nThough combing through all the examples and explanations you get a good idea of what closures are and aren&#39;t via comments and code, I was still unsatisfied with a very simple illustration that helped me get a closures usefulness without getting so complex. My wife wants to learn coding and I figured I needed to be able to show here not only what, but why, and and how.\r\n\r\nI am not sure a six year old will get this, but I think it might be a little closer to demonstrating a simple case in a real world way that might acually be useful and that is easily understandable.\r\n\r\nOne of the best (or closest to simplest) is the retelling of Morris&#39; Closures for Dummies example.\r\n\r\nTaking the &quot;SayHi2Bob&quot; concept just one step further demonstrates the two basic things you can glean from reading all the answers:\r\n\r\n 1. Closures have access to the containing function&#39;s variables.\r\n 2. Closures persist in their own memory space (and thus are useful for all kinds of oop-y instantiation stuff)\r\n\r\n\r\nProving and demonstrating this to myself, I made a little fiddle:\r\n\r\nhttp://jsfiddle.net/9ZMyr/2/\r\n\r\n    function sayHello(name) {\r\n      var text = &#39;Hello &#39; + name; // Local variable\r\n      console.log(text);\r\n      var sayAlert = function () {\r\n          alert(text);\r\n      }\r\n      return sayAlert;\r\n    }\r\n\r\n    sayHello(); \r\n    /* This will write &#39;Hello undefined&#39; to the console (in Chrome anyway), \r\n    but will not alert though since it returns a function handle to nothing). \r\n    Since no handle or reference is created, I imagine a good js engine would \r\n    destroy/dispose of the internal sayAlert function once it completes. */\r\n\r\n    // Create a handle/reference/instance of sayHello() using the name &#39;Bob&#39;\r\n    sayHelloBob = sayHello(&#39;Bob&#39;);\r\n    sayHelloBob();\r\n\r\n    // Create another handle or reference to sayHello with a different name\r\n    sayHelloGerry = sayHello(&#39;Gerry&#39;);\r\n    sayHelloGerry();\r\n\r\n    /* Now calling them again demonstrates that each handle or reference contains its own \r\n    unique local variable memory space. They remain in memory &#39;forever&#39; \r\n    (or until your computer/browser explode) */\r\n    sayHelloBob();\r\n    sayHelloGerry();\r\n    \r\n    \r\nThis demonstrates both of the basic concepts you should get about closures. \r\n\r\nIn simple terms to explain the why this is useful, I have a base function to which I can make references or handles that contain unique data which persists within that memory reference. I don&#39;t have to rewrite the function for each time I want to say someone&#39;s name. I have encapsulated that routine and made it reusable.\r\n\r\nTo me this leads to at least the basic concepts of constructors, oop practices, singletons vs instantiated instances with their own data, etc. etc.\r\n\r\nIf you start a neophyte with this, then you can move on to more complex object property/member based calls, and hopefully the concepts carry."},{"score":11,"body_markdown":"A closure is created when the inner function is somehow made available to any scope outside the outer function.\r\n\r\n**Example:**\r\n\r\n    var outer = function(params){ //Outer function defines a variable called params\r\n        var inner = function(){ // Inner function has access to the params variable of the outer function\r\n            return params;\r\n        }\r\n        return inner; //Return inner function exposing it to outer scope\r\n    },\r\n    myFunc = outer(&quot;myParams&quot;);\r\n    myFunc(); //Returns &quot;myParams&quot;\r\n"},{"score":8,"body_markdown":"Closure is when a function is **closed** in a way that it was defined in a namespace which is immutable by the time the function is called.\r\n\r\nIn JavaScript, it happens when you:\r\n\r\n - Define one function inside the other function\r\n - The inner function is called after the outer function returned\r\n\r\n&lt;!-- Uszy Wieloryba --&gt;\r\n\r\n    // &#39;name&#39; is resolved in the namespace created for one invocation of bindMessage\r\n    // the processor cannot enter this namespace by the time displayMessage is called\r\n    function bindMessage(name, div) {\r\n\r\n        function displayMessage() {\r\n            alert(&#39;This is &#39; + name);\r\n        }\r\n\r\n        $(div).click(displayMessage);\r\n    }\r\n"},{"score":6,"body_markdown":"I think it is valuable to take a step back, and examine a more general notion of a &quot;closure&quot; -- the so-called &quot;join operator&quot;.\r\n\r\nIn mathematics, a &quot;join&quot; operator is a function on a partially ordered set which returns the smallest object greater than or equal to its arguments.  In symbols, join [a,b] = d such that d &gt;= a and d &gt;= b, but there does not exist an e such that d &gt; e &gt;= a or d &gt; e &gt;= b.\r\n\r\nSo the join gives you the smallest thing &quot;bigger&quot; than the parts.\r\n\r\nNow, note that JavaScript scopes are a partially ordered structure.  So that there is a sensible notion of a join.  In particular, a join of scopes is the smallest scope bigger than the original scopes.  That scope is called the **closure**.\r\n\r\nSo a closure for the variables a, b, c is the smallest scope (in the lattice of scopes for your program!) that brings a, b, and c into scope."},{"score":11,"body_markdown":"A closure is a block of code which meets three criteria:\r\n\r\n * It can be passed around as a value and\r\n\r\n * executed on demand by anyone who has that value, at which time\r\n\r\n * it can refer to variables from the context in which it was created\r\n   (that is, it is closed with respect to variable access, in the\r\n   mathematical sense of the word &quot;closed&quot;).\r\n\r\n(The word &quot;closure&quot; actually has an imprecise meaning, and some people don&#39;t think that criterion #1 is part of the definition. I think it is.)\r\n\r\nClosures are a mainstay of functional languages, but they are present in many other languages as well (for example, Java&#39;s anonymous inner classes). You can do cool stuff with them: they allow deferred execution and some elegant tricks of style.\r\n\r\nBy: Paul Cantrell, @ http://innig.net/software/ruby/closures-in-ruby\r\n"},{"score":13,"body_markdown":"Imagine there is a very large park in your town where you see a magician called Mr. Coder starting baseball games in different corners of the park using his magic wand, called JavaScript.\r\n\r\nNaturally each baseball game has the exact same rules and each game has its own score board.\r\n\r\nNaturally, the scores of one baseball game are completely separate from the other games.\r\n\r\nA closure is the special way Mr.Coder keeps the scoring of all his magical baseball games separate.\r\n"},{"score":28,"body_markdown":"Here is a simple real-time scenario. Just read it through, and you will understand how we have used closure here (see how seat number is changing).\r\n\r\nAll other examples explained previously are also very good to understand the concept.\r\n\r\n    function movieBooking(movieName) {\r\n        var bookedSeatCount = 0;\r\n        return function(name) {\r\n            ++bookedSeatCount ;\r\n            alert( name + &quot; - &quot; + movieName + &quot;, Seat - &quot; + bookedSeatCount )\r\n        };\r\n    };\r\n\r\n    var MI1 = movieBooking(&quot;Mission Impossible 1 &quot;);\r\n    var MI2 = movieBooking(&quot;Mission Impossible 2 &quot;);\r\n\r\n    MI1(&quot;Mayur&quot;);\r\n    // alert\r\n    // Mayur - Mission Impossible 1, Seat - 1\r\n\r\n    MI1(&quot;Raju&quot;);\r\n    // alert\r\n    // Raju - Mission Impossible 1, Seat - 2\r\n\r\n    MI2(&quot;Priyanka&quot;);\r\n    // alert\r\n    // Raja - Mission Impossible 2, Seat - 1\r\n"},{"score":60,"body_markdown":"As a father of a 6-year-old, currently teaching young children (and a relative novice to coding with no formal education so corrections will be required), I think the lesson would stick best through hands-on play. If the 6-year-old is ready to understand what a closure is, then they are old enough to have a go themselves. I&#39;d suggest pasting the code into jsfiddle.net, explaining a bit, and leaving them alone to concoct a unique song. The explanatory text below is probably more appropriate for a 10 year old.\r\n\r\n    function sing(person) {\r\n\r\n        var firstPart = &quot;There was &quot; + person + &quot; who swallowed &quot;;\r\n\r\n        var fly = function() {\r\n            var creature = &quot;a fly&quot;;\r\n            var result = &quot;Perhaps she&#39;ll die&quot;;\r\n            alert(firstPart + creature + &quot;\\n&quot; + result);\r\n        };\r\n\r\n        var spider = function() {\r\n            var creature = &quot;a spider&quot;;\r\n            var result = &quot;that wiggled and jiggled and tickled inside her&quot;;\r\n            alert(firstPart + creature + &quot;\\n&quot; + result);\r\n        };\r\n\r\n        var bird = function() {\r\n            var creature = &quot;a bird&quot;;\r\n            var result = &quot;How absurd!&quot;;\r\n            alert(firstPart + creature + &quot;\\n&quot; + result);\r\n        };\r\n\r\n        var cat = function() {\r\n            var creature = &quot;a cat&quot;;\r\n            var result = &quot;Imagine That!&quot;;\r\n            alert(firstPart + creature + &quot;\\n&quot; + result);\r\n        };\r\n\r\n        fly();\r\n        spider();\r\n        bird();\r\n        cat();\r\n    }\r\n\r\n    var person=&quot;an old lady&quot;;\r\n\r\n    sing(person);\r\n\r\n**INSTRUCTIONS**\r\n\r\nDATA: Data is a collection of facts. It can be numbers, words, measurements, observations or even just descriptions of things. You can&#39;t touch it, smell it or taste it. You can write it down, speak it and hear it. You could use it to *create* touch smell and taste using a computer. It can be made useful by a computer using code.\r\n\r\nCODE: All the writing above is called *code*. It is written in JavaScript.\r\n\r\nJAVASCRIPT: JavaScript is a language. Like English or French or Chinese are languages. There are lots of languages that are understood by computers and other electronic processors. For JavaScript to be understood by a computer it needs an interpreter. Imagine if a teacher who only speaks Russian comes to teach your class at school. When the teacher says &quot;все садятся&quot;, the class would not understand. But luckily you have a Russian pupil in your class who tells everyone this means &quot;everybody sit down&quot; - so you all do. The class is like a computer and the Russian pupil is the interpreter. For JavaScript the most common interpreter is called a browser.\r\n\r\nBROWSER: When you connect to the Internet on a computer, tablet or phone to visit a website, you use a browser. Examples you may know are Internet Explorer, Chrome, Firefox and Safari. The browser can understand JavaScript and tell the computer what it needs to do. The JavaScript instructions are called functions.\r\n\r\nFUNCTION: A function in JavaScript is like a factory. It might be a little factory with only one machine inside. Or it might contain many other little factories, each with many machines doing different jobs. In a real life clothes factory you might have reams of cloth and bobbins of thread going in and T-shirts and jeans coming out. Our JavaScript factory only processes data, it can&#39;t sew, drill a hole or melt metal. In our JavaScript factory data goes in and data comes out.\r\n\r\nAll this data stuff sounds a bit boring, but it is really very cool; we might have a function that tells a robot what to make for dinner. Let&#39;s say I invite you and your friend to my house. You like chicken legs best, I like sausages, your friend always wants what you want and my friend does not eat meat.\r\n\r\nI haven&#39;t got time to go shopping, so the function needs to know what we have in the fridge to make decisions. Each ingredient has a different cooking time and we want everything to be served hot by the robot at the same time. We need to provide the function with the data about what we like, the function could &#39;talk&#39; to the fridge, and the function could control the robot.\r\n\r\nA function normally has a name, parentheses and braces. Like this:\r\n\r\n    function cookMeal() {  /*  STUFF INSIDE THE FUNCTION  */  }\r\n\r\n*Note that `/*...*/` and `//` stop code being read by the browser.*\r\n\r\nNAME: You can call a function just about whatever word you want. The example &quot;cookMeal&quot; is typical in joining two words together and giving the second one a capital letter at the beginning - but this is not necessary. It can&#39;t have a space in it, and it can&#39;t be a number on its own.\r\n\r\nPARENTHESES: &quot;Parentheses&quot; or `()` are the letter box on the JavaScript function factory&#39;s door or a post box in the street for sending packets of information to the factory. Sometimes the postbox might be marked *for example* `cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)`, in which case you know what data you have to give it.\r\n\r\nBRACES: &quot;Braces&quot; which look like this `{}` are the tinted windows of our factory. From inside the factory you can see out, but from the outside you can&#39;t see in.\r\n\r\n**THE LONG CODE EXAMPLE ABOVE**\r\n\r\nOur code begins with the word *function*, so we know that it is one! Then the name of the function *sing* - that&#39;s my own description of what the function is about. Then parentheses *()*. The parentheses are always there for a function. Sometimes they are empty, and sometimes they have something in. This one has a word in: `(person)`. After this there is a brace like this `{` . This marks the start of the function *sing()*. It has a partner which marks the end of *sing()* like this `}`\r\n\r\n    function sing(person) {  /* STUFF INSIDE THE FUNCTION */  }\r\n\r\nSo this function might have something to do with singing, and might need some data about a person. It has instructions inside to do something with that data.\r\n\r\nNow, after the function *sing()*, near the end of the code is the line\r\n\r\n    var person=&quot;an old lady&quot;;\r\n\r\nVARIABLE: The letters *var* stand for &quot;variable&quot;. A variable is like an envelope. On the outside this envelope is marked &quot;person&quot;. On the inside it contains a slip of paper with the information our function needs, some letters and spaces joined together like a piece of string (it&#39;s called a string) that make a phrase reading &quot;an old lady&quot;. Our envelope could contain other kinds of things like numbers (called integers), instructions (called functions), lists (called *arrays*). Because this variable is written outside of all the braces `{}`, and because you can see out through the tinted windows when you are inside the braces, this variable can be seen from anywhere in the code. We call this a &#39;global variable&#39;.\r\n\r\nGLOBAL VARIABLE: *person* is a global variable, meaning that if you change its value from &quot;an old lady&quot; to &quot;a young man&quot;, the *person* will keep being a young man until you decide to change it again and that any other function in the code can see that it&#39;s a young man. Press the &lt;kbd&gt;F12&lt;/kbd&gt; button or look at the Options settings to open the developer console of a browser and type &quot;person&quot; to see what this value is. Type `person=&quot;a young man&quot;` to change it and then type &quot;person&quot; again to see that it has changed.\r\n\r\nAfter this we have the line\r\n\r\n    sing(person);\r\n\r\nThis line is calling the function, as if it were calling a dog\r\n\r\n&gt; &quot;Come on *sing*, Come and get *person*!&quot;\r\n\r\nWhen the browser has loaded the JavaScript code an reached this line, it will start the function. I put the line at the end to make sure that the browser has all the information it needs to run it.\r\n\r\nFunctions define actions  - the main function is about singing. It contains a variable called *firstPart* which applies to the singing about the person that applies to each of the verses of the song: &quot;There was &quot; + person + &quot; who swallowed&quot;. If you type *firstPart* into the console, you won&#39;t get an answer because the variable is locked up in a function - the browser can&#39;t see inside the tinted windows of the braces.\r\n\r\nCLOSURES: The closures are the smaller functions that are inside the big *sing()* function. The little factories inside the big factory. They each have their own braces which mean that the variables inside them can&#39;t be seen from the outside. That&#39;s why the names of the variables (*creature* and *result*) can be repeated in the closures but with different values. If you type these variable names in the console window, you won&#39;t get its value because it&#39;s hidden by two layers of tinted windows.\r\n\r\nThe closures all know what the *sing()* function&#39;s variable called *firstPart* is, because they can see out from their tinted windows.\r\n\r\nAfter the closures come the lines\r\n\r\n    fly();\r\n    spider();\r\n    bird();\r\n    cat();\r\n\r\nThe sing() function will call each of these functions in the order they are given. Then the sing() function&#39;s work will be done.\r\n"},{"score":34,"body_markdown":"In JavaScript closures are awesome and unique, where variables or arguments are available to inner functions, and they will be alive even after the outer function has returned. Closures are used in most of the design patterns in JS \r\n\r\n    function getFullName(a, b) {\r\n      return a + b;\r\n    }\r\n    \r\n    function makeFullName(fn) {\r\n    \r\n      return function(firstName) {\r\n    \r\n        return function(secondName) {\r\n    \r\n          return fn(firstName, secondName);\r\n\r\n        }\r\n      }\r\n    }\r\n    \r\n    makeFullName(getFullName)(&quot;Stack&quot;)(&quot;overflow&quot;); // Stackoverflow"},{"score":13,"body_markdown":"Maybe you should consider an object-oriented structure instead of inner functions. For example:\r\n\r\n    var calculate = {\r\n        number: 0,\r\n        init: function (num) {\r\n            this.number = num;\r\n        },\r\n        add: function (val) {\r\n            this.number += val;\r\n        },\r\n        rem: function (val) {\r\n            this.number -= val;\r\n        }\r\n    };\r\n\r\nAnd read the result from the calculate.number variable, who needs &quot;return&quot; anyway.\r\n"},{"score":105,"body_markdown":"**I do not understand why the answers are so complex here.**\n\nHere is a closure:\n\n    var a = 42;\n\n    function b() { return a; }\n\nYes. You probably use that many times a day.\n\n&lt;br&gt;\n\n&gt; There is no reason to believe closures are a complex design hack to address specific problems. No, closures are just about using a variable that comes from a higher scope **from the perspective of where the function was declared (not run)**.\n&gt;\n&gt; Now what it *allows* you to do can be more spectacular, see other answers."},{"score":48,"body_markdown":"Perhaps a little beyond all but the most precocious of six-year-olds, but a few examples that helped make the concept of closure in JavaScript click for me.\r\n\r\nA closure is a function that has access to another function&#39;s scope (its variables and functions). The easiest way to create a closure is with a function within a function; the reason being that in JavaScript a function always has access to its containing function’s scope.\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function outerFunction() {\r\n        var outerVar = &quot;monkey&quot;;\r\n        \r\n        function innerFunction() {\r\n            alert(outerVar);\r\n        }\r\n        \r\n        innerFunction();\r\n    }\r\n\r\n    outerFunction();\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nALERT: monkey\r\n\r\nIn the above example, outerFunction is called which in turn calls innerFunction. Note how outerVar is available to innerFunction, evidenced by its correctly alerting the value of outerVar.\r\n\r\nNow consider the following:\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function outerFunction() {\r\n        var outerVar = &quot;monkey&quot;;\r\n        \r\n        function innerFunction() {\r\n            return outerVar;\r\n        }\r\n        \r\n        return innerFunction;\r\n    }\r\n\r\n    var referenceToInnerFunction = outerFunction();\r\n    alert(referenceToInnerFunction());\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nALERT: monkey\r\n\r\nreferenceToInnerFunction is set to outerFunction(), which simply returns a reference to innerFunction. When referenceToInnerFunction is called, it returns outerVar. Again, as above, this demonstrates that innerFunction has access to outerVar, a variable of outerFunction. Furthermore, it is interesting to note that it retains this access even after outerFunction has finished executing.\r\n\r\nAnd here is where things get really interesting. If we were to get rid of outerFunction, say set it to null, you might think that referenceToInnerFunction would loose its access to the value of outerVar. But this is not the case. \r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function outerFunction() {\r\n        var outerVar = &quot;monkey&quot;;\r\n        \r\n        function innerFunction() {\r\n            return outerVar;\r\n        }\r\n        \r\n        return innerFunction;\r\n    }\r\n\r\n    var referenceToInnerFunction = outerFunction();\r\n    alert(referenceToInnerFunction());\r\n\r\n    outerFunction = null;\r\n    alert(referenceToInnerFunction());\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nALERT: monkey\r\nALERT: monkey\r\n\r\nBut how is this so? How can referenceToInnerFunction still know the value of outerVar now that outerFunction has been set to null?\r\n\r\nThe reason that referenceToInnerFunction can still access the value of outerVar is because when the closure was first created by placing innerFunction inside of outerFunction, innerFunction added a reference to outerFunction’s scope (its variables and functions) to its scope chain. What this means is that innerFunction has a pointer or reference to all of outerFunction’s variables, including outerVar. So even when outerFunction has finished executing, or even if it is deleted or set to null, the variables in its scope, like outerVar, stick around in memory because of the outstanding reference to them on the part of the innerFunction that has been returned to referenceToInnerFunction. To truly release outerVar and the rest of outerFunction’s variables from memory you would have to get rid of this outstanding reference to them, say by setting referenceToInnerFunction to null as well.\r\n\r\n//////////\r\n\r\nTwo other things about closures to note. First, the closure will always have access to the last values of its containing function.\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function outerFunction() {\r\n        var outerVar = &quot;monkey&quot;;\r\n        \r\n        function innerFunction() {\r\n            alert(outerVar);\r\n        }\r\n        \r\n        outerVar = &quot;gorilla&quot;;\r\n\r\n        innerFunction();\r\n    }\r\n\r\n    outerFunction();\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nALERT: gorilla\r\n\r\nSecond, when a closure is created, it retains a reference to all of its enclosing function’s variables and functions; it doesn’t get to pick and choose. And but so, closures should be used sparingly, or at least carefully, as they can be memory intensive; a lot of variables can be kept in memory long after a containing function has finished executing.\r\n"},{"score":22,"body_markdown":"(I am not taking the 6-years-old thing into account.)\r\n\r\nIn a language like JavaScript, where you can pass functions as parameters to other functions (languages where functions are *first class citizens*), you will often find yourself doing something like:\r\n\r\n    var name = &#39;Rafael&#39;;\r\n\r\n    var sayName = function() {\r\n      console.log(name);\r\n    };\r\n\r\nYou see, `sayName` doesn&#39;t have the definition for the `name` variable, but it does use the value of `name` that was defined outside of `sayName` (in a parent scope).\r\n\r\nLet&#39;s say you pass `sayName` as a parameter to another function, that will call `sayName` as a callback:\r\n\r\n    functionThatTakesACallback(sayName);\r\n\r\nNote that:\r\n\r\n1. `sayName` will be called from inside `functionThatTakesACallback` (assume that, since I haven&#39;t implemented `functionThatTakesACallback` in this example).\r\n2. When `sayName` is called, it will log the value of the `name` variable.\r\n3. `functionThatTakesACallback` doesn&#39;t define a `name` variable (well, it could, but it wouldn&#39;t matter, so assume it doesn&#39;t).\r\n\r\nSo we have `sayName` being called inside `functionThatTakesACallback` and referring to a `name` variable that is not defined inside `functionThatTakesACallback`.\r\n\r\nWhat happens then? A `ReferenceError: name is not defined`?\r\n\r\nNo! The value of `name` is captured inside a **closure**. You can think of this closure as **context associated to a function**, that holds the values that were available where that function was defined.\r\n\r\nSo: Even though `name` is not in scope where the function `sayName` will be called (inside `functionThatTakesACallback`), `sayName` can access the value for `name` that is captured in the closure associated with `sayName`.\r\n\r\n--\r\n\r\nFrom the book *Eloquent JavaScript*:\r\n\r\n&gt; A good mental model is to think of function values as containing both the code in their body and the environment in which they are created. When called, the function body sees its original environment, not the environment in which the call is made."},{"score":24,"body_markdown":"Here&#39;s the most Zen answer I can give:\r\n\r\nWhat would you expect this code to do? Tell me in a comment before you run it. I&#39;m curious!\r\n\r\n    function foo() {\r\n      var i = 1;\r\n      return function() {\r\n        console.log(i++);\r\n      }\r\n    }\r\n\r\n    var bar = foo();\r\n    bar();\r\n    bar();\r\n    bar();\r\n\r\n    var baz = foo();\r\n    baz();\r\n    baz();\r\n    baz();\r\n\r\nNow open the console in your browser (&lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;I&lt;/kbd&gt; or &lt;kbd&gt;F12&lt;/kbd&gt;, hopefully) and paste the code in and hit &lt;kbd&gt;Enter&lt;/kbd&gt;.\r\n\r\nIf this code printed what you expect (JavaScript newbies - ignore the &quot;undefined&quot; at the end), then you already have *wordless understanding*.  *In words*, the variable `i` is part of the inner function *instance&#39;s* closure.\r\n\r\nI put it this way because, once I understood that this code is putting instances of `foo()`&#39;s inner function in `bar` and `baz` and then calling them via those variables, nothing else surprised me.\r\n\r\nBut if I&#39;m wrong and the console output surprised you, let me know!\r\n"},{"score":42,"body_markdown":"I believe in shorter explanations, so see the below image.\r\n\r\n![Enter image description here][1]\r\n\r\n\r\n`function f1()` ..&gt;  Light Red Box\r\n\r\n`function f2()` ..&gt;  Red Small Box\r\n\r\n\r\nHere we have two functions, `f1()` and `f2()`. f2() is inner to f1().\r\nf1() has a variable, `var x = 10`.\r\n\r\nWhen invoking the function `f1()`, `f2()` can access the value of `var x = 10`.\r\n\r\n\r\nHere is the code:\r\n\r\n    function f1() {\r\n        var x=10;\r\n\r\n        function f2() {\r\n            console.log(x)\r\n        }\r\n        \r\n        return f2\r\n\r\n    }\r\n    f1()\r\n\r\n`f1()` invoking here:\r\n\r\n![Enter image description here][2]\r\n\r\n  [1]: http://i.stack.imgur.com/qbv6M.jpg\r\n  [2]: http://i.stack.imgur.com/zg4UT.jpg\r\n"},{"score":6,"body_markdown":"The easiest use case I can think of to explain **JavaScript closures** is the Module Pattern. In the Module Pattern you define a function and call it immediately afterwards in what is called an Immediately Invoked Function Expression (IIFE). **Everything that you write inside that function has private scope because it&#39;s defined inside the closure**, thus allowing you to &quot;simulate&quot; privacy in JavaScript. Like so:\r\n\r\n\r\n     var Closure = (function () {\r\n        // This is a closure\r\n        // Any methods, variables and properties you define here are &quot;private&quot;\r\n        // and can&#39;t be accessed from outside the function.\r\n       \r\n        //This is a private variable\r\n        var foo = &quot;&quot;;\r\n        \r\n        //This is a private method\r\n        var method = function(){\r\n           \r\n        }\r\n    })();\r\n\r\n\r\n\r\nIf, on the other hand, you&#39;d like to make one or multiple variables or methods visible outside  the closure, you can return them inside an object literal. Like so:\r\n\r\n\r\n    var Closure = (function () {\r\n      // This is a closure\r\n      // Any methods, variables and properties you define here are &quot;private&quot;\r\n      // and can&#39;t be accessed from outside the function.\r\n\r\n      //This is a private variable\r\n      var foo = &quot;&quot;;\r\n      \r\n      //This is a private method\r\n      var method = function(){\r\n        \r\n      }\r\n      \r\n      //The method will be accessible from outside the closure\r\n      return {\r\n        method: method\r\n      }\r\n      \r\n    })();\r\n\r\n    Closure.method();\r\n\r\n\r\nHope it helps.\r\nRegards,"},{"score":4,"body_markdown":"*Also...*  Perhaps we should cut your 27-year-old friend a little *slack,* because the entire concept of &quot;closures&quot; really **is(!)** ... *voodoo!* \r\n\r\nBy that I mean: *(a)* you do not, intuitively, expect it ...AND... *(b)* when someone takes the time to explain it to you, you certainly do not expect it to *work!*\r\n\r\nIntuition tells you that &quot;this must be nonsense... *surely* it must result in some kind of syntax-error or something!&quot;  *How on earth(!)* could you, in effect, &quot;pull a function from &#39;the middle of&#39; wherever-it&#39;s-at,&quot; such that you could [still!] actually have read/write access to the context of &quot;wherever-it-*was*-at?!&quot;\r\n\r\nWhen you finally realize that such a thing is *possible,* then ... sure ... anyone&#39;s *after-the-fact* reaction would be: &quot;whoa-a-a-a(!)... kew-el-l-l-l...(!!!)&quot;\r\n\r\nBut there will be a &quot;big counter-intuitive hurdle&quot; to overcome, first.  Intuition gives you plenty of utterly-plausible expectations that such a thing would be &quot;of *course,* absolutely nonsensical and therefore quite impossible.&quot;\r\n\r\nLike I said: &quot;it&#39;s voodoo.&quot;"},{"score":21,"body_markdown":"A closure is ***a function within a function*** that has access to its &quot;parent&quot; function&#39;s variables and parameters.\r\n\r\nExample:\r\n\r\n    function showPostCard(Sender, Receiver) {\r\n        \r\n        var PostCardMessage = &quot; Happy Spring!!! Love, &quot;;\r\n    \r\n        function PreparePostCard() {\r\n            return &quot;Dear &quot; + Receiver + PostCardMessage + Sender;\r\n        }\r\n        \r\n        return PreparePostCard();\r\n    }\r\n    showPostCard(&quot;Granny&quot;, &quot;Olivia&quot;);"},{"score":131,"body_markdown":"&gt; The children will always remember the secrets they have shared with their parents, even after their parents are\r\n&gt; gone. This is what closures are for functions.\r\n\r\nThe secrets for JavaScript functions are the private variables\r\n\r\n    var parent = function() {\r\n     var name = &quot;Mary&quot;; // secret\r\n    }\r\n    \r\nEvery time you call it, local variable &quot;name&quot; is created and given name &quot;Mary&quot;. And every time the function exits the variable is lost and the name is forgotten.\r\n\r\nAs you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called **Chamber of Secrets** or **stack** or **local scope** but it doesn&#39;t really matter. We know they are there, somewhere, hidden in the memory.\r\n\r\nBut, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live.\r\n\r\n    var parent = function() {\r\n      var name = &quot;Mary&quot;;\r\n      var child = function(childName) {\r\n        // I can also see that &quot;name&quot; is &quot;Mary&quot;\r\n      }\r\n    }\r\n\r\nSo, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place.\r\n\r\nBut the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them.\r\n\r\nSo to live, the child has to leave before it&#39;s too late\r\n\r\n    var parent = function() {\r\n      var name = &quot;Mary&quot;;\r\n      var child = function(childName) {\r\n        return &quot;My name is &quot; + childName  +&quot;, child of &quot; + name; \r\n      }\r\n      return child; // child leaves the parent -&gt;\r\n    }\r\n    var child = parent(); // &lt; - and here it is outside \r\n    \r\nAnd now, even though Mary is &quot;no longer running&quot;, the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together.\r\n\r\nSo, if you call the child &quot;Alice&quot;, she will respond\r\n\r\n    child(&quot;Alice&quot;) =&gt; &quot;My name is Alice, child of Mary&quot;\r\n\r\nThat&#39;s all there is to tell."},{"score":17,"body_markdown":"A closure is something many JavaScript developers use all the time, but we take it for granted. How it works is not that complicated. Understanding how to use it purposefully *is* complex.\r\n\r\nAt its simplest definition (as other answers have pointed out), a closure is basically a function defined inside another function. And that inner function has access to variables defined in the scope of the outer function. The most common practice that you&#39;ll see using closures is defining variables and functions in the global scope, and having access to those variables in the function scope of that function.\r\n\r\n    var x = 1;\r\n    function myFN() {\r\n      alert(x); //1, as opposed to undefined.\r\n    }\r\n    // Or\r\n    function a() {\r\n       var x = 1;\r\n       function b() {\r\n           alert(x); //1, as opposed to undefined.\r\n       }\r\n       b();\r\n    }\r\n\r\nSo what?\r\n\r\nA closure isn&#39;t that special to a JavaScript user until you think about what life would be like without them. In other languages, variables used in a function get cleaned up when that function returns. In the above, x would have been a &quot;null pointer&quot;, and you&#39;d need to establish a getter and setter and start passing references. Doesn&#39;t sound like JavaScript right? Thank the mighty closure.\r\n\r\nWhy should I care?\r\n\r\nYou don&#39;t really have to be aware of closures to use them. But as others have also pointed out, they can be **leveraged** to create faux private variables. Until you get to needing private variables, just use them like you always have.\r\n\r\n"},{"score":9,"body_markdown":"I like Kyle Simpson&#39;s definition of a closure:  \r\n\r\n&gt; Closure is when a function is able to remember and access its lexical\r\n&gt; scope even when that function is executing outside its lexical scope.\r\n\r\nLexical scope is when an inner scope can access its outer scope.\r\n\r\nHere is a modified example he provides in his book series &#39;You Don&#39;t Know JS: Scopes &amp; Closures&#39;. \r\n\r\n    function foo() {\r\n      var a = 2;\r\n    \r\n      function bar() {\r\n        console.log( a );\r\n      }\r\n      return bar;\r\n    }\r\n    \r\n    function test() {\r\n      var bz = foo();\r\n      bz();\r\n    }\r\n\r\n    // prints 2. Here function bar referred by var bz is outside \r\n    // its lexical scope but it can still access it\r\n    test(); \r\n\r\n "},{"score":18,"body_markdown":"The following example is a simple illustration of a JavaScript closure.\r\nThis is the closure function, which returns a function, with access to its local variable x,\r\n\r\n    function outer(x){\r\n         return function inner(y){\r\n             return x+y;\r\n         }\r\n    }\r\n\r\nInvoke the function like this:\r\n\r\n    var add10 = outer(10);\r\n    add10(20); // The result will be 30\r\n    add10(40); // The result will be 50\r\n\r\n    var add20 = outer(20);\r\n    add20(20); // The result will be 40\r\n    add20(40); // The result will be 60\r\n"},{"score":80,"body_markdown":"The author of *[Closures][1]* has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures. &lt;br/&gt;\r\nHere is the summary:\r\n\r\nWhat if a variable is accessed, but it isn’t local? Like here:\r\n\r\n[![Enter image description here][2]][2]\r\n\r\nIn this case, the interpreter finds the variable in the\r\nouter [`LexicalEnvironment`][3] object.\r\n\r\nThe process consists of two steps:\r\n\r\n 1. First, when a function f is created, it is not created in an empty\r\n    space. There is a current LexicalEnvironment object. In the case\r\n    above, it’s window (a is undefined at the time of function\r\n    creation).\r\n\r\n[![Enter image description here][4]][4]\r\n\r\nWhen a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment.\r\n\r\n[![Enter image description here][5]][5]\r\n\r\nIf a variable is read, but can not be found anywhere, an error is generated.\r\n\r\n**Nested functions**\r\n\r\nFunctions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain.\r\n\r\n[![Enter image description here][6]][6]\r\n\r\nSo, function g has access to g, a and f.\r\n\r\n**Closures**\r\n\r\nA nested function may continue to live after the outer function has finished:\r\n\r\n[![Enter image description here][7]][7]\r\n\r\nMarking up LexicalEnvironments:\r\n\r\n[![Enter image description here][8]][8]\r\n\r\nAs we see, `this.say` is a property in the user object, so it continues to live after User completed.\r\n\r\nAnd if you remember, when `this.say` is created, it (as every function) gets an internal reference `this.say.[[Scope]]` to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually.\r\n\r\n**The whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so.**\r\n\r\nTo summarize:\r\n\r\n 1. The inner function keeps a reference to the outer\r\n    LexicalEnvironment.\r\n 2. The inner function may access variables from it\r\n    any time even if the outer function is finished.\r\n 3. The browser keeps the LexicalEnvironment and all its properties (variables) in memory until there is an inner function which references it.\r\n\r\nThis is called a closure.\r\n\r\n\r\n\r\n\r\n  [1]: http://javascript.info/tutorial/closures\r\n  [2]: http://i.stack.imgur.com/SLlVB.png\r\n  [3]: http://javascript.info/tutorial/initialization\r\n  [4]: http://i.stack.imgur.com/0KBin.png\r\n  [5]: http://i.stack.imgur.com/U3yt7.png\r\n  [6]: http://i.stack.imgur.com/2hUwr.png\r\n  [7]: http://i.stack.imgur.com/S1mlB.png\r\n  [8]: http://i.stack.imgur.com/BzUNi.png\r\n  [9]: https://stackoverflow.com/questions/2728278/what-is-a-practical-use-for-a-closure-in-javascript"},{"score":21,"body_markdown":"Meet the **illustrated explanation**: *[How do JavaScript closures work behind the scenes][1]*.\r\n\r\nThe article explains how the scope objects (or `LexicalEnvironment`s) are allocated and used in an intuitive way. Like, for this simple script:\r\n\r\n    &quot;use strict&quot;;\r\n\r\n    var foo = 1;\r\n    var bar = 2;\r\n\r\n    function myFunc() {\r\n      //-- Define local-to-function variables\r\n      var a = 1;\r\n      var b = 2;\r\n      var foo = 3;\r\n    }\r\n\r\n    //-- And then, call it:\r\n    myFunc();\r\n\r\nWhen executing the top-level code, we have the following arrangement of scope objects:\r\n\r\n[![Enter image description here][2]][2]\r\n\r\nAnd when `myFunc()` is called, we have the following scope chain:\r\n\r\n[![Enter image description here][3]][3]\r\n\r\nUnderstanding of how scope objects are created, used and deleted is a key to having a big picture and to understand how do closures work under the hood.\r\n\r\nSee the aforementioned article for all the details.\r\n\r\n  [1]: http://dmitryfrank.com/articles/js_closures\r\n  [2]: http://i.stack.imgur.com/bwjyg.png\r\n  [3]: http://i.stack.imgur.com/zRu5Z.png\r\n"},{"score":6,"body_markdown":"The best way is to explain these concepts incrementally:\r\n\r\n**Variables**\r\n\r\n    console.log(x);\r\n    // undefined\r\n\r\nHere, `undefined` is JavaScript&#39;s way of saying &quot;I have no idea what `x` means.&quot;\r\n\r\n&gt; Variables are like tags.\r\n\r\nYou can say, tag `x` points to value `42`:\r\n\r\n    var x = 42;\r\n    console.log(x);\r\n    // 42\r\n\r\nNow JavaScript knows what `x` means.\r\n\r\n&gt; You can also re-assign a variable.\r\n\r\nMake tag `x` point to a different value:\r\n\r\n    x = 43;\r\n    console.log(x);\r\n    // 43\r\n\r\nNow `x` means something else.\r\n\r\n\r\n**Scope**\r\n\r\n&gt; When you make a function, the function has its own &quot;box&quot; for variables.\r\n\r\n    function A() {\r\n      var x = 42;\r\n    }\r\n\r\n    console.log(x);\r\n\r\n    // undefined\r\n\r\nFrom outside the box, you cannot see what&#39;s inside the box.\r\n\r\nBut from inside the box, you can see what&#39;s outside that box:\r\n\r\n    var x = 42;\r\n\r\n    function A() {\r\n      console.log(x);\r\n    }\r\n\r\n    // 42\r\n\r\n&gt; Inside function `A`, you have &quot;scope access&quot; to `x`.\r\n\r\n\r\nNow if you have two boxes side-by-side:\r\n\r\n    function A() {\r\n      var x = 42;\r\n    }\r\n\r\n    function B() {\r\n      console.log(x);\r\n    }\r\n\r\n    // undefined\r\n\r\n&gt; Inside function `B`, you have no access to variables inside function `A`.\r\n\r\nBut if you put define function `B` inside function `A`:\r\n\r\n    function A() {\r\n\r\n      var x = 42;\r\n\r\n      function B() {\r\n        console.log(x);\r\n      }\r\n\r\n    }\r\n\r\n    // 42\r\n\r\nYou now have &quot;scope access&quot;.\r\n\r\n\r\n**Functions**\r\n\r\nIn JavaScript, you run a function by calling it:\r\n\r\n    function A() {\r\n      console.log(42);\r\n    }\r\n\r\nLike this:\r\n\r\n    A();\r\n\r\n    // 42\r\n\r\n\r\n**Functions as Values**\r\n\r\n\r\nIn JavaScript, you can point a tag to a function, just like pointing to a number:\r\n\r\n    var a = function() {\r\n      console.log(42);\r\n    };\r\n\r\n&gt; Variable `a` now means a function, you can run it.\r\n\r\n    a();\r\n    // 42\r\n\r\nYou can also pass this variable around:\r\n\r\n    setTimeout(a, 1000);\r\n\r\nIn a second (1000 milliseconds), the function `a` points to is called:\r\n \r\n    // 42\r\n\r\n\r\n**Closure Scope**\r\n\r\nNow when you define functions, those functions have access to their outer scopes.\r\n\r\nWhen you pass functions around as values, it would be troublesome if that access is lost.\r\n\r\n&gt; In JavaScript, functions keep their access to outer scope variables.\r\n&gt; Even when they are passed around to be run somewhere else.\r\n\r\n    var a = function() {\r\n      \r\n      var text = &#39;Hello!&#39;\r\n\r\n      var b = function() {\r\n        console.log(text);\r\n        // inside function `b`, you have access to `text`\r\n      };\r\n\r\n      // but you want to run `b` later, rather than right away\r\n      setTimeout(b, 1000);\r\n\r\n    }\r\n\r\nWhat happens now?\r\n\r\n    // &#39;Hello!&#39;\r\n\r\nOr consider this:\r\n\r\n    var c;\r\n\r\n    var a = function() {\r\n      \r\n      var text = &#39;Hello!&#39;\r\n\r\n      var b = function() {\r\n        console.log(text);\r\n        // inside function `b`, you have access to `text`\r\n      };\r\n\r\n      c = b;\r\n\r\n    }\r\n\r\n    // now we are out side of function `a`\r\n    // call `a` so the code inside `a` runs\r\n    a(); \r\n\r\n    // now `c` has a value that is a function\r\n    // because what happened when `a` ran\r\n\r\n    // when you run `c`\r\n    c();\r\n\r\n    // &#39;Hello!&#39;\r\n\r\n&gt; You can still access variables in the closure scope.\r\n\r\nEven though `a` has finished running, and now you are running `c` outside of `a`.\r\n\r\nWhat just happened here is called &#39;***closure***&#39; in JavaScript.\r\n\r\n"},{"score":13,"body_markdown":"**Pinocchio: Closures in 1883 (over a century before JavaScript)**\r\n\r\nI think it can best be explained to a 6-year-old with a nice adventure... The part of the [Adventures of Pinocchio][1] where Pinocchio is being swallowed by an oversized dogfish...\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var tellStoryOfPinocchio = function(original) {\r\n    \r\n      // Prepare for exciting things to happen\r\n      var pinocchioFindsMisterGeppetto;\r\n      var happyEnding;\r\n    \r\n      // The story starts where Pinocchio searches for his &#39;father&#39;\r\n      var pinocchio = {\r\n        name: &#39;Pinocchio&#39;,\r\n        location: &#39;in the sea&#39;,\r\n        noseLength: 2\r\n      };\r\n    \r\n      // Is it a dog... is it a fish...\r\n      // The dogfish appears, however there is no such concept as the belly\r\n      // of the monster, there is just a monster...\r\n      var terribleDogfish = {\r\n        swallowWhole: function(snack) {\r\n          // The swallowing of Pinocchio introduces a new environment (for the\r\n          // things happening inside it)...\r\n          // The BELLY closure... with all of its guts and attributes\r\n          var mysteriousLightLocation = &#39;at Gepetto\\&#39;s ship&#39;;\r\n    \r\n          // Yes: in my version of the story the monsters mouth is directly\r\n          // connected to its belly... This might explain the low ratings\r\n          // I had for biology...\r\n          var mouthLocation = &#39;in the monsters mouth and then outside&#39;;\r\n    \r\n          var puppet = snack;\r\n    \r\n    \r\n          puppet.location = &#39;inside the belly&#39;;\r\n          alert(snack.name + &#39; is swallowed by the terrible dogfish...&#39;);\r\n    \r\n          // Being inside the belly, Pinocchio can now experience new adventures inside it\r\n          pinocchioFindsMisterGeppetto = function() {\r\n            // The event of Pinocchio finding Mister Geppetto happens inside the\r\n            // belly and so it makes sence that it refers to the things inside\r\n            // the belly (closure) like the mysterious light and of course the\r\n            // hero Pinocchio himself!\r\n            alert(puppet.name + &#39; sees a mysterious light (also in the belly of the dogfish) in the distance and swims to it to find Mister Geppetto! He survived on ship supplies for two years after being swallowed himself. &#39;);\r\n            puppet.location = mysteriousLightLocation;\r\n    \r\n            alert(puppet.name + &#39; tells Mister Geppetto he missed him every single day! &#39;);\r\n            puppet.noseLength++;\r\n          }\r\n    \r\n          happyEnding = function() {\r\n            // The escape of Pinocchio and Mister Geppetto happens inside the belly:\r\n            // it refers to Pinocchio and the mouth of the beast.\r\n            alert(&#39;After finding Mister Gepetto, &#39; + puppet.name + &#39; and Mister Gepetto travel to the mouth of the monster.&#39;);\r\n            alert(&#39;The monster sleeps with its mouth open above the surface of the water. They escape through its mouth. &#39;);\r\n            puppet.location = mouthLocation;\r\n            if (original) {\r\n              alert(puppet.name + &#39; is eventually hanged for his innumerable faults. &#39;);\r\n            } else {\r\n              alert(puppet.name + &#39; is eventually turned into a real boy and they all lived happily ever after...&#39;);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    \r\n      alert(&#39;Once upon a time...&#39;);\r\n      alert(&#39;Fast forward to the moment that Pinocchio is searching for his \\&#39;father\\&#39;...&#39;);\r\n      alert(&#39;Pinocchio is &#39; + pinocchio.location + &#39;.&#39;);\r\n      terribleDogfish.swallowWhole(pinocchio);\r\n      alert(&#39;Pinocchio is &#39; + pinocchio.location + &#39;.&#39;);\r\n      pinocchioFindsMisterGeppetto();\r\n      alert(&#39;Pinocchio is &#39; + pinocchio.location + &#39;.&#39;);\r\n      happyEnding();\r\n      alert(&#39;Pinocchio is &#39; + pinocchio.location + &#39;.&#39;);\r\n    \r\n      if (pinocchio.noseLength &gt; 2)\r\n        console.log(&#39;Hmmm... apparently a little white lie was told. &#39;);\r\n    }\r\n    \r\n    tellStoryOfPinocchio(false);\r\n\r\n \r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://en.wikipedia.org/wiki/The_Adventures_of_Pinocchio\r\n\r\n\r\n"},{"score":12,"body_markdown":"# Closures are simple\n\nYou probably shouldn&#39;t tell a six-year old about closures, but if you do, you might say that closure gives an ability to gain access to a variable declared in some other function scope.\n\n[![enter image description here][1]][1]\n\n&lt;!-- begin snippet: js hide: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    function getA() {\n      var a = [];\n\n      // this action happens later,\n      // after the function returned\n      // the `a` value\n      setTimeout(function() {\n        a.splice(0, 0, 1, 2, 3, 4, 5);\n      });\n\n      return a;\n    }\n\n    var a = getA();\n    out(&#39;What is `a` length?&#39;);\n    out(&#39;`a` length is &#39; + a.length);\n\n    setTimeout(function() {\n      out(&#39;No wait...&#39;);\n      out(&#39;`a` length is &#39; + a.length);\n      out(&#39;OK :|&#39;)\n    });\n\n&lt;!-- language: lang-html --&gt;\n\n    &lt;pre id=&quot;output&quot;&gt;&lt;/pre&gt;\n\n    &lt;script&gt;\n      function out(k) {\n        document.getElementById(&#39;output&#39;).innerHTML += &#39;&gt; &#39; + k + &#39;\\n&#39;;\n      }\n    &lt;/script&gt;\n\n&lt;!-- end snippet --&gt;\n\n\n  [1]: http://i.stack.imgur.com/OX92v.png"},{"score":2,"body_markdown":"A closure is a function that has access to information from the environment it was defined in.\r\n\r\nFor some, the information is the *value* in the environment at the time of creation.  For others, the information is the variables in the environment at the time of creation.\r\n\r\nIf the lexical environment that the closure refers to belongs to a function that has exited, then (in the case of a closure referring to the variables in the environment) those lexical variables will continue to exist for reference by the closure.\r\n\r\nA closure can be thought of a special case of global variables -- with a private copy created just for the function.\r\n\r\nOr it can be thought of as a method where the environment is a specific instance of an object whose properties are the variables in the environment.\r\n\r\nThe former (closure as environment) similar to the latter where the environment copy is a context variable passed to each function in the former, and the instance variables form a context variable in the latter.\r\n\r\nSo a closure is a way to call a function without having to specify the context explicitly as a parameter or as the object in a method invocation.\r\n\r\n    var closure = createclosure(varForClosure);\r\n    closure(param1);  // closure has access to whatever createclosure gave it access to,\r\n                      // including the parameter storing varForClosure.\r\n\r\nvs\r\n\r\n    var contextvar = varForClosure; // use a struct for storing more than one..\r\n    contextclosure(contextvar, param1);\r\n\r\nvs\r\n\r\n    var contextobj = new contextclass(varForClosure);\r\n    contextobj-&gt;objclosure(param1);\r\n\r\nFor maintainable code, I recommend the object oriented way.  However for a quick and easy set of tasks (for example creating a callback), a closure can become natural and more clear, especially in the context of lamda or anonymous functions.\r\n"},{"score":13,"body_markdown":"&gt; A closure is a function having access to the parent scope, even after the parent function has closed.\r\n\r\n    var add = (function() {\r\n      var counter = 0;\r\n      return function() {\r\n        return counter += 1;\r\n      }\r\n    })();\r\n    \r\n    add();\r\n    add();\r\n    add();\r\n    // The counter is now 3\r\n\r\nExample explained:\r\n\r\n - The variable `add` is assigned the return value of a self-invoking function.\r\n - The self-invoking function only runs once. It sets the counter to zero (0), and returns a function expression.\r\n - This way add becomes a function. The &quot;wonderful&quot; part is that it can access the counter in the parent scope.\r\n - This is called a JavaScript closure. It makes it possible for a function to have &quot;private&quot; variables.\r\n - The counter is protected by the scope of the anonymous function, and can only be changed using the add function.\r\n\r\n[Source][1]\r\n\r\n  [1]: http://www.w3schools.com/js/js_function_closures.asp"},{"score":8,"body_markdown":"For a six-year-old ...\r\n\r\nDo you know what objects are?\r\n\r\nObjects are things that have properties and do stuff.\r\n\r\nOne of the most important things about closures is that they let you make objects in JavaScript. Objects in JavaScript are just functions and closures that lets JavaScript store the value of the property for the object once it has been created.\r\n\r\nObjects are very useful and keep everything nice and organised. Different objects can do different jobs and working together objects can do complicated things.\r\n\r\nIt&#39;s lucky that JavaScript has closures for making objects, otherwise everything would become a messy nightmare.\r\n"},{"score":7,"body_markdown":"There once was a caveman \r\n\r\n    function caveman {\r\n\r\nwho had a very special rock,\r\n\r\n    var rock = &quot;diamond&quot;;\r\n\r\nYou could not get the rock yourself because it was in the caveman&#39;s private cave. Only the caveman knew how to find and get the rock.\r\n\r\n    return {\r\n        getRock: function() {\r\n            return rock;\r\n        }\r\n    };\r\n    }\r\n\r\nLuckily, he was a friendly caveman, and if you were willing to wait for his return, he would gladly get it for you.\r\n\r\n    var friend = caveman();\r\n    var rock = friend.getRock();\r\n\r\nPretty smart caveman."},{"score":3,"body_markdown":"Closure can be private and public variables or functions.\r\n\r\n    var ClusureDemo = function() {\r\n    \t//privare variables\r\n    \tvar localVa1, localVa2;\r\n    \r\n    \t//private functions\r\n    \tvar setVaOne = function(newVa) {\r\n    \t\tlocalVa1 = newVa;\r\n    \t},\r\n    \tsetVaTwo = function(newVa) {\r\n    \t\tlocalVa2 = newVa;\r\n    \t},\r\n    \tgetVaOne = function() {\r\n    \t\treturn localVa1;\r\n    \t},\r\n    \tgetVaTwo = function() {\r\n    \t\treturn localVa2;\r\n    \t};\r\n    \r\n    \treturn {\r\n    \t\t//public variables and functions\r\n    \t\toutVaOne : localVa1,\r\n    \t\toutVaTwo : localVa2,\r\n    \t\tsetVaOne : setVaOne,\r\n    \t\tsetVaTwo : setVaTwo,\r\n    \t\tgetVaOne : getVaOne,\r\n    \t\tgetVaTwo : getVaTwo\r\n    \t};\r\n    };\r\n    \r\n    //Test Demo\r\n    var app = new ClusureDemo();\r\n    app.outVaOne = &#39;Hello Variable One&#39;;\r\n    app.outVaTwo = &#39;Hello Variable Two&#39;;\r\n    app.setVaOne(app.outVaOne);\r\n    app.setVaTwo(app.outVaTwo);\r\n    \r\n    alert(app.getVaOne());\r\n    alert(app.getVaTwo());\r\n\r\n[Demo][1]\r\n\r\n\r\n  [1]: http://jsfiddle.net/paoim/8o2ejzdq/"},{"score":21,"body_markdown":"To understand closures you have to get down to the program and literally execute as if you are the run time. Let&#39;s look at this simple piece of code:\r\n\r\n[![Enter image description here][1]][1]\r\n\r\nJavaScript runs the code in two phases:\r\n\r\n- Compilation Phase    // JavaScript is not a pure interpreted language\r\n- Execution Phase\r\n\r\nWhen JavaScript goes through the compilation phase it extract out the declarations of variables and functions. This is called hoisting. Functions encountered in this phase are saved as text blobs in memory also known as lambda. After compilation JavaScript enters the execution phase where it assigns all the values and runs the function. To run the function it prepares the execution context by assigning memory from the heap and repeating the compilation and execution phase for the function. This memory area is called scope of the function. There is a global scope when execution starts. Scopes are the key in understanding closures.\r\n\r\nIn this example, in first go, variable `a` is defined and then `f` is defined in the compilation phase. All undeclared variables are saved in the global scope. In the execution phase `f` is called with an argument. `f`&#39;s scope is assigned and the compilation and execution phase is repeated for it.\r\n\r\nArguments are also saved in this local scope for `f`. Whenever a local execution context or scope is created it contain a reference pointer to its parent scope. All variable access follows this lexical scope chain to find its value. If a variable is not found in the local scope it follows the chain and find it in its parent scope. This is also why a local variable overrides variables in the parent scope. The parent scope is called the &quot;Closure&quot; for local a scope or function.\r\n\r\nHere when `g`&#39;s scope is being set up it got a lexical pointer to its parents scope of `f`. The scope of `f` is the closure for `g`. In JavaScript, if there is some reference to functions, objects or scopes if you can reach them somehow, it will not get garbage collected. So when myG is running, it has a pointer to scope of `f` which is its closure. This area of memory will not get garbage collected even `f` has returned. This is a closure as far as the runtime is concerned.\r\n\r\nSO WHAT IS A CLOSURE?\r\n---------\r\n- It is an implicit, permanent link between a function and its scope chain...\r\n- A function definition&#39;s (lambda) hidden `[[scope]]` reference.\r\n- Holds the scope chain (preventing garbage collection).\r\n- It is used and copied as the &quot;outer environment reference&quot; anytime the function is run.\r\n\r\nIMPLICIT CLOSURE\r\n-----------\r\n\r\n    var data = &quot;My Data!&quot;;\r\n    setTimeout(function() {\r\n      console.log(data); // Prints &quot;My Data!&quot;\r\n    }, 3000);\r\n\r\nEXPLICIT CLOSURES\r\n-------------\r\n\r\n    function makeAdder(n) {\r\n      var inc = n;\r\n      var sum = 0;\r\n      return function add() {\r\n        sum = sum + inc;\r\n        return sum;\r\n      };\r\n    }\r\n\r\n    var adder3 = makeAdder(3);\r\n\r\nA very interesting talk on closures and more is *[Arindam Paul - JavaScript VM internals, EventLoop, Async and ScopeChains][2]*.\r\n\r\n  [1]: http://i.stack.imgur.com/kWR82.png\r\n  [2]: https://www.youtube.com/watch?v=QyUFheng6J0\r\n"},{"score":8,"body_markdown":"This is how a beginner wrapped one&#39;s head around Closures like a function is wrapped inside of a functions body also known as **Closures**.\r\n\r\nDefinition from the book Speaking JavaScript &quot;A closure is a function plus the connection to the scope in which the function was created&quot; -*Dr.Axel Rauschmayer*\r\n\r\nSo what could that look like? Here is an example\r\n\r\n    function newCounter() {\r\n      var counter = 0;\r\n       return function increment() {\r\n        counter += 1;\r\n       }\r\n    }\r\n\r\n    var counter1 = newCounter();\r\n    var counter2 = newCounter();\r\n\r\n    counter1(); // Number of events: 1\r\n    counter1(); // Number of events: 2\r\n    counter2(); // Number of events: 1\r\n    counter1(); // Number of events: 3\r\n\r\n*newCounter* closes over *increment*, *counter* can be referenced to and accessed by *increment*.\r\n\r\n*counter1* and *counter2* will keep track of their own value.\r\n\r\nSimple but hopefully a clear perspective of what a closure is around all these great and advanced answers."},{"score":10,"body_markdown":"## Functions containing no free variables are called pure functions.\n## Functions containing one or more free variables are called closures.\n\n\n    var pure = function pure(x){\n      return x \n      // only own environment is used\n    }\n\n    var foo = &quot;bar&quot;\n\n    var closure = function closure(){\n      return foo\n      // foo is free variable from the outer environment\n    }\n\n&lt;sup&gt;src: https://leanpub.com/javascriptallongesix/read#leanpub-auto-if-functions-without-free-variables-are-pure-are-closures-impure&lt;/sup&gt;"},{"score":9,"body_markdown":"MDN explains it best I think:\r\n\r\n&gt;Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure &#39;remembers&#39; the environment in which it was created.\r\n\r\nA closure always has an outer function and an inner function. The inner function is where all the work happens, and the outer function is just the environment that preserves the scope where the inner function was created. In this way, the inner function of a closure &#39;remembers&#39; the environment/scope in which it was created. The most classic example is a counter function:\r\n\r\n    var closure = function() {\r\n\t  var count = 0;\r\n\t  return function() {\r\n\t\tcount++;\r\n\t\tconsole.log(count);\r\n\t  };\r\n    };\r\n\r\n    var counter = closure();\r\n\r\n    counter() // returns 1\r\n    counter() // returns 2\r\n    counter() // returns 3\r\n\r\nIn the above code, `count` is preserved by the outer function (environment function), so that every time you call `counter()`, the inner function (work function) can increment it."},{"score":26,"body_markdown":"Closures allow JavaScript programmers to write better code. Creative, expressive, and concise. We frequently use closures in JavaScript, and, no matter our JavaScript experience, we undoubtedly encounter them time and again. Closures might appear complex but hopefully, after you read this, closures will be much more easily understood and thus more appealing for your everyday JavaScript programming tasks.\r\n\r\nYou should be familiar with [***JavaScript variable scope***][1] before you read further because to understand closures you must understand JavaScript’s variable scope.\r\n\r\nWhat is a closure?\r\n------------------\r\nA closure is an inner function that has access to the outer (enclosing) function’s variables—scope chain. The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function’s variables, and it has access to the global variables.\r\n\r\nThe inner function has access not only to the outer function’s variables, but also to the outer function’s parameters. Note that the inner function cannot call the outer function’s arguments object, however, even though it can call the outer function’s parameters directly.\r\n\r\nYou create a closure by adding a function inside another function.\r\n\r\n**A Basic Example of Closures in JavaScript:** \r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function showName (firstName, lastName) { \r\n      var nameIntro = &quot;Your name is &quot;;\r\n      // this inner function has access to the outer function&#39;s variables, including the parameter\r\n      ​function makeFullName () {             \r\n    ​    return nameIntro + firstName + &quot; &quot; + lastName;         \r\n      }\r\n    ​\r\n    ​  return makeFullName (); \r\n    } \r\n    ​\r\n    showName (&quot;Michael&quot;, &quot;Jackson&quot;); // Your name is Michael Jackson \r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nClosures are used extensively in Node.js; they are workhorses in Node.js’ asynchronous, non-blocking architecture. Closures are also frequently used in jQuery and just about every piece of JavaScript code you read.\r\n\r\n**A Classic jQuery Example of Closures:** \r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $(function() {\r\n    ​\r\n    ​  var selections = []; \r\n      $(&quot;.niners&quot;).click(function() { // this closure has access to the selections variable​\r\n        selections.push (this.prop(&quot;name&quot;)); // update the selections variable in the outer function&#39;s scope​\r\n      });\r\n    ​});\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\nClosures’ Rules and Side Effects\r\n--------------------------------\r\n\r\n**1. Closures have access to the outer function’s variable even after the outer function returns:**\r\n\r\nOne of the most important and ticklish features with closures is that the inner function still has access to the outer function’s variables even after the outer function has returned. Yep, you read that correctly. When functions in JavaScript execute, they use the same scope chain that was in effect when they were created. This means that even after the outer function has returned, the inner function still has access to the outer function’s variables. Therefore, you can call the inner function later in your program. This example demonstrates:\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function celebrityName (firstName) {\r\n        var nameIntro = &quot;This celebrity is &quot;;\r\n        // this inner function has access to the outer function&#39;s variables, including the parameter​\r\n       function lastName (theLastName) {\r\n            return nameIntro + firstName + &quot; &quot; + theLastName;\r\n        }\r\n        return lastName;\r\n    }\r\n    ​\r\n    ​var mjName = celebrityName (&quot;Michael&quot;); // At this juncture, the celebrityName outer function has returned.​\r\n    ​\r\n    ​// The closure (lastName) is called here after the outer function has returned above​\r\n    ​// Yet, the closure still has access to the outer function&#39;s variables and parameter​\r\n    mjName (&quot;Jackson&quot;); // This celebrity is Michael Jackson \r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n**2. Closures store references to the outer function’s variables:**\r\n\r\nThey do not store the actual value.  Closures get more interesting when the value of the outer function’s variable changes before the closure is called. And this powerful feature can be harnessed in creative ways, such as this private variables example first demonstrated by Douglas Crockford: \r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function celebrityID () {\r\n        var celebrityID = 999;\r\n        // We are returning an object with some inner functions​\r\n        // All the inner functions have access to the outer function&#39;s variables​\r\n        return {\r\n            getID: function ()  {\r\n                // This inner function will return the UPDATED celebrityID variable​\r\n                // It will return the current value of celebrityID, even after the changeTheID function changes it​\r\n              return celebrityID;\r\n            },\r\n            setID: function (theNewID)  {\r\n                // This inner function will change the outer function&#39;s variable anytime​\r\n                celebrityID = theNewID;\r\n            }\r\n        }\r\n    ​\r\n    }\r\n    ​\r\n    ​var mjID = celebrityID (); // At this juncture, the celebrityID outer function has returned.​\r\n    mjID.getID(); // 999​\r\n    mjID.setID(567); // Changes the outer function&#39;s variable​\r\n    mjID.getID(); // 567: It returns the updated celebrityId variable \r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n\r\n**3. Closures Gone Awry**\r\n\r\nBecause closures have access to the updated values of the outer function’s variables, they can also lead to bugs when the outer function’s variable changes with a for loop. Thus:\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // This example is explained in detail below (just after this code box).​\r\n    ​function celebrityIDCreator (theCelebrities) {\r\n        var i;\r\n        var uniqueID = 100;\r\n        for (i = 0; i &lt; theCelebrities.length; i++) {\r\n          theCelebrities[i][&quot;id&quot;] = function ()  {\r\n            return uniqueID + i;\r\n          }\r\n        }\r\n        \r\n        return theCelebrities;\r\n    }\r\n    ​\r\n    ​var actionCelebs = [{name:&quot;Stallone&quot;, id:0}, {name:&quot;Cruise&quot;, id:0}, {name:&quot;Willis&quot;, id:0}];\r\n    ​\r\n    ​var createIdForActionCelebs = celebrityIDCreator (actionCelebs);\r\n    ​\r\n    ​var stalloneID = createIdForActionCelebs [0];      console.log(stalloneID.id()); // 103\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n--------------------------------------------------\r\n\r\n--------------------------------------------------\r\n\r\n\r\nMore can be found here-\r\n-----------------------\r\n\r\n 1. http://javascript.info/tutorial/closures\r\n\r\n 2. http://www.javascriptkit.com/javatutors/closures.shtml\r\n\r\n  [1]: http://javascriptissexy.com/javascript-variable-scope-and-hoisting-explained/"},{"score":20,"body_markdown":"Version picture for this answer: **[Resolved]**\r\n\r\nJust forget about scope every thing and remember: When a variable needed somewhere, javascript will not destroy it. The variable always point to newest value.\r\n\r\n\r\n**Example 1:**\r\n\r\n[![enter image description here][1]][1]\r\n\r\n**Example 2:**\r\n\r\n[![enter image description here][2]][2]\r\n\r\n**Example 3:**\r\n[![enter image description here][3]][3]\r\n\r\n\r\n  [1]: http://i.stack.imgur.com/ckxN9.png\r\n  [2]: http://i.stack.imgur.com/dAmCA.png\r\n  [3]: http://i.stack.imgur.com/HRXgp.png"},{"score":8,"body_markdown":"Closure are not difficult to understand. It depends only from the point of view.\r\n\r\nI personally like to use them in cases of daily life.\r\n\r\n    function createCar()\r\n    {\r\n        var rawMaterial = [/* lots of object */];\r\n        function transformation(rawMaterials)\r\n        {\r\n           /* lots of changement here */\r\n           return transformedMaterial;\r\n        }\r\n        var transformedMaterial = transformation(rawMaterial);\r\n        function assemblage(transformedMaterial)\r\n        {\r\n            /*Assemblage of parts*/\r\n            return car;\r\n        }\r\n        return assemblage(transformedMaterial);\r\n    }\r\n    \r\nWe only need to go through certain steps in particular cases. As for the transformation of materials is only useful when you have the parts."},{"score":12,"body_markdown":"**Closures** are a somewhat advanced, and often misunderstood feature of the JavaScript language. Simply put, closures are objects that contain a function and a reference to the environment in which the function was created. However, in order to fully understand closures, there are two other features of the JavaScript language that must first be understood―first-class functions and inner functions.\r\n\r\n**First-Class Functions**\r\n\r\nIn programming languages, functions are considered to be first-class citizens if they can be manipulated like any other data type. For example, first-class functions can be constructed at runtime and assigned to variables.  They can also be passed to, and returned by other functions. In addition to meeting the previously mentioned criteria, JavaScript functions also have their own properties and methods. The following example shows some of the capabilities of first-class functions. In the example, two functions are created and assigned to the variables “foo” and “bar”. The function stored in “foo” displays a dialog box, while “bar” simply returns whatever argument is passed to it. The last line of the example does several things. First, the function stored in “bar” is called with “foo” as its argument. “bar” then returns the “foo” function reference. Finally, the returned “foo” reference is called, causing “Hello World!” to be displayed.\r\n\r\n    var foo = function() {\r\n      alert(&quot;Hello World!&quot;);\r\n    };\r\n    \r\n    var bar = function(arg) {\r\n      return arg;\r\n    };\r\n    \r\n    bar(foo)();\r\n\r\n**Inner Functions**\r\n\r\nInner functions, also referred to as nested functions, are functions that are defined inside of another function (referred to as the outer function). Each time the outer function is called, an instance of the inner function is created. The following example shows how inner functions are used. In this case, add() is the outer function. Inside of add(), the doAdd() inner function is defined and called.\r\n\r\n    function add(value1, value2) {\r\n      function doAdd(operand1, operand2) {\r\n        return operand1 + operand2;\r\n      }\r\n    \r\n      return doAdd(value1, value2);\r\n    }\r\n    \r\n    var foo = add(1, 2);\r\n    // foo equals 3\r\n\r\nOne important characteristic of inner functions is that they have implicit access to the outer function’s scope. This means that the inner function can use the variables, arguments, etc. of the outer function. In the previous example, the “*value1*” and “*value2*” arguments of add() were passed to *doAdd()* as the “*operand1*” and “operand2” arguments. However, this is unnecessary because *doAdd()* has direct access to “*value1*” and “*value2*”. The previous example has been rewritten below to show how *doAdd()* can use “*value1*” and “*value2*”.\r\n\r\n    function add(value1, value2) {\r\n      function doAdd() {\r\n        return value1 + value2;\r\n      }\r\n    \r\n      return doAdd();\r\n    }\r\n    \r\n    var foo = add(1, 2);\r\n    // foo equals 3\r\n\r\n&gt; **Creating Closures**\r\n&gt; \r\n&gt; A closure is created when an inner function is made accessible from\r\n&gt; outside of the function that created it. This typically occurs when an\r\n&gt; outer function returns an inner function.  When this happens, the\r\n&gt; inner function maintains a reference to the environment in which it\r\n&gt; was created.  This means that it remembers all of the variables (and\r\n&gt; their values) that were in scope at the time. The following example\r\n&gt; shows how a closure is created and used.\r\n\r\n    function add(value1) {\r\n      return function doAdd(value2) {\r\n        return value1 + value2;\r\n      };\r\n    }\r\n    \r\n    var increment = add(1);\r\n    var foo = increment(2);\r\n    // foo equals 3\r\n\r\nThere are a number of things to note about this example.\r\n\r\nThe add() function returns its inner function doAdd(). By returning a reference to an inner function, a closure is created.\r\n“value1” is a local variable of add(), and a non-local variable of doAdd(). Non-local variables refer to variables that are neither in the local nor the global scope.  “value2” is a local variable of doAdd().\r\nWhen add(1) is called, a closure is created and stored in “increment”. In the closure’s referencing environment, “value1” is bound to the value one.  Variables that are bound are also said to be closed over. This is where the name closure comes from.\r\nWhen increment(2) is called, the closure is entered. This means that doAdd() is called, with the “value1” variable holding the value one. The closure can essentially be thought of as creating the following function.\r\n\r\n    function increment(value2) {\r\n      return 1 + value2;\r\n    }\r\n\r\n&gt; **When to Use Closures**\r\n&gt; \r\n&gt; Closures can be used to accomplish many things. They are very useful\r\n&gt; for things like configuring callback functions with parameters. This\r\n&gt; section covers two scenarios where closures can make your life as a\r\n&gt; developer much simpler.\r\n\r\n**Working With Timers**\r\n\r\nClosures are useful when used in conjunction with the *setTimeout()* and *setInterval()* functions. To be more specific, closures allow you to pass arguments to the callback functions of *setTimeout()* and *setInterval()*. For example, the following code prints the string “some message” once per second by calling *showMessage()*.\r\n\r\n    &lt;!DOCTYPE html&gt;\r\n    &lt;html lang=&quot;en&quot;&gt;\r\n    &lt;head&gt;\r\n      &lt;title&gt;Closures&lt;/title&gt;\r\n      &lt;meta charset=&quot;UTF-8&quot; /&gt;\r\n      &lt;script&gt;\r\n        window.addEventListener(&quot;load&quot;, function() {\r\n          window.setInterval(showMessage, 1000, &quot;some message&lt;br /&gt;&quot;);\r\n        });\r\n    \r\n        function showMessage(message) {\r\n          document.getElementById(&quot;message&quot;).innerHTML += message;\r\n        }\r\n      &lt;/script&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n      &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;\r\n\r\nUnfortunately, Internet Explorer does not support passing callback arguments via setInterval(). Instead of displaying “some message”, Internet Explorer displays “undefined” (since no value is actually passed to showMessage()). To work around this issue, a closure can be created which binds the “message” argument to the desired value. The closure can then be used as the callback function for setInterval(). To illustrate this concept, the JavaScript code from the previous example has been rewritten below to use a closure.\r\n\r\n    window.addEventListener(&quot;load&quot;, function() {\r\n      var showMessage = getClosure(&quot;some message&lt;br /&gt;&quot;);\r\n    \r\n      window.setInterval(showMessage, 1000);\r\n    });\r\n    \r\n    function getClosure(message) {\r\n      function showMessage() {\r\n        document.getElementById(&quot;message&quot;).innerHTML += message;\r\n      }\r\n    \r\n      return showMessage;\r\n    }\r\n\r\n**Emulating Private Data**\r\n\r\nMany object-oriented languages support the concept of private member data. However, JavaScript is not a pure object-oriented language and does not support private data. But, it is possible to emulate private data using closures. Recall that a closure contains a reference to the environment in which it was originally created―which is now out of scope. Since the variables in the referencing environment are only accessible from the closure function, they are essentially private data.\r\n\r\nThe following example shows a constructor for a simple Person class. When each Person is created, it is given a name via the “*name*” argument.  Internally, the Person stores its name in the “*_name*” variable. Following good object-oriented programming practices, the method *getName()* is also provided for retrieving the name.\r\n\r\n    function Person(name) {\r\n      this._name = name;\r\n    \r\n      this.getName = function() {\r\n        return this._name;\r\n      };\r\n    }\r\n\r\nThere is still one major problem with the Person class. Because JavaScript does not support private data, there is nothing stopping somebody else from coming along and changing the name. For example, the following code creates a Person named Colin, and then changes its name to Tom.\r\n\r\n    var person = new Person(&quot;Colin&quot;);\r\n    \r\n    person._name = &quot;Tom&quot;;\r\n    // person.getName() now returns &quot;Tom&quot;\r\n\r\nPersonally, I wouldn’t like it if just anyone could come along and legally change my name. In order to stop this from happening, a closure can be used to make the “_name” variable private. The Person constructor has been rewritten below using a closure. Note that “_name” is now a local variable of the Person constructor instead of an object property. A closure is formed because the outer function, *Person()* exposes an inner function by creating the public *getName()* method.\r\n\r\n    function Person(name) {\r\n      var _name = name;\r\n    \r\n      this.getName = function() {\r\n        return _name;\r\n      };\r\n    }\r\n\r\nNow, when getName() is called, it is guaranteed to return the value that was originally passed to the constructor. It is still possible for someone to add a new “_name” property to the object, but the internal workings of the object will not be affected as long as they refer to the variable bound by the closure.  The following code shows that the “_name” variable is, indeed, private.\r\n\r\n    var person = new Person(&quot;Colin&quot;);\r\n    \r\n    person._name = &quot;Tom&quot;;\r\n    // person._name is &quot;Tom&quot; but person.getName() returns &quot;Colin&quot;\r\n\r\n&gt; **When Not to Use Closures**\r\n&gt; \r\n&gt; It is important to understand how closures work and when to use them.\r\n&gt; It is equally important to understand when they are not the right tool\r\n&gt; for the job at hand. Overusing closures can cause scripts to execute\r\n&gt; slowly and consume unnecessary memory. And because closures are so\r\n&gt; simple to create, it is possible to misuse them without even knowing\r\n&gt; it.  This section covers several scenarios where closures should be\r\n&gt; used with caution.\r\n\r\n**In Loops**\r\n\r\nCreating closures within loops can have misleading results. An example of this is shown below. In this example, three buttons are created. When “button1” is clicked, an alert should be displayed that says “Clicked button 1”.  Similar messages should be shown for “button2” and “button3”.  However, when this code is run, all of the buttons show “Clicked button 4”. This is because, by the time one of the buttons is clicked, the loop has finished executing, and the loop variable has reached its final value of four.\r\n\r\n    &lt;!DOCTYPE html&gt;\r\n    &lt;html lang=&quot;en&quot;&gt;\r\n    &lt;head&gt;\r\n      &lt;title&gt;Closures&lt;/title&gt;\r\n      &lt;meta charset=&quot;UTF-8&quot; /&gt;\r\n      &lt;script&gt;\r\n        window.addEventListener(&quot;load&quot;, function() {\r\n          for (var i = 1; i &lt; 4; i++) {\r\n            var button = document.getElementById(&quot;button&quot; + i);\r\n    \r\n            button.addEventListener(&quot;click&quot;, function() {\r\n              alert(&quot;Clicked button &quot; + i);\r\n            });\r\n          }\r\n        });\r\n      &lt;/script&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n      &lt;input type=&quot;button&quot; id=&quot;button1&quot; value=&quot;One&quot; /&gt;\r\n      &lt;input type=&quot;button&quot; id=&quot;button2&quot; value=&quot;Two&quot; /&gt;\r\n      &lt;input type=&quot;button&quot; id=&quot;button3&quot; value=&quot;Three&quot; /&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;\r\n\r\nTo solve this problem, the closure must be decoupled from the actual loop variable. This can be done by calling a new function, which in turn creates a new referencing environment. The following example shows how this is done. The loop variable is passed to the getHandler() function. getHandler() then returns a closure that is independent of the original “for” loop.\r\n\r\n\r\n    function getHandler(i) {\r\n      return function handler() {\r\n        alert(&quot;Clicked button &quot; + i);\r\n      };\r\n    }\r\n    window.addEventListener(&quot;load&quot;, function() {\r\n      for (var i = 1; i &lt; 4; i++) {\r\n        var button = document.getElementById(&quot;button&quot; + i);\r\n        button.addEventListener(&quot;click&quot;, getHandler(i));\r\n      }\r\n    });\r\n\r\n&gt; **Unnecessary Use in Constructors**\r\n\r\n&gt; Constructor functions are another common source of closure misuse.\r\n&gt; We’ve seen how closures can be used to emulate private data. However,\r\n&gt; it is overkill to implement methods as closures if they don’t actually\r\n&gt; access the private data. The following example revisits the Person\r\n&gt; class, but this time adds a sayHello() method which doesn’t use the\r\n&gt; private data.\r\n\r\n    function Person(name) {\r\n      var _name = name;\r\n    \r\n      this.getName = function() {\r\n        return _name;\r\n      };\r\n    \r\n      this.sayHello = function() {\r\n        alert(&quot;Hello!&quot;);\r\n      };\r\n    }\r\n\r\n&gt; Each time a Person is instantiated, time is spent creating the\r\n&gt; sayHello() method. If many Person objects are created, this becomes a\r\n&gt; waste of time.  A better approach would be to add sayHello() to the\r\n&gt; Person prototype. By adding to the prototype, all Person objects can\r\n&gt; share the same method.  This saves time in the constructor by not\r\n&gt; having to create a closure for each instance. The previous example is\r\n&gt; rewritten below with the extraneous closure moved into the prototype.\r\n\r\n    function Person(name) {\r\n      var _name = name;\r\n    \r\n      this.getName = function() {\r\n        return _name;\r\n      };\r\n    }\r\n    \r\n    Person.prototype.sayHello = function() {\r\n      alert(&quot;Hello!&quot;);\r\n    };\r\n\r\n**Things to Remember**\r\n\r\n - Closures contain a function and a reference to the environment in\r\n   which the function was created.\r\n - A closure is formed when an outer function exposes an inner function.\r\n   Closures can be used to easily pass parameters to callback functions.\r\n - Private data can be emulated by using closures.  This is common in\r\n   object-oriented programming and namespace design.\r\n - Closures should be not overused in constructors.  Adding to the\r\n   prototype is a better idea.\r\n\r\n[Link][1]\r\n\r\n\r\n  [1]: https://www.sitepoint.com/javascript-closures-demystified/"},{"score":7,"body_markdown":"My perspective of Closures:\r\n\r\n***Closures can be compared to a book, with a bookmark, on a bookshelf.***\r\n\r\nSuppose you have read a book, and you like some page in the book.  You put in a bookmark at that page to track it.\r\n\r\nNow once you finish reading the book, you do not need the book anymore, except, you want to have access to that page.  You could have just cut out the page, but then you would loose the context on the story.  So you put the book back in your bookshelf with the bookmark.\r\n\r\nThis is similar to a closure.  The book is the outer function, and the page is your inner function, which gets returned, from the outer function.  The bookmark is the reference to your page, and the context of the story is the lexical scope, which you need to retain.  The bookshelf is the function stack, which cannot be cleaned up of the old books, till you hold onto the page.\r\n\r\n***Code Example:***\r\n\r\n    function book() {\r\n       var pages = [....]; //array of pages in your book\r\n       var bookMarkedPage = 20; //bookmarked page number\r\n       function getPage(){\r\n           return pages[bookMarkedPage];\r\n       }\r\n       return getPage;\r\n    }\r\n\r\n    var myBook = book(),\r\n        myPage = myBook.getPage();\r\n\r\nWhen you run the `book()` function, you are allocating memory in the stack for the function to run in.  But since it returns a function, the memory cannot be released, as the inner function has access to the variables from the context outside it, in this case &#39;pages&#39; and &#39;bookMarkedPage&#39;.\r\n\r\nSo effectively calling `book()` returns a reference to a closure, i.e not only a function, but a reference to the book and it&#39;s context, i.e. a reference to the function *getPage*, state of *pages* and *bookMarkedPage* variables.\r\n\r\n***Some points to consider:***\r\n\r\n**Point 1:**\r\nThe bookshelf, just like the function stack has limited space, so use it wisely.\r\n\r\n**Point 2:**\r\nThink about the fact, whether you need to hold onto the entire book when you just want to track a single page.  You can release part of the memory, by not storing all the pages in the book when the closure is returned.\r\n\r\n*This is my perspective of Closures.  Hope it helps, and if anyone thinks that this is not correct, please do let me know, as I am very interested to understand even more about scopes and closures!*  "},{"score":3,"body_markdown":"A closure is simply when a function have access to its outside scope even after the scope&#39;s function has finished executing. \nExample: \n\n    function multiplier(n) {\n        function multiply(x) {\n              return n*x;\n        }\n        return mutliply;\n    }\n\n    var 10xmultiplier = multiplier(10);\n    var x = 10xmultiplier(5); // x= 50\n\nwe can see that even after multiplier has finished executing, the inner function multiply gets still access to the value of x which is 10 in this example.\n\nA very common use of closures is currying (the same example above) where we spice our function progressively with parameters instead of supplying all of the arguments at once.\n\nWe can achieve this because Javascript (in addition to the prototypal OOP) allows as to program in a functional fashion where higher order functions can take other functions as arguments (fisrt class functions).\n[functional programming in wikipedia][1]\n\nI highly recommend you to read this book by Kyle Simpson: [2] one part of the book series is dedicated to closures and it is called scope and closures.\n[you don&#39;t know js: free reading on github][2]\n\n\n  [1]: https://www.google.ae/url?sa=t&amp;source=web&amp;rct=j&amp;url=https://en.m.wikipedia.org/wiki/Functional_programming&amp;ved=0ahUKEwjaqeyM5enSAhUF7BQKHYyCBCUQFggZMAA&amp;usg=AFQjCNHcEMds9EmEfJfjtHIvLZhAivGFFQ&amp;sig2=rXB-1kc0AEVYLNy4fhGSmw\n  [2]: https://github.com/getify/You-Dont-Know-JS"},{"score":7,"body_markdown":"Let&#39;s start from here, As defined on MDN: [**Closures**][1] are functions that refer to independent (free) variables (variables that are used locally, but defined in an enclosing scope). In other words, these functions &#39;remember&#39; the environment in which they were created.\r\n\r\n**Lexical scoping**&lt;br&gt;\r\nConsider the following:\r\n\r\n    function init() {\r\n      var name = &#39;Mozilla&#39;; // name is a local variable created by init\r\n      function displayName() { // displayName() is the inner function, a closure\r\n        alert(name); // use variable declared in the parent function    \r\n      }\r\n      displayName();    \r\n    }\r\n    init();\r\n\r\ninit() creates a local variable called name and a function called displayName(). The displayName() function is an inner function that is defined inside init() and is only available within the body of the  init() function. The displayName() function has no local variables of its own. However, because inner functions have access to the variables of outer functions, displayName() can access the variable name declared in the parent function, init().\r\n\r\n    function init() {\r\n        var name = &quot;Mozilla&quot;; // name is a local variable created by init\r\n        function displayName() { // displayName() is the inner function, a closure\r\n            alert (name); // displayName() uses variable declared in the parent function    \r\n        }\r\n        displayName();    \r\n    }\r\n    init();\r\n\r\nRun the code and notice that the alert() statement within the displayName() function successfully displays the value of the name variable, which is declared in its parent function. This is an example of lexical scoping, which describes how a parser resolves variable names when functions are nested. The word &quot;lexical&quot; refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Nested functions have access to variables declared in their outer scope.\r\n\r\n**Closure**&lt;br&gt;\r\nNow consider the following example:\r\n\r\n    function makeFunc() {\r\n      var name = &#39;Mozilla&#39;;\r\n      function displayName() {\r\n        alert(name);\r\n      }\r\n      return displayName;\r\n    }\r\n    \r\n    var myFunc = makeFunc();\r\n    myFunc();\r\n\r\nRunning this code has exactly the same effect as the previous example of the init() function above: this time, the string &quot;Mozilla&quot; will be displayed in a JavaScript alert box. What&#39;s different — and interesting — is that the displayName() inner function is returned from the outer function before being executed.\r\n\r\nAt first glance, it may seem unintuitive that this code still works. In some programming languages, the local variables within a function exist only for the duration of that function&#39;s execution. Once makeFunc() has finished executing, you might expect that the name variable would no longer be accessible. However, because the code still works as expected, this is obviously not the case in JavaScript.\r\n\r\nThe reason is that functions in JavaScript form closures. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time that the closure was created. In this case, myFunc is a reference to the instance of the function displayName created when makeFunc is run. The instance of displayName maintains a reference to its lexical environment, within which the variable name exists. For this reason, when myFunc is invoked, the variable name remains available for use and &quot;Mozilla&quot; is passed to alert.\r\n\r\nHere&#39;s a slightly more interesting example — a makeAdder function:\r\n\r\n    function makeAdder(x) {\r\n      return function(y) {\r\n        return x + y;\r\n      };\r\n    }\r\n    \r\n    var add5 = makeAdder(5);\r\n    var add10 = makeAdder(10);\r\n    \r\n    console.log(add5(2));  // 7\r\n    console.log(add10(2)); // 12\r\n\r\nIn this example, we have defined a function makeAdder(x), which takes a single argument, x, and returns a new function. The function it returns takes a single argument, y, and returns the sum of x and y.\r\n\r\nIn essence, makeAdder is a function factory — it creates functions which can add a specific value to their argument. In the above example we use our function factory to create two new functions — one that adds 5 to its argument, and one that adds 10.\r\n\r\nadd5 and add10 are both closures. They share the same function body definition, but store different lexical environments. In add5&#39;s lexical environment, x is 5, while in the lexical environment for add10, x is 10.\r\n\r\n**Practical closures**\r\n\r\nClosures are useful because they let you associate some data (the lexical environment) with a function that operates on that data. This has obvious parallels to object oriented programming, where objects allow us to associate some data (the object&#39;s properties) with one or more methods.\r\n\r\nConsequently, you can use a closure anywhere that you might normally use an object with only a single method.\r\n\r\nSituations where you might want to do this are particularly common on the web. Much of the code we write in front-end JavaScript is event-based — we define some behavior, then attach it to an event that is triggered by the user (such as a click or a keypress). Our code is generally attached as a callback: a single function which is executed in response to the event.\r\n\r\nFor instance, suppose we wish to add some buttons to a page that adjust the text size. One way of doing this is to specify the font-size of the body element in pixels, then set the size of the other elements on the page (such as headers) using the relative em unit:\r\n\r\n    body {\r\n      font-family: Helvetica, Arial, sans-serif;\r\n      font-size: 12px;\r\n    }\r\n    \r\n    h1 {\r\n      font-size: 1.5em;\r\n    }\r\n    \r\n    h2 {\r\n      font-size: 1.2em;\r\n    }\r\n\r\nOur interactive text size buttons can change the font-size property of the body element, and the adjustments will be picked up by other elements on the page thanks to the relative units.\r\nHere&#39;s the JavaScript:\r\n\r\n    function makeSizer(size) {\r\n      return function() {\r\n        document.body.style.fontSize = size + &#39;px&#39;;\r\n      };\r\n    }\r\n    \r\n    var size12 = makeSizer(12);\r\n    var size14 = makeSizer(14);\r\n    var size16 = makeSizer(16);\r\n\r\nsize12, size14, and size16 are now functions which will resize the body text to 12, 14, and 16 pixels, respectively. We can attach them to buttons (in this case links) as follows:\r\n\r\n    document.getElementById(&#39;size-12&#39;).onclick = size12;\r\n    document.getElementById(&#39;size-14&#39;).onclick = size14;\r\n    document.getElementById(&#39;size-16&#39;).onclick = size16;\r\n\r\n    &lt;a href=&quot;#&quot; id=&quot;size-12&quot;&gt;12&lt;/a&gt;\r\n    &lt;a href=&quot;#&quot; id=&quot;size-14&quot;&gt;14&lt;/a&gt;\r\n    &lt;a href=&quot;#&quot; id=&quot;size-16&quot;&gt;16&lt;/a&gt;\r\n\r\n\r\n    function makeSizer(size) {\r\n      return function() {\r\n        document.body.style.fontSize = size + &#39;px&#39;;\r\n      };\r\n    }\r\n\r\n    var size12 = makeSizer(12);\r\n    var size14 = makeSizer(14);\r\n    var size16 = makeSizer(16);\r\n    \r\n    document.getElementById(&#39;size-12&#39;).onclick = size12;\r\n    document.getElementById(&#39;size-14&#39;).onclick = size14;\r\n    document.getElementById(&#39;size-16&#39;).onclick = size16;\r\n\r\nfor reading more about closures, visit the [link on MDN][1]\r\n[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"},{"score":20,"body_markdown":"This answer is a summary of this youtube video [Javascript Closures][1]. So full credits to that video.\r\n \r\n\r\n*Closures are nothing but Stateful functions which maintain states of their private variables.* \r\n\r\nNormally when you make a call to a function as shown in the below figure. The variables are created on a stack ( running RAM memory) used and then disallocated.\r\n\r\n[![enter image description here][2]][2]\r\n\r\nBut now there are situations where we want to maintain this state of the function thats where Javascript closures comes to use. A closure is a function inside function with a return call as shown in the below code.\r\n\r\n[![enter image description here][3]][3]\r\n\r\nSo the closure code for the counter function above looks something as shown below.Its a function inside function with a return statement.\r\n\r\n    function Counter() {\r\n               var counter = 0;\r\n               \r\n               var Increment = function () {\r\n                   counter++;\r\n                   alert(counter);\r\n               }\r\n               return {\r\n                   Increment\r\n               }\r\n           }\r\n          \r\nSo now if you make a call the counter will increment in other words the function call maintains states.\r\n\r\n    var x = Counter(); // get the reference of the closure\r\n    x.Increment(); // Displays 1\r\n    x.Increment(); // Display 2 ( Maintains the private variables)\r\n\r\n\r\nBut now the biggest question whats the use of such stateful function. Stateful functions are building blocks to implement OOP concept like abstraction ,encapsulation and creating self contained modules.\r\n\r\nSo whatever you want encapsulated you can put it as private and things to be exposed to public should be put in return statement. Also these components are self contained isolated objects so they do not pollute global variables.\r\n\r\nA object which follows OOP principles is self contained , follows abstraction , follows encapsulation and so. With out closures in Javascript this is difficult to implement.\r\n\r\n\r\n[![enter image description here][4]][4]\r\n\r\n\r\n  [1]: https://www.youtube.com/watch?v=FYrtnS3X_Lw\r\n  [2]: https://i.stack.imgur.com/QVZg5.png\r\n  [3]: https://i.stack.imgur.com/u8UIi.png\r\n  [4]: https://i.stack.imgur.com/tJ5Mm.png\r\n"},{"score":34,"body_markdown":"&gt; A closure is a function having access to the parent scope, even after the parent function has closed.\r\n\r\nSo basically a closure is a function of another function. We can say like a child function.\r\n\r\n&gt; A closure is an inner function that has access to the outer\r\n&gt; (enclosing) function’s variables—scope chain. The closure has three\r\n&gt; scope chains: it has access to its own scope (variables defined\r\n&gt; between its curly brackets), it has access to the outer function’s\r\n&gt; variables, and it has access to the global variables.\r\n&gt; \r\n&gt; The inner function has access not only to the outer function’s\r\n&gt; variables but also to the outer function’s parameters. Note that the\r\n&gt; inner function cannot call the outer function’s arguments object,\r\n&gt; however, even though it can call the outer function’s parameters\r\n&gt; directly.\r\n&gt; \r\n&gt; You create a closure by adding a function inside another function.\r\n\r\nAlso, it&#39;s very useful method which is used in many famous frameworks including `Angular`, `Node.js` and `jQuery`:\r\n\r\n&gt; Closures are used extensively in Node.js; they are workhorses in\r\n&gt; Node.js’ asynchronous, non-blocking architecture. Closures are also\r\n&gt; frequently used in jQuery and just about every piece of JavaScript\r\n&gt; code you read.\r\n\r\nBut how the closures look like in a real-life coding?\r\nLook at this simple sample code:\r\n\r\n \r\n\r\n   \r\n\r\n    function showName(firstName, lastName) {\r\n          var nameIntro = &quot;Your name is &quot;;\r\n          // this inner function has access to the outer function&#39;s variables, including the parameter\r\n          function makeFullName() {\r\n              return nameIntro + firstName + &quot; &quot; + lastName;\r\n          }\r\n          return makeFullName();\r\n      }\r\n    \r\n      console.log(showName(&quot;Michael&quot;, &quot;Jackson&quot;)); // Your name is Michael Jackson\r\n\r\nAlso, this is classic closure way in jQuery which every javascript and jQuery developers used it a lot:\r\n\r\n    $(function() {\r\n        var selections = [];\r\n        $(&quot;.niners&quot;).click(function() { // this closure has access to the selections variable\r\n            selections.push(this.prop(&quot;name&quot;)); // update the selections variable in the outer function&#39;s scope\r\n        });\r\n    });\r\n\r\nBut why we use closures? when we use it in an actual programming?\r\nwhat are the practical use of closures? the below is a good explanation and example by MDN:\r\n\r\n**Practical closures**\r\n\r\n&gt; Closures are useful because they let you associate some data (the\r\n&gt; lexical environment) with a function that operates on that data. This\r\n&gt; has obvious parallels to object oriented programming, where objects\r\n&gt; allow us to associate some data (the object&#39;s properties) with one or\r\n&gt; more methods.\r\n&gt; \r\n&gt; Consequently, you can use a closure anywhere that you might normally\r\n&gt; use an object with only a single method.\r\n&gt; \r\n&gt; Situations where you might want to do this are particularly common on\r\n&gt; the web. Much of the code we write in front-end JavaScript is\r\n&gt; event-based — we define some behavior, then attach it to an event that\r\n&gt; is triggered by the user (such as a click or a keypress). Our code is\r\n&gt; generally attached as a callback: a single function which is executed\r\n&gt; in response to the event.\r\n&gt; \r\n&gt; For instance, suppose we wish to add some buttons to a page that\r\n&gt; adjust the text size. One way of doing this is to specify the\r\n&gt; font-size of the body element in pixels, then set the size of the\r\n&gt; other elements on the page (such as headers) using the relative em\r\n&gt; unit:\r\n\r\nRead the code below and run the code to see how closure help us here to easily make separate functions for each sections:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    //javascript\r\n    function makeSizer(size) {\r\n      return function() {\r\n        document.body.style.fontSize = size + &#39;px&#39;;\r\n      };\r\n    }\r\n\r\n    var size12 = makeSizer(12);\r\n    var size14 = makeSizer(14);\r\n    var size16 = makeSizer(16);\r\n\r\n    document.getElementById(&#39;size-12&#39;).onclick = size12;\r\n    document.getElementById(&#39;size-14&#39;).onclick = size14;\r\n    document.getElementById(&#39;size-16&#39;).onclick = size16;\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    /*css*/\r\n    body {\r\n      font-family: Helvetica, Arial, sans-serif;\r\n      font-size: 12px;\r\n    }\r\n\r\n    h1 {\r\n      font-size: 1.5em;\r\n    }\r\n\r\n    h2 {\r\n      font-size: 1.2em;\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;!--html&gt;&lt;!--&gt;\r\n    &lt;p&gt;Some paragraph text&lt;/p&gt;\r\n    &lt;h1&gt;some heading 1 text&lt;/h1&gt;\r\n    &lt;h2&gt;some heading 2 text&lt;/h2&gt;\r\n\r\n    &lt;a href=&quot;#&quot; id=&quot;size-12&quot;&gt;12&lt;/a&gt;\r\n    &lt;a href=&quot;#&quot; id=&quot;size-14&quot;&gt;14&lt;/a&gt;\r\n    &lt;a href=&quot;#&quot; id=&quot;size-16&quot;&gt;16&lt;/a&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nFor further study about closures, I recommend you to visit this page by MDN:\r\nhttps://developer.mozilla.org/en/docs/Web/JavaScript/Closures"}],"score":7633}