{"body":"I&#39;d like to round at most 2 decimal places, but *only if necessary*.\r\n\r\nInput:\r\n\r\n    10\r\n    1.7777777\r\n    9.1\r\n\r\nOutput:\r\n\r\n    10\r\n    1.78\r\n    9.1\r\n\r\nHow can I do this in JavaScript? ","title":"Round to at most 2 decimal places (only if necessary)","answers":[{"score":3829,"body_markdown":"Use `Math.round(num * 100) / 100`\r\n\r\n**Edit:** to ensure things like 1.005 round correctly, we use \r\n\r\n`Math.round((num + Number.EPSILON) * 100) / 100`"},{"score":26,"body_markdown":"This may help you:\r\n\r\n    var result = Math.round(input*100)/100;\r\n\r\nfor more information, you can have a look at this link\r\n\r\nhttps://stackoverflow.com/questions/566564/javascript-functions-math-roundnum-vs-num-tofixed0-and-browser-inconsistenci"},{"score":83,"body_markdown":"Consider `.toFixed()` and `.toPrecision()`:\r\n\r\n[http://www.javascriptkit.com/javatutors/formatnumber.shtml][1]\r\n\r\n\r\n  [1]: http://www.javascriptkit.com/javatutors/formatnumber.shtml"},{"score":16,"body_markdown":"It may work for you,\r\n\r\n    Math.round(num * 100)/100;\r\n\r\nto know the difference between toFixed and round. You can have a look at *https://stackoverflow.com/questions/566564/javascript-functions-math-roundnum-vs-num-tofixed0-and-browser-inconsistenci*.\r\n"},{"score":53,"body_markdown":"Here is a simple way to do it:\r\n\r\n    Math.round(value * 100) / 100\r\n\r\nYou might want to go ahead and make a separate function to do it for you though:\r\n\r\n    function roundToTwo(value) {\r\n        return(Math.round(value * 100) / 100);\r\n    }\r\n\r\nThen you would simply pass in the value.\r\n\r\nYou could enhance it to round to any arbitrary number of decimals by adding a second parameter.\r\n\r\n    function myRound(value, places) {\r\n        var multiplier = Math.pow(10, places);\r\n    \r\n        return (Math.round(value * multiplier) / multiplier);\r\n    }"},{"score":3253,"body_markdown":"If the value is a text type:\r\n\r\n    parseFloat(&quot;123.456&quot;).toFixed(2);\r\n\r\nIf the value is a number:\r\n\r\n    var numb = 123.23454;\r\n    numb = numb.toFixed(2);\r\n\r\nThere is a downside that values like 1.5 will give &quot;1.50&quot; as the output. A fix suggested by @minitech:\r\n\r\n    var numb = 1.5;\r\n    numb = +numb.toFixed(2);\r\n    // Note the plus sign that drops any &quot;extra&quot; zeroes at the end.\r\n    // It changes the result (which is a string) into a number again (think &quot;0 + foo&quot;),\r\n    // which means that it uses only as many digits as necessary.\r\n\r\nIt seems like `Math.round` is a better solution. **But it is not!** In some cases it will **NOT** round correctly:\r\n\r\n    Math.round(1.005 * 1000)/1000 // Returns 1 instead of expected 1.01!\r\n\r\ntoFixed() will also **NOT** round correctly in some cases (tested in Chrome v.55.0.2883.87)!\r\n\r\nExamples:\r\n\r\n    parseFloat(&quot;1.555&quot;).toFixed(2); // Returns 1.55 instead of 1.56.\r\n    parseFloat(&quot;1.5550&quot;).toFixed(2); // Returns 1.55 instead of 1.56.\r\n    // However, it will return correct result if you round 1.5551.\r\n    parseFloat(&quot;1.5551&quot;).toFixed(2); // Returns 1.56 as expected.\r\n\r\n    1.3555.toFixed(3) // Returns 1.355 instead of expected 1.356.\r\n    // However, it will return correct result if you round 1.35551.\r\n    1.35551.toFixed(2); // Returns 1.36 as expected.\r\n\r\nI guess, this is because 1.555 is actually something like float 1.55499994 behind the scenes.\r\n\r\n**Solution 1** is to use a script with required rounding algorithm, for example:\r\n\r\n    function roundNumber(num, scale) {\r\n      if(!(&quot;&quot; + num).includes(&quot;e&quot;)) {\r\n        return +(Math.round(num + &quot;e+&quot; + scale)  + &quot;e-&quot; + scale);\r\n      } else {\r\n        var arr = (&quot;&quot; + num).split(&quot;e&quot;);\r\n        var sig = &quot;&quot;\r\n        if(+arr[1] + scale &gt; 0) {\r\n          sig = &quot;+&quot;;\r\n        }\r\n        return +(Math.round(+arr[0] + &quot;e&quot; + sig + (+arr[1] + scale)) + &quot;e-&quot; + scale);\r\n      }\r\n    }\r\n\r\nhttps://plnkr.co/edit/uau8BlS1cqbvWPCHJeOy?p=preview\r\n\r\n**NOTE:** This is not a universal solution for everyone. There are several different rounding algorithms, your implementation can be different, depends on your requirements. https://en.wikipedia.org/wiki/Rounding\r\n\r\n**Solution 2** is to avoid front end calculations and pull rounded values from the backend server.\r\n\r\n**Edit:** Another possible solution, which is not a bullet proof also.\r\n\r\n    Math.round((num + Number.EPSILON) * 100) / 100\r\n\r\nIn some cases, when you round number like 1.3549999999999998 it will return incorrect result. Should be 1.35 but result is 1.36."},{"score":61,"body_markdown":"**None of the answers found here is correct**. @stinkycheeseman asked to **round up**, you all rounded the number.\r\n\r\nTo round up, use this:\r\n\r\n    Math.ceil(num * 100)/100;"},{"score":3,"body_markdown":"Here is a function I came up with to do &quot;round up&quot;. I used double Math.round to compensate for JavaScript&#39;s inaccurate multiplying, so 1.005 will be correctly rounded as 1.01.\r\n\r\n    function myRound(number, decimalplaces){\r\n        if(decimalplaces &gt; 0){\r\n            var multiply1 = Math.pow(10,(decimalplaces + 4));\r\n            var divide1 = Math.pow(10, decimalplaces);\r\n            return Math.round(Math.round(number * multiply1)/10000 )/divide1;\r\n        }\r\n        if(decimalplaces &lt; 0){\r\n            var divide2 = Math.pow(10, Math.abs(decimalplaces));\r\n            var multiply2 = Math.pow(10, Math.abs(decimalplaces));\r\n            return Math.round(Math.round(number / divide2) * multiply2);\r\n        }\r\n        return Math.round(number);\r\n    }\r\n"},{"score":3,"body_markdown":"I wrote the following set of functions for myself. Maybe it will help you too.\r\n\r\n    function float_exponent(number) {\r\n        exponent = 1;\r\n        while (number &lt; 1.0) {\r\n            exponent += 1\r\n            number *= 10\r\n        }\r\n        return exponent;\r\n    }\r\n    function format_float(number, extra_precision) {\r\n        precision = float_exponent(number) + (extra_precision || 0)\r\n        return number.toFixed(precision).split(/\\.?0+$/)[0]\r\n    }\r\n\r\nUsage:\r\n\r\n    format_float(1.01); // 1\r\n    format_float(1.06); // 1.1\r\n    format_float(0.126); // 0.13\r\n    format_float(0.000189); // 0.00019\r\n\r\nFor you case:\r\n\r\n    format_float(10, 1); // 10\r\n    format_float(9.1, 1); // 9.1\r\n    format_float(1.77777, 1); // 1.78\r\n\r\n"},{"score":-9,"body_markdown":"I still don&#39;t think anyone gave him the answer to how to only do the rounding if needed. The easiest way I see to do it is to check if there is even a decimal in the number, like so:\r\n\r\n    var num = 3.21;\r\n    if ( (num+&quot;&quot;).indexOf(&#39;.&#39;) &gt;= 0 ) { //at least assert to string first...\r\n        // whatever code you decide to use to round\r\n    }"},{"score":13,"body_markdown":"Here is a prototype method:\r\n\r\n    Number.prototype.round = function(places){\r\n    \tplaces = Math.pow(10, places); \r\n        return Math.round(this * places)/places;\r\n    }\r\n    \r\n    var yournum = 10.55555;\r\n    yournum = yournum.round(2);\r\n"},{"score":495,"body_markdown":"You can use\r\n\r\n    function roundToTwo(num) {    \r\n        return +(Math.round(num + &quot;e+2&quot;)  + &quot;e-2&quot;);\r\n    }\r\n\r\nI found this over on [MDN][1]. Their way avoids the problem with 1.005 that was [mentioned][2].\r\n\r\n\r\n\r\n    roundToTwo(1.005)\r\n    1.01\r\n    roundToTwo(10)\r\n    10\r\n    roundToTwo(1.7777777)\r\n    1.78\r\n    roundToTwo(9.1)\r\n    9.1\r\n    roundToTwo(1234.5678)\r\n    1234.57\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\r\n  [2]: https://stackoverflow.com/questions/11832914/round-up-to-2-decimal-places-in-javascript#comment24719818_11832950\r\n"},{"score":12,"body_markdown":"To not deal with many 0s, use this variant:\r\n\r\n    Math.round(num * 1e2) / 1e2"},{"score":157,"body_markdown":"MarkG&#39;s answer is the correct one.  Here&#39;s a generic extension for any number of decimal places.\r\n\r\n    Number.prototype.round = function(places) {\r\n      return +(Math.round(this + &quot;e+&quot; + places)  + &quot;e-&quot; + places);\r\n    }\r\n\r\nUsage:\r\n\r\n    var n = 1.7777;    \r\n    n.round(2); // 1.78\r\n\r\nUnit test:\r\n\r\n    it.only(&#39;should round floats to 2 places&#39;, function() {\r\n        \r\n      var cases = [\r\n        { n: 10,      e: 10,    p:2 },\r\n        { n: 1.7777,  e: 1.78,  p:2 },\r\n        { n: 1.005,   e: 1.01,  p:2 },\r\n        { n: 1.005,   e: 1,     p:0 },\r\n        { n: 1.77777, e: 1.8,   p:1 }\r\n      ]\r\n        \r\n      cases.forEach(function(testCase) {\r\n        var r = testCase.n.round(testCase.p);\r\n        assert.equal(r, testCase.e, &#39;didn\\&#39;t get right number&#39;);\r\n      });\r\n    })\r\n\r\n"},{"score":23,"body_markdown":"MarkG and Lavamantis offered a much better solution than the one that has been accepted. It&#39;s a shame they don&#39;t get more upvotes!\r\n\r\nHere is the function I use to solve the floating point decimals issues [also based on MDN][1]. It is even more generic (but less concise) than Lavamantis&#39;s solution:\r\n\r\n    function round(value, exp) {\r\n      if (typeof exp === &#39;undefined&#39; || +exp === 0)\r\n        return Math.round(value);\r\n\r\n      value = +value;\r\n      exp  = +exp;\r\n\r\n      if (isNaN(value) || !(typeof exp === &#39;number&#39; &amp;&amp; exp % 1 === 0))\r\n        return NaN;\r\n\r\n      // Shift\r\n      value = value.toString().split(&#39;e&#39;);\r\n      value = Math.round(+(value[0] + &#39;e&#39; + (value[1] ? (+value[1] + exp) : exp)));\r\n\r\n      // Shift back\r\n      value = value.toString().split(&#39;e&#39;);\r\n      return +(value[0] + &#39;e&#39; + (value[1] ? (+value[1] - exp) : -exp));\r\n    }\r\n\r\nUse it with:\r\n\r\n    round(10.8034, 2);      // Returns 10.8\r\n    round(1.275, 2);        // Returns 1.28\r\n    round(1.27499, 2);      // Returns 1.27\r\n    round(1.2345678e+2, 2); // Returns 123.46\r\n\r\nCompared to Lavamantis&#39;s solution, we can do...\r\n\r\n    round(1234.5678, -2); // Returns 1200\r\n    round(&quot;123.45&quot;);      // Returns 123\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round#Example:_Decimal_rounding"},{"score":9,"body_markdown":"If you happen to already be using the d3 library, they have a powerful number formatting library: https://github.com/mbostock/d3/wiki/Formatting\r\n\r\nRounding specifically is here: https://github.com/mbostock/d3/wiki/Formatting#d3_round\r\n\r\nIn your case, the answer is:\r\n\r\n    &gt; d3.round(1.777777, 2)\r\n    1.78\r\n    &gt; d3.round(1.7, 2)\r\n    1.7\r\n    &gt; d3.round(1, 2)\r\n    1"},{"score":36,"body_markdown":"    +(10).toFixed(2); // = 10\r\n    +(10.12345).toFixed(2); // = 10.12\r\n    \r\n    (10).toFixed(2); // = 10.00\r\n    (10.12345).toFixed(2); // = 10.12"},{"score":4,"body_markdown":"Try to use the jQuery [.number plug-in][1]:\r\n\r\n    var number = 19.8000000007;\r\n    var res = 1 * $.number(number, 2);\r\n\r\n  [1]: http://www.teamdf.com/web/jquery-number-format-redux/196\r\n"},{"score":63,"body_markdown":"A precise rounding method. Source: [Mozilla][1]\r\n\r\n    (function(){\r\n\r\n        /**\r\n         * Decimal adjustment of a number.\r\n         *\r\n         * @param   {String}    type    The type of adjustment.\r\n         * @param   {Number}    value   The number.\r\n         * @param   {Integer}   exp     The exponent (the 10 logarithm of the adjustment base).\r\n         * @returns {Number}            The adjusted value.\r\n         */\r\n        function decimalAdjust(type, value, exp) {\r\n            // If the exp is undefined or zero...\r\n            if (typeof exp === &#39;undefined&#39; || +exp === 0) {\r\n                return Math[type](value);\r\n            }\r\n            value = +value;\r\n            exp = +exp;\r\n            // If the value is not a number or the exp is not an integer...\r\n            if (isNaN(value) || !(typeof exp === &#39;number&#39; &amp;&amp; exp % 1 === 0)) {\r\n                return NaN;\r\n            }\r\n            // Shift\r\n            value = value.toString().split(&#39;e&#39;);\r\n            value = Math[type](+(value[0] + &#39;e&#39; + (value[1] ? (+value[1] - exp) : -exp)));\r\n            // Shift back\r\n            value = value.toString().split(&#39;e&#39;);\r\n            return +(value[0] + &#39;e&#39; + (value[1] ? (+value[1] + exp) : exp));\r\n        }\r\n\r\n        // Decimal round\r\n        if (!Math.round10) {\r\n            Math.round10 = function(value, exp) {\r\n                return decimalAdjust(&#39;round&#39;, value, exp);\r\n            };\r\n        }\r\n        // Decimal floor\r\n        if (!Math.floor10) {\r\n            Math.floor10 = function(value, exp) {\r\n                return decimalAdjust(&#39;floor&#39;, value, exp);\r\n            };\r\n        }\r\n        // Decimal ceil\r\n        if (!Math.ceil10) {\r\n            Math.ceil10 = function(value, exp) {\r\n                return decimalAdjust(&#39;ceil&#39;, value, exp);\r\n            };\r\n        }\r\n    })();\r\n\r\nExamples:\r\n\r\n    // Round\r\n    Math.round10(55.55, -1); // 55.6\r\n    Math.round10(55.549, -1); // 55.5\r\n    Math.round10(55, 1); // 60\r\n    Math.round10(54.9, 1); // 50\r\n    Math.round10(-55.55, -1); // -55.5\r\n    Math.round10(-55.551, -1); // -55.6\r\n    Math.round10(-55, 1); // -50\r\n    Math.round10(-55.1, 1); // -60\r\n    Math.round10(1.005, -2); // 1.01 -- compare this with Math.round(1.005*100)/100 above\r\n    // Floor\r\n    Math.floor10(55.59, -1); // 55.5\r\n    Math.floor10(59, 1); // 50\r\n    Math.floor10(-55.51, -1); // -55.6\r\n    Math.floor10(-51, 1); // -60\r\n    // Ceil\r\n    Math.ceil10(55.51, -1); // 55.6\r\n    Math.ceil10(51, 1); // 60\r\n    Math.ceil10(-55.59, -1); // -55.5\r\n    Math.ceil10(-59, 1); // -50\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\r\n\r\n"},{"score":1,"body_markdown":"I just wanted to share my approach, based on previously mentioned answers:\r\n\r\nLet&#39;s create a function that rounds any given numeric value to a given amount of decimal places:\r\n\r\n    function roundWDecimals(n, decimals) {\r\n        if (!isNaN(parseFloat(n)) &amp;&amp; isFinite(n)) {\r\n            if (typeof(decimals) == typeof(undefined)) {\r\n                decimals = 0;\r\n            }\r\n            var decimalPower = Math.pow(10, decimals);\r\n            return Math.round(parseFloat(n) * decimalPower) / decimalPower;\r\n        }\r\n        return NaN;\r\n    }\r\n\r\nAnd introduce a new &quot;round&quot; method for numbers prototype:\r\n\r\n    Object.defineProperty(Number.prototype, &#39;round&#39;, {\r\n        enumerable: false,\r\n        value: function(decimals) {\r\n            return roundWDecimals(this, decimals);\r\n        }\r\n    });\r\n\r\nAnd you can test it:\r\n\r\n&lt;!-- begin snippet: js hide: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function roundWDecimals(n, decimals) {\r\n        if (!isNaN(parseFloat(n)) &amp;&amp; isFinite(n)) {\r\n            if (typeof(decimals) == typeof(undefined)) {\r\n                decimals = 0;\r\n            }\r\n            var decimalPower = Math.pow(10, decimals);\r\n            return Math.round(parseFloat(n) * decimalPower) / decimalPower;\r\n        }\r\n        return NaN;\r\n    }\r\n    Object.defineProperty(Number.prototype, &#39;round&#39;, {\r\n        enumerable: false,\r\n        value: function(decimals) {\r\n            return roundWDecimals(this, decimals);\r\n        }\r\n    });\r\n\r\n    var roundables = [\r\n        {num: 10, decimals: 2},\r\n        {num: 1.7777777, decimals: 2},\r\n        {num: 9.1, decimals: 2},\r\n        {num: 55.55, decimals: 1},\r\n        {num: 55.549, decimals: 1},\r\n        {num: 55, decimals: 0},\r\n        {num: 54.9, decimals: 0},\r\n        {num: -55.55, decimals: 1},\r\n        {num: -55.551, decimals: 1},\r\n        {num: -55, decimals: 0},\r\n        {num: 1.005, decimals: 2},\r\n        {num: 1.005, decimals: 2},\r\n        {num: 19.8000000007, decimals: 2},\r\n      ],\r\n      table = &#39;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;Num&lt;/th&gt;&lt;th&gt;Decimals&lt;/th&gt;&lt;th&gt;Result&lt;/th&gt;&lt;/tr&gt;&#39;;\r\n    $.each(roundables, function() {\r\n      table +=\r\n        &#39;&lt;tr&gt;&#39;+\r\n          &#39;&lt;td&gt;&#39;+this.num+&#39;&lt;/td&gt;&#39;+\r\n          &#39;&lt;td&gt;&#39;+this.decimals+&#39;&lt;/td&gt;&#39;+\r\n          &#39;&lt;td&gt;&#39;+this.num.round(this.decimals)+&#39;&lt;/td&gt;&#39;+\r\n        &#39;&lt;/tr&gt;&#39;\r\n      ;\r\n    });\r\n    table += &#39;&lt;/table&gt;&#39;;\r\n    $(&#39;.results&#39;).append(table);\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;div class=&quot;results&quot;&gt;&lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":35,"body_markdown":"Use this function ```Number(x).toFixed(2);```"},{"score":33,"body_markdown":"Try this **light weight** solution:\r\n\r\n    function round(x, digits){\r\n      return parseFloat(x.toFixed(digits))\r\n    }\r\n\r\n     round(1.222,  2) ;\r\n     // 1.22\r\n     round(1.222, 10) ;\r\n     // 1.222"},{"score":84,"body_markdown":"One can use `.toFixed(NumberOfDecimalPlaces)`.\r\n\r\n    var str = 10.234.toFixed(2); // =&gt; &#39;10.23&#39;\r\n    var number = Number(str); // =&gt; 10.23\r\n\r\n"},{"score":0,"body_markdown":"### Node.js\r\n\r\nThis did the trick for me on **Node.js** in a matter of seconds:\r\n\r\n    npm install math\r\n\r\n*Source: http://mathjs.org/examples/basic_usage.js.html*\r\n"},{"score":14,"body_markdown":"Easiest way:\r\n\r\n`+num.toFixed(2)`\r\n\r\nIt converts it to a string, and then back into an integer / float."},{"score":3,"body_markdown":"You could also override the Math.round function to do the rounding correct and add a parameter for decimals and use it like: Math.round(Number, Decimals). Keep in mind that this overrides the built in component Math.round and giving it another property then it original is.\r\n\r\n    var round = Math.round;\r\n    Math.round = function (value, decimals) {\r\n      decimals = decimals || 0;\r\n      return Number(round(value + &#39;e&#39; + decimals) + &#39;e-&#39; + decimals);\r\n    }\r\n\r\nThen you can simply use it like this:\r\n\r\n    Math.round(1.005, 2);\r\n\r\nhttps://jsfiddle.net/k5tpq3pd/3/\r\n"},{"score":4,"body_markdown":"**Here is the shortest and complete answer:**\r\n\r\n    function round(num, decimals) {\r\n            var n = Math.pow(10, decimals);\r\n            return Math.round( (n * num).toFixed(decimals) )  / n;\r\n    };\r\n\r\n**This also takes care of the example case 1.005 which will return 1.01.**"},{"score":17,"body_markdown":"\r\n    var roundUpto = function(number, upto){\r\n        return Number(number.toFixed(upto));\r\n    }\r\n    roundUpto(0.1464676, 2);\r\n\r\n   \r\n\r\n`toFixed(2)` here 2 is number of digits upto which we want to round this num."},{"score":15,"body_markdown":"One way to achieve such a rounding *only if necessary* is to use [Number.prototype.toLocaleString()][1]:\r\n\r\n    myNumber.toLocaleString(&#39;en&#39;, {maximumFractionDigits:2, useGrouping:false})\r\n\r\nThis will provide exactly the output you expect, but as strings. You can still convert those back to numbers if that&#39;s not the data type you expect.\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString"},{"score":31,"body_markdown":"There are a couple of ways to do that. For people like me, the Lodash&#39;s variant\r\n\r\n    function round(number, precision) {\r\n        var pair = (number + &#39;e&#39;).split(&#39;e&#39;)\r\n        var value = Math.round(pair[0] + &#39;e&#39; + (+pair[1] + precision))\r\n        pair = (value + &#39;e&#39;).split(&#39;e&#39;)\r\n        return +(pair[0] + &#39;e&#39; + (+pair[1] - precision))\r\n    }\r\n\r\n**Usage:**\r\n\r\n    round(0.015, 2) // 0.02\r\n    round(1.005, 2) // 1.01\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf your project uses jQuery or lodash, you can also find proper `round` method in the libraries.\r\n\r\n\r\n## Update 1 ##\r\nI removed the variant `n.toFixed(2)`, because it is not correct. Thank you @avalanche1\r\n\r\n"},{"score":4,"body_markdown":"To round at decimal positions `pos` (including no decimals) do `Math.round(num * Math.pow(10,pos)) / Math.pow(10,pos)`\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var console = {\r\n     log: function(s) {\r\n      document.getElementById(&quot;console&quot;).innerHTML += s + &quot;&lt;br/&gt;&quot;\r\n     }\r\n    }\r\n    var roundDecimals=function(num,pos) {\r\n     return (Math.round(num * Math.pow(10,pos)) / Math.pow(10,pos) );\r\n    }\r\n    //https://en.wikipedia.org/wiki/Pi\r\n    var pi=3.14159265358979323846264338327950288419716939937510;\r\n    for(var i=2;i&lt;15;i++) console.log(&quot;pi=&quot;+roundDecimals(pi,i));\r\n    for(var i=15;i&gt;=0;--i) console.log(&quot;pi=&quot;+roundDecimals(pi,i));\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;div id=&quot;console&quot; /&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n"},{"score":-1,"body_markdown":"Please use the below function if you don&#39;t want to round off.\r\n\r\n    function ConvertToDecimal(num) {\r\n      num = num.toString(); // If it&#39;s not already a String\r\n      num = num.slice(0, (num.indexOf(&quot;.&quot;)) + 3); // With 3 exposing the hundredths place    \r\n    alert(&#39;M : &#39; + Number(num)); // If you need it back as a Number     \r\n    }\r\n"},{"score":6,"body_markdown":"I&#39;ll add one more approach to this.\r\n\r\n    number = 16.6666666;\r\n    console.log(parseFloat(number.toFixed(2)));\r\n    &quot;16.67&quot;\r\n\r\n    number = 16.6;\r\n    console.log(parseFloat(number.toFixed(2)));\r\n    &quot;16.6&quot;\r\n\r\n    number = 16;\r\n    console.log(parseFloat(number.toFixed(2)));\r\n    &quot;16&quot;\r\n\r\n`.toFixed(2)` returns a string with exactily 2 decimal points, that may or may not be trailing zeros. Doing a `parseFloat()` will eliminate those trailing zeros."},{"score":90,"body_markdown":"This question is complicated.\r\n\r\nSuppose we have a function, `roundTo2DP(num)`, that takes a float as an argument and returns a value rounded to 2 decimal places. What should each of these expressions evaluate to?\r\n\r\n* `roundTo2DP(0.014999999999999999)`\r\n* `roundTo2DP(0.0150000000000000001)`\r\n* `roundTo2DP(0.015)`\r\n\r\nThe &#39;obvious&#39; answer is that the first example should round to 0.01 (because it&#39;s closer to 0.01 than to 0.02) while the other two should round to 0.02 (because 0.0150000000000000001 is closer to 0.02 than to 0.01, and because 0.015 is exactly halfway between them and there is a mathematical convention that such numbers get rounded up).\r\n\r\nThe catch, which you may have guessed, is that `roundTo2DP` *cannot possibly* be implemented to give those obvious answers, because all three numbers passed to it are *the same number*. IEEE 754 binary floating point numbers (the kind used by JavaScript) can&#39;t exactly represent most non-integer numbers, and so all three numeric literals above get rounded to a nearby valid floating point number. This number, as it happens, is *exactly*\r\n\r\n0.01499999999999999944488848768742172978818416595458984375\r\n\r\nwhich is closer to 0.01 than to 0.02.\r\n\r\nYou can see that all three numbers are the same at your browser console, Node shell, or other JavaScript interpreter. Just compare them:\r\n\r\n&lt;pre&gt;&lt;code&gt;&gt; &lt;b&gt;&lt;i&gt;0.014999999999999999 === 0.0150000000000000001&lt;/i&gt;&lt;/b&gt;\r\ntrue&lt;/code&gt;&lt;/pre&gt;\r\n\r\nSo when I write `m = 0.0150000000000000001`, the *exact value of `m`* that I end up with is closer to `0.01` than it is to `0.02`. And yet, if I convert `m` to a String...\r\n\r\n&lt;pre&gt;&lt;code&gt;&gt; &lt;b&gt;&lt;i&gt;var m = 0.0150000000000000001;&lt;/i&gt;&lt;/b&gt;\r\n&gt; &lt;b&gt;&lt;i&gt;console.log(String(m));&lt;/i&gt;&lt;/b&gt;\r\n0.015\r\n&gt; &lt;b&gt;&lt;i&gt;var m = 0.014999999999999999;&lt;/i&gt;&lt;/b&gt;\r\n&gt; &lt;b&gt;&lt;i&gt;console.log(String(m));&lt;/i&gt;&lt;/b&gt;\r\n0.015&lt;/code&gt;&lt;/pre&gt;\r\n\r\n... I get 0.015, which should round to 0.02, and which is noticeably *not* the 56-decimal-place number I earlier said that all of these numbers were exactly equal to. So what dark magic is this?\r\n\r\nThe answer can be found in the ECMAScript specification, in section [*7.1.12.1: ToString applied to the Number type*](http://www.ecma-international.org/ecma-262/7.0/#sec-tostring-applied-to-the-number-type). Here the rules for converting some Number *m* to a String are laid down. The key part is point 5, in which an integer *s* is generated whose digits will be used in the String representation of *m*:\r\n\r\n&gt; let *n*, *k*, and *s* be integers such that *k* ≥ 1, 10&lt;sup&gt;&lt;i&gt;k&lt;/i&gt;-1&lt;/sup&gt; ≤ *s* &lt; 10&lt;sup&gt;&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt;, the Number value for *s* &#215; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;-&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt; is *m*, and *k* is as small as possible. Note that k is the number of digits in the decimal representation of *s*, that *s* is not divisible by 10, and that the least significant digit of *s* is not necessarily uniquely determined by these criteria.\r\n\r\nThe key part here is the requirement that &quot;*k* is as small as possible&quot;. What that requirement amounts to is a requirement that, given a Number `m`, the value of `String(m)` must have *the least possible number of digits* while still satisfying the requirement that `Number(String(m)) === m`. Since we already know that `0.015 === 0.0150000000000000001`, it&#39;s now clear why `String(0.0150000000000000001) === &#39;0.015&#39;` must be true.\r\n\r\nOf course, none of this discussion has directly answered what `roundTo2DP(m)` *should* return. If `m`&#39;s exact value is 0.01499999999999999944488848768742172978818416595458984375, but its String representation is &#39;0.015&#39;, then what is the *correct* answer - mathematically, practically, philosophically, or whatever - when we round it to two decimal places?\r\n\r\nThere is no single correct answer to this. It depends upon your use case. You probably want to respect the String representation and round upwards when:\r\n\r\n- The value being represented is inherently discrete, e.g. an amount of currency in a 3-decimal-place currency like dinars. In this case, the *true* value of a Number like 0.015 *is* 0.015, and the 0.0149999999... representation that it gets in binary floating point is a rounding error. (Of course, many will argue, reasonably, that you should use a decimal library for handling such values and never represent them as binary floating point Numbers in the first place.)\r\n- The value was typed by a user. In this case, again, the exact decimal number entered is more &#39;true&#39; than the nearest binary floating point representation.\r\n\r\nOn the other hand, you probably want to respect the binary floating point value and round downwards when your value is from an inherently continuous scale - for instance, if it&#39;s a reading from a sensor.\r\n\r\nThese two approaches require different code. To respect the String representation of the Number, we can (with quite a bit of reasonably subtle code) implement our own rounding that acts directly on the String representation, digit by digit, using the same algorithm you would&#39;ve used in school when you were taught how to round numbers. Below is an example which respects the OP&#39;s requirement of representing the number to 2 decimal places &quot;only when necessary&quot; by stripping trailing zeroes after the decimal point; you may, of course, need to tweak it to your precise needs.\r\n\r\n    /**\r\n     * Converts num to a decimal string (if it isn&#39;t one already) and then rounds it\r\n     * to at most dp decimal places.\r\n     *\r\n     * For explanation of why you&#39;d want to perform rounding operations on a String\r\n     * rather than a Number, see http://stackoverflow.com/a/38676273/1709587\r\n     *\r\n     * @param {(number|string)} num\r\n     * @param {number} dp\r\n     * @return {string}\r\n     */\r\n    function roundStringNumberWithoutTrailingZeroes (num, dp) {\r\n        if (arguments.length != 2) throw new Error(&quot;2 arguments required&quot;);\r\n        \r\n        num = String(num);\r\n        if (num.indexOf(&#39;e+&#39;) != -1) {\r\n            // Can&#39;t round numbers this large because their string representation\r\n            // contains an exponent, like 9.99e+37\r\n            throw new Error(&quot;num too large&quot;);\r\n        }\r\n        if (num.indexOf(&#39;.&#39;) == -1) {\r\n            // Nothing to do\r\n            return num;\r\n        }\r\n        \r\n        var parts = num.split(&#39;.&#39;),\r\n            beforePoint = parts[0],\r\n            afterPoint = parts[1],\r\n            shouldRoundUp = afterPoint[dp] &gt;= 5,\r\n            finalNumber;\r\n            \r\n        afterPoint = afterPoint.slice(0, dp);\r\n        if (!shouldRoundUp) {\r\n            finalNumber = beforePoint + &#39;.&#39; + afterPoint;\r\n        } else if (/^9+$/.test(afterPoint)) {\r\n            // If we need to round up a number like 1.9999, increment the integer\r\n            // before the decimal point and discard the fractional part.\r\n            finalNumber = Number(beforePoint)+1;\r\n        } else {\r\n            // Starting from the last digit, increment digits until we find one\r\n            // that is not 9, then stop\r\n            var i = dp-1;\r\n            while (true) {\r\n                if (afterPoint[i] == &#39;9&#39;) {\r\n                    afterPoint = afterPoint.substr(0, i) +\r\n                                 &#39;0&#39; +\r\n                                 afterPoint.substr(i+1);\r\n                    i--;\r\n                } else {\r\n                    afterPoint = afterPoint.substr(0, i) +\r\n                                 (Number(afterPoint[i]) + 1) +\r\n                                 afterPoint.substr(i+1);\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            finalNumber = beforePoint + &#39;.&#39; + afterPoint;\r\n        }\r\n        \r\n        // Remove trailing zeroes from fractional part before returning\r\n        return finalNumber.replace(/0+$/, &#39;&#39;)\r\n    }\r\n\r\nExample usage:\r\n\r\n&lt;pre&gt;&lt;code&gt;&gt; &lt;b&gt;&lt;i&gt;roundStringNumberWithoutTrailingZeroes(1.6, 2)&lt;/i&gt;&lt;/b&gt;\r\n&#39;1.6&#39;\r\n&gt; &lt;b&gt;&lt;i&gt;roundStringNumberWithoutTrailingZeroes(10000, 2)&lt;/i&gt;&lt;/b&gt;\r\n&#39;10000&#39;\r\n&gt; &lt;b&gt;&lt;i&gt;roundStringNumberWithoutTrailingZeroes(0.015, 2)&lt;/i&gt;&lt;/b&gt;\r\n&#39;0.02&#39;\r\n&gt; &lt;b&gt;&lt;i&gt;roundStringNumberWithoutTrailingZeroes(&#39;0.015000&#39;, 2)&lt;/i&gt;&lt;/b&gt;\r\n&#39;0.02&#39;\r\n&gt; &lt;b&gt;&lt;i&gt;roundStringNumberWithoutTrailingZeroes(1, 1)&lt;/i&gt;&lt;/b&gt;\r\n&#39;1&#39;\r\n&gt; &lt;b&gt;&lt;i&gt;roundStringNumberWithoutTrailingZeroes(&#39;0.015&#39;, 2)&lt;/i&gt;&lt;/b&gt;\r\n&#39;0.02&#39;\r\n&gt; &lt;b&gt;&lt;i&gt;roundStringNumberWithoutTrailingZeroes(0.01499999999999999944488848768742172978818416595458984375, 2)&lt;/i&gt;&lt;/b&gt;\r\n&#39;0.02&#39;\r\n&gt; &lt;b&gt;&lt;i&gt;roundStringNumberWithoutTrailingZeroes(&#39;0.01499999999999999944488848768742172978818416595458984375&#39;, 2)&lt;/i&gt;&lt;/b&gt;\r\n&#39;0.01&#39;&lt;/code&gt;&lt;/pre&gt;\r\n\r\nThe function above is *probably* what you want to use to avoid users ever witnessing numbers that they have entered being rounded wrongly.\r\n\r\n(As an alternative, you could also try the [round10](https://github.com/jhohlfeld/round10) library which provides a similarly-behaving function with a wildly different implementation.)\r\n\r\nBut what if you have the second kind of Number - a value taken from a continuous scale, where there&#39;s no reason to think that approximate decimal representations with fewer decimal places are more *accurate* than those with more? In that case, we *don&#39;t* want to respect the String representation, because that representation (as explained in the spec) is already sort-of-rounded; we don&#39;t want to make the mistake of saying &quot;0.014999999...375 rounds up to 0.015, which rounds up to 0.02, so 0.014999999...375 rounds up to 0.02&quot;.\r\n\r\nHere we can simply use the built-in [`toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) method. Note that by calling `Number()` on the String returned by `toFixed`, we get a Number whose String representation has no trailing zeroes (thanks to the way JavaScript computes the String representation of a Number, discussed earlier in this answer).\r\n\r\n    /**\r\n     * Takes a float and rounds it to at most dp decimal places. For example\r\n     *\r\n     *     roundFloatNumberWithoutTrailingZeroes(1.2345, 3)\r\n     *\r\n     * returns 1.234\r\n     *\r\n     * Note that since this treats the value passed to it as a floating point\r\n     * number, it will have counterintuitive results in some cases. For instance,\r\n     * \r\n     *     roundFloatNumberWithoutTrailingZeroes(0.015, 2)\r\n     *\r\n     * gives 0.01 where 0.02 might be expected. For an explanation of why, see\r\n     * http://stackoverflow.com/a/38676273/1709587. You may want to consider using the\r\n     * roundStringNumberWithoutTrailingZeroes function there instead.\r\n     *\r\n     * @param {number} num\r\n     * @param {number} dp\r\n     * @return {number}\r\n     */\r\n    function roundFloatNumberWithoutTrailingZeroes (num, dp) {\r\n        var numToFixedDp = Number(num).toFixed(dp);\r\n        return Number(numToFixedDp);\r\n    }"},{"score":11,"body_markdown":"This is the simplest, more elegant solution (and I am the best of the world;):\r\n\r\n    function roundToX(num, X) {    \r\n        return +(Math.round(num + &quot;e+&quot;+X)  + &quot;e-&quot;+X);\r\n    }\r\n    //roundToX(66.66666666,2) =&gt; 66.67\r\n    //roundToX(10,2) =&gt; 10\r\n    //roundToX(10.904,2) =&gt; 10.9\r\n"},{"score":139,"body_markdown":"You should use:\r\n\r\n    Math.round( num * 100 + Number.EPSILON ) / 100\r\n\r\nNo one seems to be aware of [`Number.EPSILON`][1].\r\n\r\nAlso it&#39;s worth noting that this is not a *JavaScript weirdness* like some people stated.\r\n\r\n**That is simply the way floating point numbers works in a computer.** Like 99% of programming languages, JavaScript doesn&#39;t have *home made* floating point numbers; it relies on the CPU/FPU for that. A computer uses binary, and in binary, there isn&#39;t any numbers like `0.1`, but a mere binary approximation for that. Why? For the same reason than 1/3 cannot be written in decimal: its value is 0.33333333... with an infinity of threes.\r\n\r\nHere come [`Number.EPSILON`][1]. That number is the difference between 1 and the *next* number existing in the double precision floating point numbers. **That&#39;s it: There is no number between `1` and 1 + `Number.EPSILON`.**\r\n\r\n**EDIT:**\r\n\r\nAs asked in the comments, let&#39;s clarify one thing: adding `Number.EPSILON` is relevant only when the value to round is the result of an arithmetic operation, as it can swallow some floating point error delta.\r\n\r\nIt&#39;s not useful when the value comes from a direct source (e.g.: literal, user input or sensor).\r\n\r\n**EDIT (2019):**\r\n\r\nLike @maganap and some peoples have pointed out, it&#39;s best to add [`Number.EPSILON`][1] before multiplying:\r\n\r\n    Math.round( ( num + Number.EPSILON ) * 100 ) / 100\r\n\r\n**EDIT (december 2019):**\r\n\r\nLately, I use a function similar to this one for comparing numbers epsilon-aware:\r\n\r\n    const ESPILON_RATE = 1 + Number.EPSILON ;\r\n    const ESPILON_ZERO = Number.MIN_VALUE ;\r\n    \r\n    function epsilonEquals( a , b ) {\r\n      if ( Number.isNaN( a ) || Number.isNaN( b ) ) {\r\n        return false ;\r\n      }\r\n      if ( a === 0 || b === 0 ) {\r\n        return a &lt;= b + EPSILON_ZERO &amp;&amp; b &lt;= a + EPSILON_ZERO ;\r\n      }\r\n      return a &lt;= b * EPSILON_RATE &amp;&amp; b &lt;= a * EPSILON_RATE ;\r\n    }\r\n\r\nMy use-case is [an assertion + data validation lib](https://www.npmjs.com/package/doormen) I&#39;m developing for many years.\r\n\r\nIn fact, in the code I&#39;m using `ESPILON_RATE = 1 + 4 * Number.EPSILON` and `EPSILON_ZERO = 4 * Number.MIN_VALUE` (four times the epsilon), because I want an equality checker loose enough for cumulating floating point error.\r\n\r\nSo far, it looks perfect for me.\r\nI hope it will help.\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\r\n"},{"score":2,"body_markdown":"Just for the record, the scaling method could theoretically return Infinity if the number and the digits you want to round to are big enough. In JavaScript that shouldn&#39;t be a problem since the maximum number is 1.7976931348623157e+308, but if you&#39;re working with really big numbers or a lot of decimal places you could try this function instead:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    Number.prototype.roundTo = function(digits)\r\n    {\r\n        var str = this.toString();\r\n        var split = this.toString().split(&#39;e&#39;);\r\n        var scientific = split.length &gt; 1;\r\n        var index;\r\n        if (scientific)\r\n        {\r\n            str = split[0];\r\n            var decimal = str.split(&#39;.&#39;);\r\n            if (decimal.length &lt; 2)\r\n                return this;\r\n            index = decimal[0].length + 1 + digits;\r\n        }\r\n        else\r\n            index = Math.floor(this).toString().length + 1 + digits;\r\n        if (str.length &lt;= index)\r\n            return this;\r\n        var digit = str[index + 1];\r\n        var num = Number.parseFloat(str.substring(0, index));\r\n        if (digit &gt;= 5)\r\n        {\r\n            var extra = Math.pow(10, -digits);\r\n            return this &lt; 0 ? num - extra : num + extra;\r\n        }\r\n        if (scientific)\r\n            num += &quot;e&quot; + split[1];\r\n        return num;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":1,"body_markdown":" A Generic Answer for all browsers and precisions:\r\n\r\n    function round(num, places) {\r\n          if(!places){\r\n           return Math.round(num);\r\n          }\r\n\r\n          var val = Math.pow(10, places);\r\n          return Math.round(num * val) / val;\r\n    }\r\n\r\n    round(num, 2);\r\n\r\n\r\n\r\n"},{"score":27,"body_markdown":"If you are using lodash library, you can use the round method of lodash like following.\r\n\r\n    _.round(number, precision)\r\n\r\nEg: \r\n\r\n    _.round(1.7777777, 2) = 1.78\r\n\r\n"},{"score":-1,"body_markdown":"I tried my very own code, try this\r\n\r\n    function AmountDispalyFormat(value) {\r\n        value = value.toFixed(3);\r\n        var amount = value.toString().split(&#39;.&#39;);\r\n        var result = 0;\r\n        if (amount.length &gt; 1) {\r\n            var secondValue = parseInt(amount[1].toString().slice(0, 2));\r\n            if (amount[1].toString().length &gt; 2) {\r\n                if (parseInt(amount[1].toString().slice(2, 3)) &gt; 4) {\r\n                    secondValue++;\r\n                    if (secondValue == 100) {\r\n                        amount[0] = parseInt(amount[0]) + 1;\r\n                        secondValue = 0;\r\n                    }\r\n                }\r\n            }\r\n    \r\n            if (secondValue.toString().length == 1) {\r\n                secondValue = &quot;0&quot; + secondValue;\r\n            }\r\n            result = parseFloat(amount[0] + &quot;.&quot; + secondValue);\r\n        } else {\r\n            result = parseFloat(amount);\r\n        }\r\n        return result;\r\n    }\r\n\r\n"},{"score":9,"body_markdown":"A simpler ES6 way is\r\n\r\n    const round = (x, n) =&gt; \r\n      Number(parseFloat(Math.round(x * Math.pow(10, n)) / Math.pow(10, n)).toFixed(n));\r\n\r\nThis pattern also returns the precision asked for.\r\n\r\nex:\r\n\r\n    round(44.7826456, 4)  // yields 44.7826\r\n    round(78.12, 4)       // yields 78.12\r\n"},{"score":33,"body_markdown":"2017   \r\nJust use native code `.toFixed()`\r\n\r\n    number = 1.2345;\r\n    number.toFixed(2) // &quot;1.23&quot;\r\n \r\nIf you need to be strict and add digits just if needed it can use `replace`\r\n\r\n    number = 1; // &quot;1&quot;\r\n    number.toFixed(5).replace(/\\.?0*$/g,&#39;&#39;);"},{"score":5,"body_markdown":"I know there are many answers, but most of them have side effect in some specific cases.\r\n\r\nEasiest and shortest solution without any side effects is following:\r\n\r\n    Number((2.3456789).toFixed(2)) // 2.35\r\n\r\nIt rounds properly and returns number instead of string\r\n\r\n    console.log(Number((2.345).toFixed(2)))  // 2.35\r\n    console.log(Number((2.344).toFixed(2)))  // 2.34\r\n    console.log(Number((2).toFixed(2)))      // 2\r\n    console.log(Number((-2).toFixed(2)))     // -2\r\n    console.log(Number((-2.345).toFixed(2))) // -2.35\r\n    \r\n    console.log(Number((2.345678).toFixed(3))) // 2.346"},{"score":0,"body_markdown":"    number=(parseInt((number +0.005)*100))/100;     \r\n\r\nadd 0.005 if you want to normal round (2 decimals)     \r\n\r\n    8.123 +0.005=&gt; 8.128*100=&gt;812/100=&gt;8.12   \r\n\r\n    8.126 +0.005=&gt; 8.131*100=&gt;813/100=&gt;8.13   \r\n\r\n"},{"score":27,"body_markdown":"\r\n\r\nSince ES6 there is a &#39;proper&#39; way (without overriding statics and creating workarounds) to do this by [using toPrecision][1]\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var x = 1.49999999999;\r\n    console.log(x.toPrecision(4));\r\n    console.log(x.toPrecision(3));\r\n    console.log(x.toPrecision(2));\r\n\r\n    var y = Math.PI;\r\n    console.log(y.toPrecision(6));\r\n    console.log(y.toPrecision(5));\r\n    console.log(y.toPrecision(4));\r\n\r\n    var z = 222.987654\r\n    console.log(z.toPrecision(6));\r\n    console.log(z.toPrecision(5));\r\n    console.log(z.toPrecision(4));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nthen you can just `parseFloat` and zeroes will &#39;go away&#39;. \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n\r\nconsole.log(parseFloat((1.4999).toPrecision(3)));\r\nconsole.log(parseFloat((1.005).toPrecision(3)));\r\nconsole.log(parseFloat((1.0051).toPrecision(3)));\r\n\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIt doesn&#39;t solve the &#39;1.005 rounding problem&#39; though - since it is intrinsic to how [float fractions are being processed][2].\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n\r\n    console.log(1.005 - 0.005);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf you are open to libraries you can use [bignumber.js][3]\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n\r\n    console.log(1.005 - 0.005);\r\n    console.log(new BigNumber(1.005).minus(0.005));\r\n\r\n    console.log(new BigNumber(1.005).round(4));\r\n    console.log(new BigNumber(1.005).round(3));\r\n    console.log(new BigNumber(1.005).round(2));\r\n    console.log(new BigNumber(1.005).round(1));\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bignumber.js/2.3.0/bignumber.min.js&quot;&gt;&lt;/script&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision\r\n  [2]: https://softwareengineering.stackexchange.com/questions/101163/what-causes-floating-point-rounding-errors\r\n  [3]: https://github.com/MikeMcl/bignumber.js/"},{"score":2,"body_markdown":"Starting from the example proposed over the [**precisionRound**][1] that I found on [MDN][2]&#160;(that event for 1.005 returs 1 and not 1.01), I write a custom **precisionRound** that manage a random precision number and for 1.005 returns 1.01.\r\n\r\nThis is the function:\r\n\r\n    function precisionRound(number, precision)\r\n    {\r\n    &#160; if(precision &lt; 0)\r\n      {\r\n    &#160; &#160; var factor = Math.pow(10, precision);\r\n    &#160; &#160; return Math.round(number * factor) / factor;\r\n    &#160; }\r\n    &#160; else\r\n    &#160; &#160; return +(Math.round(number + &quot;e+&quot;+precision)&#160; + &quot;e-&quot;+precision);\r\n    }\r\n    \r\n    console.log(precisionRound(1234.5678, 1));  // output: 1234.6\r\n    console.log(precisionRound(1234.5678, -1)); // output: 1230\r\n    console.log(precisionRound(1.005, 2));      // output: 1.01\r\n    console.log(precisionRound(1.0005, 2));     // output: 1\r\n    console.log(precisionRound(1.0005, 3));     // output: 1.001\r\n    console.log(precisionRound(1.0005, 4));     // output: 1.0005\r\n\r\nFor TypeScript:\r\n\r\n    public static precisionRound(number: number, precision: number)\r\n    {\r\n      if (precision &lt; 0)\r\n      {\r\n        let factor = Math.pow(10, precision);\r\n        return Math.round(number * factor) / factor;\r\n      }\r\n      else\r\n        return +(Math.round(Number(number + &quot;e+&quot; + precision)) +\r\n          &quot;e-&quot; + precision);\r\n    }\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\r\n  [2]: https://developer.mozilla.org/en-US/\r\n"},{"score":30,"body_markdown":"In general, decimal rounding is done by scaling: `round(num * p) / p`\r\n\r\n**Naive implementation**\r\n\r\nUsing the following function with halfway numbers, you will get either the upper rounded value as expected, or the lower rounded value sometimes depending on the input.\r\n\r\nThis `inconsistency` in rounding may introduce hard to detect bugs in the client code.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function naiveRound(num, decimalPlaces = 0) {\r\n        var p = Math.pow(10, decimalPlaces);\r\n        return Math.round(num * p) / p;\r\n    }\r\n\r\n    console.log( naiveRound(1.245, 2) );  // 1.25 correct (rounded as expected)\r\n    console.log( naiveRound(1.255, 2) );  // 1.25 incorrect (should be 1.26)\r\n\r\n    // testing edge cases\r\n    console.log( naiveRound(1.005, 2) );  // 1    incorrect (should be 1.01)\r\n    console.log( naiveRound(2.175, 2) );  // 2.17 incorrect (should be 2.18)\r\n    console.log( naiveRound(5.015, 2) );  // 5.01 incorrect (should be 5.02)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**Better implementations**\r\n\r\n**Exponential notation**\r\n\r\nBy converting the number to a string in the exponential notation, positive numbers are rounded as expected.\r\nBut, be aware that negative numbers round differently than positive numbers.\r\n\r\nIn fact, it performs what is basically equivalent to [&quot;round half up&quot;](http://en.wikipedia.org/wiki/Rounding#Round_half_up) as the rule, you will see that `round(-1.005, 2)` evaluates to `-1` even though `round(1.005, 2)` evaluates to `1.01`. The [lodash](https://lodash.com/docs/4.17.15#round) _.round method uses this technique.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    /**\r\n     * Round half up (&#39;round half towards positive infinity&#39;)\r\n     * Uses exponential notation to avoid floating-point issues.\r\n     * Negative numbers round differently than positive numbers.\r\n     */\r\n    function round(num, decimalPlaces = 0) {\r\n        num = Math.round(num + &quot;e&quot; + decimalPlaces);\r\n        return Number(num + &quot;e&quot; + -decimalPlaces);\r\n    }\r\n\r\n    // test rounding of half\r\n    console.log( round(0.5, 0) );  // 1\r\n    console.log( round(-0.5, 0) ); // 0\r\n\r\n    // testing edge cases\r\n    console.log( round(1.005, 2) );   // 1.01\r\n    console.log( round(2.175, 2) );   // 2.18\r\n    console.log( round(5.015, 2) );   // 5.02\r\n\r\n    console.log( round(-1.005, 2) );  // -1\r\n    console.log( round(-2.175, 2) );  // -2.17\r\n    console.log( round(-5.015, 2) );  // -5.01\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf you want the usual behavior when rounding negative numbers, you would need to convert negative numbers to positive before calling [Math.round()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round), and then convert them back to negative numbers before returning.\r\n\r\n    // Round half away from zero\r\n    function round(num, decimalPlaces = 0) {\r\n        num = Math.round(Math.abs(num) + &quot;e&quot; + decimalPlaces) * Math.sign(num);\r\n        return Number(num + &quot;e&quot; + -decimalPlaces);\r\n    }\r\n\r\n**Number.EPSILON**\r\n\r\nThere is a different purely mathematical technique to perform round-to-nearest (using [&quot;round half away from zero&quot;](http://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero)), in which epsilon correction is applied before calling the rounding function.\r\n\r\nSimply, we add the smallest possible float value (= 1.0 ulp; unit in the last place) to the product before rounding. This moves to the next representable float value, away from zero.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    /**\r\n     * Round half away from zero (&#39;commercial&#39; rounding)\r\n     * Uses correction to offset floating-point inaccuracies.\r\n     * Works symmetrically for positive and negative numbers.\r\n     */\r\n    function round(num, decimalPlaces = 0) {\r\n        var p = Math.pow(10, decimalPlaces);\r\n        var m = (num * p) * (1 + Number.EPSILON);\r\n        return Math.round(m) / p;\r\n    }\r\n\r\n    // test rounding of half\r\n    console.log( round(0.5, 0) );  // 1\r\n    console.log( round(-0.5, 0) ); // -1\r\n\r\n    // testing edge cases\r\n    console.log( round(1.005, 2) );  // 1.01\r\n    console.log( round(2.175, 2) );  // 2.18\r\n    console.log( round(5.015, 2) );  // 5.02\r\n\r\n    console.log( round(-1.005, 2) ); // -1.01\r\n    console.log( round(-2.175, 2) ); // -2.18\r\n    console.log( round(-5.015, 2) ); // -5.02\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThis is needed to offset the implicit [round-off error](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems) that may occur during encoding of decimal numbers, particularly those  having &quot;5&quot; in the last decimal position, like 1.005, 2.675 and 16.235. Actually, `1.005` in decimal system is encoded to `1.0049999999999999` in 64-bit binary float; while, `1234567.005` in decimal system is encoded to `1234567.0049999998882413` in 64-bit binary float.\r\n\r\nIt is worth noting that the maximum binary `round-off error` is dependent upon (1) the magnitude of the number and (2) the relative machine epsilon (2^-52).\r\n\r\n**Double rounding**\r\n\r\nHere, we use the [toPrecision()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision) method to strip the floating-point round-off errors in the intermediate calculations. Simply, we round to 15 [significant figures](https://en.wikipedia.org/wiki/Significant_figures) to strip the round-off error at the 16th significant digit. This technique to preround the result to significant digits is also used by **PHP 7** [round](https://github.com/php/php-src/blob/PHP-7.4.10/ext/standard/math.c#L127-L206) function.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // Round half away from zero\r\n    function round(num, decimalPlaces = 0) {\r\n        var p = Math.pow(10, decimalPlaces);\r\n        var m = Number((Math.abs(num) * p).toPrecision(15));\r\n        return Math.round(m) / p * Math.sign(num);\r\n    }\r\n\r\n    // test rounding of half\r\n    console.log( round(0.5, 0) );  // 1\r\n    console.log( round(-0.5, 0) ); // -1\r\n\r\n    // testing edge cases\r\n    console.log( round(1.005, 2) );  // 1.01\r\n    console.log( round(2.175, 2) );  // 2.18\r\n    console.log( round(5.015, 2) );  // 5.02\r\n\r\n    console.log( round(-1.005, 2) ); // -1.01\r\n    console.log( round(-2.175, 2) ); // -2.18\r\n    console.log( round(-5.015, 2) ); // -5.02\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**Arbitrary-precision JavaScript library** - [decimal.js](https://mikemcl.github.io/decimal.js/)\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // Round half away from zero\r\n    function round(num, decimalPlaces = 0) {\r\n        return new Decimal(num).toDecimalPlaces(decimalPlaces).toNumber();\r\n    }\r\n\r\n    // test rounding of half\r\n    console.log( round(0.5, 0) );  // 1\r\n    console.log( round(-0.5, 0) ); // -1\r\n\r\n    // testing edge cases\r\n    console.log( round(1.005, 2) );  // 1.01\r\n    console.log( round(2.175, 2) );  // 2.18\r\n    console.log( round(5.015, 2) );  // 5.02\r\n\r\n    console.log( round(-1.005, 2) ); // -1.01\r\n    console.log( round(-2.175, 2) ); // -2.18\r\n    console.log( round(-5.015, 2) ); // -5.02\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/decimal.js/10.2.1/decimal.js&quot; integrity=&quot;sha512-GKse2KVGCCMVBn4riigHjXE8j5hCxYLPXDw8AvcjUtrt+a9TbZFtIKGdArXwYOlZvdmkhQLWQ46ZE3Q1RIa7uQ==&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n**Solution 1: string in exponential notation**\r\n\r\nInspired by the solution provided by KFish here: https://stackoverflow.com/a/55521592/4208440\r\n\r\nA simple drop in solution that provides accurate decimal rounding, flooring, and ceiling to a specific number of decimal places without adding a whole library. It treats floats more like decimals by fixing the binary rounding issues to avoid unexpected results: for example, floor((0.1+0.7)*10) will return the expected result 8.\r\n\r\nNumbers are rounded to a specific number of fractional digits. Specifying a negative precision will round to any number of places to the left of the decimal point.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // Solution 1\r\n    var DecimalPrecision = (function() {\r\n        if (Math.sign === undefined) {\r\n            Math.sign = function(x) {\r\n                return ((x &gt; 0) - (x &lt; 0)) || +x;\r\n            };\r\n        }\r\n        if (Math.trunc === undefined) {\r\n            Math.trunc = function(v) {\r\n                return v &lt; 0 ? Math.ceil(v) : Math.floor(v);\r\n            };\r\n        }\r\n        var decimalAdjust = function(type, num, decimalPlaces) {\r\n            var shift = function(value, exponent) {\r\n                value = (value + &#39;e&#39;).split(&#39;e&#39;);\r\n                return +(value[0] + &#39;e&#39; + (+value[1] + (exponent || 0)));\r\n            };\r\n            var n = type === &#39;round&#39; ? Math.abs(num) : num;\r\n            var m = shift(n, +decimalPlaces);\r\n            var r = shift(Math[type](m), -decimalPlaces);\r\n            return type === &#39;round&#39; ? Math.sign(num) * r : r;\r\n        };\r\n        return {\r\n            // Decimal round (half away from zero)\r\n            round: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;round&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal ceil\r\n            ceil: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;ceil&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal floor\r\n            floor: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;floor&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal trunc\r\n            trunc: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;trunc&#39;, num, decimalPlaces);\r\n            },\r\n            // Format using fixed-point notation\r\n            toFixed: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;round&#39;, num, decimalPlaces).toFixed(decimalPlaces);\r\n            }\r\n        };\r\n    })();\r\n\r\n    // test rounding of half\r\n    console.log(DecimalPrecision.round(0.5));  // 1\r\n    console.log(DecimalPrecision.round(-0.5)); // -1\r\n\r\n    // testing very small numbers\r\n    console.log(DecimalPrecision.ceil(1e-8, 2) === 0.01);         // 0.01\r\n    console.log(DecimalPrecision.floor(1e-8, 2) === 0);              // 0\r\n\r\n    // testing simple cases\r\n    console.log(DecimalPrecision.round(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision.round(-5.12, 1) === -5.1);       // -5.1\r\n    console.log(DecimalPrecision.ceil(5.12, 1) === 5.2);           // 5.2\r\n    console.log(DecimalPrecision.ceil(-5.12, 1) === -5.1);        // -5.1\r\n    console.log(DecimalPrecision.floor(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision.floor(-5.12, 1) === -5.2);       // -5.2\r\n    console.log(DecimalPrecision.trunc(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision.trunc(-5.12, 1) === -5.1);       // -5.1\r\n\r\n    // testing edge cases for round\r\n    console.log(DecimalPrecision.round(1.005, 2) === 1.01);       // 1.01\r\n    console.log(DecimalPrecision.round(39.425, 2) === 39.43);    // 39.43\r\n    console.log(DecimalPrecision.round(-1.005, 2) === -1.01);    // -1.01\r\n    console.log(DecimalPrecision.round(-39.425, 2) === -39.43); // -39.43\r\n\r\n    // testing edge cases for ceil\r\n    console.log(DecimalPrecision.ceil(9.130, 2) === 9.13);        // 9.13\r\n    console.log(DecimalPrecision.ceil(65.180, 2) === 65.18);     // 65.18\r\n    console.log(DecimalPrecision.ceil(-2.260, 2) === -2.26);     // -2.26\r\n    console.log(DecimalPrecision.ceil(-18.150, 2) === -18.15);  // -18.15\r\n\r\n    // testing edge cases for floor\r\n    console.log(DecimalPrecision.floor(2.260, 2) === 2.26);       // 2.26\r\n    console.log(DecimalPrecision.floor(18.150, 2) === 18.15);    // 18.15\r\n    console.log(DecimalPrecision.floor(-9.130, 2) === -9.13);    // -9.13\r\n    console.log(DecimalPrecision.floor(-65.180, 2) === -65.18); // -65.18\r\n\r\n    // testing edge cases for trunc\r\n    console.log(DecimalPrecision.trunc(2.260, 2) === 2.26);       // 2.26\r\n    console.log(DecimalPrecision.trunc(18.150, 2) === 18.15);    // 18.15\r\n    console.log(DecimalPrecision.trunc(-2.260, 2) === -2.26);    // -2.26\r\n    console.log(DecimalPrecision.trunc(-18.150, 2) === -18.15); // -18.15\r\n\r\n    // testing round to tens and hundreds\r\n    console.log(DecimalPrecision.round(1262.48, -1) === 1260);    // 1260\r\n    console.log(DecimalPrecision.round(1262.48, -2) === 1300);    // 1300\r\n\r\n    // testing toFixed()\r\n    console.log(DecimalPrecision.toFixed(1.005, 2) === &quot;1.01&quot;);   // &quot;1.01&quot;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n**Solution 2: purely mathematical (Number.EPSILON)**\r\n\r\nThis solution avoids any string conversion / manipulation of any kind for performance reasons.\r\n\r\n`Solution 1: 25,838 ops/sec`\r\n\r\n`Solution 2: 655,087 ops/sec`\r\n\r\nhttp://jsbench.github.io/#31ec3a8b3d22bd840f8e6822e681a3ac\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // Solution 2\r\n    var DecimalPrecision2 = (function() {\r\n        if (Number.EPSILON === undefined) {\r\n            Number.EPSILON = Math.pow(2, -52);\r\n        }\r\n        if (Math.trunc === undefined) {\r\n            Math.trunc = function(v) {\r\n                return v &lt; 0 ? Math.ceil(v) : Math.floor(v);\r\n            };\r\n        }\r\n        var isRound = function(num, decimalPlaces) {\r\n            //return decimalPlaces &gt;= 0 &amp;&amp;\r\n            //    +num.toFixed(decimalPlaces) === num;\r\n            var p = Math.pow(10, decimalPlaces);\r\n            return Math.round(num * p) / p === num;\r\n        };\r\n        var decimalAdjust = function(type, num, decimalPlaces) {\r\n            if (isRound(num, decimalPlaces || 0))\r\n                return num;\r\n            var p = Math.pow(10, decimalPlaces || 0);\r\n            var m = (num * p) * (1 + Number.EPSILON);\r\n            return Math[type](m) / p;\r\n        };\r\n        return {\r\n            // Decimal round (half away from zero)\r\n            round: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;round&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal ceil\r\n            ceil: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;ceil&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal floor\r\n            floor: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;floor&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal trunc\r\n            trunc: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;trunc&#39;, num, decimalPlaces);\r\n            },\r\n            // Format using fixed-point notation\r\n            toFixed: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;round&#39;, num, decimalPlaces).toFixed(decimalPlaces);\r\n            }\r\n        };\r\n    })();\r\n\r\n    // test rounding of half\r\n    console.log(DecimalPrecision2.round(0.5));  // 1\r\n    console.log(DecimalPrecision2.round(-0.5)); // -1\r\n\r\n    // testing very small numbers\r\n    console.log(DecimalPrecision2.ceil(1e-8, 2) === 0.01);         // 0.01\r\n    console.log(DecimalPrecision2.floor(1e-8, 2) === 0);              // 0\r\n\r\n    // testing simple cases\r\n    console.log(DecimalPrecision2.round(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision2.round(-5.12, 1) === -5.1);       // -5.1\r\n    console.log(DecimalPrecision2.ceil(5.12, 1) === 5.2);           // 5.2\r\n    console.log(DecimalPrecision2.ceil(-5.12, 1) === -5.1);        // -5.1\r\n    console.log(DecimalPrecision2.floor(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision2.floor(-5.12, 1) === -5.2);       // -5.2\r\n    console.log(DecimalPrecision2.trunc(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision2.trunc(-5.12, 1) === -5.1);       // -5.1\r\n\r\n    // testing edge cases for round\r\n    console.log(DecimalPrecision2.round(1.005, 2) === 1.01);       // 1.01\r\n    console.log(DecimalPrecision2.round(39.425, 2) === 39.43);    // 39.43\r\n    console.log(DecimalPrecision2.round(-1.005, 2) === -1.01);    // -1.01\r\n    console.log(DecimalPrecision2.round(-39.425, 2) === -39.43); // -39.43\r\n\r\n    // testing edge cases for ceil\r\n    console.log(DecimalPrecision2.ceil(9.130, 2) === 9.13);        // 9.13\r\n    console.log(DecimalPrecision2.ceil(65.180, 2) === 65.18);     // 65.18\r\n    console.log(DecimalPrecision2.ceil(-2.260, 2) === -2.26);     // -2.26\r\n    console.log(DecimalPrecision2.ceil(-18.150, 2) === -18.15);  // -18.15\r\n\r\n    // testing edge cases for floor\r\n    console.log(DecimalPrecision2.floor(2.260, 2) === 2.26);       // 2.26\r\n    console.log(DecimalPrecision2.floor(18.150, 2) === 18.15);    // 18.15\r\n    console.log(DecimalPrecision2.floor(-9.130, 2) === -9.13);    // -9.13\r\n    console.log(DecimalPrecision2.floor(-65.180, 2) === -65.18); // -65.18\r\n\r\n    // testing edge cases for trunc\r\n    console.log(DecimalPrecision2.trunc(2.260, 2) === 2.26);       // 2.26\r\n    console.log(DecimalPrecision2.trunc(18.150, 2) === 18.15);    // 18.15\r\n    console.log(DecimalPrecision2.trunc(-2.260, 2) === -2.26);    // -2.26\r\n    console.log(DecimalPrecision2.trunc(-18.150, 2) === -18.15); // -18.15\r\n\r\n    // testing round to tens and hundreds\r\n    console.log(DecimalPrecision2.round(1262.48, -1) === 1260);    // 1260\r\n    console.log(DecimalPrecision2.round(1262.48, -2) === 1300);    // 1300\r\n\r\n    // testing toFixed()\r\n    console.log(DecimalPrecision2.toFixed(1.005, 2) === &quot;1.01&quot;);   // &quot;1.01&quot;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n**Solution 3: double rounding**\r\n\r\nThis solution uses the [toPrecision()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision) method to strip the floating-point round-off errors.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // Solution 3\r\n    var DecimalPrecision3 = (function() {\r\n        if (Math.sign === undefined) {\r\n            Math.sign = function(x) {\r\n                return ((x &gt; 0) - (x &lt; 0)) || +x;\r\n            };\r\n        }\r\n        if (Math.trunc === undefined) {\r\n            Math.trunc = function(v) {\r\n                return v &lt; 0 ? Math.ceil(v) : Math.floor(v);\r\n            };\r\n        }\r\n        // Eliminate binary floating-point inaccuracies.\r\n        var stripError = function(num) {\r\n            if (Number.isInteger(num))\r\n                return num;\r\n            return parseFloat(num.toPrecision(15));\r\n        };\r\n        var decimalAdjust = function(type, num, decimalPlaces) {\r\n            var n = type === &#39;round&#39; ? Math.abs(num) : num;\r\n            var p = Math.pow(10, decimalPlaces || 0);\r\n            var m = stripError(n * p);\r\n            var r = Math[type](m) / p;\r\n            return type === &#39;round&#39; ? Math.sign(num) * r : r;\r\n        };\r\n        return {\r\n            // Decimal round (half away from zero)\r\n            round: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;round&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal ceil\r\n            ceil: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;ceil&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal floor\r\n            floor: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;floor&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal trunc\r\n            trunc: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;trunc&#39;, num, decimalPlaces);\r\n            },\r\n            // Format using fixed-point notation\r\n            toFixed: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;round&#39;, num, decimalPlaces).toFixed(decimalPlaces);\r\n            }\r\n        };\r\n    })();\r\n\r\n    // test rounding of half\r\n    console.log(DecimalPrecision3.round(0.5));  // 1\r\n    console.log(DecimalPrecision3.round(-0.5)); // -1\r\n\r\n    // testing very small numbers\r\n    console.log(DecimalPrecision3.ceil(1e-8, 2) === 0.01);         // 0.01\r\n    console.log(DecimalPrecision3.floor(1e-8, 2) === 0);              // 0\r\n\r\n    // testing simple cases\r\n    console.log(DecimalPrecision3.round(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision3.round(-5.12, 1) === -5.1);       // -5.1\r\n    console.log(DecimalPrecision3.ceil(5.12, 1) === 5.2);           // 5.2\r\n    console.log(DecimalPrecision3.ceil(-5.12, 1) === -5.1);        // -5.1\r\n    console.log(DecimalPrecision3.floor(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision3.floor(-5.12, 1) === -5.2);       // -5.2\r\n    console.log(DecimalPrecision3.trunc(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision3.trunc(-5.12, 1) === -5.1);       // -5.1\r\n\r\n    // testing edge cases for round\r\n    console.log(DecimalPrecision3.round(1.005, 2) === 1.01);       // 1.01\r\n    console.log(DecimalPrecision3.round(39.425, 2) === 39.43);    // 39.43\r\n    console.log(DecimalPrecision3.round(-1.005, 2) === -1.01);    // -1.01\r\n    console.log(DecimalPrecision3.round(-39.425, 2) === -39.43); // -39.43\r\n\r\n    // testing edge cases for ceil\r\n    console.log(DecimalPrecision3.ceil(9.130, 2) === 9.13);        // 9.13\r\n    console.log(DecimalPrecision3.ceil(65.180, 2) === 65.18);     // 65.18\r\n    console.log(DecimalPrecision3.ceil(-2.260, 2) === -2.26);     // -2.26\r\n    console.log(DecimalPrecision3.ceil(-18.150, 2) === -18.15);  // -18.15\r\n\r\n    // testing edge cases for floor\r\n    console.log(DecimalPrecision3.floor(2.260, 2) === 2.26);       // 2.26\r\n    console.log(DecimalPrecision3.floor(18.150, 2) === 18.15);    // 18.15\r\n    console.log(DecimalPrecision3.floor(-9.130, 2) === -9.13);    // -9.13\r\n    console.log(DecimalPrecision3.floor(-65.180, 2) === -65.18); // -65.18\r\n\r\n    // testing edge cases for trunc\r\n    console.log(DecimalPrecision3.trunc(2.260, 2) === 2.26);       // 2.26\r\n    console.log(DecimalPrecision3.trunc(18.150, 2) === 18.15);    // 18.15\r\n    console.log(DecimalPrecision3.trunc(-2.260, 2) === -2.26);    // -2.26\r\n    console.log(DecimalPrecision3.trunc(-18.150, 2) === -18.15); // -18.15\r\n\r\n    // testing round to tens and hundreds\r\n    console.log(DecimalPrecision3.round(1262.48, -1) === 1260);    // 1260\r\n    console.log(DecimalPrecision3.round(1262.48, -2) === 1300);    // 1300\r\n\r\n    // testing toFixed()\r\n    console.log(DecimalPrecision3.toFixed(1.005, 2) === &quot;1.01&quot;);   // &quot;1.01&quot;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n**Solution 4: double rounding v2**\r\n\r\nThis solution is just like Solution 3, however it uses a custom `toPrecision()` function.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // Solution 4\r\n    var DecimalPrecision4 = (function() {\r\n        if (Math.sign === undefined) {\r\n            Math.sign = function(x) {\r\n                return ((x &gt; 0) - (x &lt; 0)) || +x;\r\n            };\r\n        }\r\n        if (Math.trunc === undefined) {\r\n            Math.trunc = function(v) {\r\n                return v &lt; 0 ? Math.ceil(v) : Math.floor(v);\r\n            };\r\n        }\r\n        var toPrecision = function(num, significantDigits) {\r\n            // Return early for &#177;0, NaN and Infinity.\r\n            if (!num || !Number.isFinite(num))\r\n                return num;\r\n            // Compute shift of the decimal point.\r\n            var shift = significantDigits - 1 - Math.floor(Math.log10(Math.abs(num)));\r\n            // Return if rounding to the same or higher precision.\r\n            var decimalPlaces = 0;\r\n            for (var p = 1; !Number.isInteger(num * p); p *= 10) decimalPlaces++;\r\n            if (shift &gt;= decimalPlaces)\r\n                return num;\r\n            // Round to sf-1 fractional digits of normalized mantissa x.dddd\r\n            var scale = Math.pow(10, Math.abs(shift));\r\n            return shift &gt; 0 ?\r\n                Math.round(num * scale) / scale :\r\n                Math.round(num / scale) * scale;\r\n        };\r\n        // Eliminate binary floating-point inaccuracies.\r\n        var stripError = function(num) {\r\n            if (Number.isInteger(num))\r\n                return num;\r\n            return toPrecision(num, 15);\r\n        };\r\n        var decimalAdjust = function(type, num, decimalPlaces) {\r\n            var n = type === &#39;round&#39; ? Math.abs(num) : num;\r\n            var p = Math.pow(10, decimalPlaces || 0);\r\n            var m = stripError(n * p);\r\n            var r = Math[type](m) / p;\r\n            return type === &#39;round&#39; ? Math.sign(num) * r : r;\r\n        };\r\n        return {\r\n            // Decimal round (half away from zero)\r\n            round: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;round&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal ceil\r\n            ceil: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;ceil&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal floor\r\n            floor: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;floor&#39;, num, decimalPlaces);\r\n            },\r\n            // Decimal trunc\r\n            trunc: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;trunc&#39;, num, decimalPlaces);\r\n            },\r\n            // Format using fixed-point notation\r\n            toFixed: function(num, decimalPlaces) {\r\n                return decimalAdjust(&#39;round&#39;, num, decimalPlaces).toFixed(decimalPlaces);\r\n            }\r\n        };\r\n    })();\r\n\r\n    // test rounding of half\r\n    console.log(DecimalPrecision4.round(0.5));  // 1\r\n    console.log(DecimalPrecision4.round(-0.5)); // -1\r\n\r\n    // testing very small numbers\r\n    console.log(DecimalPrecision4.ceil(1e-8, 2) === 0.01);         // 0.01\r\n    console.log(DecimalPrecision4.floor(1e-8, 2) === 0);              // 0\r\n\r\n    // testing simple cases\r\n    console.log(DecimalPrecision4.round(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision4.round(-5.12, 1) === -5.1);       // -5.1\r\n    console.log(DecimalPrecision4.ceil(5.12, 1) === 5.2);           // 5.2\r\n    console.log(DecimalPrecision4.ceil(-5.12, 1) === -5.1);        // -5.1\r\n    console.log(DecimalPrecision4.floor(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision4.floor(-5.12, 1) === -5.2);       // -5.2\r\n    console.log(DecimalPrecision4.trunc(5.12, 1) === 5.1);          // 5.1\r\n    console.log(DecimalPrecision4.trunc(-5.12, 1) === -5.1);       // -5.1\r\n\r\n    // testing edge cases for round\r\n    console.log(DecimalPrecision4.round(1.005, 2) === 1.01);       // 1.01\r\n    console.log(DecimalPrecision4.round(39.425, 2) === 39.43);    // 39.43\r\n    console.log(DecimalPrecision4.round(-1.005, 2) === -1.01);    // -1.01\r\n    console.log(DecimalPrecision4.round(-39.425, 2) === -39.43); // -39.43\r\n\r\n    // testing edge cases for ceil\r\n    console.log(DecimalPrecision4.ceil(9.130, 2) === 9.13);        // 9.13\r\n    console.log(DecimalPrecision4.ceil(65.180, 2) === 65.18);     // 65.18\r\n    console.log(DecimalPrecision4.ceil(-2.260, 2) === -2.26);     // -2.26\r\n    console.log(DecimalPrecision4.ceil(-18.150, 2) === -18.15);  // -18.15\r\n\r\n    // testing edge cases for floor\r\n    console.log(DecimalPrecision4.floor(2.260, 2) === 2.26);       // 2.26\r\n    console.log(DecimalPrecision4.floor(18.150, 2) === 18.15);    // 18.15\r\n    console.log(DecimalPrecision4.floor(-9.130, 2) === -9.13);    // -9.13\r\n    console.log(DecimalPrecision4.floor(-65.180, 2) === -65.18); // -65.18\r\n\r\n    // testing edge cases for trunc\r\n    console.log(DecimalPrecision4.trunc(2.260, 2) === 2.26);       // 2.26\r\n    console.log(DecimalPrecision4.trunc(18.150, 2) === 18.15);    // 18.15\r\n    console.log(DecimalPrecision4.trunc(-2.260, 2) === -2.26);    // -2.26\r\n    console.log(DecimalPrecision4.trunc(-18.150, 2) === -18.15); // -18.15\r\n\r\n    // testing round to tens and hundreds\r\n    console.log(DecimalPrecision4.round(1262.48, -1) === 1260);    // 1260\r\n    console.log(DecimalPrecision4.round(1262.48, -2) === 1300);    // 1300\r\n\r\n    // testing toFixed()\r\n    console.log(DecimalPrecision4.toFixed(1.005, 2) === &quot;1.01&quot;);   // &quot;1.01&quot;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nBenchmarks\r\n-\r\nhttp://jsbench.github.io/#31ec3a8b3d22bd840f8e6822e681a3ac\r\n\r\nHere is a benchmark comparing the operations per second in the solutions above on Chrome 85.0.4183.83. Obviously all browsers differ, so your mileage may vary.\r\n\r\n[![Benchmark comparison][1]][1]\r\n(Note: More is better)\r\n\r\nThanks @Mike for adding a screenshot of the benchmark.\r\n\r\n  [1]: https://i.stack.imgur.com/llFZn.png\r\n\r\n"},{"score":1,"body_markdown":"In the node environment I just use the [roundTo][1] module:\r\n\r\n\r\n    const roundTo = require(&#39;round-to&#39;);\r\n    ...\r\n    roundTo(123.4567, 2);\r\n    \r\n    // 123.46\r\n\r\n\r\n\r\n  [1]: https://www.npmjs.com/package/round-to"},{"score":13,"body_markdown":"Use something like this \r\n&quot;parseFloat(parseFloat(value).toFixed(2))&quot; \r\n \r\n\r\n    parseFloat(parseFloat(&quot;1.7777777&quot;).toFixed(2))--&gt;1.78 \r\n    parseFloat(parseFloat(&quot;10&quot;).toFixed(2))--&gt;10 \r\n    parseFloat(parseFloat(&quot;9.1&quot;).toFixed(2))--&gt;9.1"},{"score":35,"body_markdown":"For me [Math.round()][1] was not giving correct answer. I found [toFixed(2)][2] works better. \r\nBelow are examples of both:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    console.log(Math.round(43000 / 80000) * 100); // wrong answer\r\n\r\n    console.log(((43000 / 80000) * 100).toFixed(2)); // correct answer\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed"},{"score":2,"body_markdown":"From the existing answers I found another solution which seems to work great, which also works with sending in a string and eliminates trailing zeros.\r\n\r\n    function roundToDecimal(string, decimals) {\r\n        return parseFloat(parseFloat(string).toFixed(decimals));\r\n    }\r\n\r\nIt doesn&#39;t take in to account if you send in some bull.. like &quot;apa&quot; though. Or it will probably throw an error which I think is the proper way anyway, it&#39;s never good to hide errors that should be fixed (by the calling function). "},{"score":0,"body_markdown":"Using Brian Ustas&#39;s solution:\r\n\r\n    function roundDecimal(value, precision) {\r\n        var multiplier = Math.pow(10, precision);\r\n        return Math.round(value * multiplier) / multiplier;\r\n    }"},{"score":6,"body_markdown":"This did the trick for me (TypeScript):\r\n\r\n    round(decimal: number, decimalPoints: number): number{\r\n        let roundedValue = Math.round(decimal * Math.pow(10, decimalPoints)) / Math.pow(10, decimalPoints);\r\n\r\n        console.log(`Rounded ${decimal} to ${roundedValue}`);\r\n        return roundedValue;\r\n    }\r\n\r\n    // Sample output:\r\n    Rounded 18.339840000000436 to 18.34\r\n    Rounded 52.48283999999984 to 52.48\r\n    Rounded 57.24612000000036 to 57.25\r\n    Rounded 23.068320000000142 to 23.07\r\n    Rounded 7.792980000000398 to 7.79\r\n    Rounded 31.54157999999981 to 31.54\r\n    Rounded 36.79686000000004 to 36.8\r\n    Rounded 34.723080000000124 to 34.72\r\n    Rounded 8.4375 to 8.44\r\n    Rounded 15.666960000000074 to 15.67\r\n    Rounded 29.531279999999924 to 29.53\r\n    Rounded 8.277420000000006 to 8.28"},{"score":4,"body_markdown":"I was building a simple tipCalculator and there was a lot of answers here that seem to overcomplicate the issue. So I found summarizing the issue to be the best way to truly answer this question\r\n\r\nif you want to create a rounded decimal number, first you call `toFixed(# of decimal places you want to keep)` and then wrap that in a Number() \r\n\r\nso end result:\r\n\r\n    let amountDue = 286.44;\r\n    tip = Number((amountDue * 0.2).toFixed(2));\r\n    console.log(tip)  // 57.29 instead of 57.288\r\n\r\n\r\n\r\n"},{"score":7,"body_markdown":"Simple solution would be use lodash&#39;s ceil function if you want to round up...\r\n\r\nhttps://lodash.com/docs/4.17.10#ceil\r\n\r\n    _.round(6.001,2)\r\ngives 6\r\n\r\n    _.ceil(6.001,&#160;2);\r\n\r\ngives 6.01\r\n\r\n    _.ceil(37.4929,2);\r\n\r\ngives 37.5\r\n\r\n    _.round(37.4929,2);\r\n\r\ngives 37.49\r\n"},{"score":3,"body_markdown":"The rounding problem can be avoided by using numbers represented in exponential notation.\r\n\r\n    public roundFinancial(amount: number, decimals: number) {\r\n        return Number(Math.round(Number(`${amount}e${decimals}`)) + `e-${decimals}`);\r\n    }"},{"score":1,"body_markdown":"This answer is more about speed. \r\n\r\n\r\n    var precalculatedPrecisions = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10];\r\n\r\n    function round(num, _prec) {\r\n        _precision = precalculatedPrecisions[_prec]\r\n        return Math.round(num * _precision + 1e-14) / _precision ;\r\n    }\r\n\r\n[jsPerf][1] about this.\r\n\r\n\r\n  [1]: https://jsperf.com/round-with-precisions-diffs"},{"score":2,"body_markdown":"This worked pretty well for me when wanting to always round up to a certain decimal.  The key here is that we will always be rounding up with the Math.ceil function.\r\n\r\nYou could conditionally select ceil or floor if needed.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n         /**\r\n         * Possibility to lose precision at large numbers\r\n         * @param number\r\n         * @returns Number number\r\n         */\r\n        var roundUpToNearestHundredth = function(number) {\r\n\r\n            // Ensure that we use high precision Number\r\n            number = Number(number);\r\n\r\n            // Save the original number so when we extract the Hundredth decimal place we don&#39;t bit switch or lose precision\r\n            var numberSave = Number(number.toFixed(0));\r\n\r\n            // Remove the &quot;integer&quot; values off the top of the number\r\n            number = number - numberSave;\r\n\r\n            // Get the Hundredth decimal places\r\n            number *= 100;\r\n\r\n            // Ceil the decimals.  Therefore .15000001 will equal .151, etc.\r\n            number = Math.ceil(number);\r\n\r\n            // Put the decimals back into their correct spot\r\n            number /= 100;\r\n\r\n            // Add the &quot;integer&quot; back onto the number\r\n            return number + numberSave;\r\n\r\n        };\r\n\r\n    console.log(roundUpToNearestHundredth(6132423.1200000000001))\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":6,"body_markdown":"Based on the [choosen answer][1] and the [upvoted comment][2] on the same question:\r\n\r\n    Math.round((num + 0.00001) * 100) / 100\r\n\r\nThis works for both these examples:\r\n\r\n    Math.round((1.005 + 0.00001) * 100) / 100\r\n\r\n    Math.round((1.0049 + 0.00001) * 100) / 100\r\n\r\n\r\n  [1]: https://stackoverflow.com/a/11832950/1417223\r\n  [2]: https://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-only-if-necessary#comment26122771_11832950"},{"score":7,"body_markdown":"&gt; parseFloat(&quot;1.555&quot;).toFixed(2); // Returns 1.55 instead of 1.56.\r\n\r\n1.55 is the absolute correct result, because there exists no exact representation of 1.555 in the computer. If reading 1.555 it is rounded to the nearest possible value = 1.55499999999999994 (64 bit float). And rounding this number by toFixed(2) results in 1.55.\r\n\r\nAll other functions provided here give fault result, if the input is 1.55499999999999.\r\n\r\nSolution: Append the digit &quot;5&quot; before scanning to rounding up (more exact: rounding away from 0) the number. Do this only, if the number is really a float (has a decimal point).\r\n\r\n    parseFloat(&quot;1.555&quot;+&quot;5&quot;).toFixed(2); // Returns 1.56\r\n"},{"score":9,"body_markdown":"A different approach is to use a library. Why not `lodash`:\r\n```\r\nconst _ = require(&quot;lodash&quot;)\r\nconst roundedNumber = _.round(originalNumber, 2)\r\n```\r\n"},{"score":2,"body_markdown":"The big challenge on this seemingly simple task is that we want it to yield psychologically expected results even if the input contains minimal rounding errors to start with (not mentioning the errors which will happen within our calculation). If we know that the real result is exactly 1.005, we expect that rounding to two digits yields 1.01, even if the 1.005 is the result of a large computation with loads of rounding errors on the way.\r\n\r\nThe problem becomes even more obvious when dealing with `floor()` instead of `round()`. For example, when cutting everything away after the last two digits behind the dot of 33.3, we would certainly *not* expect to get 33.29 as a result, but that is what happens:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    console.log(Math.floor(33.3 * 100) / 100)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIn simple cases, the solution is to perform calculation on strings instead of floating point numbers, and thus avoid rounding errors completely. However, this option fails at the first non-trivial mathematical operation (including most divsions), and it is slow.\r\n\r\nWhen operating on floating point numbers, the solution is to introduce a parameter which names the amount by which we are willing to deviate from the actual computation result, in order to output the psychologically expected result.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var round = function(num, digits = 2, compensateErrors = 2) {\r\n      if (num &lt; 0) {\r\n        return -this.round(-num, digits, compensateErrors);\r\n      }\r\n      const pow = Math.pow(10, digits);\r\n      return (Math.round(num * pow * (1 + compensateErrors * Number.EPSILON)) / pow);\r\n    }\r\n\r\n    /* --- testing --- */\r\n\r\n    console.log(&quot;Edge cases mentioned in this thread:&quot;)\r\n    var values = [ 0.015, 1.005, 5.555, 156893.145, 362.42499999999995, 1.275, 1.27499, 1.2345678e+2, 2.175, 5.015, 58.9 * 0.15 ];\r\n    values.forEach((n) =&gt; {\r\n      console.log(n + &quot; -&gt; &quot; + round(n));\r\n      console.log(-n + &quot; -&gt; &quot; + round(-n));\r\n    });\r\n\r\n    console.log(&quot;\\nFor numbers which are so large that rounding cannot be performed anyway within computation precision, only string-based computation can help.&quot;)\r\n    console.log(&quot;Standard: &quot; + round(1e+19));\r\n    console.log(&quot;Compensation = 1: &quot; + round(1e+19, 2, 1));\r\n    console.log(&quot;Effectively no compensation: &quot; + round(1e+19, 2, 0.4));\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nNote: Internet Explorer does not know `Number.EPSILON`. If you are in the unhappy position of still having to support it, you can use a shim, or just define the constant yourself for that specific browser family."},{"score":15,"body_markdown":"FINAL UPDATE:\r\n\r\nLeaving this answer here for posterity, but I would recommend using @AmrAli&#39;s adaptation of the DecimalPrecision function, as it is equipped to handle exponential notation as well. I had originally sought to avoid any string conversion/manipulation of any kind for performance reasons, but there is virtually no difference in performance with his implementation.\r\n\r\nEDIT 8/22/2020: I think it should be clarified here that the goal of these efforts is not to completely eliminate the inherent rounding errors caused by the floating point data type, as that will never be possible without switching to a data type that is actually storing the value as a base10 (decimal). The goal really should be to push the inaccuracies as far out to the edge as possible, so that you can perform mathematical operations on a given value without producing the bug. The moment your value hits the absolute edge, where simply invoking the value would cause JS to produce the bug, either before or after you&#39;ve manipulated it, there&#39;s nothing more you could do to alleviate that. For example, if you instantiate the value 0.014999999999999999, JS will immediately round it to 0.015. Therefore if you passed that value to any of these functions, you are actually passing 0.015. At that point you couldn&#39;t even convert to string first and then manipulate it, the value would have to be instantiated as a string from the start for that to work. The goal, and only reasonable expectation, of any functions created to alleviate this bug is simply to allow for mathematical operations to be performed on floating point values while pushing the bug all the way out to the edge where either the starting value, or resulting value would produce the bug simply by being invoked anyway. The only other alternative solutions would be to store the whole numbers and decimal values independently, both as integers, so that they are only ever invoked as such, or to always store the value as a string and use a combination of string manipulation and integer based math to perform operations on it.\r\n\r\nAfter running through various iterations of all the possible ways to achieve true accurate decimal rounding precision, it is clear that the most accurate and efficient solution is to use Number.EPSILON. This provides a true mathematical solution to the problem of floating point math precision. It can be easily polyfilled as shown here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON to support all of the last remaining IE users (then again maybe we should stop doing that). \r\n\r\nAdapted from the solution provided here: https://stackoverflow.com/a/48850944/6910392\r\n\r\nA simple drop in solution that provides accurate decimal rounding, flooring, and ceiling, with an optional precision variable without adding a whole library.\r\n\r\n05-19-2020 UPDATE: As Sergey noted in the comments, there is a limitation to this (or any) method that&#39;s worth pointing out. In the case of numbers like 0.014999999999999999, you will still experience inaccuracies which are the result of hitting the absolute edge of accuracy limitations for floating point value storage. There is no math or other solution that can be applied to account for that, as the value itself is immediately evaluated as 0.015. You can confirm this by simply invoking that value by itself in the console. Due to this limitation, it would not even be possible to use string manipulation to reduce this value, as its string representation is simply &quot;0.015&quot;. Any solution to account for this would need to be applied logically at the source of the data before ever accepting the value into a script, eg restricting the character length of a field etc. That would be a consideration that would need to be taken into account on a case by case basis to determine the best approach.\r\n\r\n08-19-2020 UPDATE: Per Amr&#39;s comment, the ceil and floor functions will produce undesired results when the input value is an integer. This is due to the addition applied to the input with Number.EPSILON in order to offset the expected float inaccuracy. The function has been updated to check if the input value is an integer and return the value unchanged, as that is the correct result of either function when applied to a whole number.\r\n\r\n*Note: This issue also reveals that while the ceil and floor functions still require the application of the Number.EPSILON adjustment, they do produce undesirable results when applied to a value where the number of decimals in the input number is lower than the number of decimals requested for the output (p). For example, ceil(17.1, 5) should return 17.1 in relation to expected &quot;ceil&quot; function behavior when applied to whole numbers in mathematics, where all decimal places after &quot;1&quot; are assumed to be 0. To correct for this, I&#39;ve added an additional function check to identify if the number of decimals in the input number is lower than the requested output decimals, and return the number unchanged, just as with whole numbers. \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var DecimalPrecision = (function(){\r\n            if (Number.EPSILON === undefined) {\r\n                Number.EPSILON = Math.pow(2, -52);\r\n            }\r\n            if(Number.isInteger === undefined){\r\n                Number.isInteger = function(value) {\r\n                    return typeof value === &#39;number&#39; &amp;&amp; \r\n                    isFinite(value) &amp;&amp; \r\n                    Math.floor(value) === value;\r\n                };\r\n            }\r\n            this.isRound = function(n,p){\r\n                let l = n.toString().split(&#39;.&#39;)[1].length;\r\n                return (p &gt;= l);\r\n\t\t\t}\r\n            this.round = function(n, p=2){\r\n                if(Number.isInteger(n) || this.isRound(n,p))\r\n                    return n;\r\n                let r = 0.5 * Number.EPSILON * n;\r\n                let o = 1; while(p-- &gt; 0) o *= 10;\r\n                if(n&lt;0)\r\n                    o *= -1;\r\n                return Math.round((n + r) * o) / o;\r\n            }\r\n            this.ceil = function(n, p=2){\r\n                if(Number.isInteger(n) || this.isRound(n,p))\r\n                    return n;\r\n                let r = 0.5 * Number.EPSILON * n;\r\n                let o = 1; while(p-- &gt; 0) o *= 10;\r\n                \r\n                return Math.ceil((n + r) * o) / o;\r\n            }\r\n            this.floor = function(n, p=2){\r\n                if(Number.isInteger(n) || this.isRound(n,p))\r\n                    return n;\r\n                let r = 0.5 * Number.EPSILON * n;\r\n                let o = 1; while(p-- &gt; 0) o *= 10;\r\n                \r\n                return Math.floor((n + r) * o) / o;\r\n            }\r\n            return this;\r\n        })();\r\n        console.log(DecimalPrecision.round(1.005));\r\n        console.log(DecimalPrecision.ceil(1.005));\r\n        console.log(DecimalPrecision.floor(1.005));\r\n        console.log(DecimalPrecision.round(1.0049999));\r\n        console.log(DecimalPrecision.ceil(1.0049999));\r\n        console.log(DecimalPrecision.floor(1.0049999));\r\n        console.log(DecimalPrecision.round(2.175495134384,7));\r\n        console.log(DecimalPrecision.round(2.1753543549,8));\r\n        console.log(DecimalPrecision.round(2.1755465135353,4));\r\n        console.log(DecimalPrecision.ceil(17,4));\r\n        console.log(DecimalPrecision.ceil(17.1,4));\r\n        console.log(DecimalPrecision.ceil(17.1,15));\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":2,"body_markdown":"Here&#39;s my solution to this problem:&lt;br&gt;\r\n\r\n    function roundNumber(number, precision = 0) {\r\n    var num = number.toString().replace(&quot;,&quot;, &quot;&quot;);\r\n    var integer, decimal, significantDigit;\r\n\r\n    if (num.indexOf(&quot;.&quot;) &gt; 0 &amp;&amp; num.substring(num.indexOf(&quot;.&quot;) + 1).length &gt; precision &amp;&amp; precision &gt; 0) {\r\n        integer = parseInt(num).toString();\r\n        decimal = num.substring(num.indexOf(&quot;.&quot;) + 1);\r\n        significantDigit = Number(decimal.substr(precision, 1));\r\n\r\n        if (significantDigit &gt;= 5) {\r\n            decimal = (Number(decimal.substr(0, precision)) + 1).toString();\r\n            return integer + &quot;.&quot; + decimal;\r\n        } else {\r\n            decimal = (Number(decimal.substr(0, precision)) + 1).toString();\r\n            return integer + &quot;.&quot; + decimal;\r\n        }\r\n    }\r\n    else if (num.indexOf(&quot;.&quot;) &gt; 0) {\r\n        integer = parseInt(num).toString();\r\n        decimal = num.substring(num.indexOf(&quot;.&quot;) + 1);\r\n        significantDigit = num.substring(num.length - 1, 1);\r\n\r\n        if (significantDigit &gt;= 5) {\r\n            decimal = (Number(decimal) + 1).toString();\r\n            return integer + &quot;.&quot; + decimal;\r\n        } else {            \r\n            return integer + &quot;.&quot; + decimal;\r\n        }\r\n    } \r\n\r\n    return number;\r\n    }\r\n"},{"score":1,"body_markdown":"I have found this works for all my use cases:\r\n\r\n    const round = (value, decimalPlaces = 0) =&gt; {\r\n    \tconst multiplier = Math.pow(10, decimalPlaces);\r\n    \treturn Math.round(value * multiplier + Number.EPSILON) / multiplier;\r\n    };\r\n\r\nKeep in mind that is ES6. An ES5 equiv. would be very easy to code though so I&#39;m not gonna add it."},{"score":10,"body_markdown":"Keep type as integer for later sorting or other math operations:\r\n\r\n    Math.round(1.7777777 * 100)/100\r\n\r\n&gt; 1.78\r\n\r\n    // Round up!\r\n    Math.ceil(1.7777777 * 100)/100 \r\n\r\n&gt; 1.78\r\n\r\n\r\n    // Round down!\r\n    Math.floor(1.7777777 * 100)/100\r\n\r\n&gt; 1.77\r\n\r\nOr convert to string:\r\n\r\n    (1.7777777).toFixed(2)\r\n\r\n&gt; &quot;1.77&quot;"},{"score":2,"body_markdown":"the question is to rounds of 2 decimal.\r\n\r\nlet&#39;s not make this complicated modifying prototype chain etc..\r\n\r\nhere is one line solution \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let round2dec = num =&gt; Math.round(num * 100) / 100; \r\n\r\n    console.log(round2dec(1.77));\r\n    console.log(round2dec(1.774));\r\n    console.log(round2dec(1.777));\r\n    console.log(round2dec(10));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"I created this function, for rounding a number. The value can be a string (ex. &#39;1.005&#39;) or a number 1.005 that will be 1 by default and if you specify the decimal to be 2, the result will be 1.01 \r\n\r\n    round(value: string | number, decimals: number | string = &quot;0&quot;): number | null {\r\n\t\treturn +( Math.round(Number(value + &quot;e+&quot;+decimals)) + &quot;e-&quot; + decimals);\r\n\t}\r\nUsage: round(1.005, 2) // 1.01\r\nor \r\nUsage: round(&#39;1.005&#39;, 2) //1.01   "},{"score":2,"body_markdown":"A slight variation on this is if you need to format a currency amount as either being a whole amount of currency or an amount with fractional currency parts.\r\n\r\nFor example:\r\n\r\n1 should output $1\r\n\r\n1.1 should output $1.10\r\n\r\n1.01 should output $1.01\r\n\r\nAssuming amount is a number:\r\n\r\n`const formatAmount = (amount) =&gt; amount % 1 === 0 ? amount : amount.toFixed(2);`\r\n\r\nIf amount is not a number then use parseFloat(amount) to convert it to a number."},{"score":0,"body_markdown":"Quick helper function where `rounging` is You default rounding:\r\nlet rounding=4;\r\n\r\n    let round=(number)=&gt;{ let multiply=Math.pow(10,rounding);  return Math.round(number*multiply)/multiply};\r\n\r\n    console.log(round(0.040579431));\r\n\r\n=&gt; 0.0406"},{"score":0,"body_markdown":"There is a solution working for all numbers, give it a try. expression is given below.\r\n```js\r\nMath.round((num + 0.00001) * 100) / 100. Try Math.round((1.005 + 0.00001) * 100) / 100 and Math.round((1.0049 + 0.00001) * 100) / 100\r\n```\r\nI recently tested every possible solution and finally arrived at the output after trying almost 10 times. Here is a screenshot of issue arised during caculations,\r\n[![Screen Capture][1]][1].\r\n\r\nhead over to the `amount` field, It&#39;s returning almost infinite. I gave a try to `toFixed()` method but it&#39;s not working for some cases(i.e try with PI) and finally derived s solution given above.\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/hpBPs.png"},{"score":0,"body_markdown":"Slight modification of [this answer][1] that seems to work well.\r\n\r\n**Function**\r\n\r\n    function roundToStep(value, stepParam) {\r\n       var step = stepParam || 1.0;\r\n       var inv = 1.0 / step;\r\n       return Math.round(value * inv) / inv;\r\n    }\r\n\r\n**Usage**\r\n\r\n    roundToStep(2.55) = 3\r\n    roundToStep(2.55, 0.1) = 2.6\r\n    roundToStep(2.55, 0.01) = 2.55\r\n\r\n\r\n  [1]: https://stackoverflow.com/a/34591063/144088"},{"score":2,"body_markdown":"Mathematic floor and round [definitions](https://math.stackexchange.com/a/2886808/605065)\r\n\r\n[![enter image description here][1]][1]\r\n\r\nlead us to\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let round= x=&gt; ( x+0.005 - (x+0.005)%0.01 +&#39;&#39; ).replace(/(\\...)(.*)/,&#39;$1&#39;);\r\n\r\n    // for case like 1.384 we need to use regexp to get only 2 digits after dot\r\n    // and cut off machine-error (epsilon)\r\n\r\n    console.log(round(10));\r\n    console.log(round(1.7777777));\r\n    console.log(round(1.7747777));\r\n    console.log(round(1.384));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/FBAmy.png"},{"score":1,"body_markdown":"As per the answer already given in comment with the link to http://jsfiddle.net/AsRqx/\r\nFollowing one worked for me perfectly.\r\n\r\n    function C(num) \r\n      { return +(Math.round(num + &quot;e+2&quot;)  + &quot;e-2&quot;);\r\n      }\r\n    \r\n    function N(num, places) \r\n      { return +(Math.round(num + &quot;e+&quot; + places)  + &quot;e-&quot; + places);\r\n      }\r\n    \r\n    C(1.005);\r\n    \r\n    N(1.005,0);\r\n    N(1.005,1); //up to 1 decimal places\r\n    N(1.005,2); //up to 2 decimal places\r\n    N(1.005,3); //up to 3 decimal places"},{"score":0,"body_markdown":"the proposed answers while generally correct doesn&#39;t consider the precision of the passed in number, which is not expressed as requirement in the original question, but may be a requirement in case of scientific application where 3 is different from 3.00 (for example) as the number of decimal digits represents the precision of the instrument that have acquired the value or the accuracy of a calculation.\r\nIn fact the proposed answers rounds 3.001 to 3 while by keeping the information about the precision of the number should be 3.00\r\n\r\nbelow a function that takes in account that\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function roundTo(value, decimal) {\r\n\r\n        let absValue = Math.abs(value);\r\n        let int = Math.floor(absValue).toString().length;\r\n        let dec = absValue.toString().length - int;\r\n        dec -= (Number.isInteger(absValue) ? 0 : 1);\r\n        return value.toPrecision(int + Math.min(dec, decimal));\r\n      \r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":21,"body_markdown":"The easiest approach would be to use toFixed and then strip trailing zeros using the Number function:\r\n\r\n```\r\nconst number = 15.5;\r\nNumber(number.toFixed(2)); // 15.5\r\n```\r\n```\r\nconst number = 1.7777777;\r\nNumber(number.toFixed(2)); // 1.78\r\n```\r\n\r\n"},{"score":1,"body_markdown":"This function works for me. You just pass in the number and the places you want to round and it does what it needs to do easily.\r\n\r\n\r\n```\r\nround(source,n) {\r\n let places = Math.pow(10,n);\r\n    \r\n return Math.round(source * places) / places;\r\n}\r\n```"},{"score":4,"body_markdown":"A simple general rounding function could be following:\r\n\r\n\r\nSteps are:\r\n==========\r\n1. Multiply the number by (10 to the power of number of decimal place) using **Math.pow(10,places)**.\r\n2. Round the result to whole integer using **Math.Round**.\r\n3. Divide the result back by (10 to the power of number of decimal place) **Math.pow(10,places)**.\r\n\r\nExample:\r\n========\r\n\r\nnumber is: 1.2375\r\nto be rounded to 3 decimal places\r\n\r\n1. 1.2375 * (10^3)  ==&gt; 1.2375 * 1000 = 1237.5\r\n2. Round to integer ==&gt; 1238\r\n3. Divide 1238 by (10^3) ==&gt; 1238 / 1000 = 1.238\r\n\r\n*(note: 10^3 means Math.pow(10,3)).*\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n     function numberRoundDecimal(v,n) {\r\n     return Math.round((v+Number.EPSILON)*Math.pow(10,n))/Math.pow(10,n)}\r\n\r\n\r\n    // ------- tests --------\r\n    console.log(numberRoundDecimal(-0.024641163062896567,3))  // -0.025\r\n    console.log(numberRoundDecimal(0.9993360575508052,3))     // 0.999\r\n    console.log(numberRoundDecimal(1.0020739645577939,3))     // 1.002\r\n    console.log(numberRoundDecimal(0.975,0))                  // 1\r\n    console.log(numberRoundDecimal(0.975,1))                  // 1\r\n    console.log(numberRoundDecimal(0.975,2))                  // 0.98\r\n    console.log(numberRoundDecimal(1.005,2))                  // 1.01\r\n\r\n&lt;!-- end snippet --&gt;"},{"score":4,"body_markdown":"I reviewed **every answer** of this post.\r\nHere is my take on the matter:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const nbRounds = 7;\r\n    const round = (x, n=2) =&gt; {\r\n    \tconst precision = Math.pow(10, n)\r\n    \treturn Math.round((x+Number.EPSILON) * precision ) / precision;\r\n    }\r\n\r\n    new Array(nbRounds).fill(1).forEach((_,i)=&gt; {\r\n    \tconsole.log(&quot;round(1.00083899, &quot;,i+1,&quot;) &gt; &quot;, round(1.00083899, i+1))\r\n    \tconsole.log(&quot;round(1.83999305, &quot;,i+1,&quot;) &gt; &quot;, round(1.83999305, i+1))\r\n    })\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":1,"body_markdown":"I&#39;ve read all the answers, the answers of similar questions and the complexity of the most &quot;good&quot; solutions didn&#39;t satisfy me. I don&#39;t want to put a huge round function set, or a small one but fails on scientific notation. So, I came up with this function. It may help someone in my situation:\r\n\r\n    function round(num, dec) {\r\n       const [sv, ev] = num.toString().split(&#39;e&#39;);\r\n       return Number(Number(Math.round(parseFloat(sv + &#39;e&#39; + dec)) + &#39;e-&#39; + dec) + &#39;e&#39; + (ev || 0));\r\n    }\r\n\r\nI didn&#39;t run any performance test because I will call this just to update the UI of my application. The function gives the following results for a quick test:\r\n\r\n    // 1/3563143 = 2.806510993243886e-7\r\n    round(1/3563143, 2)  // returns `2.81e-7`\r\n\r\n    round(1.31645, 4)    // returns 1.3165\r\n\r\n    round(-17.3954, 2)   // returns -17.4\r\n\r\nThis is enough for me.\r\n\r\n"}],"score":2989}