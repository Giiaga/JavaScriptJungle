{"body":"What&#39;s the cleanest, most effective way to validate decimal numbers in JavaScript?\r\n\r\nBonus points for:\r\n\r\n 1. Clarity. Solution should be clean and simple.\r\n 2. Cross-platform.\r\n\r\nTest cases:\r\n\r\n    01. IsNumeric(&#39;-1&#39;)      =&gt; true\r\n    02. IsNumeric(&#39;-1.5&#39;)    =&gt; true\r\n    03. IsNumeric(&#39;0&#39;)       =&gt; true\r\n    04. IsNumeric(&#39;0.42&#39;)    =&gt; true\r\n    05. IsNumeric(&#39;.42&#39;)     =&gt; true\r\n    06. IsNumeric(&#39;99,999&#39;)  =&gt; false\r\n    07. IsNumeric(&#39;0x89f&#39;)   =&gt; false\r\n    08. IsNumeric(&#39;#abcdef&#39;) =&gt; false\r\n    09. IsNumeric(&#39;1.2.3&#39;)   =&gt; false\r\n    10. IsNumeric(&#39;&#39;)        =&gt; false\r\n    11. IsNumeric(&#39;blah&#39;)    =&gt; false\r\n","title":"Validate decimal numbers in JavaScript - IsNumeric()","answers":[{"score":73,"body_markdown":"This way seems to work well:\r\n\r\n    function IsNumeric(input){\r\n        var RE = /^-{0,1}\\d*\\.{0,1}\\d+$/;\r\n        return (RE.test(input));\r\n    }\r\n\r\nIn one line:\r\n\r\n    const IsNumeric = (num) =&gt; /^-{0,1}\\d*\\.{0,1}\\d+$/.test(num);\r\n    \r\nAnd to test it:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const IsNumeric = (num) =&gt; /^-{0,1}\\d*\\.{0,1}\\d+$/.test(num);\r\n        \r\n        function TestIsNumeric(){\r\n            var results = &#39;&#39;\r\n            results += (IsNumeric(&#39;-1&#39;)?&quot;Pass&quot;:&quot;Fail&quot;) + &quot;: IsNumeric(&#39;-1&#39;) =&gt; true\\n&quot;;\r\n            results += (IsNumeric(&#39;-1.5&#39;)?&quot;Pass&quot;:&quot;Fail&quot;) + &quot;: IsNumeric(&#39;-1.5&#39;) =&gt; true\\n&quot;;\r\n            results += (IsNumeric(&#39;0&#39;)?&quot;Pass&quot;:&quot;Fail&quot;) + &quot;: IsNumeric(&#39;0&#39;) =&gt; true\\n&quot;;\r\n            results += (IsNumeric(&#39;0.42&#39;)?&quot;Pass&quot;:&quot;Fail&quot;) + &quot;: IsNumeric(&#39;0.42&#39;) =&gt; true\\n&quot;;\r\n            results += (IsNumeric(&#39;.42&#39;)?&quot;Pass&quot;:&quot;Fail&quot;) + &quot;: IsNumeric(&#39;.42&#39;) =&gt; true\\n&quot;;\r\n            results += (!IsNumeric(&#39;99,999&#39;)?&quot;Pass&quot;:&quot;Fail&quot;) + &quot;: IsNumeric(&#39;99,999&#39;) =&gt; false\\n&quot;;\r\n            results += (!IsNumeric(&#39;0x89f&#39;)?&quot;Pass&quot;:&quot;Fail&quot;) + &quot;: IsNumeric(&#39;0x89f&#39;) =&gt; false\\n&quot;;\r\n            results += (!IsNumeric(&#39;#abcdef&#39;)?&quot;Pass&quot;:&quot;Fail&quot;) + &quot;: IsNumeric(&#39;#abcdef&#39;) =&gt; false\\n&quot;;\r\n            results += (!IsNumeric(&#39;1.2.3&#39;)?&quot;Pass&quot;:&quot;Fail&quot;) + &quot;: IsNumeric(&#39;1.2.3&#39;) =&gt; false\\n&quot;;\r\n            results += (!IsNumeric(&#39;&#39;)?&quot;Pass&quot;:&quot;Fail&quot;) + &quot;: IsNumeric(&#39;&#39;) =&gt; false\\n&quot;;\r\n            results += (!IsNumeric(&#39;blah&#39;)?&quot;Pass&quot;:&quot;Fail&quot;) + &quot;: IsNumeric(&#39;blah&#39;) =&gt; false\\n&quot;;\r\n            \r\n            return results;\r\n        }\r\n\r\n    console.log(TestIsNumeric());\r\n\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper { max-height: 100% !important; top: 0; }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nI borrowed that regex from http://www.codetoad.com/javascript/isnumeric.asp. Explanation:\r\n\r\n    /^ match beginning of string\r\n    -{0,1} optional negative sign\r\n    \\d* optional digits\r\n    \\.{0,1} optional decimal point\r\n    \\d+ at least one digit\r\n    $/ match end of string\r\n\r\n"},{"score":4,"body_markdown":"A couple of tests to add:\r\n\r\n    IsNumeric(&#39;01.05&#39;) =&gt; false\r\n    IsNumeric(&#39;1.&#39;) =&gt; false\r\n    IsNumeric(&#39;.&#39;) =&gt; false\r\n\r\nI came up with this:\r\n\r\n    function IsNumeric(input) {\r\n        return /^-?(0|[1-9]\\d*|(?=\\.))(\\.\\d+)?$/.test(input);\r\n    }\r\n\r\nThe solution covers:\r\n\r\n* An optional negative sign at the beginning\r\n* A single zero, or one or more digits not starting with 0, or nothing so long as a period follows\r\n* A period that is followed by 1 or more numbers\r\n"},{"score":6,"body_markdown":"I&#39;d like to add the following:\r\n&lt;pre&gt;\r\n&lt;code&gt;1. IsNumeric(&#39;0x89f&#39;) =&gt; true\r\n2. IsNumeric(&#39;075&#39;) =&gt; true&lt;/code&gt;\r\n&lt;/pre&gt;\r\n\r\nPositive hex numbers start with `0x` and negative hex numbers start with `-0x`.\r\nPositive oct numbers start with `0` and negative oct numbers start with `-0`.\r\nThis one takes most of what has already been mentioned into consideration, but includes hex and octal numbers, negative scientific, Infinity and has removed decimal scientific (`4e3.2` is not valid).\r\n\r\n    function IsNumeric(input){\r\n      var RE = /^-?(0|INF|(0[1-7][0-7]*)|(0x[0-9a-fA-F]+)|((0|[1-9][0-9]*|(?=[\\.,]))([\\.,][0-9]+)?([eE]-?\\d+)?))$/;\r\n      return (RE.test(input));\r\n    }\r\n"},{"score":18,"body_markdown":"Use the function `isNaN`. I believe if you test for `!isNaN(yourstringhere)` it works fine for any of these situations.\r\n"},{"score":34,"body_markdown":"Yeah, the built-in [`isNaN(object)`][1] will be much faster than any regex parsing, because it&#39;s built-in and compiled, instead of interpreted on the fly.\r\n\r\nAlthough the results are somewhat different to what you&#39;re looking for ([try it][2]):\r\n\r\n                                                  // IS NUMERIC\r\n    document.write(!isNaN(&#39;-1&#39;) + &quot;&lt;br /&gt;&quot;);      // true\r\n    document.write(!isNaN(&#39;-1.5&#39;) + &quot;&lt;br /&gt;&quot;);    // true\r\n    document.write(!isNaN(&#39;0&#39;) + &quot;&lt;br /&gt;&quot;);       // true\r\n    document.write(!isNaN(&#39;0.42&#39;) + &quot;&lt;br /&gt;&quot;);    // true\r\n    document.write(!isNaN(&#39;.42&#39;) + &quot;&lt;br /&gt;&quot;);     // true\r\n    document.write(!isNaN(&#39;99,999&#39;) + &quot;&lt;br /&gt;&quot;);  // false\r\n    document.write(!isNaN(&#39;0x89f&#39;) + &quot;&lt;br /&gt;&quot;);   // true\r\n    document.write(!isNaN(&#39;#abcdef&#39;) + &quot;&lt;br /&gt;&quot;); // false\r\n    document.write(!isNaN(&#39;1.2.3&#39;) + &quot;&lt;br /&gt;&quot;);   // false\r\n    document.write(!isNaN(&#39;&#39;) + &quot;&lt;br /&gt;&quot;);        // true\r\n    document.write(!isNaN(&#39;blah&#39;) + &quot;&lt;br /&gt;&quot;);    // false\r\n\r\n  [1]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/isNaN\r\n  [2]: http://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_isnan"},{"score":13,"body_markdown":"It can be done without RegExp as \r\n\r\n    function IsNumeric(data){\r\n    \treturn parseFloat(data)==data;\r\n    }\r\n"},{"score":342,"body_markdown":"Arrrgh!  Don&#39;t listen to the regular expression answers.  RegEx is icky for this, and I&#39;m not talking just performance.  It&#39;s so easy to make subtle, impossible to spot mistakes with your regular expression.  \r\n\r\nIf you can&#39;t use `isNaN()`, this should work much better:\r\n\r\n    function IsNumeric(input)\r\n    {\r\n        return (input - 0) == input &amp;&amp; (&#39;&#39;+input).trim().length &gt; 0;\r\n    }\r\n\r\nHere&#39;s how it works:\r\n\r\nThe `(input - 0)` expression forces JavaScript to do type coercion on your input value; it must first be interpreted as a number for the subtraction operation.  If that conversion to a number fails, the expression will result in `NaN`.  This _numeric_ result is then compared to the original value you passed in.  Since the left hand side is now numeric, type coercion is again used.  Now that the input from both sides was coerced to the same type from the same original value, you would think they should always be the same (always true). However, there&#39;s a special rule that says `NaN` is never equal to `NaN`, and so a value that can&#39;t be converted to a number (and only values that cannot be converted to numbers) will result in false. \r\n\r\nThe check on the length is for a special case involving empty strings. Also note that it falls down on your 0x89f test, but that&#39;s because in many environments that&#39;s an okay way to define a number literal.  If you want to catch that specific scenario you could add an additional check.  Even better, if that&#39;s your reason for not using `isNaN()` then just wrap your own function around `isNaN()` that can also do the additional check.\r\n\r\nIn summary, ***if you want to know if a value can be converted to a number, actually try to convert it to a number.***\r\n\r\n---\r\n\r\nI went back and did some research for _why_ a whitespace string did not have the expected output, and I think I get it now: an empty string is coerced to `0` rather than `NaN`. Simply trimming the string before the length check will handle this case.\r\n\r\nRunning the unit tests against the new code and it only fails on the infinity and boolean literals, and the only time that should be a problem is if you&#39;re generating code (really, who would type in a literal and check if it&#39;s numeric? You should _know_), and that would be some strange code to generate.\r\n\r\nBut, again, **the only reason ever to use this is if for some reason you have to avoid isNaN().**\r\n"},{"score":54,"body_markdown":"[Yahoo! UI][1] uses this:\r\n\r\n    isNumber: function(o) {\r\n        return typeof o === &#39;number&#39; &amp;&amp; isFinite(o);\r\n    }\r\n\r\n [1]: http://en.wikipedia.org/wiki/Yahoo!_UI_Library\r\n"},{"score":50,"body_markdown":"    \r\n\r\n    function IsNumeric(num) {\r\n         return (num &gt;=0 || num &lt; 0);\r\n    }\r\n\r\nThis works for 0x23 type numbers as well."},{"score":2918,"body_markdown":"[@Joel&#39;s answer][1] is pretty close, but it will fail in the following cases:\r\n\r\n    // Whitespace strings:\r\n    IsNumeric(&#39; &#39;)    == true;\r\n    IsNumeric(&#39;\\t\\t&#39;) == true;\r\n    IsNumeric(&#39;\\n\\r&#39;) == true;\r\n\r\n    // Number literals:\r\n    IsNumeric(-1)  == false;\r\n    IsNumeric(0)   == false;\r\n    IsNumeric(1.1) == false;\r\n    IsNumeric(8e5) == false;\r\n\r\nSome time ago I had to implement an `IsNumeric` function, to find out if a variable contained a numeric value, **regardless of its type**, it could be a `String` containing a numeric value (I had to consider also exponential notation, etc.), a `Number` object, virtually anything could be passed to that function, I couldn&#39;t make any type assumptions,  taking care of type coercion (eg. `+true == 1;` but `true` shouldn&#39;t be considered as `&quot;numeric&quot;`).\r\n\r\nI think is worth sharing this set of [**+30 unit tests**][8] made to numerous function implementations, and also share the one that passes all my tests:\r\n\r\n    function isNumeric(n) {\r\n        return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);\r\n    }\r\n\r\n**P.S.** [isNaN][4] &amp; [isFinite][5] have a confusing behavior due to forced conversion to number. In ES6, [Number.isNaN][6] &amp; [Number.isFinite][7] would fix these issues. Keep that in mind when using them. \r\n\r\n- - - \r\n\r\n**Update** : \r\n[Here&#39;s how jQuery does it now (2.2-stable)][3]: \r\n\r\n\tisNumeric: function(obj) {\r\n\t\tvar realStringObj = obj &amp;&amp; obj.toString();\r\n\t\treturn !jQuery.isArray(obj) &amp;&amp; (realStringObj - parseFloat(realStringObj) + 1) &gt;= 0;\r\n\t}\r\n\r\n**Update** :\r\n[Angular 4.3][9]:\r\n\r\n    export function isNumeric(value: any): boolean {\r\n        return !isNaN(value - parseFloat(value));\r\n    }\r\n\r\n\r\n  [1]: https://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric/174921#174921\r\n  [3]: https://github.com/jquery/jquery/blob/2.2-stable/src/core.js#L215\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN\r\n  [5]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite\r\n  [6]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\r\n  [7]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite\r\n  [8]: http://run.plnkr.co/plunks/93FPpacuIcXqqKMecLdk/\r\n  [9]: https://github.com/angular/angular/blob/4.3.x/packages/common/src/pipes/number_pipe.ts#L172"},{"score":6,"body_markdown":"To me, this is the best way:\r\n\r\n    isNumber : function(v){\r\n       return typeof v === &#39;number&#39; &amp;&amp; isFinite(v);\r\n    }"},{"score":3,"body_markdown":"This should work. Some of the functions provided here are flawed, also should be faster than any other function here.\r\n\r\n        \tfunction isNumeric(n)\r\n        \t{\r\n        \t\tvar n2 = n;\r\n        \t\tn = parseFloat(n);\r\n        \t\treturn (n!=&#39;NaN&#39; &amp;&amp; n2==n);\r\n        \t}\r\n\r\nExplained:\r\n\r\nCreate a copy of itself, then converts the number into float, then compares itself with the original number, if it is still a number, (whether integer or float) , and matches the original number, that means, it is indeed a number.\r\n\r\nIt works with numeric strings as well as plain numbers. Does not work with hexadecimal numbers. \r\n\r\nWarning: use at your own risk, no guarantees.\r\n"},{"score":-4,"body_markdown":"The following may work as well.\r\n\r\n\r\n  \r\n\r\n\r\n    function isNumeric(v) {\r\n             return v.length &gt; 0 &amp;&amp; !isNaN(v) &amp;&amp; v.search(/[A-Z]|[#]/ig) == -1;\r\n       };\r\n\r\n"},{"score":8,"body_markdown":"    return (input - 0) == input &amp;&amp; input.length &gt; 0;\r\n\r\ndidn&#39;t work for me. When I put in an alert and tested, `input.length` was `undefined`. I think there is no property to check integer length. So what I did was\r\n\r\n    var temp = &#39;&#39; + input;\r\n    return (input - 0) == input &amp;&amp; temp.length &gt; 0;\r\n\r\nIt worked fine.\r\n"},{"score":3,"body_markdown":"My solution,\r\n\r\n    function isNumeric(input) {\r\n        var number = /^\\-{0,1}(?:[0-9]+){0,1}(?:\\.[0-9]+){0,1}$/i;\r\n        var regex = RegExp(number);\r\n        return regex.test(input) &amp;&amp; input.length&gt;0;\r\n    }\r\n\r\nIt appears to work in every situation, but I might be wrong.\r\n"},{"score":4,"body_markdown":"An integer value can be verified by:\r\n\r\n    function isNumeric(value) {\r\n        var bool = isNaN(+value));\r\n        bool = bool || (value.indexOf(&#39;.&#39;) != -1);\r\n        bool = bool || (value.indexOf(&quot;,&quot;) != -1);\r\n        return !bool;\r\n    };\r\n\r\nThis way is easier and faster! All tests are checked!\r\n\r\n"},{"score":-2,"body_markdown":"@Zoltan Lengyel &#39;other locales&#39; comment (Apr 26 at 2:14) in @CMS Dec answer (2 &#39;09 at 5:36):\r\n\r\nI would recommend testing for `typeof (n) === &#39;string&#39;`:\r\n\r\n\t\tfunction isNumber(n) {\r\n\t\t\tif (typeof (n) === &#39;string&#39;) {\r\n\t\t\t\tn = n.replace(/,/, &quot;.&quot;);\r\n\t\t\t}\r\n\t\t\treturn !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);\r\n\t\t}\r\n\r\nThis extends Zoltans recommendation to not only be able to test &quot;localized numbers&quot; like  `isNumber(&#39;12,50&#39;)` but also &quot;pure&quot; numbers like `isNumber(2011)`."},{"score":-3,"body_markdown":"Well, I&#39;m using this one I made...\r\n\r\nIt&#39;s been working so far:\r\n\r\n    function checkNumber(value) {\r\n        if ( value % 1 == 0 )\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\nIf you spot any problem with it, tell me, please.\r\n\r\nLike any numbers should be divisible by one with nothing left, I figured I could just use the module, and if you try dividing a string into a number the result wouldn&#39;t be that. So."},{"score":7,"body_markdown":"If I&#39;m not mistaken, this should match any valid JavaScript number value, excluding constants (`Infinity`, `NaN`) and the sign operators `+`/`-` (because they are not actually part of the number as far as I concerned, they are separate operators):\r\n\r\nI needed this for a tokenizer, where sending the number to JavaScript for evaluation wasn&#39;t an option... It&#39;s definitely not the shortest possible regular expression, but I believe it catches all the finer subtleties of JavaScript&#39;s number syntax.\r\n\r\n    /^(?:(?:(?:[1-9]\\d*|\\d)\\.\\d*|(?:[1-9]\\d*|\\d)?\\.\\d+|(?:[1-9]\\d*|\\d)) \r\n    (?:[e]\\d+)?|0[0-7]+|0x[0-9a-f]+)$/i\r\n\r\n**Valid numbers would include:**\r\n\r\n     - 0\r\n     - 00\r\n     - 01\r\n     - 10\r\n     - 0e1\r\n     - 0e01\r\n     - .0\r\n     - 0.\r\n     - .0e1\r\n     - 0.e1\r\n     - 0.e00\r\n     - 0xf\r\n     - 0Xf\r\n\r\n**Invalid numbers would be**\r\n\r\n     - 00e1\r\n     - 01e1\r\n     - 00.0\r\n     - 00x0\r\n     - .\r\n     - .e0\r\n\r\n"},{"score":3,"body_markdown":"I&#39;m using simpler solution:\r\n\r\n    function isNumber(num) {\r\n        return parseFloat(num).toString() == num\r\n    }\r\n\r\n"},{"score":-3,"body_markdown":"Here I&#39;ve collected the &quot;good ones&quot; from this page and put them into a simple test pattern for you to evaluate on your own.\r\n\r\nFor newbies, the `console.log` is a built in function (available in all modern browsers) that lets you output results to the JavaScript console (dig around, you&#39;ll find it) rather than having to output to your HTML page.\r\n\r\n    var isNumeric = function(val){\r\n        // --------------------------\r\n        // Recommended\r\n        // --------------------------\r\n\r\n        // jQuery - works rather well\r\n        // See CMS&#39;s unit test also: http://dl.getdropbox.com/u/35146/js/tests/isNumber.html\r\n        return !isNaN(parseFloat(val)) &amp;&amp; isFinite(val);\r\n\r\n        // Aquatic - good and fast, fails the &quot;0x89f&quot; test, but that test is questionable.\r\n        //return parseFloat(val)==val;\r\n\r\n        // --------------------------\r\n        // Other quirky options\r\n        // --------------------------\r\n        // Fails on &quot;&quot;, null, newline, tab negative.\r\n        //return !isNaN(val);\r\n\r\n        // user532188 - fails on &quot;0x89f&quot;\r\n        //var n2 = val;\r\n        //val = parseFloat(val);\r\n        //return (val!=&#39;NaN&#39; &amp;&amp; n2==val);\r\n\r\n        // Rafael - fails on negative + decimal numbers, may be good for isInt()?\r\n        // return ( val % 1 == 0 ) ? true : false;\r\n\r\n        // pottedmeat - good, but fails on stringy numbers, which may be a good thing for some folks?\r\n        //return /^-?(0|[1-9]\\d*|(?=\\.))(\\.\\d+)?$/.test(val);\r\n\r\n        // Haren - passes all\r\n        // borrowed from http://www.codetoad.com/javascript/isnumeric.asp\r\n        //var RE = /^-{0,1}\\d*\\.{0,1}\\d+$/;\r\n        //return RE.test(val);\r\n\r\n        // YUI - good for strict adherance to number type. Doesn&#39;t let stringy numbers through.\r\n        //return typeof val === &#39;number&#39; &amp;&amp; isFinite(val);\r\n\r\n        // user189277 - fails on &quot;&quot; and &quot;\\n&quot;\r\n        //return ( val &gt;=0 || val &lt; 0);\r\n    }\r\n\r\n    var tests = [0, 1, &quot;0&quot;, 0x0, 0x000, &quot;0000&quot;, &quot;0x89f&quot;, 8e5, 0x23, -0, 0.0, &quot;1.0&quot;, 1.0, -1.5, 0.42, &#39;075&#39;, &quot;01&quot;, &#39;-01&#39;, &quot;0.&quot;, &quot;.0&quot;, &quot;a&quot;, &quot;a2&quot;, true, false, &quot;#000&quot;, &#39;1.2.3&#39;, &#39;#abcdef&#39;, &#39;&#39;, &quot;&quot;, &quot;\\n&quot;, &quot;\\t&quot;, &#39;-&#39;, null, undefined];\r\n\r\n    for (var i=0; i&lt;tests.length; i++){\r\n        console.log( &quot;test &quot; + i + &quot;:    &quot; + tests[i] + &quot;    \\t   &quot; + isNumeric(tests[i]) );\r\n    }\r\n"},{"score":17,"body_markdown":"Since jQuery 1.7, you can use [`jQuery.isNumeric()`][1]:\r\n\r\n\r\n    $.isNumeric(&#39;-1&#39;);      // true\r\n    $.isNumeric(&#39;-1.5&#39;);    // true\r\n    $.isNumeric(&#39;0&#39;);       // true\r\n    $.isNumeric(&#39;0.42&#39;);    // true\r\n    $.isNumeric(&#39;.42&#39;);     // true\r\n    $.isNumeric(&#39;0x89f&#39;);   // true (valid hexa number)\r\n    $.isNumeric(&#39;99,999&#39;);  // false\r\n    $.isNumeric(&#39;#abcdef&#39;); // false\r\n    $.isNumeric(&#39;1.2.3&#39;);   // false\r\n    $.isNumeric(&#39;&#39;);        // false\r\n    $.isNumeric(&#39;blah&#39;);    // false\r\n\r\nJust note that unlike what you said, `0x89f` is a valid number (hexa)\r\n\r\n  [1]: http://api.jquery.com/jQuery.isNumeric/"},{"score":49,"body_markdown":"The accepted answer failed your test #7 and I guess it&#39;s because you changed your mind. So this is a response to the accepted answer, with which I had issues.\r\n\r\nDuring some projects I have needed to validate some data and be as certain as possible that it is a javascript numerical value that can be used in mathematical operations.\r\n\r\njQuery, and some other javascript libraries already include such a function, usually called `isNumeric`. There is also a [post on stackoverflow][1] that has been widely accepted as the answer, the same general routine that the afore mentioned libraries are using.\r\n\r\n    function isNumber(n) {\r\n      return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);\r\n    }\r\n\r\nFirst, the code above would return true if the argument was an array of length 1, and that single element was of a type deemed as numeric by the above logic. In my opinion, if it&#39;s an array then its not numeric.\r\n\r\nTo alleviate this problem, I added a check to discount arrays from the logic\r\n\r\n    function isNumber(n) {\r\n      return Object.prototype.toString.call(n) !== &#39;[object Array]&#39; &amp;&amp;!isNaN(parseFloat(n)) &amp;&amp; isFinite(n);\r\n    }\r\n\r\nOf course, you could also use `Array.isArray`, jquery `$.isArray` or prototype `Object.isArray` instead of `Object.prototype.toString.call(n) !== &#39;[object Array]&#39;`\r\n\r\nMy second issue was that Negative Hexadecimal integer literal strings (&quot;-0xA&quot; -&gt; -10) were not being counted as numeric. However, Positive Hexadecimal integer literal strings (&quot;0xA&quot; -&gt; 10) were treated as numeric.\r\nI needed both to be valid numeric.\r\n\r\nI then modified the logic to take this into account.\r\n\r\n    function isNumber(n) {\r\n      return Object.prototype.toString.call(n) !== &#39;[object Array]&#39; &amp;&amp;!isNaN(parseFloat(n)) &amp;&amp; isFinite(n.toString().replace(/^-/, &#39;&#39;));\r\n    }\r\n\r\nIf you are worried about the creation of the regex each time the function is called then you could rewrite it within a closure, something like this\r\n\r\n    var isNumber = (function () {\r\n      var rx = /^-/;\r\n       \r\n      return function (n) {\r\n          return Object.prototype.toString.call(n) !== &#39;[object Array]&#39; &amp;&amp;!isNaN(parseFloat(n)) &amp;&amp; isFinite(n.toString().replace(rx, &#39;&#39;));\r\n      };\r\n    }());\r\n\r\nI then took CMSs [+30 test cases][2] and cloned the [testing on jsfiddle][3] added my extra test cases and my above described solution.\r\n\r\nIt may not replace the widely accepted/used answer but if this is more of what you are expecting as results from your isNumeric function then hopefully this will be of some help.\r\n\r\n**EDIT:** As pointed out by [Bergi][4], there are other possible objects that could be considered numeric and it would be better to whitelist than blacklist. With this in mind I would add to the criteria.\r\n\r\nI want my isNumeric function to consider only Numbers or Strings\r\n\r\nWith this in mind, it would be better to use\r\n\r\n    function isNumber(n) {\r\n      return (Object.prototype.toString.call(n) === &#39;[object Number]&#39; || Object.prototype.toString.call(n) === &#39;[object String]&#39;) &amp;&amp;!isNaN(parseFloat(n)) &amp;&amp; isFinite(n.toString().replace(/^-/, &#39;&#39;));\r\n    }\r\n\r\n**Test the solutions**\r\n\r\n&lt;!-- begin snippet: js hide: false console: false babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var testHelper = function() {\r\n\r\n      var testSuite = function() {\r\n        test(&quot;Integer Literals&quot;, function() {\r\n          ok(isNumber(&quot;-10&quot;), &quot;Negative integer string&quot;);\r\n          ok(isNumber(&quot;0&quot;), &quot;Zero string&quot;);\r\n          ok(isNumber(&quot;5&quot;), &quot;Positive integer string&quot;);\r\n          ok(isNumber(-16), &quot;Negative integer number&quot;);\r\n          ok(isNumber(0), &quot;Zero integer number&quot;);\r\n          ok(isNumber(32), &quot;Positive integer number&quot;);\r\n          ok(isNumber(&quot;040&quot;), &quot;Octal integer literal string&quot;);\r\n          ok(isNumber(0144), &quot;Octal integer literal&quot;);\r\n          ok(isNumber(&quot;-040&quot;), &quot;Negative Octal integer literal string&quot;);\r\n          ok(isNumber(-0144), &quot;Negative Octal integer literal&quot;);\r\n          ok(isNumber(&quot;0xFF&quot;), &quot;Hexadecimal integer literal string&quot;);\r\n          ok(isNumber(0xFFF), &quot;Hexadecimal integer literal&quot;);\r\n          ok(isNumber(&quot;-0xFF&quot;), &quot;Negative Hexadecimal integer literal string&quot;);\r\n          ok(isNumber(-0xFFF), &quot;Negative Hexadecimal integer literal&quot;);\r\n        });\r\n\r\n        test(&quot;Foating-Point Literals&quot;, function() {\r\n          ok(isNumber(&quot;-1.6&quot;), &quot;Negative floating point string&quot;);\r\n          ok(isNumber(&quot;4.536&quot;), &quot;Positive floating point string&quot;);\r\n          ok(isNumber(-2.6), &quot;Negative floating point number&quot;);\r\n          ok(isNumber(3.1415), &quot;Positive floating point number&quot;);\r\n          ok(isNumber(8e5), &quot;Exponential notation&quot;);\r\n          ok(isNumber(&quot;123e-2&quot;), &quot;Exponential notation string&quot;);\r\n        });\r\n\r\n        test(&quot;Non-Numeric values&quot;, function() {\r\n          equals(isNumber(&quot;&quot;), false, &quot;Empty string&quot;);\r\n          equals(isNumber(&quot;        &quot;), false, &quot;Whitespace characters string&quot;);\r\n          equals(isNumber(&quot;\\t\\t&quot;), false, &quot;Tab characters string&quot;);\r\n          equals(isNumber(&quot;abcdefghijklm1234567890&quot;), false, &quot;Alphanumeric character string&quot;);\r\n          equals(isNumber(&quot;xabcdefx&quot;), false, &quot;Non-numeric character string&quot;);\r\n          equals(isNumber(true), false, &quot;Boolean true literal&quot;);\r\n          equals(isNumber(false), false, &quot;Boolean false literal&quot;);\r\n          equals(isNumber(&quot;bcfed5.2&quot;), false, &quot;Number with preceding non-numeric characters&quot;);\r\n          equals(isNumber(&quot;7.2acdgs&quot;), false, &quot;Number with trailling non-numeric characters&quot;);\r\n          equals(isNumber(undefined), false, &quot;Undefined value&quot;);\r\n          equals(isNumber(null), false, &quot;Null value&quot;);\r\n          equals(isNumber(NaN), false, &quot;NaN value&quot;);\r\n          equals(isNumber(Infinity), false, &quot;Infinity primitive&quot;);\r\n          equals(isNumber(Number.POSITIVE_INFINITY), false, &quot;Positive Infinity&quot;);\r\n          equals(isNumber(Number.NEGATIVE_INFINITY), false, &quot;Negative Infinity&quot;);\r\n          equals(isNumber(new Date(2009, 1, 1)), false, &quot;Date object&quot;);\r\n          equals(isNumber(new Object()), false, &quot;Empty object&quot;);\r\n          equals(isNumber(function() {}), false, &quot;Instance of a function&quot;);\r\n          equals(isNumber([]), false, &quot;Empty Array&quot;);\r\n          equals(isNumber([&quot;-10&quot;]), false, &quot;Array Negative integer string&quot;);\r\n          equals(isNumber([&quot;0&quot;]), false, &quot;Array Zero string&quot;);\r\n          equals(isNumber([&quot;5&quot;]), false, &quot;Array Positive integer string&quot;);\r\n          equals(isNumber([-16]), false, &quot;Array Negative integer number&quot;);\r\n          equals(isNumber([0]), false, &quot;Array Zero integer number&quot;);\r\n          equals(isNumber([32]), false, &quot;Array Positive integer number&quot;);\r\n          equals(isNumber([&quot;040&quot;]), false, &quot;Array Octal integer literal string&quot;);\r\n          equals(isNumber([0144]), false, &quot;Array Octal integer literal&quot;);\r\n          equals(isNumber([&quot;-040&quot;]), false, &quot;Array Negative Octal integer literal string&quot;);\r\n          equals(isNumber([-0144]), false, &quot;Array Negative Octal integer literal&quot;);\r\n          equals(isNumber([&quot;0xFF&quot;]), false, &quot;Array Hexadecimal integer literal string&quot;);\r\n          equals(isNumber([0xFFF]), false, &quot;Array Hexadecimal integer literal&quot;);\r\n          equals(isNumber([&quot;-0xFF&quot;]), false, &quot;Array Negative Hexadecimal integer literal string&quot;);\r\n          equals(isNumber([-0xFFF]), false, &quot;Array Negative Hexadecimal integer literal&quot;);\r\n          equals(isNumber([1, 2]), false, &quot;Array with more than 1 Positive interger number&quot;);\r\n          equals(isNumber([-1, -2]), false, &quot;Array with more than 1 Negative interger number&quot;);\r\n        });\r\n      }\r\n\r\n      var functionsToTest = [\r\n\r\n        function(n) {\r\n          return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);\r\n        },\r\n\r\n        function(n) {\r\n          return !isNaN(n) &amp;&amp; !isNaN(parseFloat(n));\r\n        },\r\n\r\n        function(n) {\r\n          return !isNaN((n));\r\n        },\r\n\r\n        function(n) {\r\n          return !isNaN(parseFloat(n));\r\n        },\r\n\r\n        function(n) {\r\n          return typeof(n) != &quot;boolean&quot; &amp;&amp; !isNaN(n);\r\n        },\r\n\r\n        function(n) {\r\n          return parseFloat(n) === Number(n);\r\n        },\r\n\r\n        function(n) {\r\n          return parseInt(n) === Number(n);\r\n        },\r\n\r\n        function(n) {\r\n          return !isNaN(Number(String(n)));\r\n        },\r\n\r\n        function(n) {\r\n          return !isNaN(+(&#39;&#39; + n));\r\n        },\r\n\r\n        function(n) {\r\n          return (+n) == n;\r\n        },\r\n\r\n        function(n) {\r\n          return n &amp;&amp; /^-?\\d+(\\.\\d+)?$/.test(n + &#39;&#39;);\r\n        },\r\n\r\n        function(n) {\r\n          return isFinite(Number(String(n)));\r\n        },\r\n\r\n        function(n) {\r\n          return isFinite(String(n));\r\n        },\r\n\r\n        function(n) {\r\n          return !isNaN(n) &amp;&amp; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);\r\n        },\r\n\r\n        function(n) {\r\n          return parseFloat(n) == n;\r\n        },\r\n\r\n        function(n) {\r\n          return (n - 0) == n &amp;&amp; n.length &gt; 0;\r\n        },\r\n\r\n        function(n) {\r\n          return typeof n === &#39;number&#39; &amp;&amp; isFinite(n);\r\n        },\r\n\r\n        function(n) {\r\n          return !Array.isArray(n) &amp;&amp; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n.toString().replace(/^-/, &#39;&#39;));\r\n        }\r\n\r\n      ];\r\n\r\n\r\n      // Examines the functionsToTest array, extracts the return statement of each function\r\n      // and fills the toTest select element.\r\n      var fillToTestSelect = function() {\r\n        for (var i = 0; i &lt; functionsToTest.length; i++) {\r\n          var f = functionsToTest[i].toString();\r\n          var option = /[\\s\\S]*return ([\\s\\S]*);/.exec(f)[1];\r\n          $(&quot;#toTest&quot;).append(&#39;&lt;option value=&quot;&#39; + i + &#39;&quot;&gt;&#39; + (i + 1) + &#39;. &#39; + option + &#39;&lt;/option&gt;&#39;);\r\n        }\r\n      }\r\n\r\n      var performTest = function(functionNumber) {\r\n        reset(); // Reset previous test\r\n        $(&quot;#tests&quot;).html(&quot;&quot;); //Clean test results\r\n        isNumber = functionsToTest[functionNumber]; // Override the isNumber global function with the one to test\r\n        testSuite(); // Run the test\r\n\r\n        // Get test results\r\n        var totalFail = 0;\r\n        var totalPass = 0;\r\n        $(&quot;b.fail&quot;).each(function() {\r\n          totalFail += Number($(this).html());\r\n        });\r\n        $(&quot;b.pass&quot;).each(function() {\r\n          totalPass += Number($(this).html());\r\n        });\r\n        $(&quot;#testresult&quot;).html(totalFail + &quot; of &quot; + (totalFail + totalPass) + &quot; test failed.&quot;);\r\n\r\n        $(&quot;#banner&quot;).attr(&quot;class&quot;, &quot;&quot;).addClass(totalFail &gt; 0 ? &quot;fail&quot; : &quot;pass&quot;);\r\n      }\r\n\r\n      return {\r\n        performTest: performTest,\r\n        fillToTestSelect: fillToTestSelect,\r\n        testSuite: testSuite\r\n      };\r\n    }();\r\n\r\n\r\n    $(document).ready(function() {\r\n      testHelper.fillToTestSelect();\r\n      testHelper.performTest(0);\r\n\r\n      $(&quot;#toTest&quot;).change(function() {\r\n        testHelper.performTest($(this).children(&quot;:selected&quot;).val());\r\n      });\r\n    });\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n    &lt;script src=&quot;https://rawgit.com/Xotic750/testrunner-old/master/testrunner.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n    &lt;link href=&quot;https://rawgit.com/Xotic750/testrunner-old/master/testrunner.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;\r\n    &lt;h1&gt;isNumber Test Cases&lt;/h1&gt;\r\n\r\n    &lt;h2 id=&quot;banner&quot; class=&quot;pass&quot;&gt;&lt;/h2&gt;\r\n\r\n    &lt;h2 id=&quot;userAgent&quot;&gt;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.95 Safari/537.11&lt;/h2&gt;\r\n\r\n    &lt;div id=&quot;currentFunction&quot;&gt;&lt;/div&gt;\r\n\r\n    &lt;div id=&quot;selectFunction&quot;&gt;\r\n      &lt;label for=&quot;toTest&quot; style=&quot;font-weight:bold; font-size:Large;&quot;&gt;Select function to test:&lt;/label&gt;\r\n      &lt;select id=&quot;toTest&quot; name=&quot;toTest&quot;&gt;\r\n      &lt;/select&gt;\r\n    &lt;/div&gt;\r\n\r\n    &lt;div id=&quot;testCode&quot;&gt;&lt;/div&gt;\r\n\r\n    &lt;ol id=&quot;tests&quot;&gt;\r\n      &lt;li class=&quot;pass&quot;&gt;\r\n        &lt;strong&gt;Integer Literals &lt;b style=&quot;color:black;&quot;&gt;(0, 10, 10)&lt;/b&gt;&lt;/strong&gt;\r\n\r\n        &lt;ol style=&quot;display: none;&quot;&gt;\r\n          &lt;li class=&quot;pass&quot;&gt;Negative integer string&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Zero string&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Positive integer string&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Negative integer number&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Zero integer number&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Positive integer number&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Octal integer literal string&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Octal integer literal&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Hexadecimal integer literal string&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Hexadecimal integer literal&lt;/li&gt;\r\n        &lt;/ol&gt;\r\n      &lt;/li&gt;\r\n\r\n      &lt;li class=&quot;pass&quot;&gt;\r\n        &lt;strong&gt;Foating-Point Literals &lt;b style=&quot;color:black;&quot;&gt;(0, 6, 6)&lt;/b&gt;&lt;/strong&gt;\r\n\r\n        &lt;ol style=&quot;display: none;&quot;&gt;\r\n          &lt;li class=&quot;pass&quot;&gt;Negative floating point string&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Positive floating point string&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Negative floating point number&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Positive floating point number&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Exponential notation&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Exponential notation string&lt;/li&gt;\r\n        &lt;/ol&gt;\r\n      &lt;/li&gt;\r\n\r\n      &lt;li class=&quot;pass&quot;&gt;\r\n        &lt;strong&gt;Non-Numeric values &lt;b style=&quot;color:black;&quot;&gt;(0, 18, 18)&lt;/b&gt;&lt;/strong&gt;\r\n\r\n        &lt;ol style=&quot;display: none;&quot;&gt;\r\n          &lt;li class=&quot;pass&quot;&gt;Empty string: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Whitespace characters string: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Tab characters string: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Alphanumeric character string: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Non-numeric character string: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Boolean true literal: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Boolean false literal: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Number with preceding non-numeric characters: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Number with trailling non-numeric characters: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Undefined value: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Null value: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;NaN value: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Infinity primitive: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Positive Infinity: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Negative Infinity: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Date object: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Empty object: false&lt;/li&gt;\r\n\r\n          &lt;li class=&quot;pass&quot;&gt;Instance of a function: false&lt;/li&gt;\r\n        &lt;/ol&gt;\r\n      &lt;/li&gt;\r\n    &lt;/ol&gt;\r\n\r\n    &lt;div id=&quot;main&quot;&gt;\r\n      This page contains tests for a set of isNumber functions. To see them, take a look at the source.\r\n    &lt;/div&gt;\r\n\r\n    &lt;div&gt;\r\n      &lt;p class=&quot;result&quot;&gt;Tests completed in 0 milliseconds.\r\n        &lt;br&gt;0 tests of 0 failed.&lt;/p&gt;\r\n    &lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://stackoverflow.com/a/1830844/592253\r\n  [2]: http://dl.getdropbox.com/u/35146/js/tests/isNumber.html\r\n  [3]: http://jsfiddle.net/Xotic750/2q8pp/\r\n  [4]: https://stackoverflow.com/a/15230431/592253"},{"score":2,"body_markdown":"**knockoutJs Inbuild library validation functions** \r\n\r\nBy extending it the field get validated\r\n\r\n1) number\r\n\r\n`self.number = ko.observable(numberValue)`**.extend({ number: true})**;\r\n\r\nTestCase\r\n\r\n    numberValue = &#39;0.0&#39;    --&gt; true\r\n    numberValue = &#39;0&#39;      --&gt; true\r\n    numberValue = &#39;25&#39;     --&gt; true\r\n    numberValue = &#39;-1&#39;     --&gt; true\r\n    numberValue = &#39;-3.5&#39;   --&gt; true\r\n    numberValue = &#39;11.112&#39; --&gt; true\r\n    numberValue = &#39;0x89f&#39;  --&gt; false\r\n    numberValue = &#39;&#39;       --&gt; false\r\n    numberValue = &#39;sfsd&#39;   --&gt; false\r\n    numberValue = &#39;dg##$&#39;  --&gt; false\r\n\r\n2) digit\r\n\r\n`self.number = ko.observable(numberValue)`**.extend({ digit: true})**;\r\n\r\nTestCase\r\n\r\n    numberValue = &#39;0&#39;      --&gt; true\r\n    numberValue = &#39;25&#39;     --&gt; true\r\n    numberValue = &#39;0.0&#39;    --&gt; false\r\n    numberValue = &#39;-1&#39;     --&gt; false\r\n    numberValue = &#39;-3.5&#39;   --&gt; false\r\n    numberValue = &#39;11.112&#39; --&gt; false\r\n    numberValue = &#39;0x89f&#39;  --&gt; false\r\n    numberValue = &#39;&#39;       --&gt; false\r\n    numberValue = &#39;sfsd&#39;   --&gt; false\r\n    numberValue = &#39;dg##$&#39;  --&gt; false\r\n\r\n3) min and max\r\n\r\n`self.number = ko.observable(numberValue)`**.extend({ min: 5}).extend({ max: 10})**;\r\n\r\nThis field accept value between 5 and 10 only\r\n\r\nTestCase\r\n\r\n    numberValue = &#39;5&#39;    --&gt; true\r\n    numberValue = &#39;6&#39;    --&gt; true\r\n    numberValue = &#39;6.5&#39;  --&gt; true\r\n    numberValue = &#39;9&#39;    --&gt; true\r\n    numberValue = &#39;11&#39;   --&gt; false\r\n    numberValue = &#39;0&#39;    --&gt; false\r\n    numberValue = &#39;&#39;    --&gt; false\r\n   "},{"score":1,"body_markdown":"[@CMS&#39; answer][1]: Your snippet failed on whitespace cases on my machine using nodejs. So I combined it with \r\n[@joel&#39;s answer][2] to the following:\r\n\r\n    is_float = function(v) {\r\n        return !isNaN(v) &amp;&amp; isFinite(v) &amp;&amp;\r\n            (typeof(v) == &#39;number&#39; || v.replace(/^\\s+|\\s+$/g, &#39;&#39;).length &gt; 0);\r\n    }\r\n\r\nI unittested it with those cases that are floats:\r\n\r\n    var t = [\r\n            0,\r\n            1.2123,\r\n            &#39;0&#39;,\r\n            &#39;2123.4&#39;,\r\n            -1,\r\n            &#39;-1&#39;,\r\n            -123.423,\r\n            &#39;-123.432&#39;,\r\n            07,\r\n            0xad,\r\n            &#39;07&#39;,\r\n            &#39;0xad&#39;\r\n        ];\r\n\r\nand those cases that are no floats (including empty whitespaces and objects / arrays):\r\n\r\n        var t = [\r\n            &#39;hallo&#39;,\r\n            [],\r\n            {},\r\n            &#39;jklsd0&#39;,\r\n            &#39;&#39;,\r\n            &quot;\\t&quot;,\r\n            &quot;\\n&quot;,\r\n            &#39; &#39;\r\n        ];\r\n\r\nEverything works as expected here. Maybe this helps.\r\n\r\nFull source code for this can be found [here][3].\r\n\r\n\r\n  [1]: https://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric/1839844#1839844\r\n  [2]: https://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric/174921#174921\r\n  [3]: https://github.com/philippkemmeter/philfw/blob/master/lib/ValueChecker.js"},{"score":4,"body_markdown":"Here&#39;s a lil bit improved version (probably the fastest way out there) that I use instead of exact jQuery&#39;s variant, I really don&#39;t know why don&#39;t they use this one:\r\n\r\n\r\n    function isNumeric(val) {\r\n    \treturn !isNaN(+val) &amp;&amp; isFinite(val);\r\n    }\r\n\r\nThe downside of jQuery&#39;s version is that if you pass a string with leading numerics and trailing letters like `&quot;123abc&quot;` the `parseFloat | parseInt` will extract the numeric fraction out and return 123, BUT, the second guard `isFinite` will fail it anyway.\r\nWith the unary `+` operator it will die on the very first guard since + throws NaN for such hybrids :)\r\nA little performance yet I think a solid semantic gain."},{"score":7,"body_markdown":"Only problem I had with @CMS&#39;s [answer](https://stackoverflow.com/a/1830844/623735) is the exclusion of `NaN` and Infinity, which are useful numbers for many situations. One way to check for `NaN`&#39;s is to check for numeric values that don&#39;t equal themselves, `NaN != NaN`!  So there are really 3 tests you&#39;d like to deal with ...\r\n\r\n    function isNumber(n) {\r\n      n = parseFloat(n);\r\n      return !isNaN(n) || n != n;\r\n    }\r\n    function isFiniteNumber(n) {\r\n      n = parseFloat(n);\r\n      return !isNaN(n) &amp;&amp; isFinite(n);\r\n    }    \r\n    function isComparableNumber(n) {\r\n      n = parseFloat(n);\r\n      return (n &gt;=0 || n &lt; 0);\r\n    }\r\n\r\n    isFiniteNumber(&#39;NaN&#39;)\r\n    false\r\n    isFiniteNumber(&#39;OxFF&#39;)\r\n    true\r\n    isNumber(&#39;NaN&#39;)\r\n    true\r\n    isNumber(1/0-1/0)\r\n    true\r\n    isComparableNumber(&#39;NaN&#39;)\r\n    false\r\n    isComparableNumber(&#39;Infinity&#39;)\r\n    true\r\n\r\nMy isComparableNumber is pretty close to another elegant [answer](https://stackoverflow.com/a/1561597/623735), but handles hex and other string representations of numbers."},{"score":0,"body_markdown":"I found simple solution, probably not best but it&#39;s working fine :)\r\n\r\nSo, what I do is next, I parse string to Int and check if length size of new variable which is now int type is same as length of original string variable. Logically if size is the same it means string is fully parsed to int and that is only possible if string is &quot;made&quot; only of numbers.\r\n\r\n\tvar val=1+$(e).val()+&#39;&#39;;\r\n\tvar n=parseInt(val)+&#39;&#39;;\r\n\tif(val.length == n.length )alert(&#39;Is int&#39;);\r\n\r\nYou can easily put that code in function and instead of alert use return true if int.\r\nRemember, if you use dot or comma in string you are checking it&#39;s still false cos you are parsing to int.\r\n\r\nNote: Adding 1+ on e.val so starting zero wouldn&#39;t be removed.\r\n"},{"score":2,"body_markdown":"I have run the following below and it passes all the test cases...\r\n\r\nIt makes use of the different way in which `parseFloat` and `Number` handle their inputs...\r\n\r\n    function IsNumeric(_in) {\r\n        return (parseFloat(_in) === Number(_in) &amp;&amp; Number(_in) !== NaN);\r\n    }"},{"score":1,"body_markdown":"The following seems to works fine for many cases:\r\n\r\n    function isNumeric(num) {\r\n        return (num &gt; 0 || num === 0 || num === &#39;0&#39; || num &lt; 0) &amp;&amp; num !== true &amp;&amp; isFinite(num);\r\n    }\r\n\r\nThis is built on top of this answer (which is for this answer too):\r\nhttps://stackoverflow.com/a/1561597/1985601"},{"score":8,"body_markdown":"I realize the original question did not mention jQuery, but if you do use jQuery, you can do:\r\n\r\n    $.isNumeric(val)\r\n\r\nSimple.\r\n\r\nhttps://api.jquery.com/jQuery.isNumeric/ (as of jQuery 1.7)"},{"score":2,"body_markdown":"I realize this has been answered many times, but the following is a decent candidate which can be useful in some scenarios.\r\n\r\nit should be noted that it assumes that &#39;.42&#39; is NOT a number, and &#39;4.&#39; is NOT a number, so this should be taken into account.\r\n\r\n    function isDecimal(x) {\r\n      return &#39;&#39; + x === &#39;&#39; + +x;\r\n    }\r\n\r\n    function isInteger(x) {\r\n      return &#39;&#39; + x === &#39;&#39; + parseInt(x);\r\n    }\r\n\r\nThe ```isDecimal``` passes the following test:\r\n\r\n    function testIsNumber(f) {\r\n      return f(&#39;-1&#39;) &amp;&amp; f(&#39;-1.5&#39;) &amp;&amp; f(&#39;0&#39;) &amp;&amp; f(&#39;0.42&#39;)\r\n        &amp;&amp; !f(&#39;.42&#39;) &amp;&amp; !f(&#39;99,999&#39;) &amp;&amp; !f(&#39;0x89f&#39;)\r\n        &amp;&amp; !f(&#39;#abcdef&#39;) &amp;&amp; !f(&#39;1.2.3&#39;) &amp;&amp; !f(&#39;&#39;) &amp;&amp; !f(&#39;blah&#39;);\r\n    }\r\n\r\nThe idea here is that every number or integer has one &quot;canonical&quot; string representation, and every non-canonical representation should be rejected. So we cast to a number and back, and see if the result is the original string.\r\n\r\nWhether these functions are useful for you depends on the use case. One feature is that *distinct strings represent distinct numbers* (if both pass the ```isNumber()``` test).\r\n\r\nThis is relevant e.g. for numbers as object property names.\r\n\r\n    var obj = {};\r\n    obj[&#39;4&#39;] = &#39;canonical 4&#39;;\r\n    obj[&#39;04&#39;] = &#39;alias of 4&#39;;\r\n    obj[4];  // prints &#39;canonical 4&#39; to the console."},{"score":-1,"body_markdown":"I use this way to chack that varible is numeric:\r\n\r\n    v * 1 == v"},{"score":1,"body_markdown":"    function isNumber(n) {\r\n        return (n===n+&#39;&#39;||n===n-0) &amp;&amp; n*0==0 &amp;&amp; /\\S/.test(n);\r\n    }\r\n\r\n**Explanations:**\r\n\r\n`(n===n-0||n===n+&#39;&#39;)` verifies if n is a number or a string *(discards arrays, boolean, date, null, ...)*. You can replace `(n===n-0||n===n+&#39;&#39;)` by `n!==undefined &amp;&amp; n!==null &amp;&amp; (n.constructor===Number||n.constructor===String)`: significantly faster but less concise.\r\n\r\n`n*0==0` verifies if n is a finite number as `isFinite(n)` does. If you need to check strings that represent negative hexadecimal, just replace `n*0==0` by something like `n.toString().replace(/^\\s*-/,&#39;&#39;)*0==0`.  \r\nIt costs a little of course, so if you don&#39;t need it, don&#39;t use it.\r\n\r\n`/\\S/.test(n)` discards empty strings or strings, that contain only white-spaces *(necessary since `isFinite(n) or n*0==0` return a `false` positive in this case)*. You can reduce the number of call to `.test(n)` by using `(n!=0||/0/.test(n))` instead of `/\\S/.test(n)`, or you can use a slightly faster but less concise test such as `(n!=0||(n+&#39;&#39;).indexOf(&#39;0&#39;)&gt;=0)`: tiny improvement.\r\n\r\n\r\n"},{"score":3,"body_markdown":"None of the answers return `false` for empty strings, a fix for that...\r\n\r\n    function is_numeric(n)\r\n    {\r\n     return (n != &#39;&#39; &amp;&amp; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n));\r\n    }"},{"score":1,"body_markdown":"One can use a type-check library like https://github.com/arasatasaygin/is.js or just extract a check snippet from there (https://github.com/arasatasaygin/is.js/blob/master/is.js#L131):\r\n\r\n    is.nan = function(value) {    // NaN is number :) \r\n      return value !== value;\r\n    };\r\n     // is a given value number?\r\n    is.number = function(value) {\r\n        return !is.nan(value) &amp;&amp; Object.prototype.toString.call(value) === &#39;[object Number]&#39;;\r\n    };\r\n\r\nIn general if  you need it to validate parameter types (on entry point of function call), you can go with JSDOC-compliant contracts (https://www.npmjs.com/package/bycontract):\r\n\r\n    /**\r\n     * This is JSDOC syntax\r\n     * @param {number|string} sum\r\n     * @param {Object.&lt;string, string&gt;} payload\r\n     * @param {function} cb\r\n     */\r\n    function foo( sum, payload, cb ) {\r\n      // Test if the contract is respected at entry point\r\n      byContract( arguments, [ &quot;number|string&quot;, &quot;Object.&lt;string, string&gt;&quot;, &quot;function&quot; ] );\r\n    }\r\n    // Test it\r\n    foo( 100, { foo: &quot;foo&quot; }, function(){}); // ok\r\n    foo( 100, { foo: 100 }, function(){}); // exception"},{"score":2,"body_markdown":"If you need to validate a special set of decimals y\r\nyou can use this simple javascript:\r\n\r\nhttp://codesheet.org/codesheet/x1kI7hAD\r\n\r\n\r\n\r\n\r\n    &lt;input type=&quot;text&quot; name=&quot;date&quot; value=&quot;&quot; pattern=&quot;[0-9]){1,2}(\\.){1}([0-9]){2}&quot; maxlength=&quot;6&quot; placeholder=&quot;od npr.: 16.06&quot; onchange=&quot;date(this);&quot; /&gt;\r\n\r\n\r\n\r\nThe Javascript:\r\n\r\n\r\n    function date(inputField) {        \r\n      var isValid = /^([0-9]){1,2}(\\.){1}([0-9]){2}$/.test(inputField.value);   \r\n      if (isValid) {\r\n        inputField.style.backgroundColor = &#39;#bfa&#39;;\r\n      } else {\r\n        inputField.style.backgroundColor = &#39;#fba&#39;;\r\n      }\r\n      return isValid;\r\n    }\r\n\r\n"},{"score":2,"body_markdown":"`isNumeric=(el)=&gt;{return Boolean(parseFloat(el)) &amp;&amp; isFinite(el)}`\r\n\r\nNothing very different but we can use Boolean constructor"},{"score":3,"body_markdown":"To check if a variable contains a valid number and not\r\njust a String which looks like a number,\r\n`Number.isFinite(value)` can be used.\r\n\r\nThis is part of the language since\r\n[ES2015](http://www.ecma-international.org/ecma-262/6.0/#sec-number.isfinite)\r\n\r\nExamples:\r\n\r\n    Number.isFinite(Infinity)   // false\r\n    Number.isFinite(NaN)        // false\r\n    Number.isFinite(-Infinity)  // false\r\n    \r\n    Number.isFinite(0)          // true\r\n    Number.isFinite(2e64)       // true\r\n    \r\n    Number.isFinite(&#39;0&#39;)        // false\r\n    Number.isFinite(null)       // false"},{"score":-1,"body_markdown":"    function isNumeric(n) {\r\n        var isNumber = true;\r\n  \r\n        $.each(n.replace(/ /g,&#39;&#39;).toString(), function(i, v){\r\n\t        if(v!=&#39;,&#39; &amp;&amp; v!=&#39;.&#39; &amp;&amp; v!=&#39;-&#39;){\r\n\t\t        if(isNaN(v)){\r\n\t\t\t       isNumber = false;\r\n\t\t\t       return false;\r\n\t\t        }\r\n\t         }\r\n         });\r\n  \r\n        return isNumber;\r\n    }\r\n\r\n    isNumeric(-3,4567.89);   // true &lt;br&gt;\r\n\r\n    isNumeric(3,4567.89);   // true &lt;br&gt;\r\n\r\n    isNumeric(&quot;-3,4567.89&quot;);   // true &lt;br&gt;\r\n\r\n    isNumeric(3d,4567.89);   // false"},{"score":1,"body_markdown":"Best way to do this is like this:\r\n\r\n    function isThisActuallyANumber(data){\r\n        return ( typeof data === &quot;number&quot; &amp;&amp; !isNaN(data) );\r\n    }"},{"score":6,"body_markdown":"I think parseFloat function can do all the work here. The function below passes all the tests on this page including `isNumeric(Infinity) == true`:\r\n\r\n    function isNumeric(n) {\r\n\r\n        return parseFloat(n) == n;\r\n    }\r\n\r\n"},{"score":3,"body_markdown":"    function inNumeric(n){\r\n       return Number(n).toString() === n;\r\n    }\r\nIf n is numeric `Number(n)` will return the numeric value and `toString()` will turn it back to a string. But if n isn&#39;t numeric `Number(n)` will return `NaN` so it won&#39;t match the original `n`"},{"score":2,"body_markdown":"I think my code is perfect ...\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    /**\r\n     * @param {string} s\r\n     * @return {boolean}\r\n     */\r\n    var isNumber = function(s) {\r\n        return s.trim()!==&quot;&quot; &amp;&amp; !isNaN(Number(s));\r\n    };\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":-1,"body_markdown":"\r\n\r\n    $(&#39;.rsval&#39;).bind(&#39;keypress&#39;, function(e){  \r\n            var asciiCodeOfNumbers = [48,46, 49, 50, 51, 52, 53, 54, 54, 55, 56, 57];\r\n            var keynum = (!window.event) ? e.which : e.keyCode; \r\n            var splitn = this.value.split(&quot;.&quot;); \r\n            var decimal = splitn.length;\r\n            var precision = splitn[1]; \r\n            if(decimal == 2 &amp;&amp; precision.length &gt;= 2  ) { console.log(precision , &#39;e&#39;);   e.preventDefault(); } \r\n            if( keynum == 46 ){  \r\n                if(decimal &gt; 2) { e.preventDefault(); }  \r\n            } \r\n            if ($.inArray(keynum, asciiCodeOfNumbers) == -1)\r\n                e.preventDefault();    \r\n      });\r\n\r\n"},{"score":2,"body_markdown":"You can minimize this function in a lot of way, and you can also implement it with a custom regex for negative values or custom charts:\r\n\r\n    $(&#39;.number&#39;).on(&#39;input&#39;,function(){\r\n    \tvar n=$(this).val().replace(/ /g,&#39;&#39;).replace(/\\D/g,&#39;&#39;);\r\n    \tif (!$.isNumeric(n))\r\n    \t\t$(this).val(n.slice(0, -1))\r\n    \telse\r\n    \t\t$(this).val(n)\r\n    });"},{"score":2,"body_markdown":"No need to use extra lib.\r\n\r\n    const IsNumeric = (...numbers) =&gt; {\r\n      return numbers.reduce((pre, cur) =&gt; pre &amp;&amp; !!(cur === 0 || +cur), true);\r\n    };\r\n\r\nTest\r\n\r\n    &gt; IsNumeric(1)\r\n    true\r\n    &gt; IsNumeric(1,2,3)\r\n    true\r\n    &gt; IsNumeric(1,2,3,0)\r\n    true\r\n    &gt; IsNumeric(1,2,3,0,&#39;&#39;)\r\n    false\r\n    &gt; IsNumeric(1,2,3,0,&#39;2&#39;)\r\n    true\r\n    &gt; IsNumeric(1,2,3,0,&#39;200&#39;)\r\n    true\r\n    &gt; IsNumeric(1,2,3,0,&#39;-200&#39;)\r\n    true\r\n    &gt; IsNumeric(1,2,3,0,&#39;-200&#39;,&#39;.32&#39;)\r\n    true\r\n\r\n"},{"score":2,"body_markdown":"A simple and clean solution by leveraging language&#39;s dynamic type checking:\r\n\r\n```js\r\nfunction IsNumeric (string) {\r\n   if(string === &#39; &#39;.repeat(string.length)){\r\n     return false\r\n   }\r\n   return string - 0 === string * 1\r\n}\r\n\r\n```\r\n\r\nif you don&#39;t care about white-spaces you can remove that &quot; if &quot; \r\n\r\nsee test cases below\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function IsNumeric (string) {\r\n       if(string === &#39; &#39;.repeat(string.length)){\r\n          return false\r\n       }\r\n       return string - 0 === string * 1\r\n    }\r\n\r\n\r\n    console.log(&#39;-1&#39; + &#39; → &#39; + IsNumeric(&#39;-1&#39;))    \r\n    console.log(&#39;-1.5&#39; + &#39; → &#39; + IsNumeric(&#39;-1.5&#39;)) \r\n    console.log(&#39;0&#39; + &#39; → &#39; + IsNumeric(&#39;0&#39;))     \r\n    console.log(&#39;0.42&#39; + &#39; → &#39; + IsNumeric(&#39;0.42&#39;))   \r\n    console.log(&#39;.42&#39; + &#39; → &#39; + IsNumeric(&#39;.42&#39;))    \r\n    console.log(&#39;99,999&#39; + &#39; → &#39; + IsNumeric(&#39;99,999&#39;))\r\n    console.log(&#39;0x89f&#39; + &#39; → &#39; + IsNumeric(&#39;0x89f&#39;))  \r\n    console.log(&#39;#abcdef&#39; + &#39; → &#39; + IsNumeric(&#39;#abcdef&#39;))\r\n    console.log(&#39;1.2.3&#39; + &#39; → &#39; + IsNumeric(&#39;1.2.3&#39;)) \r\n    console.log(&#39;&#39; + &#39; → &#39; + IsNumeric(&#39;&#39;))    \r\n    console.log(&#39;33 &#39; + &#39; → &#39; + IsNumeric(&#39;33 &#39;))\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"Here&#39;s a *dead-simple* one (tested in Chrome, Firefox, and IE):\r\n==\r\n    function isNumeric(x) {\r\n      return parseFloat(x) == x;\r\n    }\r\n\r\nTest cases from question:\r\n\r\n    console.log(&#39;trues&#39;);\r\n    console.log(isNumeric(&#39;-1&#39;));\r\n    console.log(isNumeric(&#39;-1.5&#39;));\r\n    console.log(isNumeric(&#39;0&#39;));\r\n    console.log(isNumeric(&#39;0.42&#39;));\r\n    console.log(isNumeric(&#39;.42&#39;));\r\n\r\n    console.log(&#39;falses&#39;);\r\n    console.log(isNumeric(&#39;99,999&#39;));\r\n    console.log(isNumeric(&#39;0x89f&#39;));\r\n    console.log(isNumeric(&#39;#abcdef&#39;));\r\n    console.log(isNumeric(&#39;1.2.3&#39;));\r\n    console.log(isNumeric(&#39;&#39;));\r\n    console.log(isNumeric(&#39;blah&#39;));\r\n\r\nSome more test cases:\r\n\r\n    console.log(&#39;trues&#39;);\r\n    console.log(isNumeric(0));\r\n    console.log(isNumeric(-1));\r\n    console.log(isNumeric(-500));\r\n    console.log(isNumeric(15000));\r\n    console.log(isNumeric(0.35));\r\n    console.log(isNumeric(-10.35));\r\n    console.log(isNumeric(2.534e25));\r\n    console.log(isNumeric(&#39;2.534e25&#39;));\r\n    console.log(isNumeric(&#39;52334&#39;));\r\n    console.log(isNumeric(&#39;-234&#39;));\r\n    console.log(isNumeric(Infinity));\r\n    console.log(isNumeric(-Infinity));\r\n    console.log(isNumeric(&#39;Infinity&#39;));\r\n    console.log(isNumeric(&#39;-Infinity&#39;));\r\n    \r\n    console.log(&#39;falses&#39;);\r\n    console.log(isNumeric(NaN));\r\n    console.log(isNumeric({}));\r\n    console.log(isNumeric([]));\r\n    console.log(isNumeric(&#39;&#39;));\r\n    console.log(isNumeric(&#39;one&#39;));\r\n    console.log(isNumeric(true));\r\n    console.log(isNumeric(false));\r\n    console.log(isNumeric());\r\n    console.log(isNumeric(undefined));\r\n    console.log(isNumeric(null));\r\n    console.log(isNumeric(&#39;-234aa&#39;));\r\n\r\nNote that it considers infinity a number."}],"score":2421}