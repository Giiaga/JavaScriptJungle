{"body":"I have some HTML menus, which I show completely when a user clicks on the head of these menus. I would like to hide these elements when the user clicks outside the menus&#39; area.\r\n\r\nIs something like this possible with jQuery?\r\n\r\n    $(&quot;#menuscontainer&quot;).clickOutsideThisElement(function() {\r\n        // Hide the menus\r\n    });\r\n","title":"How do I detect a click outside an element?","answers":[{"score":21,"body_markdown":"Check the window click event target (it should propagate to the window, as long as it&#39;s not captured anywhere else), and ensure that it&#39;s not any of the menu elements.  If it&#39;s not, then you&#39;re outside your menu.\r\n\r\nOr check the position of the click, and see if it&#39;s contained within the menu area."},{"score":1863,"body_markdown":"&gt; NOTE: Using `stopEventPropagation()` is something that should be avoided as it breaks normal event flow in the DOM. See [this article][1] for more information. Consider using [this method](https://stackoverflow.com/a/3028037/561309) instead\r\n\r\nAttach a click event to the document body which closes the window. Attach a separate click event to the container which stops propagation to the document body.\r\n\r\n    $(window).click(function() {\r\n    //Hide the menus if visible\r\n    });\r\n\r\n    $(&#39;#menucontainer&#39;).click(function(event){\r\n        event.stopPropagation();\r\n    });\r\n\r\n\r\n  [1]: https://css-tricks.com/dangers-stopping-event-propagation/"},{"score":131,"body_markdown":"I have an application that works similarly to Eran&#39;s example, except I attach the click event to the body when I open the menu... Kinda like this:\r\n\r\n    $(&#39;#menucontainer&#39;).click(function(event) {\r\n      $(&#39;html&#39;).one(&#39;click&#39;,function() {\r\n        // Hide the menus\r\n      });\r\n    \r\n      event.stopPropagation();\r\n    });\r\n\r\nMore information on [jQuery&#39;s `one()` function][1]\r\n\r\n\r\n  [1]: http://docs.jquery.com/Events/one"},{"score":145,"body_markdown":"The other solutions here didn&#39;t work for me so I had to use:\r\n\r\n    if(!$(event.target).is(&#39;#foo&#39;))\r\n\t{\r\n\t\t// hide menu\r\n\t}"},{"score":8,"body_markdown":"If you are scripting for IE and FF 3.* and you just want to know if the click occured within a certain box area, you could also use something like:\r\n\r\n    this.outsideElementClick = function(objEvent, objElement){   \r\n    var objCurrentElement = objEvent.target || objEvent.srcElement;\r\n    var blnInsideX = false;\r\n    var blnInsideY = false;\r\n    \r\n    if (objCurrentElement.getBoundingClientRect().left &gt;= objElement.getBoundingClientRect().left &amp;&amp; objCurrentElement.getBoundingClientRect().right &lt;= objElement.getBoundingClientRect().right)\r\n        blnInsideX = true;\r\n\r\n    if (objCurrentElement.getBoundingClientRect().top &gt;= objElement.getBoundingClientRect().top &amp;&amp; objCurrentElement.getBoundingClientRect().bottom &lt;= objElement.getBoundingClientRect().bottom)\r\n        blnInsideY = true;\r\n\r\n    if (blnInsideX &amp;&amp; blnInsideY)\r\n        return false;\r\n    else\r\n        return true;}\r\n\r\n"},{"score":42,"body_markdown":"    $(&quot;#menuscontainer&quot;).click(function() {\r\n        $(this).focus();\r\n    });\r\n    $(&quot;#menuscontainer&quot;).blur(function(){\r\n        $(this).hide();\r\n    });\r\n\r\nWorks for me just fine."},{"score":38,"body_markdown":"Now there is a plugin for that: [outside events][1] ([blog post][2])\r\n\r\nThe following happens when a *clickoutside* handler (WLOG) is bound to an element:\r\n\r\n - the element is added to an array which holds all elements with *clickoutside* handlers\r\n - a ([namespaced][3]) *click* handler is bound to the document (if not already there)\r\n - on any *click* in the document, the *clickoutside* event is triggered for those elements in that array that are not equal to or a parent of the *click*-events target\r\n - additionally, the event.target for the *clickoutside* event is set to the element the user clicked on (so you even know what the user clicked, not just that he clicked outside)\r\n\r\nSo no events are stopped from propagation and additional *click* handlers may be used &quot;above&quot; the element with the outside-handler.\r\n\r\n  [1]: https://github.com/cowboy/jquery-outside-events\r\n  [2]: http://benalman.com/projects/jquery-outside-events-plugin/\r\n  [3]: http://docs.jquery.com/Namespaced_Events"},{"score":2,"body_markdown":"This worked perfectly fine in time for me:\r\n\r\n    $(&#39;body&#39;).click(function() {\r\n        // Hide the menus if visible.\r\n    });\r\n"},{"score":1443,"body_markdown":"You can listen for a **click** event on `document` and then make sure `#menucontainer` is not an ancestor or the target of the clicked element by using  [`.closest()`](http://api.jquery.com/closest/).\r\n\r\nIf it is not, then the clicked element is outside of the `#menucontainer` and you can safely hide it.\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $(document).click(function(event) { \r\n      var $target = $(event.target);\r\n      if(!$target.closest(&#39;#menucontainer&#39;).length &amp;&amp; \r\n      $(&#39;#menucontainer&#39;).is(&quot;:visible&quot;)) {\r\n        $(&#39;#menucontainer&#39;).hide();\r\n      }        \r\n    });\r\n\r\n### Edit – 2017-06-23\r\n\r\nYou can also clean up after the event listener if you plan to dismiss the menu and want to stop listening for events. This function will clean up only the newly created listener, preserving any other click listeners on `document`. With ES2015 syntax:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    export function hideOnClickOutside(selector) {\r\n      const outsideClickListener = (event) =&gt; {\r\n        const $target = $(event.target);\r\n        if (!$target.closest(selector).length &amp;&amp; $(selector).is(&#39;:visible&#39;)) {\r\n            $(selector).hide();\r\n            removeClickListener();\r\n        }\r\n      }\r\n\r\n      const removeClickListener = () =&gt; {\r\n        document.removeEventListener(&#39;click&#39;, outsideClickListener)\r\n      }\r\n\r\n      document.addEventListener(&#39;click&#39;, outsideClickListener)\r\n    }\r\n\r\n### Edit – 2018-03-11\r\n\r\nFor those who don&#39;t want to use jQuery. Here&#39;s the above code in plain vanillaJS (ECMAScript6).\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function hideOnClickOutside(element) {\r\n    \tconst outsideClickListener = event =&gt; {\r\n    \t\tif (!element.contains(event.target) &amp;&amp; isVisible(element)) { // or use: event.target.closest(selector) === null\r\n    \t\t  element.style.display = &#39;none&#39;\r\n    \t\t  removeClickListener()\r\n    \t\t}\r\n    \t}\r\n    \r\n    \tconst removeClickListener = () =&gt; {\r\n    \t\tdocument.removeEventListener(&#39;click&#39;, outsideClickListener)\r\n    \t}\r\n    \r\n    \tdocument.addEventListener(&#39;click&#39;, outsideClickListener)\r\n    }\r\n\r\n    const isVisible = elem =&gt; !!elem &amp;&amp; !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length ) // source (2018-03-11): https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js \r\n\r\n**NOTE:**\r\nThis is based on Alex comment to just use `!element.contains(event.target)` instead of the jQuery part.\r\n\r\nBut `element.closest()` is now also available in all major browsers (the W3C version differs a bit from the jQuery one).\r\nPolyfills can be found here: [Element.closest()][1]\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\r\n\r\n### Edit – 2020-05-21\r\n\r\nIn the case where you want the user to be able to click-and-drag inside the element, then release the mouse outside the element, without closing the element:\r\n          \r\n          ...\r\n          let lastMouseDownX = 0;\r\n          let lastMouseDownY = 0;\r\n          let lastMouseDownWasOutside = false;\r\n\r\n          const mouseDownListener = (event: MouseEvent) =&gt; {\r\n            lastMouseDownX = event.offsetX\r\n            lastMouseDownY = event.offsetY\r\n            lastMouseDownWasOutside = !$(event.target).closest(element).length\r\n          }\r\n          document.addEventListener(&#39;mousedown&#39;, mouseDownListener);\r\n\r\nAnd in `outsideClickListener`:\r\n\r\n    const outsideClickListener = event =&gt; {\r\n            const deltaX = event.offsetX - lastMouseDownX\r\n            const deltaY = event.offsetY - lastMouseDownY\r\n            const distSq = (deltaX * deltaX) + (deltaY * deltaY)\r\n            const isDrag = distSq &gt; 3\r\n            const isDragException = isDrag &amp;&amp; !lastMouseDownWasOutside\r\n\r\n    \t\tif (!element.contains(event.target) &amp;&amp; isVisible(element) &amp;&amp; !isDragException) { // or use: event.target.closest(selector) === null\r\n    \t\t  element.style.display = &#39;none&#39;\r\n    \t\t  removeClickListener()\r\n              document.removeEventListener(&#39;mousedown&#39;, mouseDownListener); // Or add this line to removeClickListener()\r\n    \t\t}\r\n    \t}"},{"score":4,"body_markdown":"Function:\r\n\r\n    $(function() {\r\n        $.fn.click_inout = function(clickin_handler, clickout_handler) {\r\n            var item = this;\r\n            var is_me = false;\r\n            item.click(function(event) {\r\n                clickin_handler(event);\r\n                is_me = true;\r\n            });\r\n            $(document).click(function(event) {\r\n                if (is_me) {\r\n                    is_me = false;\r\n                } else {\r\n                    clickout_handler(event);\r\n                }\r\n            });\r\n            return this;\r\n        }\r\n    });\r\n\r\nUsage:\r\n\r\n    this.input = $(&#39;&lt;input&gt;&#39;)\r\n        .click_inout(\r\n            function(event) { me.ShowTree(event); },\r\n            function() { me.Hide(); }\r\n        )\r\n        .appendTo(this.node);\r\n\r\nAnd functions are very simple:\r\n\r\n    ShowTree: function(event) {\r\n        this.data_span.show();\r\n    }\r\n    Hide: function() {\r\n        this.data_span.hide();\r\n    }\r\n"},{"score":18,"body_markdown":"I&#39;ve had success with something like this:\r\n\r\n    var $menuscontainer = ...;\r\n\r\n    $(&#39;#trigger&#39;).click(function() {\r\n      $menuscontainer.show();\r\n\r\n      $(&#39;body&#39;).click(function(event) {\r\n        var $target = $(event.target);\r\n\r\n        if ($target.parents(&#39;#menuscontainer&#39;).length == 0) {\r\n          $menuscontainer.hide();\r\n        }\r\n      });\r\n    });\r\n\r\nThe logic is: when `#menuscontainer` is shown, bind a click handler to the body that hides `#menuscontainer` only if the target (of the click) isn&#39;t a child of it."},{"score":8,"body_markdown":"Use:\r\n\r\n    var go = false;\r\n    $(document).click(function(){\r\n        if(go){\r\n            $(&#39;#divID&#39;).hide();\r\n            go = false;\r\n        }\r\n    })\r\n\r\n    $(&quot;#divID&quot;).mouseover(function(){\r\n        go = false;\r\n    });\r\n\r\n    $(&quot;#divID&quot;).mouseout(function (){\r\n        go = true;\r\n    });\r\n\r\n    $(&quot;btnID&quot;).click( function(){\r\n        if($(&quot;#divID:visible&quot;).length==1)\r\n            $(&quot;#divID&quot;).hide(); // Toggle\r\n        $(&quot;#divID&quot;).show();\r\n    });\r\n"},{"score":26,"body_markdown":"I don&#39;t think what you really need is to close the menu when the user clicks outside; what you need is for the menu to close when the user clicks anywhere at all on the page. If you click on the menu, or off the menu it should close right? \r\n\r\nFinding no satisfactory answers above prompted me to write [this blog post][1] the other day. For the more pedantic, there are a number of gotchas to take note of: \r\n\r\n 1. If you attach a click event handler to the body element at click time be sure to wait for the 2nd click before closing the menu, and unbinding the event. Otherwise the click event that opened the menu will bubble up to the listener that has to close the menu.\r\n 2. If you use event.stopPropogation() on a click event, no other elements in your page can have a click-anywhere-to-close feature.\r\n 3. Attaching a click event handler to the body element indefinitely is not a performant solution\r\n 4. Comparing the target of the event, and its parents to the handler&#39;s creator assumes that what you want is to close the menu when you click off it, when what you really want is to close it when you click anywhere on the page.\r\n 5. Listening for events on the body element will make your code more brittle. Styling as innocent as this would break it: `body { margin-left:auto; margin-right: auto; width:960px;}`\r\n\r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  [1]: http://programming34m0.blogspot.com/2011/05/simplifying-javascript-jump-menu.html"},{"score":14,"body_markdown":"I found this method in some jQuery calendar plugin.\r\n\r\n    function ClickOutsideCheck(e)\r\n    {\r\n      var el = e.target;\r\n      var popup = $(&#39;.popup:visible&#39;)[0];\r\n      if (popup==undefined)\r\n        return true;\r\n\r\n      while (true){\r\n        if (el == popup ) {\r\n          return true;\r\n        } else if (el == document) {\r\n          $(&quot;.popup&quot;).hide();\r\n          return false;\r\n        } else {\r\n          el = $(el).parent()[0];\r\n        }\r\n      }\r\n    };\r\n\r\n    $(document).bind(&#39;mousedown.popup&#39;, ClickOutsideCheck);\r\n"},{"score":6,"body_markdown":"    $(document).click(function() {\r\n        $(&quot;.overlay-window&quot;).hide();\r\n    });\r\n    $(&quot;.overlay-window&quot;).click(function() {\r\n        return false;\r\n    });\r\n\r\nIf you click on the document, hide a given element, unless you click on that same element."},{"score":5,"body_markdown":"I did it like this in [YUI][1]&amp;nbsp;3:\r\n\r\n    // Detect the click anywhere other than the overlay element to close it.\r\n    Y.one(document).on(&#39;click&#39;, function (e) {\r\n        if (e.target.ancestor(&#39;#overlay&#39;) === null &amp;&amp; e.target.get(&#39;id&#39;) != &#39;show&#39; &amp;&amp; overlay.get(&#39;visible&#39;) == true) {\r\n            overlay.hide();\r\n        }\r\n    });\r\n\r\nI am checking if ancestor is not the widget element container, &lt;br/&gt;\r\nif target is not which open the widget/element, &lt;br/&gt;\r\nif widget/element I want to close is already open (not that important).\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Yahoo!_UI_Library\r\n"},{"score":25,"body_markdown":"As another poster said there are a lot of gotchas, especially if the element you are displaying (in this case a menu) has interactive elements.\r\nI&#39;ve found the following method to be fairly robust:\r\n\r\n    $(&#39;#menuscontainer&#39;).click(function(event) {\r\n        //your code that shows the menus fully\r\n    \r\n    \t//now set up an event listener so that clicking anywhere outside will close the menu\r\n    \t$(&#39;html&#39;).click(function(event) {\r\n    \t    //check up the tree of the click target to check whether user has clicked outside of menu\r\n    \t    if ($(event.target).parents(&#39;#menuscontainer&#39;).length==0) {\r\n    \t\t\t// your code to hide menu\r\n                \r\n                //this event listener has done its job so we can unbind it.\r\n    \t\t\t$(this).unbind(event);\r\n    \t\t}\r\n    \t\r\n    \t})\r\n    });"},{"score":2,"body_markdown":"Here is my code:\r\n\r\n    // Listen to every click\r\n    $(&#39;html&#39;).click(function(event) {\r\n        if ( $(&#39;#mypopupmenu&#39;).is(&#39;:visible&#39;) ) {\r\n            if (event.target.id != &#39;click_this_to_show_mypopupmenu&#39;) {\r\n                $(&#39;#mypopupmenu&#39;).hide();\r\n            }\r\n        }\r\n    });\r\n\r\n    // Listen to selector&#39;s clicks\r\n    $(&#39;#click_this_to_show_mypopupmenu&#39;).click(function() {\r\n\r\n      // If the menu is visible, and you clicked the selector again we need to hide\r\n      if ( $(&#39;#mypopupmenu&#39;).is(&#39;:visible&#39;) {\r\n          $(&#39;#mypopupmenu&#39;).hide();\r\n          return true;\r\n      }\r\n\r\n      // Else we need to show the popup menu\r\n      $(&#39;#mypopupmenu&#39;).show();\r\n    });\r\n"},{"score":4,"body_markdown":"This is my solution to this problem:\r\n\r\n\r\n    $(document).ready(function() {\r\n      $(&#39;#user-toggle&#39;).click(function(e) {\r\n        $(&#39;#user-nav&#39;).toggle();\r\n        e.stopPropagation();\r\n      });\r\n\r\n      $(&#39;body&#39;).click(function() {\r\n        $(&#39;#user-nav&#39;).hide(); \r\n      });\r\n\r\n      $(&#39;#user-nav&#39;).click(function(e){\r\n        e.stopPropagation();\r\n      });\r\n    });"},{"score":2,"body_markdown":"    jQuery().ready(function(){\r\n    \t$(&#39;#nav&#39;).click(function (event) {\r\n    \t\t$(this).addClass(&#39;activ&#39;);\r\n    \t\tevent.stopPropagation();\r\n    \t});\r\n    \t\r\n    \t$(&#39;html&#39;).click(function () {\r\n    \t\tif( $(&#39;#nav&#39;).hasClass(&#39;activ&#39;) ){\r\n    \t\t\t$(&#39;#nav&#39;).removeClass(&#39;activ&#39;);\r\n    \t\t}\r\n    \t});\r\n    });"},{"score":6,"body_markdown":"Hook a click event listener on the document. Inside the event listener, you can look at the [event object][1], in particular, the [event.target][2] to see what element was clicked:\r\n\r\n    $(document).click(function(e){\r\n        if ($(e.target).closest(&quot;#menuscontainer&quot;).length == 0) {\r\n            // .closest can help you determine if the element \r\n            // or one of its ancestors is #menuscontainer\r\n            console.log(&quot;hide&quot;);\r\n        }\r\n    });\r\n\r\n\r\n  [1]: http://api.jquery.com/category/events/event-object/\r\n  [2]: http://api.jquery.com/event.target/"},{"score":33,"body_markdown":"This worked for me perfectly!!\r\n\r\n    $(&#39;html&#39;).click(function (e) {\r\n        if (e.target.id == &#39;YOUR-DIV-ID&#39;) {\r\n            //do something\r\n        } else {\r\n            //do something\r\n        }\r\n    });"},{"score":2,"body_markdown":"To be honest, I didn&#39;t like any of previous the solutions.\r\n\r\nThe best way to do this, is binding the &quot;click&quot; event to the document, and comparing if that click is really outside the element (just like Art said in his suggestion).\r\n\r\nHowever, you&#39;ll have some problems there: You&#39;ll never be able to unbind it, and you cannot have an external button to open/close that element.\r\n\r\nThat&#39;s why I wrote [this small plugin (click here to link)][1], to simplify these tasks. Could it be simpler?\r\n\r\n    &lt;a id=&#39;theButton&#39; href=&quot;#&quot;&gt;Toggle the menu&lt;/a&gt;&lt;br/&gt;\r\n    &lt;div id=&#39;theMenu&#39;&gt;\r\n        I should be toggled when the above menu is clicked,\r\n        and hidden when user clicks outside.\r\n    &lt;/div&gt;\r\n\r\n    &lt;script&gt;\r\n    $(&#39;#theButton&#39;).click(function(){\r\n        $(&#39;#theMenu&#39;).slideDown();\r\n    });\r\n    $(&quot;#theMenu&quot;).dClickOutside({ ignoreList: $(&quot;#theButton&quot;) }, function(clickedObj){\r\n        $(this).slideUp();\r\n    });\r\n    &lt;/script&gt;\r\n\r\n  [1]: http://www.imaginacom.com/eval.php?exec=29\r\n"},{"score":0,"body_markdown":"Just a warning that using this:\r\n\r\n    $(&#39;html&#39;).click(function() {\r\n      // Hide the menus if visible\r\n    });\r\n\r\n    $(&#39;#menucontainer&#39;).click(function(event){\r\n      event.stopPropagation();\r\n    });\r\n\r\nIt **prevents** the [Ruby on Rails][1] UJS driver from working properly. For example, `link_to &#39;click&#39;, &#39;/url&#39;, :method =&gt; :delete` will not work.\r\n\r\nThis might be a workaround:\r\n\r\n    $(&#39;html&#39;).click(function() {\r\n      // Hide the menus if visible\r\n    });\r\n\r\n    $(&#39;#menucontainer&#39;).click(function(event){\r\n      if (!$(event.target).data(&#39;method&#39;)) {\r\n        event.stopPropagation();\r\n      }\r\n    });\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Ruby_on_Rails\r\n"},{"score":4,"body_markdown":"This should work:\r\n\r\n    $(&#39;body&#39;).click(function (event) {\r\n        var obj = $(event.target);\r\n        obj = obj[&#39;context&#39;]; // context : clicked element inside body\r\n        if ($(obj).attr(&#39;id&#39;) != &quot;menuscontainer&quot; &amp;&amp; $(&#39;#menuscontainer&#39;).is(&#39;:visible&#39;) == true) {\r\n            //hide menu\r\n        }\r\n    });"},{"score":-2,"body_markdown":"     &lt;div class=&quot;feedbackCont&quot; onblur=&quot;hidefeedback();&quot;&gt;\r\n            &lt;div class=&quot;feedbackb&quot; onclick=&quot;showfeedback();&quot; &gt;&lt;/div&gt;\r\n            &lt;div class=&quot;feedbackhide&quot; tabindex=&quot;1&quot;&gt; &lt;/div&gt;\r\n     &lt;/div&gt;\r\n\r\n    function hidefeedback(){\r\n        $j(&quot;.feedbackhide&quot;).hide();\r\n    }\r\n\r\n    function showfeedback(){\r\n        $j(&quot;.feedbackhide&quot;).show();\r\n        $j(&quot;.feedbackCont&quot;).attr(&quot;tabindex&quot;,1).focus();\r\n    }\r\n\r\nThis is the simplest solution I came up with. "},{"score":3,"body_markdown":"One more solution is here:\r\n\r\nhttp://jsfiddle.net/zR76D/\r\n\r\nUsage:\r\n\r\n    &lt;div onClick=&quot;$(&#39;#menu&#39;).toggle();$(&#39;#menu&#39;).clickOutside(function() { $(this).hide(); $(this).clickOutside(&#39;disable&#39;); });&quot;&gt;Open / Close Menu&lt;/div&gt;\r\n    &lt;div id=&quot;menu&quot; style=&quot;display: none; border: 1px solid #000000; background: #660000;&quot;&gt;I am a menu, whoa is me.&lt;/div&gt;\r\n\r\nPlugin:\r\n\r\n    (function($) {\r\n        var clickOutsideElements = [];\r\n        var clickListener = false;\r\n\r\n        $.fn.clickOutside = function(options, ignoreFirstClick) {\r\n            var that = this;\r\n            if (ignoreFirstClick == null) ignoreFirstClick = true;\r\n\r\n            if (options != &quot;disable&quot;) {\r\n                for (var i in clickOutsideElements) {\r\n                    if (clickOutsideElements[i].element[0] == $(this)[0]) return this;\r\n                }\r\n\r\n                clickOutsideElements.push({ element : this, clickDetected : ignoreFirstClick, fnc : (typeof(options) != &quot;function&quot;) ? function() {} : options });\r\n\r\n                $(this).on(&quot;click.clickOutside&quot;, function(event) {\r\n                    for (var i in clickOutsideElements) {\r\n                        if (clickOutsideElements[i].element[0] == $(this)[0]) {\r\n                            clickOutsideElements[i].clickDetected = true;\r\n                        }\r\n                    }\r\n                });\r\n\r\n                if (!clickListener) {\r\n                    if (options != null &amp;&amp; typeof(options) == &quot;function&quot;) {\r\n                        $(&#39;html&#39;).click(function() {\r\n                            for (var i in clickOutsideElements) {\r\n                                if (!clickOutsideElements[i].clickDetected) {\r\n                                    clickOutsideElements[i].fnc.call(that);\r\n                                }\r\n                                if (clickOutsideElements[i] != null) clickOutsideElements[i].clickDetected = false;\r\n                            }\r\n                        });\r\n                        clickListener = true;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                $(this).off(&quot;click.clickoutside&quot;);\r\n                for (var i = 0; i &lt; clickOutsideElements.length; ++i) {\r\n                    if (clickOutsideElements[i].element[0] == $(this)[0]) {\r\n                        clickOutsideElements.splice(i, 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this;\r\n        }\r\n    })(jQuery);\r\n\r\n"},{"score":2,"body_markdown":"The broadest way to do this is to select everything on the web page except the element where you don&#39;t want clicks detected and bind the click event those when the menu is opened. \r\n\r\nThen when the menu is closed remove the binding.\r\n\r\nUse .stopPropagation to prevent the event from affecting any part of the menuscontainer.\r\n\r\n    $(&quot;*&quot;).not($(&quot;#menuscontainer&quot;)).bind(&quot;click.OutsideMenus&quot;, function ()\r\n    {\r\n        // hide the menus\r\n\r\n        //then remove all of the handlers\r\n        $(&quot;*&quot;).unbind(&quot;.OutsideMenus&quot;);\r\n    });\r\n    \r\n    $(&quot;#menuscontainer&quot;).bind(&quot;click.OutsideMenus&quot;, function (event) \r\n    {\r\n        event.stopPropagation(); \r\n    });"},{"score":4,"body_markdown":"The solutions here work fine **when only one element is to be managed**. If there are multiple elements, however, the problem is much more complicated. Tricks with e.stopPropagation() and all the others will not work.\r\n\r\nI came up with a **solution**, and maybe it is not so easy, but it&#39;s better than nothing. Have a look:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $view.on(&quot;click&quot;, function(e) {\r\n\r\n        if(model.isActivated()) return;\r\n\r\n            var watchUnclick = function() {\r\n                rootView.one(&quot;mouseleave&quot;, function() {\r\n                    $(document).one(&quot;click&quot;, function() {\r\n                        model.deactivate();\r\n                    });\r\n                    rootView.one(&quot;mouseenter&quot;, function() {\r\n                        watchUnclick();\r\n                    });\r\n                });\r\n            };\r\n            watchUnclick();\r\n            model.activate();\r\n        });\r\n"},{"score":8,"body_markdown":"Instead using flow interruption, blur/focus event or any other tricky technics, simply match event flow with element&#39;s kinship:\r\n\r\n\t$(document).on(&quot;click.menu-outside&quot;, function(event){\r\n\t\t// Test if target and it&#39;s parent aren&#39;t #menuscontainer\r\n\t\t// That means the click event occur on other branch of document tree\r\n\t\tif(!$(event.target).parents().andSelf().is(&quot;#menuscontainer&quot;)){\r\n\t\t\t// Click outisde #menuscontainer\r\n\t\t\t// Hide the menus (but test if menus aren&#39;t already hidden)\r\n\t\t}\r\n\t});\r\n\r\nTo remove click outside event listener, simply:\r\n\r\n\t$(document).off(&quot;click.menu-outside&quot;);"},{"score":3,"body_markdown":"The answer marked as the accepted answer does not take into account that you can have overlays over the element, like dialogs, popovers, datepickers, etc. Clicks in these should not hide the element.\r\n\r\nI have made my own version that does take this into account. It&#39;s created as a [KnockoutJS][1] binding, but it can easily be converted to jQuery-only.\r\n\r\nIt works by the first query for all elements with either z-index or absolute position that are visible. It then hit tests those elements against the element I want to hide if click outside. If it&#39;s a hit I calculate a new bound rectangle which takes into account the overlay bounds.\r\n\r\n    ko.bindingHandlers.clickedIn = (function () {\r\n        function getBounds(element) {\r\n            var pos = element.offset();\r\n            return {\r\n                x: pos.left,\r\n                x2: pos.left + element.outerWidth(),\r\n                y: pos.top,\r\n                y2: pos.top + element.outerHeight()\r\n            };\r\n        }\r\n\r\n        function hitTest(o, l) {\r\n            function getOffset(o) {\r\n                for (var r = { l: o.offsetLeft, t: o.offsetTop, r: o.offsetWidth, b: o.offsetHeight };\r\n                    o = o.offsetParent; r.l += o.offsetLeft, r.t += o.offsetTop);\r\n                return r.r += r.l, r.b += r.t, r;\r\n            }\r\n\r\n            for (var b, s, r = [], a = getOffset(o), j = isNaN(l.length), i = (j ? l = [l] : l).length; i;\r\n                b = getOffset(l[--i]), (a.l == b.l || (a.l &gt; b.l ? a.l &lt;= b.r : b.l &lt;= a.r))\r\n                    &amp;&amp; (a.t == b.t || (a.t &gt; b.t ? a.t &lt;= b.b : b.t &lt;= a.b)) &amp;&amp; (r[r.length] = l[i]));\r\n            return j ? !!r.length : r;\r\n        }\r\n\r\n        return {\r\n            init: function (element, valueAccessor) {\r\n                var target = valueAccessor();\r\n                $(document).click(function (e) {\r\n                    if (element._clickedInElementShowing === false &amp;&amp; target()) {\r\n                        var $element = $(element);\r\n                        var bounds = getBounds($element);\r\n\r\n                        var possibleOverlays = $(&quot;[style*=z-index],[style*=absolute]&quot;).not(&quot;:hidden&quot;);\r\n                        $.each(possibleOverlays, function () {\r\n                            if (hitTest(element, this)) {\r\n                                var b = getBounds($(this));\r\n                                bounds.x = Math.min(bounds.x, b.x);\r\n                                bounds.x2 = Math.max(bounds.x2, b.x2);\r\n                                bounds.y = Math.min(bounds.y, b.y);\r\n                                bounds.y2 = Math.max(bounds.y2, b.y2);\r\n                            }\r\n                        });\r\n\r\n                        if (e.clientX &lt; bounds.x || e.clientX &gt; bounds.x2 ||\r\n                            e.clientY &lt; bounds.y || e.clientY &gt; bounds.y2) {\r\n\r\n                            target(false);\r\n                        }\r\n                    }\r\n                    element._clickedInElementShowing = false;\r\n                });\r\n\r\n                $(element).click(function (e) {\r\n                    e.stopPropagation();\r\n                });\r\n            },\r\n            update: function (element, valueAccessor) {\r\n                var showing = ko.utils.unwrapObservable(valueAccessor());\r\n                if (showing) {\r\n                    element._clickedInElementShowing = true;\r\n                }\r\n            }\r\n        };\r\n    })();\r\n\r\n  [1]: http://en.wikipedia.org/wiki/KnockoutJS\r\n"},{"score":1,"body_markdown":"This is a more general solution that **allows multiple elements to be watched, and dynamically adding and removing elements from the queue**.\r\n\r\nIt holds a global queue (**autoCloseQueue**) - an object container for elements that should be closed on outside clicks. \r\n\r\n\r\nEach queue object key should be the DOM Element id, and the value should be an object with 2 callback functions: \r\n\r\n     {onPress: someCallbackFunction, onOutsidePress: anotherCallbackFunction}\r\n\r\nPut this in your document ready callback:\r\n\r\n    window.autoCloseQueue = {} \t\r\n\t\r\n\t$(document).click(function(event) {\r\n\t\tfor (id in autoCloseQueue){\r\n\t\t\tvar element = autoCloseQueue[id];\r\n\t\t\tif ( ($(e.target).parents(&#39;#&#39; + id).length) &gt; 0) { // This is a click on the element (or its child element)\r\n\t\t\t\tconsole.log(&#39;This is a click on an element (or its child element) with  id: &#39; + id);\r\n\t\t\t\tif (typeof element.onPress == &#39;function&#39;) element.onPress(event, id);\r\n\t\t\t} else { //This is a click outside the element\r\n\t\t\t\tconsole.log(&#39;This is a click outside the element with id: &#39; + id);\r\n\t\t\t\tif (typeof element.onOutsidePress == &#39;function&#39;) element.onOutsidePress(event, id); //call the outside callback\r\n\t\t\t\tdelete autoCloseQueue[id]; //remove the element from the queue\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\r\n\r\n\r\nThen, when the DOM element with id  &#39;**menuscontainer**&#39; is created, just add this object to the queue: \r\n\r\n    window.autoCloseQueue[&#39;menuscontainer&#39;] = {onOutsidePress: clickOutsideThisElement}"},{"score":4,"body_markdown":"I ended up doing something like this:\r\n\r\n\t$(document).on(&#39;click&#39;, &#39;body, #msg_count_results .close&#39;,function() {\r\n\t\t$(document).find(&#39;#msg_count_results&#39;).remove();\r\n\t});\r\n\t$(document).on(&#39;click&#39;,&#39;#msg_count_results&#39;,function(e) {\r\n\t\te.preventDefault();\r\n\t\treturn false;\r\n\t});\r\n\r\nI have a close button within the new container for end users friendly UI purposes. I had to use return false in order to not go through. Of course, having an A HREF on there to take you somewhere would be nice, or you could call some ajax stuff instead. Either way, it works ok for me. Just what I wanted.\r\n"},{"score":-2,"body_markdown":"Try this code:\r\n\r\n    if ($(event.target).parents().index($(&#39;#searchFormEdit&#39;)) == -1 &amp;&amp;\r\n        $(event.target).parents().index($(&#39;.DynarchCalendar-topCont&#39;)) == -1 &amp;&amp;\r\n        (_x &lt; os.left || _x &gt; (os.left + 570) || _y &lt; os.top || _y &gt; (os.top + 155)) &amp;&amp;\r\n        isShowEditForm) {\r\n\r\n        setVisibleEditForm(false);\r\n    }\r\n"},{"score":-1,"body_markdown":"You can set a tabindex to the [DOM][1] element. This will trigger a blur event when the user click outside the DOM element.\r\n\r\n[Demo][2]\r\n\r\n    &lt;div tabindex=&quot;1&quot;&gt;\r\n        Focus me\r\n    &lt;/div&gt;\r\n\r\n    document.querySelector(&quot;div&quot;).onblur = function(){\r\n       console.log(&#39;clicked outside&#39;)\r\n    }\r\n    document.querySelector(&quot;div&quot;).onfocus = function(){\r\n       console.log(&#39;clicked inside&#39;)\r\n    }\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Document_Object_Model\r\n  [2]: http://jsbin.com/fuloqixe/5\r\n"},{"score":0,"body_markdown":"This will toggle the Nav menu when you click on/off the element.     \r\n\r\n    $(document).on(&#39;click&#39;, function(e) {\r\n        var elem = $(e.target).closest(&#39;#menu&#39;),\r\n        box = $(e.target).closest(&#39;#nav&#39;);\r\n     if (elem.length) {\r\n        e.preventDefault();\r\n        $(&#39;#nav&#39;).toggle();\r\n      } else if (!box.length) {\r\n        $(&#39;#nav&#39;).hide();\r\n     }\r\n    });\r\n\r\n\r\n\r\n    &lt;li id=&quot;menu&quot;&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt;\r\n    &lt;ul id=&quot;nav&quot; &gt;  //Nav will toggle when you Click on Menu(it can be an icon in this example)\r\n            &lt;li class=&quot;page&quot;&gt;&lt;a&gt;Page1&lt;/a&gt;&lt;/li&gt;\r\n            &lt;li class=&quot;page&quot;&gt;&lt;a&gt;Pag2&lt;/a&gt;&lt;/li&gt;\r\n            &lt;li class=&quot;page&quot;&gt;&lt;a&gt;Page3&lt;/a&gt;&lt;/li&gt;            \r\n            &lt;li class=&quot;page&quot;&gt;&lt;a&gt;Page4&lt;/a&gt;&lt;/li&gt;\r\n    &lt;/ul&gt;"},{"score":-2,"body_markdown":"Standard HTML:\r\n\r\nSurround the menus by a `&lt;label&gt;` and fetch focus state changes.\r\n\r\nhttp://jsfiddle.net/bK3gL/\r\n\r\nPlus: you can unfold the menu by &lt;kbd&gt;Tab&lt;/kbd&gt;.\r\n"},{"score":-1,"body_markdown":"As a [wrapper to this great answer from Art](https://stackoverflow.com/a/3028037/1366033), and to use the syntax originally requested by OP, here&#39;s a jQuery extension that can record wether a click occured outside of a set element.\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $.fn.clickOutsideThisElement = function (callback) {\r\n        return this.each(function () {\r\n            var self = this;\r\n            $(document).click(function (e) {\r\n                if (!$(e.target).closest(self).length) {\r\n                    callback.call(self, e)\r\n                }\r\n            })\r\n        });\r\n    };\r\n\r\nThen you can call like this:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $(&quot;#menuscontainer&quot;).clickOutsideThisElement(function() {\r\n        // handle menu toggle\r\n    });\r\n\r\n## [Here&#39;s a demo in fiddle](http://jsfiddle.net/KyleMit/Fv2fY/)"},{"score":16,"body_markdown":"As a variant:\r\n\r\n    var $menu = $(&#39;#menucontainer&#39;);\r\n    $(document).on(&#39;click&#39;, function (e) {\r\n\r\n        // If element is opened and click target is outside it, hide it\r\n        if ($menu.is(&#39;:visible&#39;) &amp;&amp; !$menu.is(e.target) &amp;&amp; !$menu.has(e.target).length) {\r\n            $menu.hide();\r\n        }\r\n    });\r\n\r\nIt has no problem with [stopping event propagation][1] and better supports multiple menus on the same page where clicking on a second menu while a first is open will leave the first open in the stopPropagation solution.\r\n\r\n  [1]: http://css-tricks.com/dangers-stopping-event-propagation/\r\n"},{"score":3,"body_markdown":"For touch devices like iPad and iPhone we can use this code:\r\n\r\n    $(document).on(&#39;touchstart&#39;, function (event) {\r\n        var container = $(&quot;YOUR CONTAINER SELECTOR&quot;);\r\n\r\n        if (!container.is(e.target) &amp;&amp;            // If the target of the click isn&#39;t the container...\r\n            container.has(e.target).length === 0) // ... nor a descendant of the container\r\n        {\r\n            container.hide();\r\n        }\r\n    });\r\n"},{"score":-1,"body_markdown":"Using not():\r\n\r\n    $(&quot;#id&quot;).not().click(function() {\r\n        alert(&#39;Clicked other that #id&#39;);\r\n    });\r\n"},{"score":-2,"body_markdown":"    $(&quot;body &gt; div:not(#dvid)&quot;).click(function (e) {\r\n        //your code\r\n    }); "},{"score":-2,"body_markdown":"    $(&quot;html&quot;).click(function(){\r\n        if($(&#39;#info&#39;).css(&quot;opacity&quot;)&gt;0.9) {\r\n            $(&#39;#info&#39;).fadeOut(&#39;fast&#39;);\r\n        }\r\n    });"},{"score":22,"body_markdown":"**Solution1**\r\n-------------\r\n\r\nInstead of using event.stopPropagation() which can have some side affects, just define a simple flag variable and add one `if` condition. I tested this and worked properly without any side affects of stopPropagation:\r\n\r\n    var flag = &quot;1&quot;;\r\n    $(&#39;#menucontainer&#39;).click(function(event){\r\n        flag = &quot;0&quot;; // flag 0 means click happened in the area where we should not do any action\r\n    });\r\n\r\n    $(&#39;html&#39;).click(function() {\r\n        if(flag != &quot;0&quot;){\r\n            // Hide the menus if visible\r\n        }\r\n        else {\r\n            flag = &quot;1&quot;;\r\n        }\r\n    });\r\n\r\n**Solution2**\r\n-------------\r\n\r\nWith just a simple `if` condition:\r\n\r\n    $(document).on(&#39;click&#39;, function(event){\r\n        var container = $(&quot;#menucontainer&quot;);\r\n        if (!container.is(event.target) &amp;&amp;            // If the target of the click isn&#39;t the container...\r\n            container.has(event.target).length === 0) // ... nor a descendant of the container\r\n        {\r\n            // Do whatever you want to do when click is outside the element\r\n        }\r\n    });\r\n\r\n\r\n"},{"score":13,"body_markdown":"Here is the vanilla JavaScript solution for future viewers.\r\n\r\nUpon clicking any element within the document, if the clicked element&#39;s id is toggled, or the hidden element is not hidden and the hidden element does not contain the clicked element, toggle the element.\r\n\r\n    (function () {\r\n        &quot;use strict&quot;;\r\n        var hidden = document.getElementById(&#39;hidden&#39;);\r\n        document.addEventListener(&#39;click&#39;, function (e) {\r\n            if (e.target.id == &#39;toggle&#39; || (hidden.style.display != &#39;none&#39; &amp;&amp; !hidden.contains(e.target))) hidden.style.display = hidden.style.display == &#39;none&#39; ? &#39;block&#39; : &#39;none&#39;;\r\n        }, false);\r\n    })();\r\n\r\n&lt;!-- begin snippet: js hide: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    (function () {\r\n        &quot;use strict&quot;;\r\n        var hidden = document.getElementById(&#39;hidden&#39;);\r\n        document.addEventListener(&#39;click&#39;, function (e) {\r\n            if (e.target.id == &#39;toggle&#39; || (hidden.style.display != &#39;none&#39; &amp;&amp; !hidden.contains(e.target))) hidden.style.display = hidden.style.display == &#39;none&#39; ? &#39;block&#39; : &#39;none&#39;;\r\n        }, false);\r\n    })();\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;a href=&quot;javascript:void(0)&quot; id=&quot;toggle&quot;&gt;Toggle Hidden Div&lt;/a&gt;\r\n    &lt;div id=&quot;hidden&quot; style=&quot;display: none;&quot;&gt;This content is normally hidden. click anywhere other than this content to make me disappear&lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf you are going to have multiple toggles on the same page you can use something like this:\r\n\r\n1. Add the class name `hidden` to the collapsible item.\r\n2. Upon document click, close all hidden elements which do not contain the clicked element and are not hidden\r\n3. If the clicked element is a toggle, toggle the specified element.\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    (function () {\r\n        &quot;use strict&quot;;\r\n        var hiddenItems = document.getElementsByClassName(&#39;hidden&#39;), hidden;\r\n        document.addEventListener(&#39;click&#39;, function (e) {\r\n            for (var i = 0; hidden = hiddenItems[i]; i++) {\r\n                if (!hidden.contains(e.target) &amp;&amp; hidden.style.display != &#39;none&#39;)\r\n                    hidden.style.display = &#39;none&#39;;\r\n            }\r\n            if (e.target.getAttribute(&#39;data-toggle&#39;)) {\r\n                var toggle = document.querySelector(e.target.getAttribute(&#39;data-toggle&#39;));\r\n                toggle.style.display = toggle.style.display == &#39;none&#39; ? &#39;block&#39; : &#39;none&#39;;\r\n            }\r\n        }, false);\r\n    })();\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;a href=&quot;javascript:void(0)&quot; data-toggle=&quot;#hidden1&quot;&gt;Toggle Hidden Div&lt;/a&gt;\r\n    &lt;div class=&quot;hidden&quot; id=&quot;hidden1&quot; style=&quot;display: none;&quot; data-hidden=&quot;true&quot;&gt;This content is normally hidden&lt;/div&gt;\r\n    &lt;a href=&quot;javascript:void(0)&quot; data-toggle=&quot;#hidden2&quot;&gt;Toggle Hidden Div&lt;/a&gt;\r\n    &lt;div class=&quot;hidden&quot; id=&quot;hidden2&quot; style=&quot;display: none;&quot; data-hidden=&quot;true&quot;&gt;This content is normally hidden&lt;/div&gt;\r\n    &lt;a href=&quot;javascript:void(0)&quot; data-toggle=&quot;#hidden3&quot;&gt;Toggle Hidden Div&lt;/a&gt;\r\n    &lt;div class=&quot;hidden&quot; id=&quot;hidden3&quot; style=&quot;display: none;&quot; data-hidden=&quot;true&quot;&gt;This content is normally hidden&lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n"},{"score":5,"body_markdown":"We implemented a solution, partly based off a comment from a user above, which works perfectly for us. We use it to hide a search box / results when clicking outside those elements, excluding the element that originally.\r\n\r\n    // HIDE SEARCH BOX IF CLICKING OUTSIDE\r\n    $(document).click(function(event){ \r\n    \t// IF NOT CLICKING THE SEARCH BOX OR ITS CONTENTS OR SEARCH ICON \r\n    \tif ($(&quot;#search-holder&quot;).is(&quot;:visible&quot;) &amp;&amp; !$(event.target).is(&quot;#search-holder *, #search&quot;)) {\r\n    \t \t$(&quot;#search-holder&quot;).fadeOut(&#39;fast&#39;);\r\n    \t \t$(&quot;#search&quot;).removeClass(&#39;active&#39;);\r\n    \t}\r\n    });\r\n\r\nIt checks if the search box is already visible first also, and in our case, it&#39;s also removing an active class on the hide/show search button."},{"score":6,"body_markdown":"Upvote for the most popular answer, but add \r\n\r\n    &amp;&amp; (e.target != $(&#39;html&#39;).get(0)) // ignore the scrollbar\r\n\r\nso, a click on a scroll bar does not [hide or whatever] your target element."},{"score":-2,"body_markdown":"This is a classic case of where a tweak to the HTML would be a better solution. Why not set the click on the elements which don&#39;t contain the menu item? Then you don&#39;t need to add the propagation.\r\n\r\n    $(&#39;.header, .footer, .main-content&#39;).click(function() {\r\n    //Hide the menus if visible\r\n    });"},{"score":-1,"body_markdown":"**Outside click plugin!**\r\n\r\n**Usage:**\r\n\r\n    $(&#39;.target-element&#39;).outsideClick(function(event){\r\n    \t//code that fires when user clicks outside the element\r\n        //event = the click event\r\n        //$(this) = the &#39;.target-element&#39; that is firing this function \r\n    }, &#39;.excluded-element&#39;)\r\n\r\n**The code for it:**\r\n\r\n\t(function($) {\r\n\r\n\t//when the user hits the escape key, it will trigger all outsideClick functions\r\n\t$(document).on(&quot;keyup&quot;, function (e) {\r\n\t\tif (e.which == 27) $(&#39;body&#39;).click(); //escape key\r\n\t});\r\n\r\n\t//The actual plugin\r\n    $.fn.outsideClick = function(callback, exclusions) {\r\n    \tvar subject = this;\r\n\r\n\t\t//test if exclusions have been set\r\n\t\tvar hasExclusions = typeof exclusions !== &#39;undefined&#39;;\r\n\r\n        //switches click event with touch event if on a touch device\r\n\t\tvar ClickOrTouchEvent = &quot;ontouchend&quot; in document ? &quot;touchend&quot; : &quot;click&quot;;\r\n\r\n\t\t$(&#39;body&#39;).on(ClickOrTouchEvent, function(event) {\r\n\t\t\t//click target does not contain subject as a parent\r\n\t\t\tvar clickedOutside = !$(event.target).closest(subject).length;\r\n\r\n\t\t\t//click target was on one of the excluded elements\r\n\t\t\tvar clickedExclusion = $(event.target).closest(exclusions).length;\r\n\r\n\t\t\tvar testSuccessful;\r\n\r\n\t\t\tif (hasExclusions) {\r\n\t\t\t\ttestSuccessful = clickedOutside &amp;&amp; !clickedExclusion;\r\n\t\t\t} else {\r\n\t\t\t\ttestSuccessful = clickedOutside;\r\n\t\t\t}\r\n\r\n\t\t    if(testSuccessful) {\r\n\t\t\t\tcallback.call(subject, event);\r\n\t\t    }\r\n\t\t});\r\n\r\n        return this;\r\n    };\r\n\r\n\t}(jQuery));\r\n\r\nAdapted from this answer https://stackoverflow.com/a/3028037/1611058"},{"score":47,"body_markdown":"After research I have found three working solutions (I forgot the page links for reference)\r\n\r\nFirst solution\r\n-----------------------------\r\n\r\n    &lt;script&gt;\r\n        //The good thing about this solution is it doesn&#39;t stop event propagation.\r\n\r\n        var clickFlag = 0;\r\n        $(&#39;body&#39;).on(&#39;click&#39;, function () {\r\n            if(clickFlag == 0) {\r\n                console.log(&#39;hide element here&#39;);\r\n                /* Hide element here */\r\n            }\r\n            else {\r\n                clickFlag=0;\r\n            }\r\n        });\r\n        $(&#39;body&#39;).on(&#39;click&#39;,&#39;#testDiv&#39;, function (event) {\r\n            clickFlag = 1;\r\n            console.log(&#39;showed the element&#39;);\r\n            /* Show the element */\r\n        });\r\n    &lt;/script&gt;\r\n\r\nSecond solution\r\n-----------------------------\r\n\r\n    &lt;script&gt;\r\n        $(&#39;body&#39;).on(&#39;click&#39;, function(e) {\r\n            if($(e.target).closest(&#39;#testDiv&#39;).length == 0) {\r\n               /* Hide dropdown here */\r\n            }\r\n        });\r\n    &lt;/script&gt;\r\n\r\nThird solution\r\n-----------------------------\r\n\r\n    &lt;script&gt;\r\n        var specifiedElement = document.getElementById(&#39;testDiv&#39;);\r\n        document.addEventListener(&#39;click&#39;, function(event) {\r\n            var isClickInside = specifiedElement.contains(event.target);\r\n            if (isClickInside) {\r\n              console.log(&#39;You clicked inside&#39;)\r\n            }\r\n            else {\r\n              console.log(&#39;You clicked outside&#39;)\r\n            }\r\n        });\r\n    &lt;/script&gt;\r\n"},{"score":0,"body_markdown":"   \r\n\r\n        $(&#39;#menucontainer&#39;).click(function(e){\r\n        \te.stopPropagation();\r\n         });\r\n        \t\t\r\n        $(document).on(&#39;click&#39;,  function(e){\r\n        \t// code\r\n        });"},{"score":26,"body_markdown":"A simple solution for the situation is:\r\n\r\n    $(document).mouseup(function (e)\r\n    {\r\n        var container = $(&quot;YOUR SELECTOR&quot;); // Give you class or ID\r\n        \r\n        if (!container.is(e.target) &amp;&amp;            // If the target of the click is not the desired div or section\r\n            container.has(e.target).length === 0) // ... nor a descendant-child of the container\r\n        {\r\n            container.hide();\r\n        }\r\n    });\r\n\r\nThe above script will hide the `div` if outside of the `div` click event is triggered.\r\n\r\nYou can see the following blog for more information : http://www.codecanal.com/detect-click-outside-div-using-javascript/\r\n"},{"score":0,"body_markdown":"\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $(&#39;html&#39;).click(function() {\r\n    //Hide the menus if visible\r\n    });\r\n\r\n    $(&#39;#menucontainer&#39;).click(function(event){\r\n        event.stopPropagation();\r\n    });\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;html&gt;\r\n     &lt;button id=&#39;#menucontainer&#39;&gt;Ok&lt;/button&gt; \r\n    &lt;/html&gt;\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n"},{"score":0,"body_markdown":"Have a try of this:\r\n\r\n    $(&#39;html&#39;).click(function(e) {\r\n      if($(e.target).parents(&#39;#menuscontainer&#39;).length == 0) {\r\n        $(&#39;#menuscontainer&#39;).hide();\r\n      }\r\n    });\r\n\r\nhttps://jsfiddle.net/4cj4jxy0/\r\n\r\nBut note that this cannot work if the click event cannot reach the `html` tag. (Maybe other elements have `stopPropagation()`)."},{"score":0,"body_markdown":"Subscribe _capturing phase_ of click to handle click on elements which call `preventDefault`.  \r\nRetrigger it on document element using the other name `click-anywhere`.\r\n\r\n    document.addEventListener(&#39;click&#39;, function (event) {\r\n      event = $.event.fix(event);\r\n      event.type = &#39;click-anywhere&#39;;\r\n      $document.trigger(event);\r\n    }, true);\r\n\r\nThen where you need click outside functionality subscribe on `click-anywhere` event on `document` and check if the click was outside of the element you are interested in:\r\n\r\n    $(document).on(&#39;click-anywhere&#39;, function (event) {\r\n      if (!$(event.target).closest(&#39;#smth&#39;).length) {\r\n        // Do anything you need here\r\n      }\r\n    });\r\n\r\nSome notes:\r\n\r\n- You have to use `document` as it would be a perfomance fault to trigger event on all elements outside of which the click occured.\r\n\r\n- This functionality can be wrapped into special plugin, which calls some callback on outside click.\r\n\r\n- You can&#39;t subscribe capturing phase using jQuery itself.\r\n\r\n- You don&#39;t need document load to subscribe as subscription is on `document`, even not on its `body`, so it exists always independently ащкь script placement and load status."},{"score":5,"body_markdown":"For easier use, and more expressive code, I created a jQuery plugin for this:\r\n\r\n    $(&#39;div.my-element&#39;).clickOut(function(target) { \r\n        //do something here... \r\n    });\r\n\r\nNote:  **target** is the element the user actually clicked.  But callback is still executed in the context of the original element, so you can utilize **this** as you&#39;d expect in a jQuery callback.\r\n\r\nPlugin:\r\n\r\n    $.fn.clickOut = function (parent, fn) {\r\n        var context = this;\r\n        fn = (typeof parent === &#39;function&#39;) ? parent : fn;\r\n        parent = (parent instanceof jQuery) ? parent : $(document);\r\n\r\n        context.each(function () {\r\n            var that = this;\r\n            parent.on(&#39;click&#39;, function (e) {\r\n                var clicked = $(e.target);\r\n                if (!clicked.is(that) &amp;&amp; !clicked.parents().is(that)) {\r\n                    if (typeof fn === &#39;function&#39;) {\r\n                        fn.call(that, clicked);\r\n                    }\r\n                }\r\n            });\r\n\r\n        });\r\n        return context;\r\n    };\r\n\r\n\r\nBy default, the click event listener is placed on the document.  However, if you want to limit the event listener scope, you can pass in a jQuery object representing a parent level element that will be the top parent at which clicks will be listened to.  This prevents unnecessary document level event listeners.  Obviously, it won&#39;t work unless the parent element supplied is a parent of your initial element. \r\n\r\nUse like so:\r\n\r\n    $(&#39;div.my-element&#39;).clickOut($(&#39;div.my-parent&#39;), function(target) { \r\n        //do something here...\r\n    });\r\n"},{"score":0,"body_markdown":"&lt;!-- begin snippet: js hide: false--&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $(document).on(&#39;click.menu.hide&#39;, function(e){\r\n      if ( !$(e.target).closest(&#39;#my_menu&#39;).length ) {\r\n        $(&#39;#my_menu&#39;).find(&#39;ul&#39;).toggleClass(&#39;active&#39;, false);\r\n      }\r\n    });\r\n\r\n    $(document).on(&#39;click.menu.show&#39;, &#39;#my_menu li&#39;, function(e){\r\n      $(this).find(&#39;ul&#39;).toggleClass(&#39;active&#39;);\r\n    });\r\n\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    div {\r\n      float: left;\r\n    }\r\n\r\n    ul {\r\n      padding: 0;\r\n      position: relative;\r\n    }\r\n    ul li {\r\n      padding: 5px 25px 5px 10px;\r\n      border: 1px solid silver;\r\n      cursor: pointer;\r\n      list-style: none;\r\n      margin-top: -1px;\r\n      white-space: nowrap;\r\n    }\r\n    ul li ul:before {\r\n      margin-right: -20px;\r\n      position: absolute;\r\n      top: -17px;\r\n      right: 0;\r\n      content: &quot;\\25BC&quot;;\r\n    }\r\n    ul li ul li {\r\n      visibility: hidden;\r\n      height: 0;\r\n      padding-top: 0;\r\n      padding-bottom: 0;\r\n      border-width: 0 0 1px 0;\r\n    }\r\n    ul li ul li:last-child {\r\n      border: none;\r\n    }\r\n    ul li ul.active:before {\r\n      content: &quot;\\25B2&quot;;\r\n    }\r\n    ul li ul.active li {\r\n      display: list-item;\r\n      visibility: visible;\r\n      height: inherit;\r\n      padding: 5px 25px 5px 10px;\r\n    }\r\n\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://code.jquery.com/jquery-2.1.4.js&quot;&gt;&lt;/script&gt;\r\n    &lt;div&gt;\r\n      &lt;ul id=&quot;my_menu&quot;&gt;\r\n        &lt;li&gt;Menu 1\r\n          &lt;ul&gt;\r\n            &lt;li&gt;subMenu 1&lt;/li&gt;\r\n            &lt;li&gt;subMenu 2&lt;/li&gt;\r\n            &lt;li&gt;subMenu 3&lt;/li&gt;\r\n            &lt;li&gt;subMenu 4&lt;/li&gt;\r\n          &lt;/ul&gt;\r\n        &lt;/li&gt;\r\n        &lt;li&gt;Menu 2\r\n          &lt;ul&gt;\r\n            &lt;li&gt;subMenu 1&lt;/li&gt;\r\n            &lt;li&gt;subMenu 2&lt;/li&gt;\r\n            &lt;li&gt;subMenu 3&lt;/li&gt;\r\n            &lt;li&gt;subMenu 4&lt;/li&gt;\r\n          &lt;/ul&gt;\r\n        &lt;/li&gt;\r\n        &lt;li&gt;Menu 3&lt;/li&gt;\r\n        &lt;li&gt;Menu 4&lt;/li&gt;\r\n        &lt;li&gt;Menu 5&lt;/li&gt;\r\n        &lt;li&gt;Menu 6&lt;/li&gt;\r\n      &lt;/ul&gt;\r\n    &lt;/div&gt;\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nHere is jsbin version http://jsbin.com/xopacadeni/edit?html,css,js,output"},{"score":328,"body_markdown":"&gt; How to detect a click outside an element?\n\nThe reason that this question is so popular and has so many answers is that it is deceptively complex. After almost eight years and dozens of answers, I am genuinely surprised to see how little care has been given to accessibility.\n\n&gt; I would like to hide these elements when the user clicks outside the menus&#39; area.\n\nThis is a noble cause and is the *actual* issue. The title of the question&amp;mdash;which is what most answers appear to attempt to address&amp;mdash;contains an unfortunate red herring.\n\n**Hint: it&#39;s the word *&quot;click&quot;*!**\n\n# You don&#39;t actually want to bind click handlers.\n\nIf you&#39;re binding click handlers to close the dialog, you&#39;ve already failed. The reason you&#39;ve failed is that not everyone triggers `click` events. Users not using a mouse will be able to escape your dialog (and your pop-up menu is arguably a type of dialog) by pressing &lt;kbd&gt;Tab&lt;/kbd&gt;, and they then won&#39;t be able to read the content behind the dialog without subsequently triggering a `click` event.\n\nSo let&#39;s rephrase the question.\n\n&gt; How does one close a dialog when a user is finished with it?\n\nThis is the goal. Unfortunately, now we need to bind the `userisfinishedwiththedialog` event, and that binding isn&#39;t so straightforward.\n\nSo how can we detect that a user has finished using a dialog?\n\n## `focusout` event\n\nA good start is to determine if focus has left the dialog.\n\n**Hint: be careful with the `blur` event, `blur` doesn&#39;t propagate if the event was bound to the bubbling phase!**\n\njQuery&#39;s [`focusout`][1] will do just fine. If you can&#39;t use jQuery, then you can use `blur` during the capturing phase:\n\n    element.addEventListener(&#39;blur&#39;, ..., true);\n    //                       use capture: ^^^^\n\nAlso, for many dialogs you&#39;ll need to allow the container to gain focus. Add `tabindex=&quot;-1&quot;` to allow the dialog to receive focus dynamically without otherwise interrupting the tabbing flow.\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    $(&#39;a&#39;).on(&#39;click&#39;, function () {\n      $(this.hash).toggleClass(&#39;active&#39;).focus();\n    });\n\n    $(&#39;div&#39;).on(&#39;focusout&#39;, function () {\n      $(this).removeClass(&#39;active&#39;);\n    });\n\n&lt;!-- language: lang-css --&gt;\n\n    div {\n      display: none;\n    }\n    .active {\n      display: block;\n    }\n\n&lt;!-- language: lang-html --&gt;\n\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n    &lt;a href=&quot;#example&quot;&gt;Example&lt;/a&gt;\n    &lt;div id=&quot;example&quot; tabindex=&quot;-1&quot;&gt;\n      Lorem ipsum &lt;a href=&quot;http://example.com&quot;&gt;dolor&lt;/a&gt; sit amet.\n    &lt;/div&gt;\n\n&lt;!-- end snippet --&gt;\n\n---\n\nIf you play with that demo for more than a minute you should quickly start seeing issues.\n\nThe first is that the link in the dialog isn&#39;t clickable. Attempting to click on it or tab to it will lead to the dialog closing before the interaction takes place. This is because focusing the inner element triggers a `focusout` event before triggering a `focusin` event again.\n\nThe fix is to queue the state change on the event loop. This can be done by using `setImmediate(...)`, or `setTimeout(..., 0)` for browsers that don&#39;t support `setImmediate`. Once queued it can be cancelled by a subsequent `focusin`:\n\n    $(&#39;.submenu&#39;).on({\n      focusout: function (e) {\n        $(this).data(&#39;submenuTimer&#39;, setTimeout(function () {\n          $(this).removeClass(&#39;submenu--active&#39;);\n        }.bind(this), 0));\n      },\n      focusin: function (e) {\n        clearTimeout($(this).data(&#39;submenuTimer&#39;));\n      }\n    });\n\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    $(&#39;a&#39;).on(&#39;click&#39;, function () {\n      $(this.hash).toggleClass(&#39;active&#39;).focus();\n    });\n\n    $(&#39;div&#39;).on({\n      focusout: function () {\n        $(this).data(&#39;timer&#39;, setTimeout(function () {\n          $(this).removeClass(&#39;active&#39;);\n        }.bind(this), 0));\n      },\n      focusin: function () {\n        clearTimeout($(this).data(&#39;timer&#39;));\n      }\n    });\n\n&lt;!-- language: lang-css --&gt;\n\n    div {\n      display: none;\n    }\n    .active {\n      display: block;\n    }\n\n&lt;!-- language: lang-html --&gt;\n\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n    &lt;a href=&quot;#example&quot;&gt;Example&lt;/a&gt;\n    &lt;div id=&quot;example&quot; tabindex=&quot;-1&quot;&gt;\n      Lorem ipsum &lt;a href=&quot;http://example.com&quot;&gt;dolor&lt;/a&gt; sit amet.\n    &lt;/div&gt;\n\n&lt;!-- end snippet --&gt;\n\nThe second issue is that the dialog won&#39;t close when the link is pressed again. This is because the dialog loses focus, triggering the close behavior, after which the link click triggers the dialog to reopen.\n\nSimilar to the previous issue, the focus state needs to be managed. Given that the state change has already been queued, it&#39;s just a matter of handling focus events on the dialog triggers:\n\n#### &lt;sub&gt;This should look familiar&lt;/sub&gt;\n\n    $(&#39;a&#39;).on({\n      focusout: function () {\n        $(this.hash).data(&#39;timer&#39;, setTimeout(function () {\n          $(this.hash).removeClass(&#39;active&#39;);\n        }.bind(this), 0));\n      },\n      focusin: function () {\n        clearTimeout($(this.hash).data(&#39;timer&#39;));  \n      }\n    });\n\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    $(&#39;a&#39;).on(&#39;click&#39;, function () {\n      $(this.hash).toggleClass(&#39;active&#39;).focus();\n    });\n\n    $(&#39;div&#39;).on({\n      focusout: function () {\n        $(this).data(&#39;timer&#39;, setTimeout(function () {\n          $(this).removeClass(&#39;active&#39;);\n        }.bind(this), 0));\n      },\n      focusin: function () {\n        clearTimeout($(this).data(&#39;timer&#39;));\n      }\n    });\n\n    $(&#39;a&#39;).on({\n      focusout: function () {\n        $(this.hash).data(&#39;timer&#39;, setTimeout(function () {\n          $(this.hash).removeClass(&#39;active&#39;);\n        }.bind(this), 0));\n      },\n      focusin: function () {\n        clearTimeout($(this.hash).data(&#39;timer&#39;));  \n      }\n    });\n\n&lt;!-- language: lang-css --&gt;\n\n    div {\n      display: none;\n    }\n    .active {\n      display: block;\n    }\n\n&lt;!-- language: lang-html --&gt;\n\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n    &lt;a href=&quot;#example&quot;&gt;Example&lt;/a&gt;\n    &lt;div id=&quot;example&quot; tabindex=&quot;-1&quot;&gt;\n      Lorem ipsum &lt;a href=&quot;http://example.com&quot;&gt;dolor&lt;/a&gt; sit amet.\n    &lt;/div&gt;\n\n&lt;!-- end snippet --&gt;\n\n---\n\n## &lt;kbd&gt;Esc&lt;/kbd&gt; key\n\nIf you thought you were done by handling the focus states, there&#39;s more you can do to simplify the user experience.\n\nThis is often a &quot;nice to have&quot; feature, but it&#39;s common that when you have a modal or popup of any sort that the &lt;kbd&gt;Esc&lt;/kbd&gt; key will close it out.\n\n    keydown: function (e) {\n      if (e.which === 27) {\n        $(this).removeClass(&#39;active&#39;);\n        e.preventDefault();\n      }\n    }\n\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    $(&#39;a&#39;).on(&#39;click&#39;, function () {\n      $(this.hash).toggleClass(&#39;active&#39;).focus();\n    });\n\n    $(&#39;div&#39;).on({\n      focusout: function () {\n        $(this).data(&#39;timer&#39;, setTimeout(function () {\n          $(this).removeClass(&#39;active&#39;);\n        }.bind(this), 0));\n      },\n      focusin: function () {\n        clearTimeout($(this).data(&#39;timer&#39;));\n      },\n      keydown: function (e) {\n        if (e.which === 27) {\n          $(this).removeClass(&#39;active&#39;);\n          e.preventDefault();\n        }\n      }\n    });\n\n    $(&#39;a&#39;).on({\n      focusout: function () {\n        $(this.hash).data(&#39;timer&#39;, setTimeout(function () {\n          $(this.hash).removeClass(&#39;active&#39;);\n        }.bind(this), 0));\n      },\n      focusin: function () {\n        clearTimeout($(this.hash).data(&#39;timer&#39;));  \n      }\n    });\n\n&lt;!-- language: lang-css --&gt;\n\n    div {\n      display: none;\n    }\n    .active {\n      display: block;\n    }\n\n&lt;!-- language: lang-html --&gt;\n\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n    &lt;a href=&quot;#example&quot;&gt;Example&lt;/a&gt;\n    &lt;div id=&quot;example&quot; tabindex=&quot;-1&quot;&gt;\n      Lorem ipsum &lt;a href=&quot;http://example.com&quot;&gt;dolor&lt;/a&gt; sit amet.\n    &lt;/div&gt;\n\n&lt;!-- end snippet --&gt;\n\n---\n\nIf you know you have focusable elements within the dialog, you won&#39;t need to focus the dialog directly. If you&#39;re building a menu, you could focus the first menu item instead.\n\n    click: function (e) {\n      $(this.hash)\n        .toggleClass(&#39;submenu--active&#39;)\n        .find(&#39;a:first&#39;)\n        .focus();\n      e.preventDefault();\n    }\n\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    $(&#39;.menu__link&#39;).on({\n      click: function (e) {\n        $(this.hash)\n          .toggleClass(&#39;submenu--active&#39;)\n          .find(&#39;a:first&#39;)\n          .focus();\n        e.preventDefault();\n      },\n      focusout: function () {\n        $(this.hash).data(&#39;submenuTimer&#39;, setTimeout(function () {\n          $(this.hash).removeClass(&#39;submenu--active&#39;);\n        }.bind(this), 0));\n      },\n      focusin: function () {\n        clearTimeout($(this.hash).data(&#39;submenuTimer&#39;));  \n      }\n    });\n\n    $(&#39;.submenu&#39;).on({\n      focusout: function () {\n        $(this).data(&#39;submenuTimer&#39;, setTimeout(function () {\n          $(this).removeClass(&#39;submenu--active&#39;);\n        }.bind(this), 0));\n      },\n      focusin: function () {\n        clearTimeout($(this).data(&#39;submenuTimer&#39;));\n      },\n      keydown: function (e) {\n        if (e.which === 27) {\n          $(this).removeClass(&#39;submenu--active&#39;);\n          e.preventDefault();\n        }\n      }\n    });\n\n&lt;!-- language: lang-css --&gt;\n\n    .menu {\n      list-style: none;\n      margin: 0;\n      padding: 0;\n    }\n    .menu:after {\n      clear: both;\n      content: &#39;&#39;;\n      display: table;\n    }\n    .menu__item {\n      float: left;\n      position: relative;\n    }\n\n    .menu__link {\n      background-color: lightblue;\n      color: black;\n      display: block;\n      padding: 0.5em 1em;\n      text-decoration: none;\n    }\n    .menu__link:hover,\n    .menu__link:focus {\n      background-color: black;\n      color: lightblue;\n    }\n\n    .submenu {\n      border: 1px solid black;\n      display: none;\n      left: 0;\n      list-style: none;\n      margin: 0;\n      padding: 0;\n      position: absolute;\n      top: 100%;\n    }\n    .submenu--active {\n      display: block;\n    }\n\n    .submenu__item {\n      width: 150px;\n    }\n\n    .submenu__link {\n      background-color: lightblue;\n      color: black;\n      display: block;\n      padding: 0.5em 1em;\n      text-decoration: none;\n    }\n\n    .submenu__link:hover,\n    .submenu__link:focus {\n      background-color: black;\n      color: lightblue;\n    }\n\n&lt;!-- language: lang-html --&gt;\n\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n    &lt;ul class=&quot;menu&quot;&gt;\n      &lt;li class=&quot;menu__item&quot;&gt;\n        &lt;a class=&quot;menu__link&quot; href=&quot;#menu-1&quot;&gt;Menu 1&lt;/a&gt;\n        &lt;ul class=&quot;submenu&quot; id=&quot;menu-1&quot; tabindex=&quot;-1&quot;&gt;\n          &lt;li class=&quot;submenu__item&quot;&gt;&lt;a class=&quot;submenu__link&quot; href=&quot;http://example.com/#1&quot;&gt;Example 1&lt;/a&gt;&lt;/li&gt;\n          &lt;li class=&quot;submenu__item&quot;&gt;&lt;a class=&quot;submenu__link&quot; href=&quot;http://example.com/#2&quot;&gt;Example 2&lt;/a&gt;&lt;/li&gt;\n          &lt;li class=&quot;submenu__item&quot;&gt;&lt;a class=&quot;submenu__link&quot; href=&quot;http://example.com/#3&quot;&gt;Example 3&lt;/a&gt;&lt;/li&gt;\n          &lt;li class=&quot;submenu__item&quot;&gt;&lt;a class=&quot;submenu__link&quot; href=&quot;http://example.com/#4&quot;&gt;Example 4&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n      &lt;/li&gt;\n      &lt;li class=&quot;menu__item&quot;&gt;\n        &lt;a  class=&quot;menu__link&quot; href=&quot;#menu-2&quot;&gt;Menu 2&lt;/a&gt;\n        &lt;ul class=&quot;submenu&quot; id=&quot;menu-2&quot; tabindex=&quot;-1&quot;&gt;\n          &lt;li class=&quot;submenu__item&quot;&gt;&lt;a class=&quot;submenu__link&quot; href=&quot;http://example.com/#1&quot;&gt;Example 1&lt;/a&gt;&lt;/li&gt;\n          &lt;li class=&quot;submenu__item&quot;&gt;&lt;a class=&quot;submenu__link&quot; href=&quot;http://example.com/#2&quot;&gt;Example 2&lt;/a&gt;&lt;/li&gt;\n          &lt;li class=&quot;submenu__item&quot;&gt;&lt;a class=&quot;submenu__link&quot; href=&quot;http://example.com/#3&quot;&gt;Example 3&lt;/a&gt;&lt;/li&gt;\n          &lt;li class=&quot;submenu__item&quot;&gt;&lt;a class=&quot;submenu__link&quot; href=&quot;http://example.com/#4&quot;&gt;Example 4&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n    lorem ipsum &lt;a href=&quot;http://example.com/&quot;&gt;dolor&lt;/a&gt; sit amet.\n\n&lt;!-- end snippet --&gt;\n\n---\n\n# WAI-ARIA Roles and Other Accessibility Support\n\nThis answer hopefully covers the basics of accessible keyboard and mouse support for this feature, but as it&#39;s already quite sizable I&#39;m going to avoid any discussion of [WAI-ARIA roles and attributes][2], however I *highly* recommend that implementers refer to the spec for details on what roles they should use and any other appropriate attributes.\n\n[1]: http://api.jquery.com/focusout/\n[2]: https://www.w3.org/TR/wai-aria/"},{"score":1,"body_markdown":"To hide `fileTreeClass` if clicked outside of it   \r\n\r\n     jQuery(document).mouseup(function (e) {\r\n        \t\tvar container = $(&quot;.fileTreeClass&quot;);\r\n        \t\tif (!container.is(e.target) // if the target of the click isn&#39;t the container...\r\n        \t\t\t&amp;&amp; container.has(e.target).length === 0) // ... nor a descendant of the container\r\n        \t\t{\r\n        \t\t\tcontainer.hide();\r\n        \t\t}\r\n        \t});"},{"score":1,"body_markdown":"Simple plugin:\r\n    \r\n    $.fn.clickOff = function(callback, selfDestroy) {\r\n        var clicked = false;\r\n        var parent = this;\r\n        var destroy = selfDestroy || true;\r\n\r\n        parent.click(function() {\r\n            clicked = true;\r\n        });\r\n\r\n        $(document).click(function(event) {\r\n            if (!clicked &amp;&amp; parent.is(&#39;:visible&#39;)) {\r\n                if(callback) callback.call(parent, event)\r\n            }\r\n            if (destroy) {\r\n                //parent.clickOff = function() {};\r\n                //parent.off(&quot;click&quot;);\r\n                //$(document).off(&quot;click&quot;);\r\n                parent.off(&quot;clickOff&quot;);\r\n            }\r\n            clicked = false;\r\n        });\r\n    };\r\n\r\nUse:\r\n\r\n    $(&quot;#myDiv&quot;).clickOff(function() {\r\n       alert(&#39;clickOff&#39;);\r\n    });\r\n"},{"score":2,"body_markdown":"This might be a better fix for some people. \r\n\r\n    \r\n\r\n    $(&quot;.menu_link&quot;).click(function(){\r\n        // show menu code\r\n    });\r\n        \r\n    $(&quot;.menu_link&quot;).mouseleave(function(){\r\n        //hide menu code, you may add a timer for 3 seconds before code to be run\r\n    });\r\n\r\nI know mouseleave does not only mean a click outside, it also means leaving that element&#39;s area.\r\n\r\nOnce the menu itself is inside the `menu_link` element then the menu itself should not be a problem to click on or move on."},{"score":2,"body_markdown":"I believe the best way of doing it is something like this. \r\n\r\n    $(document).on(&quot;click&quot;, function(event) {\r\n      clickedtarget = $(event.target).closest(&#39;#menuscontainer&#39;);\r\n      $(&quot;#menuscontainer&quot;).not(clickedtarget).hide();\r\n    });\r\n\r\nThis type of solution could easily be made to work for multiple menus and also menus that are dynamically added through javascript. Basically it just allows you to click anywhere in your document, and checks which element you clicked in, and selects it&#39;s closest &quot;#menuscontainer&quot;. Then it hides all menuscontainers but excludes the one you clicked in. \r\n\r\nNot sure about exactly how your menus are built, but feel free to copy my code in the JSFiddle. It&#39;s a very simple but thoroughly functional menu/modal system. All you need to do is build the html-menus and the code will do the work for you.\r\n\r\n[https://jsfiddle.net/zs6anrn7/][1]\r\n\r\n\r\n  [1]: https://jsfiddle.net/zs6anrn7/"},{"score":3,"body_markdown":"I know there are a million answers to this question, but I&#39;ve always been a fan of using HTML and CSS to do most of the work. In this case, z-index and positioning. The simplest way that I have found to do this is as follows:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $(&quot;#show-trigger&quot;).click(function(){\r\n      $(&quot;#element&quot;).animate({width: &#39;toggle&#39;});\r\n      $(&quot;#outside-element&quot;).show();\r\n    });\r\n    $(&quot;#outside-element&quot;).click(function(){\r\n      $(&quot;#element&quot;).hide();\r\n      $(&quot;#outside-element&quot;).hide();\r\n    });\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    #outside-element {\r\n      position:fixed;\r\n      width:100%;\r\n      height:100%;\r\n      z-index:1;\r\n      display:none;\r\n    }\r\n    #element {\r\n      display:none;\r\n      padding:20px;\r\n      background-color:#ccc;\r\n      width:300px;\r\n      z-index:2;\r\n      position:relative;\r\n    }\r\n    #show-trigger {\r\n      padding:20px;\r\n      background-color:#ccc;\r\n      margin:20px auto;\r\n      z-index:2;\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;div id=&quot;outside-element&quot;&gt;&lt;/div&gt;\r\n    &lt;div id=&quot;element&quot;&gt;\r\n      &lt;div class=&quot;menu-item&quot;&gt;&lt;a href=&quot;#1&quot;&gt;Menu Item 1&lt;/a&gt;&lt;/div&gt;\r\n      &lt;div class=&quot;menu-item&quot;&gt;&lt;a href=&quot;#2&quot;&gt;Menu Item 1&lt;/a&gt;&lt;/div&gt;\r\n      &lt;div class=&quot;menu-item&quot;&gt;&lt;a href=&quot;#3&quot;&gt;Menu Item 1&lt;/a&gt;&lt;/div&gt;\r\n      &lt;div class=&quot;menu-item&quot;&gt;&lt;a href=&quot;#4&quot;&gt;Menu Item 1&lt;/a&gt;&lt;/div&gt;\r\n    &lt;/div&gt;\r\n    &lt;div id=&quot;show-trigger&quot;&gt;Show Menu&lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThis creates a safe environment, since nothing is going to get triggered unless the menu is actually open and the z-index protects any of the content within the element from creating any misfires upon being clicked.\r\n\r\nAdditionally, you&#39;re not requiring jQuery to cover all of your bases with propagation calls and having to purge all of the inner elements from misfires."},{"score":3,"body_markdown":"    $(document).on(&quot;click&quot;,function (event)   \r\n     {   \r\n         console.log(event);\r\n       if ($(event.target).closest(&#39;.element&#39;).length == 0)\r\n         {\r\n        //your code here\r\n          if ($(&quot;.element&quot;).hasClass(&quot;active&quot;))\r\n          {\r\n            $(&quot;.element&quot;).removeClass(&quot;active&quot;);\r\n          }\r\n         }\r\n     });\r\nTry this coding for getting the solution."},{"score":17,"body_markdown":"The event has a property called event.path of the element which is a *&quot;static ordered list of all its ancestors in tree order&quot;*. To check if an event originated from a specific DOM element or one of its children, just check the path for that specific DOM element. It can also be used to check multiple elements by logically `OR`ing the element check in the `some` function.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $(&quot;body&quot;).click(function() {\r\n      target = document.getElementById(&quot;main&quot;);\r\n      flag = event.path.some(function(el, i, arr) {\r\n        return (el == target)\r\n      })\r\n      if (flag) {\r\n        console.log(&quot;Inside&quot;)\r\n      } else {\r\n        console.log(&quot;Outside&quot;)\r\n      }\r\n    });\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    #main {\r\n      display: inline-block;\r\n      background:yellow;\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;div id=&quot;main&quot;&gt;\r\n      &lt;ul&gt;\r\n        &lt;li&gt;Test-Main&lt;/li&gt;\r\n        &lt;li&gt;Test-Main&lt;/li&gt;\r\n        &lt;li&gt;Test-Main&lt;/li&gt;\r\n        &lt;li&gt;Test-Main&lt;/li&gt;\r\n        &lt;li&gt;Test-Main&lt;/li&gt;\r\n      &lt;/ul&gt;\r\n    &lt;/div&gt;\r\n    &lt;div id=&quot;main2&quot;&gt;\r\n      Outside Main\r\n    &lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nSo for your case It should be \r\n    \r\n    $(&quot;body&quot;).click(function() {\r\n      target = $(&quot;#menuscontainer&quot;)[0];\r\n      flag = event.path.some(function(el, i, arr) {\r\n        return (el == target)\r\n      });\r\n      if (!flag) {\r\n        // Hide the menus\r\n      }\r\n    });\r\n\r\n"},{"score":7,"body_markdown":"If someone curious here is javascript solution(es6):\r\n\r\n    window.addEventListener(&#39;mouseup&#39;, e =&gt; {\r\n            if (e.target != yourDiv &amp;&amp; e.target.parentNode != yourDiv) {\r\n                yourDiv.classList.remove(&#39;show-menu&#39;);\r\n                //or yourDiv.style.display = &#39;none&#39;;\r\n            }\r\n        })\r\nand es5, just in case:\r\n\r\n    window.addEventListener(&#39;mouseup&#39;, function (e) {\r\n    if (e.target != yourDiv &amp;&amp; e.target.parentNode != yourDiv) {\r\n        yourDiv.classList.remove(&#39;show-menu&#39;); \r\n        //or yourDiv.style.display = &#39;none&#39;;\r\n    }\r\n});\r\n\r\n"},{"score":4,"body_markdown":"Here is what I do to solve to problem.\r\n\r\n    \r\n    $(window).click(function (event) {\r\n        //To improve performance add a checklike \r\n        //if(myElement.isClosed) return;\r\n        var isClickedElementChildOfMyBox = isChildOfElement(event,&#39;#id-of-my-element&#39;);\r\n\r\n        if (isClickedElementChildOfMyBox)\r\n            return;\r\n\r\n        //your code to hide the element \r\n    });\r\n\r\n    var isChildOfElement = function (event, selector) {\r\n        if (event.originalEvent.path) {\r\n            return event.originalEvent.path[0].closest(selector) !== null;\r\n        }\r\n\r\n        return event.originalEvent.originalTarget.closest(selector) !== null;\r\n    }\r\n"},{"score":3,"body_markdown":"This works for me\r\n\r\n    $(&quot;body&quot;).mouseup(function(e) {\r\n\t\tvar subject = $(&quot;.main-menu&quot;);\r\n\t\tif(e.target.id != subject.attr(&#39;id&#39;) &amp;&amp; !subject.has(e.target).length) {\r\n\t\t\t$(&#39;.sub-menu&#39;).hide();\r\n\t\t}\r\n\t});"},{"score":7,"body_markdown":"Here is a simple solution by pure javascript. It is **up-to-date with ES6**:\r\n\r\n    var isMenuClick = false;\r\n    var menu = document.getElementById(&#39;menuscontainer&#39;);\r\n    document.addEventListener(&#39;click&#39;,()=&gt;{\r\n        if(!isMenuClick){\r\n           //Hide the menu here\r\n        }\r\n        //Reset isMenuClick \r\n        isMenuClick = false;\r\n    })\r\n    menu.addEventListener(&#39;click&#39;,()=&gt;{\r\n        isMenuClick = true;\r\n    })\r\n\r\n"},{"score":0,"body_markdown":"if you just want to display a window when you click on a button and undisp this window when you click outside.( or on the button again ) this bellow work good\r\n\r\n\r\n    document.body.onclick = function() { undisp_menu(); };\r\n    var menu_on = 0;\r\n    \r\n    function menu_trigger(event){\r\n    \t\r\n    \tif (menu_on == 0)\r\n    \t{\r\n            // otherwise u will call the undisp on body when \r\n            // click on the button\r\n    \t\tevent.stopPropagation(); \r\n\r\n    \t\tdisp_menu();\r\n    \t}\r\n    \t\r\n    \telse{\r\n    \t\tundisp_menu();\r\n    \t}\r\n    \t\r\n    }\r\n    \r\n    \r\n    function disp_menu(){\r\n    \r\n    \tmenu_on = 1;\r\n    \tvar e = document.getElementsByClassName(&quot;menu&quot;)[0];\r\n    \te.className = &quot;menu on&quot;;\r\n    \r\n    }\r\n    \r\n    function undisp_menu(){\r\n    \t\r\n    \tmenu_on = 0;\r\n    \tvar e = document.getElementsByClassName(&quot;menu&quot;)[0];\r\n    \te.className = &quot;menu&quot;;\r\n    \t\r\n    }\r\n\r\ndon&#39;t forget this for the button\r\n\r\n    &lt;div class=&quot;button&quot; onclick=&quot;menu_trigger(event)&quot;&gt;\r\n\r\n    &lt;div class=&quot;menu&quot;&gt;\r\n\r\nand the css:\r\n\r\n    .menu{\r\n        display: none;\r\n    }\r\n    \r\n    .on {\r\n        display: inline-block;\r\n    }"},{"score":3,"body_markdown":"If you are using tools like &quot;Pop-up&quot;, you can use the &quot;onFocusOut&quot; event.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    window.onload=function(){\r\n    document.getElementById(&quot;inside-div&quot;).focus();\r\n    }\r\n    function loseFocus(){\r\n    alert(&quot;Clicked outside&quot;);\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    #container{\r\n    background-color:lightblue;\r\n    width:200px;\r\n    height:200px;\r\n    }\r\n\r\n    #inside-div{\r\n    background-color:lightgray;\r\n    width:100px;\r\n    height:100px;\r\n\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;div id=&quot;container&quot;&gt;\r\n    &lt;input type=&quot;text&quot; id=&quot;inside-div&quot; onfocusout=&quot;loseFocus()&quot;&gt;\r\n    &lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":2,"body_markdown":"    $(&#39;#propertyType&#39;).on(&quot;click&quot;,function(e){\r\n              self.propertyTypeDialog = !self.propertyTypeDialog;\r\n              b = true;\r\n              e.stopPropagation();\r\n              console.log(&quot;input clicked&quot;);\r\n          });\r\n    \r\n          $(document).on(&#39;click&#39;,&#39;body:not(#propertyType)&#39;,function (e) {\r\n              e.stopPropagation();\r\n              if(b == true)  {\r\n                  if ($(e.target).closest(&quot;#configuration&quot;).length == 0) {\r\n                      b = false;\r\n                      self.propertyTypeDialog = false;\r\n                      console.log(&quot;outside clicked&quot;);\r\n                  }\r\n              }\r\n            // console.log($(e.target).closest(&quot;#configuration&quot;).length);\r\n          });"},{"score":7,"body_markdown":"I have used below script and done with jQuery.\r\n\r\n\r\n    jQuery(document).click(function(e) {\r\n        var target = e.target; //target div recorded\r\n        if (!jQuery(target).is(&#39;#tobehide&#39;) ) {\r\n            jQuery(this).fadeOut(); //if the click element is not the above id will hide\r\n        }\r\n    })\r\n\r\nBelow find the HTML code\r\n\r\n    &lt;div class=&quot;main-container&quot;&gt;\r\n    &lt;div&gt; Hello I am the title&lt;/div&gt;\r\n    &lt;div class=&quot;tobehide&quot;&gt;I will hide when you click outside of me&lt;/div&gt;\r\n    &lt;/div&gt;\r\n\r\nYou can read the tutorial [here][1] \r\n\r\n\r\n  [1]: http://tutsplanet.com/trigger-function-clicks-outside-element-jquery-492/"},{"score":18,"body_markdown":"I am surprised nobody actually acknowledged [`focusout`][1] event:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var button = document.getElementById(&#39;button&#39;);\r\n    button.addEventListener(&#39;click&#39;, function(e){\r\n      e.target.style.backgroundColor = &#39;green&#39;;\r\n    });\r\n    button.addEventListener(&#39;focusout&#39;, function(e){\r\n      e.target.style.backgroundColor = &#39;&#39;;\r\n    });\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;!DOCTYPE html&gt;\r\n    &lt;html&gt;\r\n    &lt;head&gt;\r\n      &lt;meta charset=&quot;utf-8&quot;&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n      &lt;button id=&quot;button&quot;&gt;Click&lt;/button&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/API/Element/focusout_event"},{"score":4,"body_markdown":"I just want to make @Pistos answer more apparent since it&#39;s hidden in the comments.\r\n\r\nThis solution worked perfectly for me. Plain JS:\r\n\r\n    var elementToToggle = $(&#39;.some-element&#39;);\r\n    $(document).click( function(event) {\r\n      if( $(event.target).closest(elementToToggle).length === 0 ) {\r\n        elementToToggle.hide();\r\n      }\r\n    });\r\n\r\nin CoffeeScript:\r\n\r\n    elementToToggle = $(&#39;.some-element&#39;)\r\n    $(document).click (event) -&gt;\r\n      if $(event.target).closest(elementToToggle).length == 0\r\n        elementToToggle.hide()"},{"score":4,"body_markdown":"Let&#39;s say the div you want to detect if the user clicked outside or inside has an id, for example: &quot;my-special-widget&quot;.\r\n\r\nListen to body click events:\r\n\r\n    document.body.addEventListener(&#39;click&#39;, (e) =&gt; {\r\n        if (isInsideMySpecialWidget(e.target, &quot;my-special-widget&quot;)) {\r\n            console.log(&quot;user clicked INSIDE the widget&quot;);\r\n        }\r\n        console.log(&quot;user clicked OUTSIDE the widget&quot;);\r\n    });\r\n\r\n    function isInsideMySpecialWidget(elem, mySpecialWidgetId){\r\n        while (elem.parentElement) {\r\n            if (elem.id === mySpecialWidgetId) {\r\n                return true;\r\n            }\r\n            elem = elem.parentElement;\r\n        }\r\n        return false;\r\n    }\r\n\r\nIn this case, you won&#39;t break the normal flow of click on some element in your page, since you are not using the &quot;stopPropagation&quot; method."},{"score":-1,"body_markdown":"First you have to track wether the mouse is inside or outside your element1, using the mouseenter and mouseleave events.\r\nThen you can create an element2 which covers the whole screen to detect any clicks, and react accordingly depending on wether you are inside or outside element1.\r\n\r\nI strongly recommend to handle both initialization and cleanup, and that the element2 is made as temporary as possible, for obvious reasons.\r\n\r\nIn the example below, the overlay is an element positionned somewhere, which can be selected by clicking inside, and unselected by clicking outside.\r\nThe _init and _release methods are called as part of an automatic initialisation/cleanup process.\r\nThe class inherits from a ClickOverlay which has an inner and outerElement, don&#39;t worry about it. I used outerElement.parentNode.appendChild to avoid conflicts.\r\n    \r\n\timport ClickOverlay from &#39;./ClickOverlay.js&#39;\r\n\r\n\t/* CSS */\r\n\t// .unselect-helper {\r\n\t// \tposition: fixed; left: -100vw; top: -100vh;\r\n\t// \twidth: 200vw; height: 200vh;\r\n\t// }\r\n\t// .selected {outline: 1px solid black}\r\n\r\n\texport default class ResizeOverlay extends ClickOverlay {\r\n\t\t_init(_opts) {\r\n\t\t\tthis.enterListener = () =&gt; this.onEnter()\r\n\t\t\tthis.innerElement.addEventListener(&#39;mouseenter&#39;, this.enterListener)\r\n\t\t\tthis.leaveListener = () =&gt; this.onLeave()\r\n\t\t\tthis.innerElement.addEventListener(&#39;mouseleave&#39;, this.leaveListener)\r\n\t\t\tthis.selectListener = () =&gt; {\r\n\t\t\t\tif (this.unselectHelper)\r\n\t\t\t\t\treturn\r\n\t\t\t\tthis.unselectHelper = document.createElement(&#39;div&#39;)\r\n\t\t\t\tthis.unselectHelper.classList.add(&#39;unselect-helper&#39;)\r\n\t\t\t\tthis.unselectListener = () =&gt; {\r\n\t\t\t\t\tif (this.mouseInside)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\tthis.clearUnselectHelper()\r\n\t\t\t\t\tthis.onUnselect()\r\n\t\t\t\t}\r\n\t\t\t\tthis.unselectHelper.addEventListener(&#39;pointerdown&#39;\r\n\t\t\t\t\t, this.unselectListener)\r\n\t\t\t\tthis.outerElement.parentNode.appendChild(this.unselectHelper)\r\n\t\t\t\tthis.onSelect()\r\n\t\t\t}\r\n\t\t\tthis.innerElement.addEventListener(&#39;pointerup&#39;, this.selectListener)\r\n\t\t}\r\n\r\n\t\t_release() {\r\n\t\t\tthis.innerElement.removeEventListener(&#39;mouseenter&#39;, this.enterListener)\r\n\t\t\tthis.innerElement.removeEventListener(&#39;mouseleave&#39;, this.leaveListener)\r\n\t\t\tthis.innerElement.removeEventListener(&#39;pointerup&#39;, this.selectListener)\r\n\t\t\tthis.clearUnselectHelper()\r\n\t\t}\r\n\r\n\t\tclearUnselectHelper() {\r\n\t\t\tif (!this.unselectHelper)\r\n\t\t\t\treturn\r\n\t\t\tthis.unselectHelper.removeEventListener(&#39;pointerdown&#39;\r\n\t\t\t\t, this.unselectListener)\r\n\t\t\tthis.unselectHelper.remove()\r\n\t\t\tdelete this.unselectListener\r\n\t\t\tdelete this.unselectHelper\r\n\t\t}\r\n\r\n\t\tonEnter() {\r\n\t\t\tthis.mouseInside = true\r\n\t\t}\r\n\r\n\t\tonLeave() {\r\n\t\t\tdelete this.mouseInside\r\n\t\t}\r\n\r\n\t\tonSelect() {\r\n\t\t\tthis.innerElement.classList.add(&#39;selected&#39;)\r\n\t\t}\r\n\r\n\t\tonUnselect() {\r\n\t\t\tthis.innerElement.classList.remove(&#39;selected&#39;)\r\n\t\t}\r\n\t}"},{"score":2,"body_markdown":"\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const button = document.querySelector(&#39;button&#39;)\r\n    const box = document.querySelector(&#39;.box&#39;);\r\n\r\n    const toggle = event =&gt; {\r\n      event.stopPropagation();\r\n      \r\n      if (!event.target.closest(&#39;.box&#39;)) {\r\n        console.log(&#39;Click outside&#39;);\r\n\r\n        box.classList.toggle(&#39;active&#39;);\r\n\r\n        box.classList.contains(&#39;active&#39;)\r\n          ? document.addEventListener(&#39;click&#39;, toggle)\r\n          : document.removeEventListener(&#39;click&#39;, toggle);\r\n      } else {\r\n        console.log(&#39;Click inside&#39;);\r\n      }\r\n    }\r\n\r\n    button.addEventListener(&#39;click&#39;, toggle);\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .box {\r\n      position: absolute;\r\n      display: none;\r\n      margin-top: 8px;\r\n      padding: 20px;\r\n      background: lightgray;\r\n    }\r\n\r\n    .box.active {\r\n      display: block;\r\n    }\r\n\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;button&gt;Toggle box&lt;/button&gt;\r\n\r\n    &lt;div class=&quot;box&quot;&gt;\r\n      &lt;form action=&quot;&quot;&gt;\r\n        &lt;input type=&quot;text&quot;&gt;\r\n        &lt;button type=&quot;button&quot;&gt;Search&lt;/button&gt;\r\n      &lt;/form&gt;\r\n    &lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"The easiest way: `mouseleave(function())`\r\n\r\nMore info: https://www.w3schools.com/jquery/jquery_events.asp"},{"score":3,"body_markdown":"2020 solution using native JS API [closest][1] method.\r\n\r\n``` js\r\ndocument.addEventListener(&#39;click&#39;, ({ target }) =&gt; {\r\n  if (!target.closest(&#39;.el1, .el2, #el3&#39;)) {\r\n    alert(&#39;click outside&#39;)\r\n  }\r\n})\r\n\r\n```\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/API/Element/closest"},{"score":1,"body_markdown":"Still looking for that perfect solution for detecting clicking outside? Look no further! Introducing [Clickout-Event](https://www.npmjs.com/package/clickout-event), a package that provides universal support for clickout and other similar events, and it works in **all** scenarios: plain HTML `onclickout` attributes, `.addEventListener(&#39;clickout&#39;)` of vanilla JavaScript, `.on(&#39;clickout&#39;)` of jQuery, `v-on:clickout` directives of Vue.js, you name it. As long as a front-end framework internally uses `addEventListener` to handle events, Clickout-Event works for it. Just add the script tag anywhere in your page, and it simply works like magic.\r\n\r\nHTML attribute\r\n```html\r\n&lt;div onclickout=&quot;console.log(&#39;clickout detected&#39;)&quot;&gt;...&lt;/div&gt;\r\n```\r\nVanilla JavaScript\r\n```js\r\ndocument.getElementById(&#39;myId&#39;).addEventListener(&#39;clickout&#39;, myListener);\r\n```\r\njQuery\r\n```js\r\n$(&#39;#myId&#39;).on(&#39;clickout&#39;, myListener);\r\n```\r\nVue.js\r\n```html\r\n&lt;div v-on:clickout=&quot;open=false&quot;&gt;...&lt;/div&gt;\r\n```\r\nAngular\r\n```html\r\n&lt;div (clickout)=&quot;close()&quot;&gt;...&lt;/div&gt;\r\n```"},{"score":1,"body_markdown":"All of these answers solve the problem, but I would like to contribute with a moders es6 solution that does exactly what is needed. I just hope to make someone happy with this runnable demo.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    window.clickOutSide = (element, clickOutside, clickInside) =&gt; {\r\n      document.addEventListener(&#39;click&#39;, (event) =&gt; {\r\n        if (!element.contains(event.target)) {\r\n          if (typeof clickInside === &#39;function&#39;) {\r\n            clickOutside();\r\n          }\r\n        } else {\r\n          if (typeof clickInside === &#39;function&#39;) {\r\n            clickInside();\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    window.clickOutSide(document.querySelector(&#39;.block&#39;), () =&gt; alert(&#39;clicked outside&#39;), () =&gt; alert(&#39;clicked inside&#39;));\r\n\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .block {\r\n      width: 400px;\r\n      height: 400px;\r\n      background-color: red;\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"this works fine for me. i am not an expert.\r\n\r\n\r\n \r\n\r\n    $(document).click(function(event) {\r\n      var $target = $(event.target);\r\n      if(!$target.closest(&#39;#hamburger, a&#39;).length &amp;&amp;\r\n      $(&#39;#hamburger, a&#39;).is(&quot;:visible&quot;)) {\r\n        $(&#39;nav&#39;).slideToggle();\r\n      }\r\n    });\r\n    "},{"score":9,"body_markdown":"## It&#39;s 2020 and you can use `event.composedPath()`\r\n\r\nFrom: https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath\r\n\r\n&gt; The composedPath() method of the Event interface returns the event’s path, which is an array of the objects on which listeners will be invoked. \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\nconst target = document.querySelector(&#39;#myTarget&#39;)\r\n\r\ndocument.addEventListener(&#39;click&#39;, (event) =&gt; {\r\n      const withinBoundaries = event.composedPath().includes(target)\r\n\r\n      if (withinBoundaries) {\r\n        target.innerText = &#39;Click happened inside element&#39;\r\n      } else {\r\n        target.innerText = &#39;Click happened **OUTSIDE** element&#39;\r\n      } \r\n    })\r\n\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    /* just to make it good looking. you don&#39;t need this */\r\n    #myTarget {\r\n      margin: 50px auto;\r\n      width: 500px;\r\n      height: 500px;\r\n      background: gray;\r\n      border: 10px solid black;\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;div id=&quot;myTarget&quot;&gt;\r\n      click me (or not!)\r\n    &lt;/div&gt;\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"}],"score":2570}