{"body":"Is there a better way to engineer a `sleep` in JavaScript than the following `pausecomp` function ([taken from here][1])?\r\n\r\n    function pausecomp(millis)\r\n    {\r\n        var date = new Date();\r\n        var curDate = null;\r\n        do { curDate = new Date(); }\r\n        while(curDate-date &lt; millis);\r\n    }\r\n\r\n\r\nThis is not a duplicate of https://stackoverflow.com/questions/758688/sleep-in-javascript-delay-between-actions; I want a *real sleep* in the middle of a function, and not a delay before a piece of code executes.\r\n\r\n\r\n  [1]: http://www.sean.co.uk/a/webdesign/javascriptdelay.shtm","title":"What is the JavaScript version of sleep()?","answers":[{"score":136,"body_markdown":"For the love of $DEITY please do not make a busy-wait sleep function.  `setTimeout` and `setInterval` do everything you need.\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var showHide = document.getElementById(&#39;showHide&#39;);\r\n    setInterval(() =&gt; {\r\n        showHide.style.visibility = &quot;initial&quot;;\r\n        setTimeout(() =&gt; {\r\n            showHide.style.visibility = &quot;hidden&quot;\r\n        }, 1000);\r\n        ;\r\n    }, 2000);   \r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;div id=&quot;showHide&quot;&gt;Hello! Goodbye!&lt;/div&gt;\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nEvery two second interval hide text for one second. This shows how to use setInterval and setTimeout to show and hide text each second. "},{"score":6,"body_markdown":"You can&#39;t do a sleep like that in JavaScript, or, rather, you shouldn&#39;t. Running a sleep or a while loop will cause the user&#39;s browser to hang until the loop is done.\r\n\r\nUse a timer, as specified in the link you referenced. "},{"score":684,"body_markdown":"In JavaScript, I rewrite every function so that it can end as soon as possible. You want the browser back in control so it can make your DOM changes.\r\n\r\nEvery time I&#39;ve wanted a sleep in the middle of my function, I refactored to use a `setTimeout()`.\r\n\r\nEdit\r\n---\r\n\r\nThe infamous sleep, or delay, function within any language is much debated.  Some will say that there should always be a signal or callback to fire a given functionality, others will argue that sometimes an arbitrary moment of delay is useful.  I say that to each their own and one rule can never dictate anything in this industry.\r\n\r\nWriting a sleep function is simple and made even more usable with JavaScript Promises:\r\n\r\n    // sleep time expects milliseconds\r\n    function sleep (time) {\r\n      return new Promise((resolve) =&gt; setTimeout(resolve, time));\r\n    }\r\n    \r\n    // Usage!\r\n    sleep(500).then(() =&gt; {\r\n        // Do something after the sleep!\r\n    });"},{"score":21,"body_markdown":"First:\r\n\r\nDefine a function you want to execute like this:\r\n\r\n    function alertWorld(){\r\n      alert(&quot;Hello World&quot;);\r\n    }\r\n\r\nThen schedule its execution with the setTimeout method:\r\n\r\n    setTimeout(alertWorld,1000)\r\n\r\n\r\nNote two things\r\n\r\n* the second argument is time in miliseconds\r\n* as a first argument you have to pass just the name (reference) of the function, without the parenthesis\r\n"},{"score":3,"body_markdown":"This is really not a good idea, doing something like this would cause the entire page to freeze up while the system waited for your function to return."},{"score":180,"body_markdown":"I agree with the other posters, a busy sleep is just a bad idea.\r\n\r\nHowever, setTimeout does not hold up execution, it executes the next line of the function immediately after the timeout is SET, not after the timeout expires, so that does not accomplish the same task that a sleep would accomplish.\r\n\r\nThe way to do it is to breakdown your function in to before and after parts. \r\n\r\n    function doStuff()\r\n    {\r\n      //do some things\r\n      setTimeout(continueExecution, 10000) //wait ten seconds before continuing\r\n    }\r\n    \r\n    function continueExecution()\r\n    {\r\n       //finish doing things after the pause\r\n    }\r\n\r\nMake sure your function names still accurately describe what each piece is doing (I.E. GatherInputThenWait and CheckInput, rather than funcPart1 and funcPart2)\r\n\r\n**Edit** \r\n\r\nThis method achieves the purpose of not executing the lines of code you decide until AFTER your timeout, while still returning control back to the client PC to execute whatever else it has queued up.\r\n\r\n**Further Edit**\r\n\r\nAs pointed out in the comments this will absolutely NOT WORK in a loop. You could do some fancy (ugly) hacking to make it work in a loop, but in general that will just make for disastrous spaghetti code.\r\n"},{"score":71,"body_markdown":"If you&#39;re using jQuery, someone actually created a &quot;delay&quot; plugin that&#39;s nothing more than a wrapper for setTimeout:\r\n\r\n    // Delay Plugin for jQuery\r\n    // - http://www.evanbot.com\r\n    // - &#169; 2008 Evan Byrne\r\n    \r\n    jQuery.fn.delay = function(time,func){\r\n    \tthis.each(function(){\r\n    \t\tsetTimeout(func,time);\r\n    \t});\r\n    \r\n    \treturn this;\r\n    };\r\n\r\nYou can then just use it in a row of function calls as expected:\r\n\r\n    $(&#39;#warning&#39;)\r\n    .addClass(&#39;highlight&#39;)\r\n    .delay(1000)\r\n    .removeClass(&#39;highlight&#39;);"},{"score":8,"body_markdown":"I have searched/googled quite a few webpages on javascript sleep/wait... and there is NO answer if you want javascript to &quot;RUN, DELAY, RUN&quot;... what most people got was either, &quot;RUN, RUN(useless stuff), RUN&quot; or &quot;RUN, RUN + delayed RUN&quot;....\r\n\r\nSo I ate some burgers and got thinking:::\r\nhere is a solution that works... but you have to chop up your running codes...:::\r\nyes, I know, this is just an easier to read refactoring... still...\r\n\r\n//.........................................\r\n//example1:\r\n\r\n    &lt;html&gt;\r\n    &lt;body&gt;\r\n    &lt;div id=&quot;id1&quot;&gt;DISPLAY&lt;/div&gt;\r\n    \r\n    &lt;script&gt;\r\n    //javascript sleep by &quot;therealdealsince1982&quot;; copyrighted 2009\r\n    //setInterval\r\n    var i = 0;\r\n    \r\n    function run() {\r\n    \t//pieces of codes to run\r\n    \tif (i==0){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ i +&quot; is ran&lt;/p&gt;&quot;; }\r\n    \tif (i==1){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ i +&quot; is ran&lt;/p&gt;&quot;; }\r\n    \tif (i==2){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ i +&quot; is ran&lt;/p&gt;&quot;; }\r\n    \tif (i &gt;2){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ i +&quot; is ran&lt;/p&gt;&quot;; }\r\n    \tif (i==5){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;all code segment finished running&lt;/p&gt;&quot;; clearInterval(t); } //end interval, stops run\r\n    \ti++; //segment of code finished running, next...\r\n    }\r\n    \r\n    run();\r\n    t=setInterval(&quot;run()&quot;,1000);\r\n    \r\n    &lt;/script&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;\r\n\r\n//....................................\r\n//example2:\r\n\r\n    &lt;html&gt;\r\n    &lt;body&gt;\r\n    &lt;div id=&quot;id1&quot;&gt;DISPLAY&lt;/div&gt;\r\n    \r\n    &lt;script&gt;\r\n    //javascript sleep by &quot;therealdealsince1982&quot;; copyrighted 2009\r\n    //setTimeout\r\n    var i = 0;\r\n    \r\n    function run() {\r\n    \t//pieces of codes to run, can use switch statement\r\n    \tif (i==0){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ i +&quot; ran&lt;/p&gt;&quot;; sleep(1000);}\r\n    \tif (i==1){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ i +&quot; ran&lt;/p&gt;&quot;; sleep(2000);}\r\n    \tif (i==2){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ i +&quot; ran&lt;/p&gt;&quot;; sleep(3000);}\r\n    \tif (i==3){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ i +&quot; ran&lt;/p&gt;&quot;;} //stops automatically\r\n    \ti++;\r\n    }\r\n    \r\n    function sleep(dur) {t=setTimeout(&quot;run()&quot;,dur);} //starts flow control again after dur\r\n    \r\n    run(); //starts\r\n    &lt;/script&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;\r\n//.................\r\nexample3:\r\n\r\n    &lt;html&gt;\r\n    &lt;body&gt;\r\n    &lt;div id=&quot;id1&quot;&gt;DISPLAY&lt;/div&gt;\r\n    \r\n    &lt;script&gt;\r\n    //javascript sleep by &quot;therealdealsince1982&quot;; copyrighted 2009\r\n    //setTimeout\r\n    var i = 0;\r\n    \r\n    function flow() {\r\n    \trun(i);\r\n    \ti++; //code segment finished running, increment i; can put elsewhere\r\n    \tsleep(1000);\r\n    \tif (i==5) {clearTimeout(t);} //stops flow, must be after sleep()\r\n    }\r\n    \r\n    function run(segment) {\r\n    \t//pieces of codes to run, can use switch statement\r\n    \tif (segment==0){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ segment +&quot; is ran&lt;/p&gt;&quot;; }\r\n    \tif (segment==1){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ segment +&quot; is ran&lt;/p&gt;&quot;; }\r\n    \tif (segment==2){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ segment +&quot; is ran&lt;/p&gt;&quot;; }\r\n    \tif (segment &gt;2){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ segment +&quot; is ran&lt;/p&gt;&quot;; }\r\n    }\r\n    \r\n    function sleep(dur) {t=setTimeout(&quot;flow()&quot;,dur);} //starts flow control again after dur\r\n    \r\n    flow(); //starts flow\r\n    &lt;/script&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;\r\n\r\n//..............\r\nexample4:\r\n\r\n    &lt;html&gt;\r\n    &lt;body&gt;\r\n    &lt;div id=&quot;id1&quot;&gt;DISPLAY&lt;/div&gt;\r\n    \r\n    &lt;script&gt;\r\n    //javascript sleep by &quot;therealdealsince1982&quot;; copyrighted 2009\r\n    //setTimeout, switch\r\n    var i = 0;\r\n    \r\n    function flow() {\r\n    \tswitch(i)\r\n    \t{\r\n    \t\tcase 0:\r\n    \t\t\trun(i);\r\n    \t\t\tsleep(1000);\r\n    \t\t\tbreak;\r\n    \t\tcase 1:\r\n    \t\t\trun(i);\r\n    \t\t\tsleep(2000);\r\n    \t\t\tbreak;\r\n    \t\tcase 5:\r\n    \t\t\trun(i);\r\n    \t\t\tclearTimeout(t); //stops flow\r\n    \t\t\tbreak;\r\n    \t\tdefault:\r\n    \t\t\trun(i);\r\n    \t\t\tsleep(3000);\r\n    \t\t\tbreak;\r\n    \t}\r\n    }\r\n    \r\n    function run(segment) {\r\n    \t//pieces of codes to run, can use switch statement\r\n    \tif (segment==0){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ segment +&quot; is ran&lt;/p&gt;&quot;; }\r\n    \tif (segment==1){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ segment +&quot; is ran&lt;/p&gt;&quot;; }\r\n    \tif (segment==2){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ segment +&quot; is ran&lt;/p&gt;&quot;; }\r\n    \tif (segment &gt;2){document.getElementById(&quot;id1&quot;).innerHTML= &quot;&lt;p&gt;code segment &quot;+ segment +&quot; is ran&lt;/p&gt;&quot;; }\r\n    \ti++; //current segment of code finished running, next...\r\n    }\r\n    \r\n    function sleep(dur) {t=setTimeout(&quot;flow()&quot;,dur);} //starts flow control again after dur\r\n    \r\n    flow(); //starts flow control for first time...\r\n    &lt;/script&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;"},{"score":5,"body_markdown":"For the specific case of wanting to space out a set of calls being executed by a loop, you can use something like the code below with prototype. Without prototype, you can substitute the delay function with setTimeout.\r\n\r\n    function itemHandler(item)\r\n    {\r\n        alert(item);\r\n    }\r\n\r\n    var itemSet = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];\r\n    \r\n    // Each call to itemHandler will execute\r\n    // 1 second apart\r\n    for(var i=0; i&lt;itemSet.length; i++)\r\n    {\r\n        var secondsUntilExecution = i;\r\n        itemHandler.delay(secondsUntilExecution, item)\r\n    }"},{"score":6,"body_markdown":"One scenario where you might want a sleep() function rather than using setTimeout() is if you have a function responding to a user click that will ultimately end up opening a new i.e. popup window and you have initiated some processing that requires a short period to complete before the popup is displayed. Moving the open window into a closure means that it typically gets blocked by the browser."},{"score":852,"body_markdown":"(See the [updated answer for 2016](https://stackoverflow.com/a/39914235/11236))\r\n\r\nI think it&#39;s perfectly reasonable to want to perform an action, wait, then perform another action. If you are used to writing in multi-threaded languages, you probably have the idea of yielding execution for a set amount of time until your thread wakes up.\r\n\r\nThe issue here is that JavaScript is a single-thread event-based model. While in a specific case, it might be nice to have the whole engine wait for a few seconds, in general it is bad practice. Suppose I wanted to make use of your functions while writing my own? When I called your method, my methods would all freeze up. If JavaScript could somehow preserve your function&#39;s execution context, store it somewhere, then bring it back and continue later, then sleep could happen, but that would basically be threading.\r\n\r\nSo you are pretty much stuck with what others have suggested -- you&#39;ll need to break your code up into multiple functions.\r\n\r\nYour question is a bit of a false choice, then. There is no way to sleep in the way you want, nor should you pursue the solution you suggest."},{"score":48,"body_markdown":"I&#39;ve searched for sleep solution too (not for production code, only for dev/tests) and found this article:\r\n\r\nhttp://narayanraman.blogspot.com/2005/12/javascript-sleep-or-wait.html\r\n\r\n...and here&#39;s another link with client-side solutions: http://www.devcheater.com/\r\n\r\nAlso, when you are calling `alert()`, your code will be paused too, while alert is shown -- need to find a way to not display alert but get the same effect. :)"},{"score":6,"body_markdown":"I can understand the purpose of a sleep function if you have to deal with synchronous execution. The setInterval and setTimeout functions create a parallel execution thread which returns the execution sequence back to the main program, which is ineffective if you have to wait for a given result. Of course one may use events and handlers, but in some cases is not what is intended."},{"score":18,"body_markdown":"Better solution to make things look like what most people want is to use an anonymous function:\r\n\r\n    alert(&#39;start&#39;);\r\n    var a = &#39;foo&#39;;\r\n    //lots of code\r\n    setTimeout(function(){  //Beginning of code that should run AFTER the timeout\r\n        alert(a);\r\n        //lots more code\r\n    },5000);  // put the timeout here\r\n\r\nThis is probably the closest you&#39;ll get to something that simply does what you want.\r\n\r\nNote, if you need multiple sleeps this can get ugly in a hurry and you might actually need to rethink your design.\r\n\r\n\r\n"},{"score":4,"body_markdown":"First of all - setTimeout and setInterval is what **should** be used, because of javascript&#39;s callback-ish nature. If you want to use `sleep()` it&#39;s the control flow or the architecture of your code that is incorrect.\r\n\r\nHaving said that I suppose I still can help with two implementation of a sleep.\r\n\r\n1. faking synchronous run off the top of my head:\r\n\r\n          \r\n        //a module to do taht //dual-license: MIT or WTF [you can use it anyhow and leave my nickname in a comment if you want to]\r\n        var _=(function(){\r\n         var queue=[];\r\n         var play=function(){\r\n           var go=queue.shift();\r\n             if(go){if(go.a){go.f();play();}else{setTimeout(play,go.t);}}\r\n           }\r\n         return {\r\n           go:function(f){\r\n            queue.push({a:1,f:f});\r\n            },\r\n           sleep:function(t){\r\n            queue.push({a:0,t:t});\r\n            },\r\n           playback:play \r\n         }\r\n        })();\r\n[making playback automatic should also be possible]\r\n        \r\n        //usage\r\n        \r\n        _.go(function(){\r\n    \r\n        //your code\r\n        console.log(&#39;first&#39;);\r\n    \r\n        });\r\n        \r\n        \r\n        _.sleep(5000);\r\n        \r\n        _.go(function(){\r\n    \r\n        //your code\r\n        console.log(&#39;next&#39;);\r\n    \r\n        });\r\n        \r\n        //this triggers the simulation\r\n        _.playback();\r\n          \r\n\r\n2. real synchronous run\r\n\r\nI gave it a lot of thought one day and the only idea I had for a true sleep in javascript is technical.\r\n\r\na sleep function would have to be a **synchronous** AJAX call with a timeout set to the sleep value. That&#39;s all and an only way to have a real `sleep()`\r\n"},{"score":1,"body_markdown":"If you want to sleep an anonymous function like one you&#39;ve created as a handler, I recommend the following:\r\n\r\n    function()\r\n    {\r\n    if (!wait_condition)\r\n        {\r\n        setTimeout(arguments.callee, 100, /*comma-separated arguments here*/);\r\n        }\r\n    //rest of function\r\n    }\r\nThis code says &quot;If the wait condition has not yet been satisfied, call this function again with these arguments.&quot; I&#39;ve used this method to pass in the same arguments to my handlers, effectively making this code a non-polling sleep() (which only works at the start of your function)."},{"score":111,"body_markdown":"I know this is a bit of an old question, but if (like me) you&#39;re using Javascript with Rhino, you can use...\r\n\r\n    try\r\n    {\r\n      java.lang.Thread.sleep(timeInMilliseconds);\r\n    }\r\n    catch (e)\r\n    {\r\n      /*\r\n       * This will happen if the sleep is woken up - you might want to check\r\n       * if enough time has passed and sleep again if not - depending on how\r\n       * important the sleep time is to you.\r\n       */\r\n    }\r\n"},{"score":4,"body_markdown":"Code taken from this [link][1] will not freeze comp. But it works only on ff.\r\n\r\n\r\n    /**\r\n     * Netscape compatible WaitForDelay function.\r\n     * You can use it as an alternative to Thread.Sleep() in any major programming language\r\n     * that support it while JavaScript it self doesn&#39;t have any built-in function to do such a thing.\r\n     * parameters:\r\n     * (Number) delay in millisecond\r\n     */\r\n    function nsWaitForDelay(delay) {\r\n        /**\r\n         * Just uncomment this code if you&#39;re building an extention for Firefox.\r\n         * Since FF3, we&#39;ll have to ask for user permission to execute XPCOM objects.\r\n         */\r\n        netscape.security.PrivilegeManager.enablePrivilege(&quot;UniversalXPConnect&quot;);\r\n    \r\n        // Get the current thread.\r\n        var thread = Components.classes[&quot;@mozilla.org/thread-manager;1&quot;].getService(Components.interfaces.nsIThreadManager).currentThread;\r\n    \r\n        // Create an inner property to be used later as a notifier.\r\n        this.delayed = true;\r\n    \r\n        /* Call JavaScript setTimeout function\r\n          * to execute this.delayed = false\r\n          * after it finish.\r\n          */\r\n        setTimeout(&quot;this.delayed = false;&quot;, delay);\r\n    \r\n        /**\r\n         * Keep looping until this.delayed = false\r\n         */\r\n        while (this.delayed) {\r\n            /**\r\n             * This code will not freeze your browser as it&#39;s documented in here:\r\n             * https://developer.mozilla.org/en/Code_snippets/Threads#Waiting_for_a_background_task_to_complete\r\n             */\r\n            thread.processNextEvent(true);\r\n        }\r\n    }\r\n\r\n\r\n  [1]: http://www.daniweb.com/web-development/javascript-dhtml-ajax/threads/47199"},{"score":1,"body_markdown":"A method of an object that needs to use a &quot;sleep&quot; method such as the following:\r\n\r\n    function SomeObject() {\r\n        this.SomeProperty = &quot;xxx&quot;;\r\n        return this;\r\n    }\r\n    SomeObject.prototype.SomeMethod = function () {\r\n        this.DoSomething1(arg1);\r\n        sleep(500);\r\n        this.DoSomething2(arg1);\r\n    }\r\n\r\nCan almost be translated to:\r\n\r\n\r\n    function SomeObject() {\r\n        this.SomeProperty = &quot;xxx&quot;;\r\n        return this;\r\n    }\r\n    SomeObject.prototype.SomeMethod = function (arg1) {\r\n        var self = this;\r\n        self.DoSomething1(arg1);\r\n        setTimeout(function () {\r\n            self.DoSomething2(arg1);\r\n        }, 500);\r\n    }\r\n\r\nThe difference is that the operation of &quot;SomeMethod&quot; returns before the operation &quot;DoSomething2&quot; is executed. The caller of &quot;SomeMethod&quot; cannot depend on this. Since the &quot;Sleep&quot; method does not exists, I use the later method and design my code accordingly.\r\n\r\nI hope this helps.\r\n\r\n"},{"score":0,"body_markdown":"A good alternative in some situations is to display a top-level message panel to stop user interaction, and then hide it again when you get the result you&#39;re waiting for (asynchronously). That allows the browser to get on with background tasks, but pauses the workflow until you&#39;ve got your result back."},{"score":30,"body_markdown":"Here you go.  As the code says, don&#39;t be a bad dev and use this on websites.  It&#39;s a development utility function.\r\n\r\n    // Basic sleep function based on ms.\r\n    // DO NOT USE ON PUBLIC FACING WEBSITES.\r\n    function sleep(ms) {\r\n        var unixtime_ms = new Date().getTime();\r\n        while(new Date().getTime() &lt; unixtime_ms + ms) {}\r\n    }\r\n"},{"score":4,"body_markdown":"Adding my two bits. I needed a busy-wait for testing purposes. I didn&#39;t want to split the code as that would be a lot of work, so a simple for did it for me. \r\n\r\n    for (var i=0;i&lt;1000000;i++){\t\t\t\t\t\r\n         //waiting\r\n      }\r\n\r\nI don&#39;t see any downside in doing this and it did the trick for me."},{"score":6,"body_markdown":"It can be done using Java&#39;s sleep method. I&#39;ve tested it in FF and IE and it doesn&#39;t lock the computer, chew up resources, or cause endless server hits. Seems like a clean solution to me.\r\n\r\nFirst you have to get Java loaded up on the page and make its methods available. To do that, I did this:\r\n\r\n    &lt;html&gt;\r\n    &lt;head&gt;\r\n\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        \r\n      function load() {\r\n       \tvar appletRef = document.getElementById(&quot;app&quot;);\r\n    \twindow.java = appletRef.Packages.java;\r\n      } // endfunction\r\n\r\n    &lt;/script&gt;\r\n    \r\n    &lt;body onLoad=&quot;load()&quot;&gt;\r\n    \r\n    &lt;embed id=&quot;app&quot; code=&quot;java.applet.Applet&quot; type=&quot;application/x-java-applet&quot; MAYSCRIPT=&quot;true&quot; width=&quot;0&quot; height=&quot;0&quot; /&gt;\r\n\r\nThen, all you have to do when you want a painless pause in your JS is:\r\n\r\n    java.lang.Thread.sleep(xxx)\r\n\r\nWhere xxx is time in milliseconds. In my case (by way of justification), this was part of back-end order fulfillment at a very small company and I needed to print an invoice that had to be loaded from the server. I did it by loading the invoice (as a webpage) into an iFrame and then printing the iFrame. Of course, I had to wait until the page was fully loaded before I could print, so the JS had to pause. I accomplished this by having the invoice page (in the iFrame) change a hidden form field on the parent page with the onLoad event.  And the code on the parent page to print the invoice looked like this (irrelevant parts cut for clarity):\r\n\r\n    var isReady = eval(&#39;document.batchForm.ready&#39;);\r\n    isReady.value=0;\r\n    \r\n    frames[&#39;rpc_frame&#39;].location.href=url;\r\n    \r\n    while (isReady.value==0) {\r\n      java.lang.Thread.sleep(250);\r\n    } // endwhile\r\n    \r\n    window.frames[&#39;rpc_frame&#39;].focus();\r\n    window.frames[&#39;rpc_frame&#39;].print();\r\n\r\nSo the user pushes the button, the script loads the invoice page, then waits, checking every quarter second to see if the invoice page is finished loading, then pops up the print dialog for the user to send it to the printer.  QED.\r\n\r\n\r\n\r\n"},{"score":-7,"body_markdown":"Or just create this:\r\n\r\n    function yourFunction(){\r\n    \r\n       //do something\r\n       setInterval(myFunc(),1000);\r\n       //do something else\r\n     \r\n    }\r\n    \r\n    function myFunc(){\r\n       return;\r\n    }\r\n\r\nthis will just wait the interval specified and call the function which will just do nothing."},{"score":11,"body_markdown":"For browsers, I agree that setTimeout and setInterval are the way to go.\r\n\r\nBut for server-side code, it may require a blocking function (for example, so you can effectively have thread synchronization).\r\n\r\nIf you&#39;re using node.js and meteor, you may have run into the limitations of using setTimeout in a fiber. Here is the code for server-side sleep.\r\n\r\n    var Fiber = require(&#39;fibers&#39;);\r\n    \r\n    function sleep(ms) {\r\n        var fiber = Fiber.current;\r\n        setTimeout(function() {\r\n            fiber.run();\r\n        }, ms);\r\n        Fiber.yield();\r\n    }\r\n    \r\n    Fiber(function() {\r\n        console.log(&#39;wait... &#39; + new Date);\r\n        sleep(1000);\r\n        console.log(&#39;ok... &#39; + new Date);\r\n    }).run();\r\n    console.log(&#39;back in main&#39;);\r\n\r\nSee: https://github.com/laverdet/node-fibers#sleep\r\n"},{"score":4,"body_markdown":"If you right a sleep function like this\r\n\r\n\tvar sleep = function(period, decision, callback){\r\n\t\tvar interval = setInterval(function(){\r\n\t\t\tif (decision()) {\r\n\t\t\t\tinterval = clearInterval(interval);\r\n\t\t\t\tcallback();\r\n\t\t\t}\r\n\t\t}, period);\r\n\t}\r\n\r\nand you have a asynchronous function to call multiple times\r\n\r\n\tvar xhr = function(url, callback){\r\n\t\t// make ajax request\r\n\t\t// call callback when request fulfills\r\n\t}\r\n\r\nAnd you setup your project like this:\r\n\r\n\tvar ready = false;\r\n\r\n\tfunction xhr1(){\r\n\t\txhr(url1, function(){ ready = true;});\t\r\n\t}\r\n\tfunction xhr2(){\r\n\t\txhr(url2, function(){ ready = true; });\t\r\n\t}\r\n\tfunction xhr3(){\r\n\t\txhr(url3, function(){ ready = true; });\t\r\n\t}\r\n\r\nThen you can do this:\r\n\r\n\txhr1();\r\n\tsleep(100, function(){ return done; }, xhr2);\r\n\tsleep(100, function(){ return done; }, xhr3);\r\n\tsleep(100, function(){ return done; }, function(){\r\n\t\t// do more\r\n\t});\r\n\r\nInstead of endless callback indentation like this:\r\n\r\n\txhr(url1, function(){\r\n\t\txhr2(url2, function(){\r\n\t\t\txhr3(url3, function(){\r\n\t\t\t\t// do more\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n"},{"score":315,"body_markdown":"**Only for debug/dev** , I post this if it&#39;s useful to someone\r\n\r\nInteresting stuff, in Firebug ( &amp; probably other js consoles ), nothing happen after hitting enter, only after the sleep duration specified (...)\r\n\r\n    function sleepFor( sleepDuration ){\r\n        var now = new Date().getTime();\r\n        while(new Date().getTime() &lt; now + sleepDuration){ /* do nothing */ } \r\n    }\r\n\r\nExample of use:\r\n\r\n    function sleepThenAct(){ sleepFor(2000); console.log(&quot;hello js sleep !&quot;); }"},{"score":-5,"body_markdown":"    var waitTillSomethingHappens = function(){  \r\n        if(somethingHappened == 1)  \r\n        {  \r\n            alert(&#39;Something Happened get out of sleep&#39;);  \r\n        }\r\n        else\r\n        {  \r\n        setTimeout(waitTillSomethingHappens,1000);  \r\n        }  \r\n    };"},{"score":0,"body_markdown":"I use the multithread HTML5 Worker which will be able to abort an synchronous XMLHttpRequest pointing to an unresponsive URL. This does not block the browser.\r\n\r\nhttps://gist.github.com/el-gringo/6990785"},{"score":0,"body_markdown":"The short answer is *NO*, not in javascript by itself.  You solution seems to be the only way to not return control back to the environment.\r\n\r\nThis is necessary if the environment does not support events.  They probably wouldn&#39;t support the settimeout either.\r\n\r\nsettimeout is definitely the best way if you are in an event driven environment suchas a browser or node.js.\r\n"},{"score":7,"body_markdown":"    function sleep(milliseconds) {\r\n      var start = new Date().getTime();\r\n      for (var i = 0; i &lt; 1e7; i++) {\r\n        if ((new Date().getTime() - start) &gt; milliseconds){\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n"},{"score":-2,"body_markdown":"I&#39;m sure there is a million ways to do this one better, but I thought I would give it a try by creating an object:\r\n\r\n\t// execute code consecutively with delays (blocking/non-blocking internally)\r\n\tfunction timed_functions() \r\n\t{\r\n\tthis.myfuncs = [];\r\n\tthis.myfuncs_delays = []; // mirrors keys of myfuncs -- values stored are custom delays, or -1 for use default\r\n\tthis.myfuncs_count = 0; // increment by 1 whenever we add a function\r\n\tthis.myfuncs_prev\t= -1; // previous index in array\r\n\tthis.myfuncs_cur\t= 0; // current index in array\r\n\tthis.myfuncs_next  = 0; // next index in array\r\n\tthis.delay_cur     = 0; // current delay in ms\r\n\tthis.delay_default = 0; // default delay in ms\r\n\tthis.loop = false;      // will this object continue to execute when at end of myfuncs array?\r\n\tthis.finished = false;  // are we there yet?\r\n\tthis.blocking = true;   // wait till code completes before firing timer?\r\n\tthis.destroy = false;   // &lt;advanced&gt; destroy self when finished\r\n\r\n\r\n\tthis.next_cycle = function() {\r\n\tvar that  = this;\r\n\tvar mytimer = this.delay_default;\r\n\r\n\tif(this.myfuncs_cur &gt; -1)\r\n\tif(this.myfuncs_delays[this.myfuncs_cur] &gt; -1)\r\n\tmytimer = this.myfuncs_delays[this.myfuncs_cur];\r\n\r\n\tconsole.log(&quot;fnc:&quot; + this.myfuncs_cur);\r\n\tconsole.log(&quot;timer:&quot; + mytimer);\r\n\tconsole.log(&quot;custom delay:&quot; + this.myfuncs_delays[this.myfuncs_cur]);\r\n\tsetTimeout(function() {\r\n\t// times up! next cycle...\r\n\tthat.cycle(); \r\n\r\n\t}, mytimer);\r\n\t}\r\n\r\n\tthis.cycle = function() {\r\n\r\n\t// now check how far we are along our queue.. is this the last function?\r\n\tif(this.myfuncs_next + 1 &gt; this.myfuncs_count)\r\n\t{\r\n\tif(this.loop)\r\n\t{\r\n\tconsole.log(&#39;looping..&#39;);\r\n\tthis.myfuncs_next = 0;\r\n\t}\r\n\telse\r\n\tthis.finished = true;\r\n\t}\r\n\r\n\r\n\t// first check if object isn&#39;t finished\r\n\tif(this.finished)\r\n\treturn false;\r\n\r\n\t// HANDLE NON BLOCKING //\r\n\tif(this.blocking != true) // blocking disabled\r\n\t{\r\n\tconsole.log(&quot;NOT BLOCKING&quot;);\r\n\tthis.next_cycle();\r\n\t}\r\n\r\n\r\n\t// set prev = current, and current to next, and next to new next\r\n\tthis.myfuncs_prev = this.myfuncs_cur;\r\n\tthis.myfuncs_cur  = this.myfuncs_next;\r\n\tthis.myfuncs_next++; \r\n\r\n\t// execute current slot\r\n\tthis.myfuncs[this.myfuncs_cur]();\r\n\r\n\r\n\r\n\r\n\t// HANDLE BLOCKING\r\n\tif(this.blocking == true)  // blocking enabled\r\n\t{\r\n\tconsole.log(&quot;BLOCKING&quot;);\r\n\tthis.next_cycle();\r\n\t}\r\n\r\n\r\n\r\n\r\n\treturn true;\r\n\t};\r\n\r\n\t// adders \r\n\tthis.add = {\r\n\tthat:this,\r\n\r\n\tfnc: function(aFunction) { \r\n\t// add to the function array\r\n\tvar cur_key = this.that.myfuncs_count++;\r\n\tthis.that.myfuncs[cur_key] = aFunction;\r\n\t// add to the delay reference array\r\n\tthis.that.myfuncs_delays[cur_key] = -1;\r\n\t}\r\n\t}; // end::this.add\r\n\r\n\t// setters\r\n\tthis.set = {\r\n\tthat:this, \r\n\r\n\tdelay: \t\t\tfunction(ms) \t{  \r\n\tvar cur_key = this.that.myfuncs_count - 1;\r\n\t// this will handle the custom delay array this.that.myfunc_delays\r\n\t// add a custom delay to your function container\r\n\r\n\tconsole.log(&quot;setting custom delay. key: &quot;+ cur_key + &quot; msecs: &quot; + ms);\r\n\tif(cur_key &gt; -1)\r\n\t{ \r\n\tthis.that.myfuncs_delays[cur_key] = ms; \r\n\t}\r\n\r\n\t// so now we create an entry on the delay variable\r\n\t},  \r\n\r\n\tdelay_cur: \t\tfunction(ms) \t{ this.that.delay_cur = ms;      \t},\r\n\tdelay_default: \tfunction(ms) \t{ this.that.delay_default = ms;      \t},\r\n\tloop_on:          function() \t\t{ this.that.loop = true; }, \r\n\tloop_off:         function() \t    { this.that.loop = false; },\r\n\tblocking_on:      function() \t\t{ this.that.blocking = true; }, \r\n\tblocking_off:     function() \t    { this.that.blocking = false; },\r\n\r\n\tfinished:\t\t\tfunction(aBool) { this.that.finished = true; }\r\n\t}; // end::this.set    \r\n\r\n\r\n\t// setters\r\n\tthis.get = {\r\n\tthat:this, \r\n\r\n\tdelay_default: function() { return this.that.delay_default; },\r\n\tdelay_cur:     function() { return this.that.delay_cur; }\r\n\t}; // end::this.get     \r\n\r\n\t} // end:::function timed_functions()\r\n\r\n\r\nand use like:\r\n\t// // // BEGIN :: TEST // // //\r\n\r\n\t// initialize\r\n\tvar fncTimer = new timed_functions;\r\n\t\r\n\t// set some defaults\r\n\tfncTimer.set.delay_default(1000);\r\n\tfncTimer.set.blocking_on();\r\n\t// fncTimer.set.loop_on();\r\n\t// fncTimer.set.loop_off();\r\n\r\n\r\n\t// BEGIN :: ADD FUNCTIONS (they will fire off in order)\r\n\tfncTimer.add.fnc(function() {\r\n\t\tconsole.log(&#39;plan a (2 secs)&#39;);\r\n\t});\r\n\tfncTimer.set.delay(2000); // set custom delay for previously added function\r\n\r\n\tfncTimer.add.fnc(function() {\r\n\t\tconsole.log(&#39;hello world (delay 3 seconds)&#39;);\r\n\t});\r\n\tfncTimer.set.delay(3000);\r\n\r\n\tfncTimer.add.fnc(function() {\r\n\t\tconsole.log(&#39;wait 4 seconds...&#39;);\r\n\t});\r\n\tfncTimer.set.delay(4000);\r\n\r\n\tfncTimer.add.fnc(function() {\r\n\t\tconsole.log(&#39;wait 2 seconds&#39;);\r\n\t});\r\n\tfncTimer.set.delay(2000);\r\n\r\n\tfncTimer.add.fnc(function() {\r\n\t\tconsole.log(&#39;finished.&#39;);\r\n\t});\r\n\t// END :: ADD FUNCTIONS\r\n\r\n\r\n\t// NOW RUN\r\n\tfncTimer.cycle(); // begin execution \r\n \r\n\r\n\t// // // END :: TEST // // //"},{"score":1,"body_markdown":"You can use a closure call setTimeout() with incrementally larger values.\r\n\r\n    var items = [&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;];\r\n    \r\n    function functionToExecute(item) {\r\n      console.log(&#39;function executed for item: &#39; + item);\r\n    }\r\n    \r\n    $.each(items, function (index, item) {\r\n      var timeoutValue = index * 2000;\r\n      setTimeout(function() {\r\n    \tconsole.log(&#39;waited &#39; + timeoutValue + &#39; milliseconds&#39;);\r\n    \tfunctionToExecute(item);\r\n      }, timeoutValue);\r\n    });\r\n\r\nResult:\r\n\r\n    waited 0 milliseconds\r\n    function executed for item: item1\r\n    waited 2000 milliseconds\r\n    function executed for item: item2\r\n    waited 4000 milliseconds\r\n    function executed for item: item3 \r\n"},{"score":2,"body_markdown":"If you like an advise to not loss performance . `setTimeout` is your expected `sleep` . \r\nHowever , if you wanna a syntax where code  is &quot;divided in middle&quot; by `sleep`, we can do :  \r\n\r\n    sleep=function(tm,fn){\r\n       window.setTimeout(fn,tm);\r\n    }\r\n\r\nthen , perpare functions as following : \r\n\r\n    var fnBeforeSleep=function(){\r\n    \r\n     //All codes before sleep\r\n    \r\n    }  \r\n    \r\n    var fnAfterSleep=function(){\r\n    \r\n     //All codes after sleep\r\n    \r\n    }  \r\n\r\n \r\nThen :\r\n\r\n    fnBeforeSleep();\r\n    sleep(2000,\r\n    fnAfterSleep);\r\n#YEP! ٍsyntactically,It is very close to : \r\n\r\n    fnBeforeSleep();\r\n    sleep(2000); \r\n    fnAfterSleep();"},{"score":11,"body_markdown":"Most of the answers here are misguided or at the very least outdated. There is no reason javascript has to be single threaded, and indeed it isnt&#39;t. Today all the mainstream browsers support workers, before this was the case other javascript runtimes like Rhino and Node.js supported multithreading.\r\n\r\n&#39;Javascript is single threaded&#39; is not a valid answer. For example running a sleep function within a worker would not block any of the code running in the ui thread.\r\n\r\nIn newer runtimes supporting generators and yield, one could bring similar functionality to the sleep function in a single threaded environment:\r\n\r\n\r\n    // This is based on the latest ES6 drafts.\r\n    // js 1.7+ (SpiderMonkey/Firefox 2+) syntax is slightly different\r\n    \r\n    // run code you want to sleep here (ommit star if using js 1.7)\r\n    function* main(){\r\n    \tfor (var i = 0; i &lt; 10; i++) {\r\n    \t\t// to sleep for 10 milliseconds 10 times in a row\r\n    \t\tyield 10;\r\n    \t}\r\n    \r\n    \tyield 5;\r\n    \tconsole.log(&#39;I just slept 5 milliseconds!&#39;);\r\n    }\r\n    \r\n    // resume the given generator after ms milliseconds\r\n    function resume(ms, generator){\r\n    \tsetTimeout(function(){\r\n    \t\t// ommit .value if using js 1.7\r\n    \t\tvar nextSleep = generator.next().value;\r\n    \t\tresume(nextSleep, generator);\r\n    \t}, ms);\r\n    }\r\n    \r\n    // initialize generator and get first sleep for recursive function\r\n    var\r\n    \tgenerator = main(),\r\n    \tfirstSleep = generator.next().value;\r\n    \r\n    // initialize recursive resume function\r\n    resume(firstSleep, generator);\r\n\r\nThis imitation of sleep is different from a true sleep function as it does not block the thread. It is simply sugar on top of javascript&#39;s current setTimeout function. This functionality type has been implemented in [Task.js][1] and should work today in Firefox.\r\n\r\n\r\n  [1]: http://taskjs.org/"},{"score":2,"body_markdown":"Embrace the asyncronous nature of javascript!\r\n\r\n\r\nAll of the following will return immediately but have a single place for putting code you want to run after something has happened.  \r\n\r\nThe methods I&#39;ve outlined here are all for different use cases and are roughly ordered in terms of their complexity.\r\n\r\nThe different things are as follows:\r\n\r\n* Waiting for some condition to become true\r\n* Waiting for a set of methods to finish (in any order) before calling a single callback\r\n* Running a series of asyncronous methods with shared state in a particular order before calling a callback\r\n\r\n**Wait**\r\n\r\nWaiting to see if some condition is true is usedful where there is no accessible callback to tell you when something has finished executing.\r\n\r\nThis is a pretty basic implementation that assumes that the condition will become true at some point.  With a few tweaks it could be expanded to be even more useful (eg by setting a call limit).  (I only wrote this one yesterday!)\r\n\r\n    function waitFor(predicate, successCallback) {\r\n        setTimeout(function () {\r\n            var result = predicate();\r\n            if (result !== undefined)\r\n                successCallback(result);\r\n            else\r\n                waitFor(predicate, successCallback);\r\n        }, 100);\r\n    }\r\n\r\ncalling code:\r\n\r\n        beforeEach(function (done) {\r\n            selectListField(&#39;A field&#39;);\r\n\r\n            waitFor(function () {\r\n                var availableOptions = stores.scrapeStore(optionStore);\r\n                if (availableOptions.length !== 0)\r\n                    return availableOptions;\r\n            }, done);\r\n        });\r\n\r\nHere I&#39;m calling something which loads an extjs &#39;store&#39; and waiting til the store contains something before continuing (the beforeEach is a jasmine test framework thing).\r\n\r\n\r\n**Wait for several things to complete**\r\n\r\n\r\nAnother thing I needed to do was run a single callback after a load of different methods finished.  You can do that like this:\r\n\r\n    createWaitRunner = function (completionCallback) {\r\n        var callback = completionCallback;\r\n        var completionRecord = [];\r\n        var elements = 0;\r\n\r\n        function maybeFinish() {\r\n            var done = completionRecord.every(function (element) {\r\n                return element === true\r\n            });\r\n\r\n            if (done)\r\n                callback();\r\n        }\r\n\r\n        return {\r\n            getNotifier: function (func) {\r\n                func = func || function (){};\r\n\r\n                var index = elements++;\r\n                completionRecord[index] = false;\r\n\r\n                return function () {\r\n                    func.applyTo(arguments);\r\n                    completionRecord[index] = true;\r\n                    maybeFinish();\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\ncalling code:\r\n\r\n        var waiter = createWaitRunner(done);\r\n\r\n        filterList.bindStore = waiter.getNotifier();\r\n        includeGrid.reconfigure = waiter.getNotifier(function (store) {\r\n            includeStore = store;\r\n        });\r\n        excludeGrid.reconfigure = waiter.getNotifier(function (store) {\r\n            excludeStore = store;\r\n        });\r\n\r\nYou either just wait for the notifications or can also wrap other functions which use the values passed to the function.  When all the methods are called then `done` will be run.\r\n\r\n\r\n**Running asynchronous methods in order**\r\n\r\n\r\nI&#39;ve used a different approach when I had a series of asynchronous methods to call in a row (again in tests).  This is somewhat similar to something you can get in [the Async library](https://github.com/caolan/async) - series does about the same thing and I had a little read of that library first to see if it did what I wanted.  I think mine has a nicer api for working with tests though (+ it was fun to implement!).\r\n\r\n    //provides a context for running asyncronous methods syncronously\r\n    //the context just provides a way of sharing bits of state\r\n    //use run to execute the methods.  These should be methods that take a callback and optionally the context as arguments\r\n    //note the callback is provided first so you have the option of just partially applying your function to the arguments you want\r\n    //instead of having to wrap even simple functions in another function\r\n\r\n    //when adding steps you can supply either just a function or a variable name and a function\r\n    //if you supply a variable name then the output of the function (which should be passed into the callback) will be written to the context\r\n    createSynchronisedRunner = function (doneFunction) {\r\n        var context = {};\r\n\r\n        var currentPosition = 0;\r\n        var steps = [];\r\n\r\n        //this is the loop. it is triggered again when each method finishes\r\n        var runNext = function () {\r\n            var step = steps[currentPosition];\r\n            step.func.call(null,\r\n                           function (output) {\r\n                               step.outputHandler(output);\r\n                               currentPosition++;\r\n\r\n                               if (currentPosition === steps.length)\r\n                                   return;\r\n\r\n                               runNext();\r\n                           }, context);\r\n        };\r\n\r\n        var api = {};\r\n\r\n        api.addStep = function (firstArg, secondArg) {\r\n            var assignOutput;\r\n            var func;\r\n\r\n            //overloads\r\n            if (secondArg === undefined) {\r\n                assignOutput = function () {\r\n                };\r\n                func = firstArg;\r\n            }\r\n            else {\r\n                var propertyName = firstArg;\r\n                assignOutput = function (output) {\r\n                    context[propertyName] = output;\r\n                };\r\n                func = secondArg;\r\n            }\r\n\r\n            steps.push({\r\n                           func: func,\r\n                           outputHandler: assignOutput\r\n                       });\r\n        };\r\n\r\n        api.run = function (completedAllCallback) {\r\n            completedAllCallback = completedAllCallback || function(){};\r\n\r\n            var lastStep = steps[steps.length - 1];\r\n            var currentHandler = lastStep.outputHandler;\r\n            lastStep.outputHandler = function (output) {\r\n                currentHandler(output);\r\n                completedAllCallback(context);\r\n                doneFunction();\r\n            };\r\n\r\n            runNext();\r\n        };\r\n\r\n        //this is to support more flexible use where you use a done function in a different scope to initialisation\r\n        //eg the done of a test but create in a beforeEach\r\n        api.setDoneCallback = function (done) {\r\n            doneFunction = done;\r\n        };\r\n\r\n        return api;\r\n    };\r\n\r\ncalling code:\r\n\r\n    beforeAll(function (done) {\r\n        var runner = createSynchronisedRunner(done);\r\n        runner.addStep(&#39;attachmentInformation&#39;, testEventService.getAttachmentCalled.partiallyApplyTo(&#39;cat eating lots of memory.jpg&#39;));\r\n        runner.addStep(&#39;attachment&#39;, getAttachment.partiallyApplyTo(&quot;cat eating lots of memory.jpg&quot;));\r\n        runner.addStep(&#39;noAttachment&#39;, getAttachment.partiallyApplyTo(&quot;somethingElse.jpg&quot;));\r\n        runner.run(function (context) {\r\n            attachment = context.attachment;\r\n            noAttachment = context.noAttachment;\r\n        });\r\n    });\r\n\r\n\r\nPartiallyApplyTo here is basically a renamed version of Doug Crockford&#39;s implementation of Curry.  A lot of the stuff I&#39;m working with takes a callback as the final argument so simple calls can be done like this rather than having to wrap everything with an extra func.\r\n\r\nHopefully some of the ideas in there might be useful to people."},{"score":28,"body_markdown":"Here&#39;s a simple solution using a synchronous XMLHttpRequest:\r\n\r\n    function sleep(n){\r\n      var request = new XMLHttpRequest();\r\n      request.open(&#39;GET&#39;, &#39;/sleep.php?n=&#39; + n, false);  // `false` makes the request synchronous\r\n      request.send(null);\r\n    }\r\n\r\ncontents of sleep.php:\r\n\r\n    &lt;?php sleep($_GET[&#39;n&#39;]);\r\nNow call it with:\r\nsleep(5);"},{"score":7,"body_markdown":"A lot of the answers don&#39;t (directly) answer the question, and neither does this one...\r\n\r\nHere&#39;s my two cents (or functions):\r\n\r\nIf you want less clunky functions than `setTimeout` and `setInterval`, you can wrap them in functions that just reverse the order of the arguments and give them nice names:\r\n\r\n    function after(ms, fn){ setTimeout(fn, ms); }\r\n    function every(ms, fn){ setInterval(fn, ms); }\r\n\r\nCoffeeScript versions:\r\n\r\n    after = (ms, fn)-&gt; setTimeout fn, ms\r\n    every = (ms, fn)-&gt; setInterval fn, ms\r\n\r\nYou can then use them nicely with anonymous functions:\r\n\r\n    after(1000, function(){\r\n        console.log(&quot;it&#39;s been a second&quot;);\r\n        after(1000, function(){\r\n            console.log(&quot;it&#39;s been another second&quot;);\r\n        });\r\n    });\r\n\r\nNow it reads easily as &quot;after N milliseconds, ...&quot; (or &quot;every N milliseconds, ...&quot;)\r\n"},{"score":3,"body_markdown":"In case you really need a sleep() just to test something. But be aware that it&#39;ll crash the browser most of the times while debuggin - probably that&#39;s why you need it anyway. In production mode I&#39;ll comment out this function.\r\n\r\n    function pauseBrowser(millis) {\r\n    \tvar date = Date.now();\r\n    \tvar curDate = null;\r\n    \tdo {\r\n    \t\tcurDate = Date.now();\r\n    \t} while (curDate-date &lt; millis);\r\n    }\r\n\r\nDon&#39;t use new Date() in the loop, unless you want to waste memory, processing power, battery and possibly the lifetime of your device."},{"score":2,"body_markdown":"I know the question is about sleep, and clearly the answer is that it isn&#39;t possible. I think a common want for sleep is to handle asynchronous tasks in order, I know I have had to deal with it for sure.\r\n\r\nMany cases may be able to use promises (AJAX requests common use). They let you do asynchronous things in a synchronous manner.  There is also handling for success/failure, and they can be chained. \r\n\r\nThey part of ECMAScript 6, so browser support isn&#39;t all there yet, mainly, IE does not support them.  There is also library called Q for doing promises.\r\n\r\nReferences:\r\nhttp://www.html5rocks.com/en/tutorials/es6/promises/\r\n\r\nhttps://github.com/jakearchibald/es6-promise#readme (Shim for older, or IE browsers)"},{"score":6,"body_markdown":"If you&#39;re on node.js, you can have a look at [fibers](https://www.npmjs.com/package/fibers) – a native C extension to node, a kinda-multi-threading simulation.\r\n\r\nIt allows you to do a real `sleep` in a way which is blocking execution in a fiber, but it&#39;s non-blocking in the main thread and other fibers.\r\n\r\nHere&#39;s an example fresh from their own readme:\r\n\r\n    // sleep.js\r\n\r\n    var Fiber = require(&#39;fibers&#39;);\r\n     \r\n    function sleep(ms) {\r\n        var fiber = Fiber.current;\r\n        setTimeout(function() {\r\n            fiber.run();\r\n        }, ms);\r\n        Fiber.yield();\r\n    }\r\n     \r\n    Fiber(function() {\r\n        console.log(&#39;wait... &#39; + new Date);\r\n        sleep(1000);\r\n        console.log(&#39;ok... &#39; + new Date);\r\n    }).run();\r\n    console.log(&#39;back in main&#39;);\r\n\r\n– and the results are:\r\n\r\n    $ node sleep.js\r\n    wait... Fri Jan 21 2011 22:42:04 GMT+0900 (JST)\r\n    back in main\r\n    ok... Fri Jan 21 2011 22:42:05 GMT+0900 (JST)"},{"score":2,"body_markdown":"Try this simple javascript function:\r\n\r\n    function sleep(milliseconds) {\r\n        var $return = false;\r\n        if (typeof importScripts == &#39;function&#39;) {\r\n            var sleep_xhr = function (milliseconds) {\r\n                try {\r\n                    var xhr = new XMLHttpRequest();\r\n                    xhr.open(&#39;GET&#39;, &#39;http://128.0.0.1:&#39; + (Math.random() * 100000).toFixed(0) + &#39;/&#39;, false);\r\n                    xhr.timeout = milliseconds;\r\n                    xhr.send();\r\n                } catch (E) {\r\n                    // Nothing to do...\r\n                }\r\n            };\r\n            milliseconds = milliseconds | 0;\r\n            if (milliseconds &gt; 0) {\r\n                var start = Date.now();\r\n                while (Date.now() &lt; start + milliseconds) {\r\n                    sleep_xhr((start + milliseconds) - Date.now());\r\n                }\r\n                $return = Date.now() - start;\r\n            }\r\n        }\r\n        return $return;\r\n    }\r\n\r\nNote: This function only works on **web workers**."},{"score":-2,"body_markdown":"Here is a way to sleep in a `.hta` script, such that when the script wakes up it executes the next command in sequence, as is necessary in a loop.  This is a real sleep; it does not keep a processor busy during the sleep.  E.g. the processor is able to download and render pages during the sleep.\r\n\r\nJust once, near the beginning of the code, go\r\n\r\n    var WSHShell = new ActiveXObject (&quot;WScript.Shell&quot;);\r\n\r\nFor a sleep of e.g. 1 second = 1000 milliseconds, execute the statement\r\n\r\n    WSHShell.Run (&#39;Sleep.js 1000&#39;, 3, true);\r\n\r\nIn the same directory as the script is the file `Sleep.js`, which contains the following one line:\r\n\r\n    WScript.Sleep (WScript.Arguments (0));\r\n\r\n(Beware; `0` is in parentheses, not brackets.) The latter is the line that actually performs the sleep.  The argument `true` in the preceding snippet makes the call synchronous.  The `3` in the preceding argument seems not to have any effect, but you need some argument so that `true` is the 3rd argument.  Microsoft says &quot;The WScript object ... never needs to be instantiated before invoking its properties and methods, and it is always available from any script file.&quot;, but that&#39;s not true.  It is available in a free-standing `.js` file such as the above, but apparently not in a `.js` file used by a `.hta` file, so that is why it must be in a separate file, invoked as above."},{"score":10,"body_markdown":"I would encapsulate setTimeOut in a Promise for code consistency with other asynchronous tasks : Demo in [Fiddle][1]\r\n\r\n    function sleep(ms)\r\n    {\r\n        return(new Promise(function(resolve, reject) {        \r\n            setTimeout(function() { resolve(); }, ms);        \r\n        }));    \r\n    }\r\n\r\nUsed like that :\r\n\r\n    sleep(2000).then(function() { \r\n       // Do something\r\n    });\r\n\r\n\r\nIt is easy to remember syntax if you used to use Promises.\r\n\r\n  [1]: http://jsfiddle.net/a4gjhpgd/"},{"score":0,"body_markdown":"To summarize (like it has been said in previous answers):\r\n\r\nThere is no built-in sleep function in JavaScript. You should use [setTimeout][1] or [setInterval][2] to achieve a similar effect.\r\n\r\nIf you really wanted to, you could simulate sleep functionality with a for loop such as the one shown in the original question, but that would make your CPU work like crazy. Inside a Web Worker an alternative solution would be to make a synchronous `XMLHttpRequest` to a non-responsive IP and set a proper timeout. This would avoid the CPU utilization problem. Here&#39;s a code example:\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // Works only inside a web worker\r\n\r\n    function sleep(milliseconds) {\r\n    \tvar req = new XMLHttpRequest();\r\n    \treq.open(&quot;GET&quot;, &quot;http://192.0.2.0/&quot;, false);\r\n    \treq.timeout = milliseconds;\r\n    \ttry {\r\n    \t\treq.send();\r\n    \t} catch (ex) {\r\n    \t\t\r\n    \t}\r\n    }\r\n\r\n    console.log(&#39;Sleeping for 1 second...&#39;);\r\n    sleep(1000);\r\n    console.log(&#39;Slept!&#39;);\r\n\r\n    console.log(&#39;Sleeping for 5 seconds...&#39;)\r\n    sleep(5000);\r\n    console.log(&#39;Slept!&#39;);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval"},{"score":5,"body_markdown":"An old question from 2009.  Now in 2015 a new solution is possible with generators defined in ECMAscript 2015 aka ES6.  It was approved in June, but it was implemented in Firefox and Chrome before.  Now a sleep function can be made non-busy, non-blocking and nested inside loops and sub-functions without freezing the browser.  Only pure JavaScript is needed, no libraries or frameworks.\r\n\r\nThe program below shows how `sleep()` and `runSleepyTask()` can be made.  The `sleep()` function is only a `yield` statement.  It is so simple that it is actually easier to write the `yield` statement directly in stead of calling `sleep()`, but then there would be no sleep-word :-)  The yield returns a time value to the `next()` method inside `wakeup()` and waits.  The actual &quot;sleeping&quot; is done in `wakeup()` using the good old `setTimeout()`.  At callback the the `next()` method triggers the `yield` statement to continue, and the &quot;magic&quot; of yield is that all the local variables and the whole call-stack around it is still intact.\r\n\r\nFunctions that use sleep() or yield must be defined as generators.  Easy done by adding an asterix to the keyword `function*`.  To execute a generator is a bit trickier.  When invoked with the keyword `new` the generator returns an object that has the `next()` method, but the body of the generator is not executed (the keyword `new` is optional and makes no difference).  The `next()` method triggers execution of the generator body until it encounters a `yield`.  The wrapper function `runSleepyTask()` starts up the ping-pong: `next()` waits for a `yield`, and `yield` waits a `next()`.\r\n\r\nAnother way to invoke a generator is with keyword `yield*`, here it works like a simple function call, but it also includes the ability to yield back to `next()`.\r\n\r\nThis is all demonstrated by the example `drawTree()`.  It draws a tree with leaves on a rotating 3D scene.  A tree is drawn as a trunk with 3 parts at the top in different directions.  Each part is then drawn as another but smaller tree by calling `drawTree()` recursively after a short sleep.  A very small tree is drawn as only a leaf.\r\n\r\nEach leaf has its own life in a separate task started with `runSleepyTask()`.  It is born, grows, sits, fades, falls and dies in `growLeaf()`.  The speed is controlled with `sleep()`.  This demonstrates how easy multitasking can be done.\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function* sleep(milliseconds) {yield milliseconds};\r\n\r\n    function runSleepyTask(task) {\r\n        (function wakeup() {\r\n            var result = task.next();\r\n            if (!result.done) setTimeout(wakeup, result.value);\r\n        })()\r\n    }\r\n    //////////////// written by Ole Middelboe  /////////////////////////////\r\n\r\n    pen3D =setup3D();\r\n    var taskObject = new drawTree(pen3D.center, 5);\r\n    runSleepyTask(taskObject);\r\n\r\n    function* drawTree(root3D, size) {\r\n        if (size &lt; 2) runSleepyTask(new growLeaf(root3D))\r\n        else {\r\n            pen3D.drawTrunk(root3D, size);\r\n            for (var p of [1, 3, 5]) {\r\n                var part3D = new pen3D.Thing;\r\n                root3D.add(part3D);\r\n                part3D.move(size).turn(p).tilt(1-p/20);\r\n                yield* sleep(50);\r\n                yield* drawTree(part3D, (0.7+p/40)*size);\r\n            }\r\n        }\r\n    }\r\n\r\n    function* growLeaf(stem3D) {\r\n        var leaf3D = pen3D.drawLeaf(stem3D);\r\n        for (var s=0;s++&lt;15;) {yield* sleep(100); leaf3D.scale.multiplyScalar(1.1)}\r\n        yield* sleep( 1000 + 9000*Math.random() );\r\n        for (var c=0;c++&lt;30;) {yield* sleep(200); leaf3D.skin.color.setRGB(c/30, 1-c/40, 0)}\r\n        for (var m=0;m++&lt;90;) {yield* sleep( 50); leaf3D.turn(0.4).tilt(0.3).move(2)}\r\n        leaf3D.visible = false;\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////\r\n\r\n    function setup3D() {\r\n        var scene, camera, renderer, diretionalLight, pen3D;\r\n\r\n        scene = new THREE.Scene();\r\n        camera = new THREE.PerspectiveCamera(75, \r\n            window.innerWidth / window.innerHeight, 0.1, 1000);\r\n        camera.position.set(0, 15, 20);\r\n        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });\r\n        renderer.setSize(window.innerWidth, window.innerHeight);\r\n        document.body.appendChild(renderer.domElement);\r\n        \r\n        directionalLight = new THREE.DirectionalLight(0xffffaa, 0.7);\r\n        directionalLight.position.set(-1, 2, 1);\r\n        scene.add(directionalLight);\r\n        scene.add(new THREE.AmbientLight(0x9999ff));\r\n          \r\n        (function render() {\r\n            requestAnimationFrame(render);\r\n            // renderer.setSize( window.innerWidth, window.innerHeight );\r\n            scene.rotateY(10/60/60);\r\n            renderer.render(scene, camera);\r\n        })();\r\n        \r\n        window.addEventListener(\r\n            &#39;resize&#39;,\r\n            function(){\r\n                renderer.setSize( window.innerWidth, window.innerHeight );\r\n                camera.aspect = window.innerWidth / window.innerHeight;\r\n                camera.updateProjectionMatrix();\r\n           }, \r\n           false\r\n        );\r\n        \r\n        pen3D = {\r\n            drawTrunk: function(root, size) {\r\n                // root.skin = skin(0.5, 0.3, 0.2);\r\n                root.add(new THREE.Mesh(new THREE.CylinderGeometry(size/12, size/10, size, 16), \r\n                    root.skin).translateY(size/2));\r\n                root.add(new THREE.Mesh(new THREE.SphereGeometry(size/12, 16), \r\n                    root.skin).translateY(size));\r\n                return root;\r\n            },\r\n            \r\n            drawLeaf: function(stem) {\r\n                stem.skin.color.setRGB(0, 1, 0);\r\n                stem.add(new THREE.Mesh(new THREE.CylinderGeometry(0, 0.02, 0.6), \r\n                    stem.skin) .rotateX(0.3).translateY(0.3));\r\n                stem.add(new THREE.Mesh(new THREE.CircleGeometry(0.2), \r\n                    stem.skin) .rotateX(0.3).translateY(0.4));\r\n                return stem;\r\n            },\r\n            \r\n            Thing: function() {\r\n                THREE.Object3D.call(this);\r\n                this.skin = new THREE.MeshLambertMaterial({\r\n                    color: new THREE.Color(0.5, 0.3, 0.2),\r\n                    vertexColors: THREE.FaceColors,\r\n                    side: THREE.DoubleSide\r\n                })\r\n            }\r\n        };\r\n\r\n        pen3D.Thing.prototype = Object.create(THREE.Object3D.prototype);\r\n        pen3D.Thing.prototype.tilt = pen3D.Thing.prototype.rotateX;\r\n        pen3D.Thing.prototype.turn = pen3D.Thing.prototype.rotateY;\r\n        pen3D.Thing.prototype.move = pen3D.Thing.prototype.translateY;\r\n        \r\n        pen3D.center = new pen3D.Thing;\r\n        scene.add(pen3D.center);\r\n        \r\n        return pen3D;\r\n    }\r\n\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js&quot;&gt;&lt;/script&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe 3D stuff is hidden inside setup3D() and is only included to make it less boring than console.log().  Angels are measured in radians by the way.\r\n\r\nTested to work in Firefox and Chrome.  Not implemented in Internet Explore and iOS (iPads).  Try to run it yourself.\r\n\r\nAfter another pass of the answers I found, that Gabriel Ratener made a similar answer a year ago: [https://stackoverflow.com/a/24401317/5032384][1] \r\n\r\n\r\n  [1]: https://stackoverflow.com/a/24401317/5032384"},{"score":1,"body_markdown":"There&#39;s a new library that neatly chains functions together with timeouts so you can avoid callback hell.\r\n\r\n[Sequencr.js][1]\r\n\r\nTurns this:\r\n\r\n    setTimeout(function(timeout){\r\n        function1();\r\n        setTimeout(function(timeout){\r\n            function2();\r\n            setTimeout(function(timeout){\r\n                function3();\r\n            }, timeout, timeout)\r\n        }, timeout, timeout)\r\n    }, 10, 10);\r\n\r\ninto this:\r\n\r\n    Sequencr.chain([function1, function2, function3], 10);\r\n\r\nAnd has built-in support for loops that &quot;sleep&quot; between each iteration.\r\n\r\n\r\n  [1]: https://github.com/JSideris/Sequencr.js/wiki"},{"score":-1,"body_markdown":"Another possible way is:\r\n\r\n    var _timer;\r\n    clearTimeout(_timer);\r\n    _timer = setTimeout(function() {\r\n        // Your code\r\n    }, 1000); // Delay for 1 s."},{"score":0,"body_markdown":"I navigate the solution for a day but still thinking how to maintain the chainability in using callback. Everyone is familiar with the traditional programming style which running the code line by line in synchronised way. SetTimeout uses a callback so the next line does not wait for it to complete. This let me think how to make it &quot;sync&quot;, so as to make a &quot;sleep&quot; function.\r\n\r\nBeginning with a simple coroutine:\r\n\r\n    function coroutine() {\r\n    \tconsole.log(&#39;coroutine-1:start&#39;);\r\n    \tsleepFor(3000); //sleep for 3 seconds here\r\n    \tconsole.log(&#39;coroutine-2:complete&#39;);\r\n    }\r\n\r\nI want to sleep 3 seconds in the middle but don&#39;t want to dominate the whole flow, so the coroutine must be executed by another thread. I consider the [Unity YieldInstruction][1], and modify the coroutine in the following:\r\n\r\n    function coroutine1() {\r\n    \tthis.a = 100;\r\n    \tconsole.log(&#39;coroutine1-1:start&#39;);\r\n    \treturn sleepFor(3000).yield; // sleep for 3 seconds here\r\n    \tconsole.log(&#39;coroutine1-2:complete&#39;);\r\n    \tthis.a++;\r\n    }\r\n\r\n\tvar c1 = new coroutine1();\r\n\r\nDeclare the sleepFor prototype:\r\n\r\n    sleepFor = function(ms) {\r\n    \tvar caller = arguments.callee.caller.toString();\r\n    \tvar funcArgs = /\\(([\\s\\S]*?)\\)/gi.exec(caller)[1];\r\n    \tvar args = arguments.callee.caller.arguments;\r\n    \tvar funcBody = caller.replace(/^[\\s\\S]*?sleepFor[\\s\\S]*?yield;|}[\\s;]*$/g,&#39;&#39;);\r\n    \tvar context = this;\r\n    \tsetTimeout(function() {\r\n    \t\tnew Function(funcArgs, funcBody).apply(context, args);\r\n    \t}, ms);\r\n    \treturn this;\r\n    }\r\n    \r\nAfter run the coroutine1 (I tested in IE11 and Chrome49), you will see it sleep 3 seconds between two console statements. It keeps the codes as pretty as the traditional style. The tricky is in sleepFor routine. It reads the caller function body as string and break it into 2 parts. Remove the upper part and create another function by lower part. After waiting for the specified number of milliseconds, it calls the created function by applying the original context and arguments. For the original flow, it will end by &quot;return&quot; as usual. For the &quot;yield&quot;? It is used for regex matching. It is necessary but no use at all.\r\n\r\nIt is not 100% perfect at all but it achieves my jobs at least. I have to mention some limitations in using this piece of codes. As the code is being broken into 2 parts, the &quot;return&quot; statement must be in outer, instead of in any loop or {}. i.e.\r\n\r\n\tfunction coroutine3() {\r\n\t\tthis.a = 100;\r\n\t\tconsole.log(&#39;coroutine3-1:start&#39;);\r\n\t\tif(true) {\r\n\t\t\treturn sleepFor(3000).yield;\r\n\t\t} // &lt;- raise exception here\r\n\t\tconsole.log(&#39;coroutine3-2:complete&#39;);\r\n\t\tthis.a++;\r\n\t}\r\n\r\nThe above codes must have problem as the close bracket could not exist individually in the created function. Another limitation is all local variables declared by &quot;var xxx=123&quot; could not carry to next function. You must use &quot;this.xxx=123&quot; to achieve the same thing. If your function has arguments and they got changes, the modified value also could not carry to next function.\r\n\r\n\tfunction coroutine4(x) { // assume x=abc\r\n\t\tvar z = x;\r\n\t\tx = &#39;def&#39;;\r\n\t\tconsole.log(&#39;coroutine4-1:start&#39; + z + x); //z=abc, x=def\r\n\t\treturn sleepFor(3000).yield;\r\n\t\tconsole.log(&#39;coroutine4-2:&#39; + z + x); //z=undefined, x=abc\r\n\t}\r\n\r\nI would introduce another function prototype: waitFor\r\n\r\n\twaitFor = function(check, ms) {\r\n\t\tvar caller = arguments.callee.caller.toString();\r\n\t\tvar funcArgs = /\\(([\\s\\S]*?)\\)/gi.exec(caller)[1];\r\n\t\tvar args = arguments.callee.caller.arguments;\r\n\t\tvar funcBody = caller.replace(/^[\\s\\S]*?waitFor[\\s\\S]*?yield;|}[\\s;]*$/g,&#39;&#39;);\r\n\t\tvar context = this;\r\n\t\tvar thread = setInterval(function() {\r\n\t\t\tif(check()) {\r\n\t\t\t\tclearInterval(thread);\r\n\t\t\t\tnew Function(funcArgs, funcBody).apply(context, args);\r\n\t\t\t}\r\n\t\t}, ms?ms:100);\r\n\t\treturn this;\r\n\t}\r\n\r\nIt waits for &quot;check&quot; function until it returns true. It checks the value every 100ms. You can adjust it by passing additional argument. Consider the testing coroutine2:\r\n\r\n\tfunction coroutine2(c) {\r\n\t\t/* some codes here */\r\n\t\tthis.a = 1;\r\n\t\tconsole.log(&#39;coroutine2-1:&#39; + this.a++);\r\n\t\treturn sleepFor(500).yield;\r\n\r\n\t\t/* next */\r\n\t\tconsole.log(&#39;coroutine2-2:&#39; + this.a++);\r\n\t\tconsole.log(&#39;coroutine2-2:waitFor c.a&gt;100:&#39; + c.a);\r\n\t\treturn waitFor(function() {\r\n\t\t\treturn c.a&gt;100;\r\n\t\t}).yield;\r\n\r\n\t\t/* the rest of code */\r\n\t\tconsole.log(&#39;coroutine2-3:&#39; + this.a++);\r\n\t}\r\n\r\nAlso in pretty style we love so far. Actually I hate the nested callback. It is easily understood that the coroutine2 will wait for the completion of coroutine1. Interesting? Ok, then run the following codes:\r\n\r\n\tthis.a = 10;\r\n\tconsole.log(&#39;outer-1:&#39; + this.a++);\r\n\tvar c1 = new coroutine1();\r\n\tvar c2 = new coroutine2(c1);\r\n\tconsole.log(&#39;outer-2:&#39; + this.a++);\r\n\r\nThe output is:\r\n\r\n    outer-1:10\r\n    coroutine1-1:start\r\n    coroutine2-1:1\r\n    outer-2:11\r\n    coroutine2-2:2\r\n    coroutine2-2:waitFor c.a&gt;100:100\r\n    coroutine1-2:complete\r\n    coroutine2-3:3\r\n\r\nOuter is immediately completed after initialised coroutine1 and coroutine2. Then, coroutine1 will wait for 3000ms. Coroutine2 will enter into step 2 after waited for 500ms. After that, it will continue step 3 once it detects the coroutine1.a values &gt; 100.\r\n\r\nBeware of that there are 3 contexts to hold variable &quot;a&quot;. One is outer, which values are 10 and 11. Another one is in coroutine1, which values are 100 and 101. The last one is in coroutine2, which values are 1,2 and 3. In coroutine2, it also waits for c.a which comes from coroutine1, until its value is greater than 100. 3 contexts are independent.\r\n\r\nThe whole code for copy&amp;paste:\r\n\r\n\tsleepFor = function(ms) {\r\n\t\tvar caller = arguments.callee.caller.toString();\r\n\t\tvar funcArgs = /\\(([\\s\\S]*?)\\)/gi.exec(caller)[1];\r\n\t\tvar args = arguments.callee.caller.arguments;\r\n\t\tvar funcBody = caller.replace(/^[\\s\\S]*?sleepFor[\\s\\S]*?yield;|}[\\s;]*$/g,&#39;&#39;);\r\n\t\tvar context = this;\r\n\t\tsetTimeout(function() {\r\n\t\t\tnew Function(funcArgs, funcBody).apply(context, args);\r\n\t\t}, ms);\r\n\t\treturn this;\r\n\t}\r\n\r\n\twaitFor = function(check, ms) {\r\n\t\tvar caller = arguments.callee.caller.toString();\r\n\t\tvar funcArgs = /\\(([\\s\\S]*?)\\)/gi.exec(caller)[1];\r\n\t\tvar args = arguments.callee.caller.arguments;\r\n\t\tvar funcBody = caller.replace(/^[\\s\\S]*?waitFor[\\s\\S]*?yield;|}[\\s;]*$/g,&#39;&#39;);\r\n\t\tvar context = this;\r\n\t\tvar thread = setInterval(function() {\r\n\t\t\tif(check()) {\r\n\t\t\t\tclearInterval(thread);\r\n\t\t\t\tnew Function(funcArgs, funcBody).apply(context, args);\r\n\t\t\t}\r\n\t\t}, ms?ms:100);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tfunction coroutine1() {\r\n\t\tthis.a = 100;\r\n\t\tconsole.log(&#39;coroutine1-1:start&#39;);\r\n\t\treturn sleepFor(3000).yield;\r\n\t\tconsole.log(&#39;coroutine1-2:complete&#39;);\r\n\t\tthis.a++;\r\n\t}\r\n\r\n\tfunction coroutine2(c) {\r\n\t\t/* some codes here */\r\n\t\tthis.a = 1;\r\n\t\tconsole.log(&#39;coroutine2-1:&#39; + this.a++);\r\n\t\treturn sleepFor(500).yield;\r\n\r\n\t\t/* next */\r\n\t\tconsole.log(&#39;coroutine2-2:&#39; + this.a++);\r\n\t\tconsole.log(&#39;coroutine2-2:waitFor c.a&gt;100:&#39; + c.a);\r\n\t\treturn waitFor(function() {\r\n\t\t\treturn c.a&gt;100;\r\n\t\t}).yield;\r\n\r\n\t\t/* the rest of code */\r\n\t\tconsole.log(&#39;coroutine2-3:&#39; + this.a++);\r\n\t}\r\n\r\n\tthis.a = 10;\r\n\tconsole.log(&#39;outer-1:&#39; + this.a++);\r\n\tvar c1 = new coroutine1();\r\n\tvar c2 = new coroutine2(c1);\r\n\tconsole.log(&#39;outer-2:&#39; + this.a++);\r\n\r\nIt is tested in IE11 and Chrome49. Because it uses arguments.callee, so it may be trouble if it runs in strict mode.\r\n\r\n  [1]: http://docs.unity3d.com/ScriptReference/WaitForSeconds.html"},{"score":0,"body_markdown":"If you *really* want to pause a script, you can do this:\r\n\r\n    var milliseconds;\r\n    var pretime;\r\n    var stage;\r\n\r\n    function step(time){\r\n      switch(stage){\r\n        case 0:\r\n          //Code before the pause\r\n\r\n          pretime=time;\r\n          milliseconds=XXX;\r\n          stage=1;\r\n          break;\r\n        case 1:\r\n          //Code that is looped through while paused\r\n\r\n          if(time-pretime &gt;= milliseconds){\r\n            //Code after the pause\r\n\r\n            pretime=time;\r\n            milliseconds=XXX;\r\n            stage=2;\r\n          }\r\n          break;\r\n        case 2:\r\n          //Code that is looped through while paused\r\n\r\n          if(time-pretime &gt;= milliseconds){\r\n            //Code after the pause\r\n\r\n            pretime=time;\r\n            milliseconds=XXX;\r\n            stage=3;\r\n          }\r\n          break;\r\n        case 3:\r\n          //Etc...\r\n      }\r\n\r\n      Window.requestAnimationFrame(step)\r\n    }\r\n\r\n    step();\r\n\r\nThis is probably exactly what you want if you use a loop anyway, and you can change it in ways so that you have pseudo-multi-threading, where you have some functions waiting a while and others running normally. I use this all the time for pure-JS games."},{"score":-2,"body_markdown":"In Livescript (which compiles to Javascript), you can do like the following: \r\n\r\n    sleep = (ms, func) -&gt; set-timeout func, ms\r\n\r\n    console.log &quot;hello-1&quot;\r\n    &lt;- sleep 2000ms\r\n    console.log &quot;hello-2&quot;\r\n    &lt;- sleep 2000ms\r\n    console.log &quot;hello-3&quot;"},{"score":-4,"body_markdown":"This might work. It worked for me in c and javascript.\r\n\r\n    function sleep(time) {\r\n     var x = 0;\r\n     for(x = 0;x &lt; time;x++) {/* Do nothing*/}\r\n    }"},{"score":-2,"body_markdown":"Use three functions:\r\n\r\n1. A function which calls `setInterval` to start the loop\r\n2. A function which calls `clearInterval` to stop the loop, then calls `setTimeout` to sleep, and finally calls to within the `setTimeout` as the callback to restart the loop\r\n3. A loop which tracks the number of iterations, sets a sleep number and a maximum number, calls the sleep function once the sleep number has been reached, and calls `clearInterval` after the maximum number has been reached\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var foo = {};\r\n\r\n    function main()\r\n      {\r\n      &#39;use strict&#39;;\r\n      /*Initialize global state*/\r\n      foo.bar = foo.bar || 0;\r\n      /* Initialize timer */ \r\n      foo.bop = setInterval(foo.baz, 1000); \r\n      }\r\n     \r\n     sleep = \r\n          function(timer)\r\n          {\r\n          &#39;use strict&#39;;\r\n          clearInterval(timer);\r\n          timer = setTimeout(function(){main()}, 5000);\r\n          };\r\n           \r\n     \r\n     foo.baz = \r\n       function()\r\n          {\r\n          &#39;use strict&#39;;\r\n          /* Update state */\r\n          foo.bar = Number(foo.bar + 1) || 0; \r\n          /* Log state */\r\n          console.log(foo.bar);\r\n          /* Check state and stop at 10 */ \r\n          (foo.bar === 5) &amp;&amp; sleep(foo.bop);\r\n          (foo.bar === 10) &amp;&amp; clearInterval(foo.bop);\r\n          };\r\n          \r\n    main();\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n[![Event Loop][1]][1]\r\n\r\n**References**\r\n\r\n* [Game Development Using JavaScript](http://www.codeproject.com/Articles/563425/Game-Development-Using-JavaScript)\r\n\r\n* [Why the Scroll Event Change in iOS 8 is a Big Deal](http://developer.telerik.com/featured/scroll-event-change-ios-8-big-deal/)\r\n\r\n* [A live polling system in Ember.js](http://yoranbrondsema.com/live-polling-system-ember-js/)\r\n\r\n* [Driving Animation with requestAnimationFrame()](http://chimera.labs.oreilly.com/books/1234000000802/ch05.html)\r\n\r\n* [MDN: JavaScript Concurrency Model and the Event Loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)\r\n\r\n* [Grid Studies: Node.js](http://monome.org/docs/grid-studies/nodejs/)\r\n\r\n* [Beating 60fps in JavaScript](http://jsfiddle.net/chandlerprall/Wj5yM/)\r\n\r\n* [Part 2: CPU intensive javascript computations without blocking the single thread](https://benjaminhorn.io/code/part-2-cpu-intensive-javascript-computations-without-blocking-the-single-thread/)\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/l0lJB.png"},{"score":2,"body_markdown":"With `await` support and [bluebird promise](http://bluebirdjs.com/docs/getting-started.html):\r\n\r\n`await bluebird.delay(1000);`\r\n\r\nThis will work like a synchronous `sleep(1)` of c language. My favorite solution."},{"score":3010,"body_markdown":"## 2017 &amp;mdash; 2019 update\r\n\r\nSince 2009 when this question was asked, JavaScript has evolved significantly. All other answers are now obsolete or overly complicated. Here is the current best practice:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function sleep(ms) {\r\n      return new Promise(resolve =&gt; setTimeout(resolve, ms));\r\n    }\r\n\r\n    async function demo() {\r\n      console.log(&#39;Taking a break...&#39;);\r\n      await sleep(2000);\r\n      console.log(&#39;Two seconds later, showing sleep in a loop...&#39;);\r\n\r\n      // Sleep in loop\r\n      for (let i = 0; i &lt; 5; i++) {\r\n        if (i === 3)\r\n          await sleep(2000);\r\n        console.log(i);\r\n      }\r\n    }\r\n\r\n    demo();\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n### This is it. `await sleep(&lt;duration&gt;)`.\r\n\r\nOr as a one-liner:\r\n\r\n    await new Promise(r =&gt; setTimeout(r, 2000));\r\n\r\nNote that,\r\n\r\n1. `await` can only be executed in functions prefixed with the `async` keyword, or at the [top level](https://developers.google.com/web/updates/2017/08/devtools-release-notes#await) of your script in some environments (e.g. the Chrome DevTools console, or Runkit).\r\n2. `await` only pauses the current `async` function\r\n\r\nTwo new JavaScript features helped write this &quot;sleep&quot; function:\r\n\r\n- [Promises, a native feature of ES2015][2] (aka ES6). We also use [arrow functions][3] in the definition of the sleep function.\r\n- The [`async/await`][5] feature lets the code explicitly wait for a promise to settle (resolve or reject).\r\n\r\n## Compatibility\r\n\r\n- promises are supported [in Node v0.12+][6] and [widely supported in browsers][7], except IE\r\n- `async`/`await` landed in V8 and has been [enabled by default since Chrome 55][8] (released in Dec 2016)\r\n  - it landed [in Node 7 in October 2016][9]\r\n  - and also landed [in Firefox Nightly in November 2016][10]\r\n\r\nIf for some weird reason you&#39;re using Node older than 7 (which has reached [end of life](https://github.com/nodejs/Release)), or are targeting old browsers, `async`/`await` can still be used via [Babel][11] (a tool that will [transpile][12] JavaScript + new features into plain old JavaScript), with the [`transform-async-to-generator`](https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator) plugin.\r\n\r\n  [1]: https://runkit.com/dandv/57f770a7aed68d0014e7b660\r\n  [2]: https://ponyfoo.com/articles/es6-promises-in-depth\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\r\n  [5]: https://ponyfoo.com/articles/understanding-javascript-async-await\r\n  [6]: http://node.green/#Promise\r\n  [7]: http://caniuse.com/#feat=promises\r\n  [8]: https://developers.google.com/web/fundamentals/getting-started/primers/async-functions\r\n  [9]: https://blog.risingstack.com/async-await-node-js-7-nightly/\r\n  [10]: https://blog.nightly.mozilla.org/2016/11/01/async-await-support-in-firefox/\r\n  [11]: https://babeljs.io/\r\n  [12]: https://www.stevefenton.co.uk/2012/11/compiling-vs-transpiling/\r\n"},{"score":1,"body_markdown":"The problem with most solutions here is that they rewind the stack. This can be a big problem in some cases.In this example I show how to use iterators in different way to simulate ***real sleep***\r\n\r\nIn this example the generator is calling  it&#39;s own `next()` so once it&#39;s going, it&#39;s on his own.\r\n\r\n    var h=a();\r\n    h.next().value.r=h; //that&#39;s how U run it, best I came up with\r\n    \r\n    //sleep without breaking stack !!!\r\n    function *a(){\r\n    \tvar obj= {};\r\n    \t\r\n    \tconsole.log(&quot;going to sleep....2s&quot;)\r\n    \t\r\n    \tsetTimeout(function(){obj.r.next();},2000)\t\r\n    \t yield obj;\r\n    \t\r\n    \tconsole.log(&quot;woke up&quot;);\r\n    \tconsole.log(&quot;going to sleep no 2....2s&quot;)\r\n    \tsetTimeout(function(){obj.r.next();},2000)\t\r\n    \t yield obj;\r\n    \t \r\n    \t console.log(&quot;woke up&quot;);\r\n    \tconsole.log(&quot;going to sleep no 3....2s&quot;)\r\n    \t\r\n    \t setTimeout(function(){obj.r.next();},2000)\t\r\n    \t yield obj;\r\n    \r\n    \tconsole.log(&quot;done&quot;);\r\n    \t\r\n    }"},{"score":0,"body_markdown":"At server side, you can use the [deasync][1] `sleep()` method, which is natively implemented in *C* so it can effectively implement a *wait* effect without blocking the *event-loop* or putting your CPU at 100% of load.\r\n\r\nExample:\r\n\r\n    #!/usr/bin/env node\r\n\r\n    // Requires `npm install --save deasync`\r\n    var sleep = require(&quot;deasync&quot;).sleep;\r\n\r\n    sleep(5000);\r\n\r\n    console.log (&quot;Hello World!!&quot;);\r\n\r\n\r\nBut, if you need a *pure* javascript function (for example, to run it at client-side by a browser), I&#39;m sorry to say that I think your `pausecomp()` function is the only way to approach it and, more than that:\r\n\r\n  1. That pauses not only your function but the whole event loop. So no other events will be attended.\r\n\r\n  2. It puts your cpu at 100% load.\r\n\r\nSo, if you need it for a browser script and doesn&#39;t want those terrible effects, I must say you should rethink your function in a way:\r\n\r\n  a). You can recall it (or call a `do_the_rest()` function) at a timeout. The easier way if you are not expecting any result from your function.\r\n\r\n  b). Or, if you need to wait for a result, then you should move to using promises (or a callback hell, of course ;-)).\r\n\r\nNo result expected example:\r\n\r\n    function myFunc() {\r\n\r\n        console.log (&quot;Do some things&quot;);\r\n\r\n        setTimeout(function doTheRest(){\r\n            console.log (&quot;Do more things...&quot;);\r\n        }, 5000);\r\n\r\n        // Returns undefined.\r\n    };\r\n\r\n\r\n    myFunc();\r\n\r\n\r\nExample returning a promise (notice it alters your function usage):\r\n\r\n    function myFunc(someString) {\r\n\r\n        return new Promise(function(resolve, reject) {\r\n\r\n            var result = [someString];\r\n            result.push(&quot;Do some things&quot;);\r\n\r\n            setTimeout(function(){\r\n                result.push(&quot;Do more things...&quot;);\r\n                resolve(result.join(&quot;\\n&quot;));\r\n            }, 5000);\r\n\r\n        });\r\n\r\n    };\r\n\r\n\r\n    // But notice that this approach affect to the function usage...\r\n    // (It returns a promise, not actual data):\r\n    myFunc(&quot;Hello!!&quot;).then(function(data){\r\n        console.log(data);\r\n    }).catch(function(err){\r\n        console.error(err);\r\n    });\r\n\r\n\r\n\r\n\r\n  [1]: https://www.npmjs.com/package/deasync"},{"score":22,"body_markdown":"I personally like the simple:\r\n\r\n    function sleep(seconds){\r\n        var waitUntil = new Date().getTime() + seconds*1000;\r\n        while(new Date().getTime() &lt; waitUntil) true;\r\n    }\r\n\r\nthen:\r\n\r\n    sleep(2); // Sleeps for 2 seconds\r\n\r\nI&#39;m using it all the time to create fake load time while creating scripts in P5js"},{"score":2,"body_markdown":"This will do you the trick.\r\n\r\n\tvar reloadAfter = 10; //seconds\r\n\tvar intervalId = setTimeout(function() {\r\n        //code you want to execute after the time waiting\r\n\t}, reloadAfter * 1000); // 60000 = 60 sec = 1 min"},{"score":0,"body_markdown":"I have had this question for a long time and the answer I needed was not exactly what has been provided here. This wait function causes a synchronous wait that does not tie up the cpu. waitForIt makes an ajax request to anywhere and sets the async flag to false. waitF does the same with a frame and waitD does the same with a div. Ajax takes about 100 ms, frame is about 25, and div is about 1. The wait function leverages all of these depending on how much time you give it. If it didn&#39;t wait long enough then do it again. I need this when dealing with multiple asynchronous loading elements. Basically for &#39;wait until this element exists&#39;. You can play with it here https://jsfiddle.net/h2vm29ue/ It just leverages the things that the browser naturally waits for. Longer version https://jsfiddle.net/5cov1p0z/32/ is more precise.\r\n\r\n     function waitForIt() {\r\n         var start = new Date();\r\n         var xhttp = new XMLHttpRequest();\r\n         xhttp.onreadystatechange = function() {\r\n             if (this.readyState == 4 &amp;&amp; this.status == 200) {\r\n                //doesn&#39;t matter\r\n             }\r\n         };\r\n         xhttp.open(&quot;GET&quot;, &quot;WaitForIt&quot;, false);\r\n         xhttp.send();\r\n         var end = new Date();\r\n     }\r\n     //\r\n    \r\n    \r\n    \r\n     function waitF() {\r\n         var start = new Date();\r\n         var ifram = document.createElement(&#39;iframe&#39;);\r\n         ifram.id = &#39;ifram&#39;;\r\n         ifram.src = &#39;&#39;;\r\n         var div = document.createElement(&#39;div&#39;);\r\n         div.id = &#39;timer&#39;;\r\n         document.body.appendChild(div);\r\n         document.getElementById(&#39;timer&#39;).appendChild(ifram);\r\n         document.getElementById(&#39;timer&#39;).removeChild(ifram);\r\n         document.body.removeChild(div);\r\n         var end = new Date();\r\n         return (end - start);\r\n     }\r\n    \r\n    \r\n     function waitD() {\r\n         var start = new Date();\r\n         var div = document.createElement(&#39;div&#39;);\r\n         div.id = &#39;timer&#39;;\r\n         document.body.appendChild(div);\r\n         div.click();\r\n         document.body.removeChild(div);\r\n         var end = new Date();\r\n         return (end - start);\r\n     }\r\n    \r\n     function wait(time) {\r\n         var start = new Date();\r\n         var end = new Date();\r\n         while ((end - start &lt; time)) {\r\n    \r\n             if ((time - (end - start)) &gt;= 200) {\r\n                 waitForIt();\r\n             } else {\r\n                 if ((time - (end - start)) &gt;= 50) {\r\n                     waitF();\r\n                 } else {\r\n                     waitD();\r\n                 }\r\n    \r\n             }\r\n             end = new Date();\r\n         }\r\n         return (end - start);\r\n     }"},{"score":2,"body_markdown":"A function to sleep, using a synchronous call to let the OS do it.\r\nUse any OS sleep command you like. It is not busy waiting in the sense of using CPU time.\r\n\r\nI chose ping on a non-existant address.\r\n\r\n    const cp = require(&#39;child_process&#39;);\r\n\r\n    function sleep(ms)\r\n    { \r\n        try{cp.execSync(&#39;ping 192.0.2.0 -n 1 -w &#39;+ms);}\r\n        catch(err){}\r\n    }\r\n\r\nA test to verify it works\r\n\r\n    console.log(Date.now());\r\n    console.log(Date.now());\r\n    sleep(10000);\r\n    console.log(Date.now());\r\n    console.log(Date.now());\r\n\r\nAnd some test results.\r\n\r\n    1491575275136\r\n    1491575275157\r\n(and after 10 seconds)\r\n\r\n    1491575285075\r\n    1491575285076\r\n\r\n"},{"score":-6,"body_markdown":"It might me a little late and a little lazy and a little boring or a little intrusive or a little like &quot;back of, bigmouth&quot;, but...\r\n\r\nEach and any solution I&#39;ve read so far would be like &quot;let&#39;s get to sleep and look what happened, tomorrow&quot;.\r\n\r\nsetInterval(callback, time) would wait time long and then call the callback, WHILE blocking the runtime. The current implementation of &quot;setInterval&quot; is far from being thread-save, not even to mind concurrency.\r\n\r\nWhile the sparse solutions mentioned look like, guess what, C# (*laughs*), they still don&#39;t work like in C#/.NET. They still work like in C.\r\n\r\nJavaScript currently does NOT provide an architecture to accomplish real multi-threading. The best approach would be TypeScript, but still this lacks so much of a real solution that it... hurts. JavaScript, and jQuery, and AJAX, and jNode, and even TypeScript are just a bunch of Wannabes relying on the goods and bads of the moods of the implementors. Fact. Full stop.\r\n"},{"score":0,"body_markdown":"Javascript Functions allow no suspension. With synchronous Javascript procedures are implemented. Procedures await i/o operations and sleep timeouts. Available for javascript 1.7.\r\n\r\ndemos: \r\n[demo sleep][1]\r\n[demo suspendable procedures][2]\r\n\r\n\r\n  [1]: http://qns.ch/sync.demo1.html\r\n  [2]: http://qns.ch/sync.demo2.html"},{"score":1,"body_markdown":"To keep the main thread busy for some milliseconds:\r\n\r\n    function wait(ms) {\r\n      const start = performance.now();\r\n      while(performance.now() - start &lt; ms);\r\n    }"},{"score":-2,"body_markdown":"It is now also possible to use the native module util to promisify regular sync functions.\r\n\r\n    const { promisify } = require(&#39;util&#39;)\r\n    const sleep = promisify(setTimeout)\r\n\r\n    module.exports = () =&gt; {\r\n      await someAsyncFunction()\r\n      await sleep(2000)\r\n      console.log(&#39;2 seconds later...&#39;)\r\n    }"},{"score":5,"body_markdown":"*Since Node 7.6*, you can combine the  `promisify` function from the utils module with `setTimeout`. \r\n\r\n    const sleep = require(&#39;util&#39;).promisify(setTimeout)\r\n\r\n\r\n##General Usage\r\n    \r\n    async function main() {\r\n        console.time(&quot;Slept for&quot;)\r\n        await sleep(3000)\r\n        console.timeEnd(&quot;Slept for&quot;)\r\n    }\r\n    \r\n    main()\r\n\r\n\r\n##Question Usage\r\n\r\n    async function asyncGenerator() {\r\n        while (goOn) {\r\n          var fileList = await listFiles(nextPageToken);\r\n          await sleep(3000)\r\n          var parents = await requestParents(fileList);\r\n        }\r\n      }"},{"score":-1,"body_markdown":"\r\nI had a similar problem, having to wait for control existence and checking in intervals.\r\nSince there is no real sleep, wait or pause in JavaScript and using await / async is not supported properly in Internet Explorer, I made a solution using setTimeOut and injecting the function in case of successfully finding the element.\r\nHere is the complete sample code, so everyone can reproduce and use it for their own project:\r\n\r\n    &lt;html&gt;\r\n    &lt;head&gt;\r\n        &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n        &lt;script type=&quot;text/javascript&quot;&gt;\r\n            var ElementSearchStatus = {\r\n                None: 0,\r\n                Found: 1,\r\n                NotFound: 2,\r\n                Timeout: 3\r\n            };\r\n    \r\n            var maxTimeout = 5;\r\n            var timeoutMiliseconds = 1000;\r\n    \r\n            function waitForElement(elementId, count, timeout, onSuccessFunction) {\r\n                ++count;\r\n                var elementSearchStatus = existsElement(elementId, count, timeout);\r\n                if (elementSearchStatus == ElementSearchStatus.None) {\r\n                    window.setTimeout(waitForElement, timeoutMiliseconds, elementId, count, timeout, onSuccessFunction);\r\n                }\r\n                else {\r\n                    if (elementSearchStatus == ElementSearchStatus.Found) {\r\n                        onSuccessFunction();\r\n                    }\r\n                }\r\n            }\r\n    \r\n            function existsElement(elementId, count, timeout) {\r\n                var foundElements = $(&quot;#&quot; + elementId);\r\n                if (foundElements.length &gt; 0 || count &gt; timeout) {\r\n                    if (foundElements.length &gt; 0) {\r\n                        console.log(elementId + &quot; found&quot;);\r\n                        return ElementSearchStatus.Found;\r\n                    }\r\n                    else {\r\n                        console.log(&quot;Search for &quot; + elementId + &quot; timed out after &quot; + count + &quot; tries.&quot;);\r\n                        return ElementSearchStatus.Timeout;\r\n                    }\r\n                }\r\n                else {\r\n                    console.log(&quot;waiting for &quot; + elementId + &quot; after &quot; + count + &quot; of &quot; + timeout);\r\n                    return ElementSearchStatus.None;\r\n                }\r\n            }\r\n    \r\n            function main() {\r\n                waitForElement(&quot;StartButton&quot;, 0, maxTimeout, function () {\r\n                    console.log(&quot;found StartButton!&quot;);\r\n                    DoOtherStuff(&quot;StartButton2&quot;)\r\n                });\r\n            }\r\n    \r\n            function DoOtherStuff(elementId) {\r\n                waitForElement(elementId, 0, maxTimeout, function () {\r\n                    console.log(&quot;found &quot; + elementId);\r\n                    DoOtherStuff(&quot;StartButton3&quot;);\r\n                });\r\n            }\r\n        &lt;/script&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n        &lt;button type=&quot;button&quot; id=&quot;StartButton&quot; onclick=&quot;main();&quot;&gt;Start Test&lt;/button&gt;\r\n        &lt;button type=&quot;button&quot; id=&quot;StartButton2&quot; onclick=&quot;alert(&#39;Hey ya Start Button 2&#39;);&quot;&gt;Show alert&lt;/button&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;"},{"score":-1,"body_markdown":"A very simple way to do do sleep, that WILL be compatible with anything that runs Javascript... This code has been tested with something like 500 entries, CPU and memory usage still not visible on my web browsers.\r\n\r\nHere one function that wait until the node becomes visible... \r\n\r\nThis function creates a new context `function () {}` to avoid recursion.  We placed a code that does the same as the caller code inside this new context.  We use the function `Timeout` to call our function after a few time second.   \r\n\r\n    var get_hyper = function (node , maxcount , only_relation) {\r\n        if (node.offsetParent === null) {\r\n                // node is hidden\r\n                setTimeout(function () { get_hyper(node , maxcount , only_relation)}\r\n                          ,1000);\r\n                return;\r\n        };\r\n\r\n        // Enter here the code that wait that that the node is visible\r\n        // before getting executed.\r\n    \r\n    };"},{"score":1,"body_markdown":"I prefer this _functional style_ **one liner** `sleep` function:\r\n\r\n```js\r\nconst sleep = (ms) =&gt; new Promise((res) =&gt; setTimeout(res, ms, ms));\r\n\r\n// usage\r\nasync function main() {\r\n  console.log(&quot;before&quot;);\r\n  const t = await sleep(10_000); /* 10 sec */\r\n  console.log(&quot;after &quot; + t);\r\n}\r\nmain();\r\n```\r\n"},{"score":-1,"body_markdown":"I got Promise is not a constructor using the top answer. If you import bluebird you can do this. Simplest solution imo.\r\n\r\n    import * as Promise from &#39;bluebird&#39;;\r\n\r\n\r\n      await Promise.delay(5000)\r\n"},{"score":0,"body_markdown":"The problem with using an actual sleep function is that JavaScript is single-threaded and a sleep function will pretty much make your browser tab hang for that duration."},{"score":13,"body_markdown":"**2019 Update using [Atomics.wait][1]**\r\n\r\nShould work in Node 9.3 or higher.\r\n\r\nI needed a pretty accurate timer in Node.js and it works great for that.\r\nHowever it seems like there is extremely limited support in browsers.\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let ms = 10000;\r\n    Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, ms);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nRan a few 10 second timer benchmarks.\r\n\r\nWith setTimeout I get a error of up to 7000 microseconds. (7ms)\r\n\r\nWith Atomics my error seems to stay under 600 microseconds. (0.6ms)\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait\r\n\r\n**2020 Update: In Summary**\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function sleep(millis){ // need help of a server-side page\r\n      let netMillis=Math.max(millis-5,0); //assuming 5ms overhead\r\n      let xhr=new XMLHttpRequest();\r\n      xhr.open(&#39;GET&#39;,&#39;/sleep.jsp?millis=&#39;+netMillis+&#39;&amp;rand=&#39;+Math.random(), false);\r\n      try{\r\n        xhr.send();\r\n      }catch(e){\r\n      }\r\n    }\r\n    function sleepAsync(millis){ // use only in async function\r\n      let netMillis=Math.max(millis-1,0); // assuming 1ms overhead\r\n      return new Promise((resolve)=&gt;{\r\n        setTimeout(resolve, netMillis);\r\n      });\r\n    }\r\n    function sleepSync(millis){ // use only in worker thread, currently Chrome-only\r\n      Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, millis);\r\n    }\r\n    \r\n    function sleepTest(){\r\n      console.time(&#39;sleep&#39;);\r\n      sleep(1000);\r\n      console.timeEnd(&#39;sleep&#39;);\r\n    }\r\n    async function sleepAsyncTest(){\r\n      console.time(&#39;sleepAsync&#39;);\r\n      await sleepAsync(1000);\r\n      console.timeEnd(&#39;sleepAsync&#39;);\r\n    }\r\n    function sleepSyncTest(){ \r\n      let source=`${sleepSync.toString()}\r\n        console.time(&#39;sleepSync&#39;);\r\n        sleepSync(1000);\r\n        console.timeEnd(&#39;sleepSync&#39;);`;\r\n      let src=&#39;data:text/javascript,&#39;+encodeURIComponent(source);\r\n      console.log(src);\r\n      var worker=new Worker(src);\r\n    }\r\n\r\nof which the a server-side page, e.g. `sleep.jsp`, looks like\r\n\r\n&lt;!-- language: lang-jsp --&gt;\r\n\r\n    &lt;%\r\n    try{\r\n      Thread.sleep(Long.parseLong(request.getParameter(&quot;millis&quot;)));\r\n    }catch(InterruptedException e){}\r\n    %&gt;\r\n"},{"score":25,"body_markdown":"   \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n      await new Promise(resolve =&gt; setTimeout(resolve, 2000));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nmake sure your calling function is async \r\n\r\nverified and working fine"},{"score":7,"body_markdown":"The shortest solution without any dependencies:\r\n\r\n    await new Promise(resolve =&gt; setTimeout(resolve, 5000));"},{"score":1,"body_markdown":"If you really want to block the main thread altogether and keep the event loop from pulling from the event queue, here&#39;s a nice way to do that without creating any functions, new Date objects or leaking any variables. I know there&#39;s a million answers to this silly question already but I didn&#39;t see anyone using this exact solution. This is modern browser only.\r\n\r\nWARNING: This is not something you would ever put into production, it is just helpful for understanding the browser event loop. It is probably not even useful for any testing. It is not like a normal system sleep function because the javascript runtime is still doing work every cycle. \r\n\r\n```js\r\nfor (let e = performance.now() + 2000; performance.now() &lt; e; ) {}\r\n```\r\n\r\nUsed here, the setTimeout callback won&#39;t be called until at least 2 seconds later even though it enters the event queue almost instantly:\r\n```js\r\nsetTimeout(function() {\r\n  console.log(&quot;timeout finished&quot;);\r\n}, 0);\r\n\r\nfor (let e = performance.now() + 2000; performance.now() &lt; e; ) {}\r\nconsole.log(&quot;haha wait for me first&quot;);\r\n```\r\n\r\nYou will experience a ~2 second pause then see\r\n```\r\nhaha wait for me first\r\ntimeout finished\r\n```\r\n\r\nThe benefit of using performance.now() over Date.now() is that that the Date object is\r\n\r\n&gt; subject to both clock skew and adjustment of the system clock. The\r\n&gt; value of time may not always be monotonically increasing and\r\n&gt; subsequent values may either decrease or remain the same.\r\n[*]\r\n\r\nIn general performance.now() is more suited to measuring differences in time at high accuracy.\r\n\r\nUsing a `for` loop has the benefit of letting you set variables local to the block before running. This allows you to do the addition math outside the loop while still being a &#39;one-liner&#39;. This should hopefully minimize the CPU load of this hot cycle burn.\r\n\r\n  [*]: https://www.w3.org/TR/hr-time-2/#introduction"},{"score":1,"body_markdown":"Using Typescript?\r\n\r\nHere&#39;s a quick `sleep()` implementation that can be awaited.  This is as similar as possible to the top answer.  It&#39;s functionally equivalent except `ms` is typed as `number` for typescript.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: typescript --&gt;\r\n\r\n    const sleep = (ms: number) =&gt;\r\n      new Promise((resolve) =&gt; setTimeout(resolve, ms));\r\n\r\n    async function demo() {\r\n      console.log(&#39;Taking a break for 2s (2000ms)...&#39;);\r\n      await sleep(2000);\r\n      console.log(&#39;Two seconds later&#39;);\r\n    }\r\n\r\n    demo();\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n### This is it. `await sleep(&lt;duration&gt;)`.\r\n\r\nNote that,\r\n\r\n1. `await` can only be executed in functions prefixed with the `async` keyword, or at the [top level](https://developers.google.com/web/updates/2017/08/devtools-release-notes#await) of your script in some environments (e.g. the Chrome DevTools console, or Runkit).\r\n2. `await` only pauses the current `async` function\r\n"},{"score":4,"body_markdown":"\r\nCould do something like this. A sleep method that all functions can inherit:\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    Function.prototype.sleep = function(delay, ...args) {\r\n        setTimeout(() =&gt; this(...args), delay)\r\n    }\r\n\r\n    console.log.sleep(2000, &#39;Hello world!&#39;)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"\r\nIn sleep method you can return any then-able object. and not necessarily a new promise.\r\n\r\n\r\nexample : \r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const sleep = (t) =&gt;  ({ then: (r) =&gt; setTimeout(r, t) })\r\n\r\n    const someMethod = async () =&gt; {\r\n\r\n        console.log(&quot;hi&quot;);\r\n        await sleep(5000)\r\n        console.log(&quot;bye&quot;);\r\n    }\r\n\r\n    someMethod()\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n\r\n"},{"score":0,"body_markdown":"I think the question is great and points out important perspectives and considerations.\r\n\r\nWith that said, I think the core of the question is in the intention and understanding what developer (you) wants to have controlled.\r\n\r\nFirst, the name `sleep` is an overloaded naming choice. I.e., &quot;what&quot; is going to be &quot;slept&quot;; and &quot;what&quot; as a developer am I in control of?\r\n\r\n&gt; In any language-engine, running on any OS process, on any bare-metal-or-hosted system the &quot;developer&quot; is NOT in control _(owner)_ of the OS-shared-resource CPU core(s) [and/or threads] unless they are the writing the OS/Process system itself. _CPUs are a time-shared resource, and the currency of work-execution progress are the &quot;cycles&quot; allocated amongst all work to be performed on the system._\r\n\r\nAs an app/service developer, it is best to consider that I am in control of a workflow-activity-stream managed by a os-process/language-engine. On some systems that means I control a native-os-thread _(which likely shares CPU cores)_, on others it means I control an **async-continuation-workflow chain/tree**.\r\n\r\n**In the case of JavaScript, it is the &quot;latter&quot;.**\r\n\r\nSo when &quot;sleep&quot; is desired, I am intending to cause my workflow to be &quot;delayed&quot; from execution for some period of time, before it proceeds to execute the next &quot;step&quot; (phase/activity/task) in its workflow.\r\n\r\nThis is &quot;appropriately&quot; saying that as a developer it is easiest to _(think in terms of)_ model work as a linear-code flow; resorting to compositions of workflows to scale as needed.\r\n&gt;Today, in JavaScript, we have the option to design such linear work flows using efficient multi-tasking 1980s actor based continuation architectures _**(relabeled as modern Futures/Promises/then/await etc)**_.\r\n\r\nWith that in mind, my answer is **not** contributing a **new** technical solution, but rather focusing on the **intent** and the **design** _perspective_ within the question itself.\r\n\r\nI suggest that any answer begins with thinking about the above concepts and then choosing a NAME (other than `sleep`) that reminds and suggests what the intention is.\r\n\r\n&gt;Workflow\r\n&gt;- Choice 1: `delayWorkForMs(nMsToDelay)`\r\n&gt;- Choice 2: `delayAsyncSequenceForMs(msPeriod)`\r\n\r\n```JavaScript\r\nasync delayAsyncSequenceForMs(msPeriod) {\r\n  await new Promise(resolve =&gt; setTimeout(resolve, msPeriod));\r\n}\r\n```\r\n\r\n&gt;Keep in mind that any `async` _function_ *always* returns a `Promise`, and `await` may only be used within an `async` _function_.&lt;br&gt;\r\n&gt;_(lol, you might ask yourself why...)_.&lt;br&gt;\r\n&gt;- Consideration 1: **do-not** use &quot;loops&quot; to BURN UP cpu-cycles.&lt;br&gt;\r\n&gt;- Consideration 2: In the JavaScript model, when inside a non-async function you cannot &quot;delay&quot; (wait for) an &quot;async&quot; workflow&#39;s execution _(unless you are doing bad things needlessly burning cpu cycles)_. You can only &quot;delay&quot; code-steps within an &quot;async&quot; function.&lt;br&gt;\r\n&gt;Internally, an &quot;async&quot; function is modelled as a collection of entry-point/continuations at each `await` _keyword_. If you are familiar with the backtick interpolation model, you can &quot;think of await&quot; as being conceptually modelled similarly to writing a backquote string like:\r\n```JavaScript\r\n  // Conceptualizing, using an interpolation example to illustrate\r\n  // how to think about &quot;await&quot; and &quot;async&quot; functions\r\n  `code${await then-restart-point}more-code${await then-restart-point}`\r\n```"},{"score":0,"body_markdown":"### ONE-LINER using **Promises**\r\n```js\r\nconst sleep = t =&gt; new Promise(s =&gt; setTimeout(s, t));\r\n```\r\n**DEMO**\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const sleep = t =&gt; new Promise(s =&gt; setTimeout(s, t));\r\n    // usage\r\n    async function demo() {\r\n        // count down\r\n        let i = 6;\r\n        while (i--) {\r\n            await sleep(1000);\r\n            console.log(i);\r\n        }\r\n        // sum of numbers 0 to 5 using by delay of 1 second\r\n        const sum = await [...Array(6).keys()].reduce(async (a, b) =&gt; {\r\n            a = await a;\r\n            await sleep(1000);\r\n            const result = a + b;\r\n            console.log(`${a} + ${b} = ${result}`);\r\n            return result;\r\n        }, Promise.resolve(0));\r\n        console.log(&quot;sum&quot;, sum);\r\n    }\r\n    demo();\r\n\r\n&lt;!-- end snippet --&gt;"}],"score":2551}