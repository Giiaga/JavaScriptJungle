{"body":"I am looking for a JavaScript array insert method, in the style of:\r\n\r\n    arr.insert(index, item)\r\n\r\nPreferably in jQuery, but any JavaScript implementation will do at this point.","title":"How to insert an item into an array at a specific index (JavaScript)?","answers":[{"score":5129,"body_markdown":"What you want is the **[`splice`][1]** function on the native array object.\r\n\r\n`arr.splice(index, 0, item);` will insert `item` into `arr` at the specified index (deleting `0` items first, that is, it&#39;s just an insert).\r\n\r\nIn this example we will create an array and add an element to it into index 2:\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var arr = [];\r\n    arr[0] = &quot;Jani&quot;;\r\n    arr[1] = &quot;Hege&quot;;\r\n    arr[2] = &quot;Stale&quot;;\r\n    arr[3] = &quot;Kai Jim&quot;;\r\n    arr[4] = &quot;Borge&quot;;\r\n\r\n    console.log(arr.join());\r\n    arr.splice(2, 0, &quot;Lene&quot;);\r\n    console.log(arr.join());\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice"},{"score":42,"body_markdown":"If you want to insert multiple elements into an array at once check out this Stack Overflow answer: https://stackoverflow.com/questions/1348178/a-better-way-to-splice-an-arrray-into-an-array-in-javascript\r\n\r\nAlso here are some functions to illustrate both examples:\r\n\r\n    function insertAt(array, index) {\r\n        var arrayToInsert = Array.prototype.splice.apply(arguments, [2]);\r\n        return insertArrayAt(array, index, arrayToInsert);\r\n    }\r\n    \r\n    function insertArrayAt(array, index, arrayToInsert) {\r\n        Array.prototype.splice.apply(array, [index, 0].concat(arrayToInsert));\r\n        return array;\r\n    }\r\n\r\nFinally here is a jsFiddle so you can see it for youself: http://jsfiddle.net/luisperezphd/Wc8aS/\r\n\r\nAnd this is how you use the functions:\r\n\r\n    // if you want to insert specific values whether constants or variables:\r\n    insertAt(arr, 1, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;);\r\n\r\n    // OR if you have an array:\r\n    var arrToInsert = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;];\r\n    insertArrayAt(arr, 1, arrToInsert);"},{"score":301,"body_markdown":"You can implement the `Array.insert` method by doing this:\r\n\r\n    Array.prototype.insert = function ( index, item ) {\r\n        this.splice( index, 0, item );\r\n    };\r\n\r\nThen you can use it like:\r\n\r\n    var arr = [ &#39;A&#39;, &#39;B&#39;, &#39;D&#39;, &#39;E&#39; ];\r\n    arr.insert(2, &#39;C&#39;);\r\n    \r\n    // =&gt; arr == [ &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39; ]"},{"score":77,"body_markdown":"# Custom array `insert` methods\r\n### *1. With multiple arguments and chaining support*\r\n\r\n    /* Syntax:\r\n       array.insert(index, value1, value2, ..., valueN) */\r\n    \r\n    Array.prototype.insert = function(index) {\r\n        this.splice.apply(this, [index, 0].concat(\r\n            Array.prototype.slice.call(arguments, 1)));\r\n        return this;\r\n    };\r\n\r\nIt can insert multiple elements (as native [`splice`][1] does) and supports chaining:\r\n\r\n    [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;].insert(2, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;).slice(1, 6);\r\n    // [&quot;b&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;c&quot;]\r\n\r\n---\r\n### *2. With array-type arguments merging and chaining support*\r\n\r\n    /* Syntax:\r\n       array.insert(index, value1, value2, ..., valueN) */\r\n    \r\n    Array.prototype.insert = function(index) {\r\n        index = Math.min(index, this.length);\r\n        arguments.length &gt; 1\r\n            &amp;&amp; this.splice.apply(this, [index, 0].concat([].pop.call(arguments)))\r\n            &amp;&amp; this.insert.apply(this, arguments);\r\n        return this;\r\n    };\r\n\r\nIt can merge arrays from the arguments with the given array and also supports chaining:\r\n\r\n    [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;].insert(2, &quot;V&quot;, [&quot;W&quot;, &quot;X&quot;, &quot;Y&quot;], &quot;Z&quot;).join(&quot;-&quot;);\r\n    // &quot;a-b-V-W-X-Y-Z-c-d&quot;\r\n\r\n**DEMO:** http://jsfiddle.net/UPphH/\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/splice"},{"score":4,"body_markdown":"Even though this has been answered already, I&#39;m adding this note for an alternative approach.\r\n\r\nI wanted to place a **known number** of items into an array, into specific positions, as they come off of an &quot;associative array&quot; (i.e. an object) which by definition is not guaranteed to be in a sorted order. I wanted the resulting array to be an array of objects, but the objects to be in a specific order in the array since an array guarantees their order. So I did this.\r\n\r\nFirst the source object, a JSONB string retrieved from PostgreSQL. I wanted to have it sorted by the &quot;order&quot; property in each child object.\r\n\r\n    var jsonb_str = &#39;{&quot;one&quot;: {&quot;abbr&quot;: &quot;&quot;, &quot;order&quot;: 3}, &quot;two&quot;: {&quot;abbr&quot;: &quot;&quot;, &quot;order&quot;: 4}, &quot;three&quot;: {&quot;abbr&quot;: &quot;&quot;, &quot;order&quot;: 5}, &quot;initialize&quot;: {&quot;abbr&quot;: &quot;init&quot;, &quot;order&quot;: 1}, &quot;start&quot;: {&quot;abbr&quot;: &quot;&quot;, &quot;order&quot;: 2}}&#39;;\r\n\r\n    var jsonb_obj = JSON.parse(jsonb_str);\r\n\r\nSince the number of nodes in the object is known, I first create an array with the specified length:\r\n\r\n    var obj_length = Object.keys(jsonb_obj).length;\r\n    var sorted_array = new Array(obj_length);\r\n\r\nAnd then iterate the object, placing the newly created temporary objects into the desired locations in the array without really any &quot;sorting&quot; taking place.\r\n\r\n    for (var key of Object.keys(jsonb_obj)) {\r\n      var tobj = {};\r\n      tobj[key] = jsonb_obj[key].abbr;\r\n\r\n      var position = jsonb_obj[key].order - 1;\r\n      sorted_array[position] = tobj;\r\n    }\r\n\r\n    console.dir(sorted_array);\r\n"},{"score":22,"body_markdown":"For proper functional programming and chaining purposes an invention of `Array.prototype.insert()` is essential. Actually splice could have been perfect if it had returned the mutated array instead of a totally meaningless empty array. So here it goes\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    Array.prototype.insert = function(i,...rest){\r\n      this.splice(i,0,...rest)\r\n      return this\r\n    }\r\n\r\n    var a = [3,4,8,9];\r\n    document.write(&quot;&lt;pre&gt;&quot; + JSON.stringify(a.insert(2,5,6,7)) + &quot;&lt;/pre&gt;&quot;);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nWell ok the above with the `Array.prototype.splice()` one mutates the original array and some might complain like &quot;you shouldn&#39;t modify what doesn&#39;t belong to you&quot; and that might turn out to be right as well. So for the public welfare i would like to give another `Array.prototype.insert()` which doesn&#39;t mutate the original array. Here it goes;\r\n\r\n&lt;!-- begin snippet: js hide: false console: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    Array.prototype.insert = function(i,...rest){\r\n      return this.slice(0,i).concat(rest,this.slice(i));\r\n    }\r\n\r\n    var a = [3,4,8,9],\r\n        b = a.insert(2,5,6,7);\r\n    console.log(JSON.stringify(a));\r\n    console.log(JSON.stringify(b));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":160,"body_markdown":"Other than splice, you can use this approach which will not mutate the original array, but will create a new array with the added item. You should usually avoid mutation whenever possible. I&#39;m using ES6 spread operator here.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const items = [1, 2, 3, 4, 5]\r\n\r\n    const insert = (arr, index, newItem) =&gt; [\r\n      // part of the array before the specified index\r\n      ...arr.slice(0, index),\r\n      // inserted item\r\n      newItem,\r\n      // part of the array after the specified index\r\n      ...arr.slice(index)\r\n    ]\r\n\r\n    const result = insert(items, 1, 10)\r\n\r\n    console.log(result)\r\n    // [1, 10, 2, 3, 4, 5]\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThis can be used to add more than one item by tweaking the function a bit to use the rest operator for the new items, and spread that in the returned result as well\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const items = [1, 2, 3, 4, 5]\r\n\r\n    const insert = (arr, index, ...newItems) =&gt; [\r\n      // part of the array before the specified index\r\n      ...arr.slice(0, index),\r\n      // inserted items\r\n      ...newItems,\r\n      // part of the array after the specified index\r\n      ...arr.slice(index)\r\n    ]\r\n\r\n    const result = insert(items, 1, 10, 20)\r\n\r\n    console.log(result)\r\n    // [1, 10, 20, 2, 3, 4, 5]\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":2,"body_markdown":"I tried this and it is working fine!\r\n    \r\n    var initialArr = [&quot;India&quot;,&quot;China&quot;,&quot;Japan&quot;,&quot;USA&quot;];\r\n    initialArr.splice(index, 0, item);\r\n\r\nIndex is the position where you want to insert or delete the element.\r\n0 i.e. the second parameters defines the number of element from the index to be removed\r\nitem are the new entries which you want to make in array. It can be one or more than one.\r\n    \r\n    initialArr.splice(2, 0, &quot;Nigeria&quot;);\r\n    initialArr.splice(2, 0, &quot;Australia&quot;,&quot;UK&quot;);\r\n"},{"score":7,"body_markdown":"Another possible solution, with usage of `Array#reduce`.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const arr = [&quot;apple&quot;, &quot;orange&quot;, &quot;raspberry&quot;];\r\n    const arr2 = [1, 2, 4];\r\n\r\n    const insert = (arr, item, index) =&gt;\r\n      arr.reduce(function(s, a, i) {\r\n        i === index ? s.push(item, a) : s.push(a);\r\n        return s;\r\n      }, []); \r\n\r\n    console.log(insert(arr, &quot;banana&quot;, 1));\r\n    console.log(insert(arr2, 3, 2))\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":19,"body_markdown":"I recommend using pure **JavaScript** in this case, also there is no insert method in JavaScript, but we have a method which is a  **built-in Array** method which does the job for you, it&#39;s called **splice**...\r\n\r\nLet&#39;s see what&#39;s **splice()**...\r\n\r\n&gt; The splice() method changes the contents of an array by removing\r\n&gt; existing elements and/or adding new elements.\r\n\r\nOK, imagine we have this array below:\r\n\r\n    const arr = [1, 2, 3, 4, 5];\r\n\r\nWe can remove `3` like this:\r\n\r\n    arr.splice(arr.indexOf(3), 1);\r\n\r\nIt will return 3, but if we check the arr now, we have:\r\n\r\n    [1, 2, 4, 5]\r\n\r\nSo far, so good, but how we can add a new element to array using splice?\r\nLet&#39;s put back 3 in the arr...\r\n\r\n    arr.splice(2, 0, 3);\r\n\r\nLet&#39;s see what we have done...\r\n\r\nWe use **splice** again, but this time for the second argument, we pass **0**, means we want to delete no item, but at the same time, we add third argument which is 3 that will be added at second index...\r\n\r\nYou should be aware, that we can **delete** and **add** at the same time, for example now we can do:\r\n\r\n    arr.splice(2, 2, 3);\r\n\r\nWhich will delete **2 items** at index 2, then add **3** at index 2 and result will be:\r\n\r\n    [1, 2, 3, 5];\r\n\r\nThis is showing how each item in splice work:\r\n\r\n&gt; array.splice(start, deleteCount, item1, item2, item3 ...)\r\n\r\n"},{"score":15,"body_markdown":"**Append Single Element at a specific index**\r\n\r\n    //Append at specific position(here at index 1)\r\n    arrName.splice(1, 0,&#39;newName1&#39;);\r\n    //1: index number, 0: number of element to remove, newName1: new element\r\n    \r\n    \r\n    //Append at specific position (here at index 3)\r\n    arrName[3] = &#39;newName1&#39;;\r\n\r\n**Append Multiple Element at a specific index**\r\n\r\n    //Append from index number 1\r\n    arrName.splice(1, 0,&#39;newElemenet1&#39;, &#39;newElemenet2&#39;, &#39;newElemenet3&#39;);\r\n    //1: index number from where append start, \r\n    //0: number of element to remove, \r\n    //newElemenet1,2,3: new elements"},{"score":3,"body_markdown":"Anyone who&#39;s still having issues with this one and have tried all the options above and never got it. I&#39;m sharing my solution, this is to take consideration that you don&#39;t wan&#39;t to explicitly state the properties of your object vs the array.\r\n\r\n    function isIdentical(left, right){\r\n\t\treturn JSON.stringify(left) === JSON.stringify(right);\r\n\t}\r\n\r\n\tfunction contains(array, obj){\r\n\t\tlet count = 0;\r\n\t\tarray.map((cur) =&gt; {\r\n\t\t\t  if(this.isIdentical(cur, obj)) count++;\r\n\t\t});\r\n\t\treturn count &gt; 0;\r\n\t}\r\n\r\nThis is a combination of iterating the reference array and comparing it to the object you wanted to check, convert both of them into a string then iterated if it matched. Then you can just count. This can be improved but this is where I settled. Hope this helps."},{"score":3,"body_markdown":"Taking profit of reduce method as following:\r\n\r\n    function insert(arr, val, index) {\r\n        return index &gt;= arr.length \r\n            ? arr.concat(val)\r\n            : arr.reduce((prev, x, i) =&gt; prev.concat(i === index ? [val, x] : x), []);\r\n    }\r\n\r\nSo at this way we can return a new array (will be a cool functional way - more much better than use push or splice) with the element inserted at index, and if the index is greater than the length of the array it will be inserted at the end.\r\n"},{"score":1,"body_markdown":"Here&#39;s a working function that I uses in one of my application. \r\n\r\nThis checks if item exit\r\n\r\n    let ifExist = (item, strings = [ &#39;&#39; ], position = 0) =&gt; {\r\n         // output into an array with empty string. Important just in case their is no item. \r\n    \tlet output = [ &#39;&#39; ];\r\n        // check to see if the item that will be positioned exist.\r\n    \tif (item) {\r\n            // output should equal to array of strings. \r\n    \t\toutput = strings;\r\n           // use splice in order to break the array. \r\n           // use positition param to state where to put the item\r\n           // and 0 is to not replace an index. Item is the actual item we are placing at the prescribed position. \r\n    \t\toutput.splice(position, 0, item);\r\n    \t}\r\n        //empty string is so we do not concatenate with comma or anything else. \r\n    \treturn output.join(&quot;&quot;);\r\n    };\r\n\r\n\r\nAnd then I call it below. \r\n\r\n\r\n    ifExist(&quot;friends&quot;, [ &#39; ( &#39;, &#39; )&#39; ], 1)}  // output: ( friends )\r\n    ifExist(&quot;friends&quot;, [ &#39; - &#39;], 1)}  // output:  - friends \r\n    ifExist(&quot;friends&quot;, [ &#39;:&#39;], 0)}  // output:   friends: \r\n\r\n"},{"score":1,"body_markdown":"A bit of an older thread, but I have to agree with Redu above because splice definitely has a bit of a confusing interface. And the response given by cdbajorin that &quot;it only returns an empty array when the second parameter is 0. If it&#39;s greater than 0, it returns the items removed from the array&quot; is, while accurate, proving the point. The function&#39;s intent is to splice or as said earlier by Jakob Keller, &quot;to join or connect, also to change. You have an established array that you are now changing which would involve adding or removing elements....&quot; Given that, the return value of the elements, if any, that were removed is awkward at best. And I 100% agree that this method could have been better suited to chaining if it had returned what seems natural, a new array with the spliced elements added. Then you could do things like [&quot;19&quot;, &quot;17&quot;].splice(1,0,&quot;18&quot;).join(&quot;...&quot;) or whatever you like with the returned array. The fact that it returns what was removed is just kinda nonsense IMHO. If the intention of the method was to &quot;cut out a set of elements&quot; and that was it&#39;s only intent, maybe. It seems like if I don&#39;t know what I&#39;m cutting out already though, I probably have little reason to cut those elements out, doesn&#39;t it? It would be better if it behaved like concat, map, reduce, slice, etc where a new array is made from the existing array rather than mutating the existing array. Those are all chainable, and that IS a significant issue. It&#39;s rather common to chain array manipulation. Seems like the language needs to go one or the other direction and try to stick to it as much as possible. Javascript being functional and less declarative, it just seems like a strange deviation from the norm."},{"score":8,"body_markdown":"**Here are two ways :** \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const array = [ &#39;My&#39;, &#39;name&#39;, &#39;Hamza&#39; ];\r\n\r\n    array.splice(2, 0, &#39;is&#39;);\r\n\r\n    console.log(&quot;Method 1 : &quot;, array.join(&quot; &quot;));\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**OR**\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    Array.prototype.insert = function ( index, item ) {\r\n        this.splice( index, 0, item );\r\n    };\r\n\r\n    const array = [ &#39;My&#39;, &#39;name&#39;, &#39;Hamza&#39; ];\r\n    array.insert(2, &#39;is&#39;);\r\n\r\n    console.log(&quot;Method 2 : &quot;, array.join(&quot; &quot;));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n   \r\n"},{"score":5,"body_markdown":"[`Array#splice()`][1] is the way to go, unless you really want to avoid mutating the array. Given 2 arrays `arr1` and `arr2`, here&#39;s how you would insert the contents of `arr2` into `arr1` after the first element:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const arr1 = [&#39;a&#39;, &#39;d&#39;, &#39;e&#39;];\r\n    const arr2 = [&#39;b&#39;, &#39;c&#39;];\r\n\r\n    arr1.splice(1, 0, ...arr2); // arr1 now contains [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]\r\n\r\n    console.log(arr1)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf you are concerned about mutating the array (for example, if using Immutable.js), you can instead use [`slice()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice), not to be confused with `splice()` with a `&#39;p&#39;`.\r\n\r\n    const arr3 = [...arr1.slice(0, 1), ...arr2, ...arr1.slice(1)];\r\n\r\n\r\n  [1]: https://masteringjs.io/tutorials/fundamentals/array-splice"},{"score":2,"body_markdown":"# Solutions &amp; Performance\r\n\r\nToday (2020.04.24) I perform tests for chosen solutions for big and small arrays . I tested them on MacOs High Sierra 10.13.6 on Chrome 81.0, Safari 13.1, Firefox 75.0. \r\n\r\nConclusions\r\n-\r\nFor all browsers\r\n\r\n * surprisingly for small arrays non-in-place solutions based on `slice` and `reduce` (D,E,F) are usually 10x-100x faster than in-place solutions\r\n * for big arrays the in-place-solutions based on `splice` (AI,BI,CI) was fastest (sometimes ~100x - but it depends of array size)\r\n * for small arrays BI solution was slowest\r\n * for big arrays E solution was slowest\r\n\r\n[![enter image description here][1]][1]\r\n\r\nDetails\r\n-\r\n\r\nTests was divided into two groups: in-place solutions (AI,BI,CI) and non-in-place solutions (D,E,F) and was perform for two cases\r\n\r\n* test for array with 10 elements - you can run it [HERE](https://jsbench.me/bhk9e06ktc/1)\r\n* test for array with 1.000.000 elements - you can run it [HERE](https://jsbench.me/20k9e0au9q/1)\r\n\r\nTested code is presented in below snippet \r\n\r\n[jsfiddle](https://jsfiddle.net/Lamik/b14wkntp/)\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function AI(arr, i, el) {\r\n      arr.splice(i, 0, el);\r\n      return arr;\r\n    }\r\n\r\n    function BI(arr, i, el) {\r\n      Array.prototype.splice.apply(arr, [i, 0, el]);\r\n      return arr;\r\n    }\r\n\r\n    function CI(arr, i, el) {\r\n      Array.prototype.splice.call(arr, i, 0, el);\r\n      return arr;\r\n    }\r\n\r\n    function D(arr, i, el) {\r\n      return arr.slice(0, i).concat(el, arr.slice(i));\r\n    }\r\n\r\n    function E(arr, i, el) {\r\n      return [...arr.slice(0, i), el, ...arr.slice(i)]\r\n    }\r\n\r\n    function F(arr, i, el) {\r\n      return arr.reduce((s, a, j)=&gt; (j-i ? s.push(a) : s.push(el, a), s), []);\r\n    }\r\n\r\n\r\n\r\n    // -------------\r\n    // TEST\r\n    // -------------\r\n\r\n    let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];\r\n\r\n    let log = (n, f) =&gt; {\r\n      let a = f([...arr], 3, &quot;NEW&quot;);\r\n      console.log(`${n}: [${a}]`);\r\n    };\r\n\r\n    log(&#39;AI&#39;, AI);\r\n    log(&#39;BI&#39;, BI);\r\n    log(&#39;CI&#39;, CI);\r\n    log(&#39;D&#39;, D);\r\n    log(&#39;E&#39;, E);\r\n    log(&#39;F&#39;, F);\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    This snippet only presents tested code (it not perform tests)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nExample results for small array on chrome are below\r\n\r\n[![enter image description here][2]][2]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/gZjhH.png\r\n  [2]: https://i.stack.imgur.com/cS1YZ.png"},{"score":2,"body_markdown":"### Immutable insertion\r\n\r\nUsing [`splice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) method is surely the best answer if you need to insert into an array in-place.\r\n\r\nHowever, if you are looking for an immutable function that returns a new updated array instead of mutating the original array on insert, you can use the following function.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function insert(array, index) {\r\n      const items = Array.prototype.slice.call(arguments, 2);\r\n\r\n      return [].concat(array.slice(0, index), items, array.slice(index));\r\n    }\r\n\r\n    const list = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;];\r\n\r\n    const list1 = insert(list, 0, &#39;zero&#39;); // Insert single item\r\n    const list2 = insert(list, 3, &#39;four&#39;, &#39;five&#39;, &#39;six&#39;); // Insert multiple\r\n\r\n\r\n    console.log(&#39;Original list: &#39;, list);\r\n    console.log(&#39;Inserted list1: &#39;, list1);\r\n    console.log(&#39;Inserted list2: &#39;, list2);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**Note:** This is a pre-ES2015 way of doing it so it works for both older and newer browsers.\r\n\r\nIf you&#39;re using ES6 then you can try out [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) too; see [this](https://stackoverflow.com/questions/586182/how-to-insert-an-item-into-an-array-at-a-specific-index-javascript/586189#answer-38181008) answer.\r\n\r\n"},{"score":1,"body_markdown":"i like little safety and i use this\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n       Array.prototype.Insert = function (item, before) {\r\n            if (!item) return;\r\n            if (before == null || before &lt; 0 || before &gt; this.length - 1) {\r\n                this.push(item);\r\n                return;\r\n            }\r\n            this.splice(before, 0,item );\r\n        }\r\n        \r\n        \r\n       var t = [&quot;a&quot;,&quot;b&quot;]\r\n       \r\n       t.Insert(&quot;v&quot;,1)\r\n        \r\n        console.log(t )\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"}],"score":3165}