{"body":"&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var obj = {\r\n        name: &quot;Simon&quot;,\r\n        age: &quot;20&quot;,\r\n        clothing: {\r\n            style: &quot;simple&quot;,\r\n            hipster: false\r\n        }\r\n    }\r\n\r\n    for(var propt in obj){\r\n        console.log(propt + &#39;: &#39; + obj[propt]);\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nHow does the variable `propt` represent the properties of the object? It&#39;s not a built-in method or property. Why does it come up with every property in the object?","title":"Iterate through object properties","answers":[{"score":222,"body_markdown":"It&#39;s the `for...in statement` ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in), [ECMAScript spec](http://es5.github.io/#x12.6.4)).\r\n\r\nYou can read it as &quot;**FOR** every property **IN** the `obj` object, assign each property to the **PROPT** variable in turn&quot;."},{"score":37,"body_markdown":"It&#39;s just a `for...in` loop. Check out [the documentation at Mozilla][1].\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in"},{"score":9,"body_markdown":"Your `for` loop is iterating over all of the properties of the object `obj`. `propt` is defined in the first line of your for loop. It is a string that is a name of a property of the `obj` object. In the first iteration of the loop, `propt` would be &quot;name&quot;."},{"score":9,"body_markdown":"Objects in JavaScript are collections of properties and can therefore be looped in a for each statement. \r\n\r\nYou should think of `obj` as an key value collection."},{"score":2473,"body_markdown":"Iterating over properties requires this additional `hasOwnProperty` check: \r\n\r\n    for (var prop in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, prop)) {\r\n            // do stuff\r\n        }\r\n    }\r\n\r\nIt&#39;s necessary because an object&#39;s prototype contains additional properties for the object which are technically part of the object. These additional properties are inherited from the base object class, but are still properties of `obj`.\r\n\r\n[`hasOwnProperty`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty) simply checks to see if this is a property specific to this class, and not one inherited from the base class.\r\n\r\n---\r\n\r\nIt&#39;s also possible to call `hasOwnProperty` through the object itself:\r\n\r\n    if (obj.hasOwnProperty(prop)) {\r\n        // do stuff\r\n    }\r\n\r\nBut this will fail if the object has an unrelated field with the same name:\r\n\r\n    var obj = { foo: 42, hasOwnProperty: &#39;lol&#39; };\r\n    obj.hasOwnProperty(&#39;foo&#39;);  // TypeError: hasOwnProperty is not a function\r\n\r\nThat&#39;s why it&#39;s safer to call it through `Object.prototype` instead:\r\n\r\n    var obj = { foo: 42, hasOwnProperty: &#39;lol&#39; };\r\n    Object.prototype.hasOwnProperty.call(obj, &#39;foo&#39;);  // true"},{"score":1187,"body_markdown":"As of JavaScript 1.8.5 you can use `Object.keys(obj)` to get an Array of properties defined on the object itself (the ones that return true for `obj.hasOwnProperty(key)`).\r\n    \r\n    Object.keys(obj).forEach(function(key,index) {\r\n        // key: the name of the object key\r\n        // index: the ordinal position of the key within the object \r\n    });\r\n\r\nThis is better (and more readable) than using a for-in loop.\r\n\r\nIts supported on these browsers: \r\n\r\n- Firefox (Gecko): 4 (2.0)\r\n- Chrome: 5\r\n- Internet Explorer: 9\r\n\r\nSee [the Mozilla Developer Network **Object.keys()**&#39;s reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) for futher information.\r\n"},{"score":3,"body_markdown":"What for..in loop does is that it creates a new variable (var someVariable) and then stores each property of the given object in this new variable(someVariable) one by one. Therefore if you use block {}, you can iterate. Consider the following example. \r\n    \r\n    var obj = {\r\n         name:&#39;raman&#39;,\r\n         hobby:&#39;coding&#39;,\r\n         planet:&#39;earth&#39;\r\n         };\r\n\r\n    for(var someVariable in obj) {\r\n      //do nothing..\r\n    }\r\n\r\n    console.log(someVariable); // outputs planet"},{"score":13,"body_markdown":"The for...in loop represents each property in an object because it is just like a for loop. You defined propt in the for...in loop by doing:\r\n\r\n        for(var propt in obj){\r\n    alert(propt + &#39;: &#39; + obj[propt]);\r\n    }\r\n\r\nA for...in loop iterates through the enumerable properties of an object. Whichever variable you define, or put in the for...in loop, changes each time it goes to the next property it iterates. The variable in the for...in loop iterates through the keys, but the value of it is the key&#39;s value. For example:\r\n\r\n        for(var propt in obj) {\r\n          console.log(propt);//logs name\r\n          console.log(obj[propt]);//logs &quot;Simon&quot;\r\n        }\r\nYou can see how the variable differs from the variable&#39;s value. In contrast, a for...of loop does the opposite.\r\n\r\nI hope this helps."},{"score":3,"body_markdown":"I want to add to the answers above, because you might have different intentions from Javascript.  A JSON object and a Javascript object are different things, and you might want to iterate through the properties of a JSON object using the solutions proposed above, and then be surprised. \r\n\r\nSuppose that you have a JSON object like:\r\n\r\n    var example = {\r\n        &quot;prop1&quot;: &quot;value1&quot;,\r\n        &quot;prop2&quot;: [ &quot;value2_0&quot;, value2_1&quot;],\r\n        &quot;prop3&quot;: {\r\n             &quot;prop3_1&quot;: &quot;value3_1&quot;\r\n        }\r\n    }\r\n\r\n**The wrong way to iterate through its &#39;properties&#39;:**\r\n\r\n    function recursivelyIterateProperties(jsonObject) {\r\n        for (var prop in Object.keys(example)) {\r\n            console.log(prop);\r\n            recursivelyIterateProperties(jsonObject[prop]);\r\n        }\r\n    }\r\n\r\nYou might be surprised of seeing the console logging `0`, `1`, etc. when iterating through the properties of `prop1` and `prop2` and of `prop3_1`. Those objects are sequences, and the indexes of a sequence are properties of that object in Javascript.\r\n\r\n**A better way to recursively iterate through a JSON object properties** would be to first check if that object is a sequence or not:\r\n\r\n    function recursivelyIterateProperties(jsonObject) {\r\n        for (var prop in Object.keys(example)) {\r\n            console.log(prop);\r\n            if (!(typeof(jsonObject[prop]) === &#39;string&#39;)\r\n                &amp;&amp; !(jsonObject[prop] instanceof Array)) {\r\n                    recursivelyIterateProperties(jsonObject[prop]);\r\n\r\n                }\r\n                \r\n         }\r\n    }\r\n"},{"score":4,"body_markdown":"Also adding the recursive way:\r\n    \r\n    function iterate(obj) {\r\n        // watch for objects we&#39;ve already iterated so we won&#39;t end in endless cycle\r\n        // for cases like var foo = {}; foo.bar = foo; iterate(foo);\r\n        var walked = [];\r\n        var stack = [{obj: obj, stack: &#39;&#39;}];\r\n        while(stack.length &gt; 0)\r\n        {\r\n            var item = stack.pop();\r\n            var obj = item.obj;\r\n            for (var property in obj) {\r\n                if (obj.hasOwnProperty(property)) {\r\n                    if (typeof obj[property] == &quot;object&quot;) {\r\n                      // check if we haven&#39;t iterated through the reference yet\r\n                      var alreadyFound = false;\r\n                      for(var i = 0; i &lt; walked.length; i++)\r\n                      {\r\n                        if (walked[i] === obj[property])\r\n                        {\r\n                          alreadyFound = true;\r\n                          break;\r\n                        }\r\n                      }\r\n                      // new object reference\r\n                      if (!alreadyFound)\r\n                      {\r\n                        walked.push(obj[property]);\r\n                        stack.push({obj: obj[property], stack: item.stack + &#39;.&#39; + property});\r\n                      }\r\n                    }\r\n                    else\r\n                    {\r\n                        console.log(item.stack + &#39;.&#39; + property + &quot;=&quot; + obj[property]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nUsage:\r\n    \r\n    iterate({ foo: &quot;foo&quot;, bar: { foo: &quot;foo&quot;} }); "},{"score":3,"body_markdown":"Here I am iterating each node and creating meaningful node names. If you notice, instanceOf Array and instanceOf Object pretty much does the same thing (in my application, i am giving different logic though)\r\n\r\n    function iterate(obj,parent_node) {\r\n    \tparent_node = parent_node || &#39;&#39;;\r\n    \tfor (var property in obj) {\r\n    \t\tif (obj.hasOwnProperty(property)) {\r\n    \t\t\tvar node = parent_node + &quot;/&quot; + property;\r\n    \t\t\tif(obj[property] instanceof Array) {\r\n    \t\t\t\t//console.log(&#39;array: &#39; + node + &quot;:&quot; + obj[property]);\r\n    \t\t\t\titerate(obj[property],node)\r\n    \t\t\t} else if(obj[property] instanceof Object){\r\n    \t\t\t\t//console.log(&#39;Object: &#39; + node + &quot;:&quot; + obj[property]);\r\n    \t\t\t\titerate(obj[property],node)\r\n    \t\t\t}\r\n    \t\t\telse {\r\n    \t\t\t\tconsole.log(node + &quot;:&quot; + obj[property]);\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\nnote - I am inspired by Ondrej Svejdar&#39;s answer. But this solution has better performance and less ambiguous"},{"score":21,"body_markdown":"jquery allows you to do this now:\r\n\r\n    $.each( obj, function( key, value ) {\r\n      alert( key + &quot;: &quot; + value );\r\n    });"},{"score":3,"body_markdown":"You basically want to loop through each property in the object.\r\n\r\n[JSFiddle](https://jsfiddle.net/HovyTech/djf2q8e8/)\r\n\r\n    var Dictionary = {\r\n      If: {\r\n        you: {\r\n          can: &#39;&#39;,\r\n          make: &#39;&#39;\r\n        },\r\n        sense: &#39;&#39;\r\n      },\r\n      of: {\r\n        the: {\r\n          sentence: {\r\n            it: &#39;&#39;,\r\n            worked: &#39;&#39;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    \r\n    function Iterate(obj) {\r\n      for (prop in obj) {\r\n        if (obj.hasOwnProperty(prop) &amp;&amp; isNaN(prop)) {\r\n          console.log(prop + &#39;: &#39; + obj[prop]);\r\n          Iterate(obj[prop]);\r\n        }\r\n      }\r\n    }\r\n    Iterate(Dictionary);"},{"score":10,"body_markdown":"Nowadays you can convert a standard JS object into an iterable object just by adding a Symbol.iterator method. Then you can use a `for of` loop and acceess its values directly or even can use a spread operator on the object too. Cool. Let&#39;s see how we can make it:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var o = {a:1,b:2,c:3},\r\n        a = [];\r\n    o[Symbol.iterator] = function*(){\r\n                           var ok = Object.keys(this);\r\n                                i = 0;\r\n                           while (i &lt; ok.length) yield this[ok[i++]];\r\n                         };\r\n    for (var value of o) console.log(value);\r\n    // or you can even do like\r\n    a = [...o];\r\n    console.log(a);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":184,"body_markdown":"In up-to-date implementations of ES, you can use [`Object.entries`][1]:\r\n\r\n    for (const [key, value] of Object.entries(obj)) { }\r\n\r\nor\r\n\r\n    Object.entries(obj).forEach(([key, value]) =&gt; ...)\r\n\r\nIf you just want to iterate over the values, then use Object.values:\r\n\r\n    for (const value of Object.values(obj)) { }\r\n\r\nor\r\n\r\n    Object.values(obj).forEach(value =&gt; ...)\r\n\r\n  [1]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"},{"score":12,"body_markdown":"You can use Lodash. [The documentation][1] \r\n\r\n    var obj = {a: 1, b: 2, c: 3};\r\n    _.keys(obj).forEach(function (key) {\r\n        ...\r\n    });\r\n\r\n\r\n  [1]: https://lodash.com/docs/4.16.6#keys &quot;documentation&quot;"},{"score":330,"body_markdown":"Girls and guys we are in 2019 and we do not have that much time for typing... So lets do this cool new fancy ECMAScript 2016:\r\n\r\n    Object.keys(obj).forEach(e =&gt; console.log(`key=${e}  value=${obj[e]}`));"},{"score":11,"body_markdown":"    let obj = {&quot;a&quot;: 3, &quot;b&quot;: 2, &quot;6&quot;: &quot;a&quot;}\r\n    \r\n    Object.keys(obj).map((item) =&gt; {console.log(&quot;item&quot;, obj[item])})\r\n    \r\n    // a\r\n    // 3\r\n    // 2"},{"score":7,"body_markdown":"If running **Node** I&#39;d recommend:\r\n\r\n    Object.keys(obj).forEach((key, index) =&gt; {\r\n        console.log(key);\r\n    });"},{"score":1,"body_markdown":"To further refine the accepted answer it&#39;s worth noting that if you instantiate the object with a `var object = Object.create(null)` then `object.hasOwnProperty(property)` will trigger a TypeError. So to be on the safe side, you&#39;d need to call it from the prototype like this:\r\n\r\n    for (var property in object) {\r\n        if (Object.prototype.hasOwnProperty.call(object, property)) {\r\n            // do stuff\r\n        }\r\n    }\r\n\r\n"},{"score":28,"body_markdown":"If your environment supports **ES2017** then I would recommend **Object.entries**:\r\n\r\n    Object.entries(obj).forEach(([key, value]) =&gt; {\r\n      console.log(`${key} ${value}`);\r\n    });\r\n\r\nAs shown in [Mozillas Object.entries()][1] documentation:\r\n&gt; The **Object.entries()** method returns an array of a given object&#39;s own\r\n&gt; enumerable property [key, value] pairs, in the same order as that\r\n&gt; provided by a for...in loop (the difference being that a for-in loop\r\n&gt; enumerates properties in the prototype chain as well).\r\n\r\nBasically with Object.entries we can forgo the following extra step that is required with the older **for...in** loop:\r\n\r\n    // This step is not necessary with Object.entries\r\n    if (object.hasOwnProperty(property)) {\r\n      // do stuff\r\n    }\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"},{"score":17,"body_markdown":"The above answers are a bit annoying because they don&#39;t explain what you do inside the for loop after you ensure it&#39;s an object: YOU DON&#39;T ACCESS IT DIRECTLY! You are actually only delivered the KEY that you need to apply to the OBJ:\r\n\r\n    var obj = {\r\n      a: &quot;foo&quot;,\r\n      b: &quot;bar&quot;,\r\n      c: &quot;foobar&quot;\r\n    };\r\n\r\n    // We need to iterate the string keys (not the objects)\r\n    for(var someKey in obj)\r\n    {\r\n      // We check if this key exists in the obj\r\n      if (obj.hasOwnProperty(someKey))\r\n      {\r\n        // someKey is only the KEY (string)! Use it to get the obj:\r\n        var myActualPropFromObj = obj[someKey]; // Since dynamic, use [] since the key isn&#39;t literally named &quot;someKey&quot;\r\n    \r\n        // NOW you can treat it like an obj\r\n        var shouldBeBar = myActualPropFromObj.b;\r\n      }\r\n    }\r\n\r\nThis is all ECMA5 safe. Even works in the lame JS versions like Rhino ;)"},{"score":21,"body_markdown":"[Dominik&#39;s][1] answer is perfect, I just prefer to do it that way, as it&#39;s cleaner to read:\r\n\r\n    for (var property in object) {\r\n        if (!object.hasOwnProperty(property)) continue;\r\n    \r\n        // Do stuff...\r\n    }\r\n\r\n\r\n  [1]: https://stackoverflow.com/a/16735184/330867"},{"score":12,"body_markdown":"    Object.keys(obj).forEach(key =&gt;\r\n      console.log(`key=${key} value=${obj[key]}`)\r\n    );\r\n"},{"score":16,"body_markdown":"To add ES2015&#39;s usage of `Reflect.ownKeys(obj)` and also iterating over the properties via an iterator.\r\n\r\nFor example:\r\n\r\n    let obj = { a: &#39;Carrot&#39;, b: &#39;Potato&#39;, Car: { doors: 4 } };\r\n\r\ncan be iterated over by\r\n\r\n    // logs each key\r\n    Reflect.ownKeys(obj).forEach(key =&gt; console.log(key));\r\n\r\n\r\nIf you would like to iterate directly over the values of the keys of an object, you can define an `iterator`, just like JavaScipts&#39;s default iterators for strings, arrays, typed arrays, Map and Set.\r\n\r\nJS will attempt to iterate via the default iterator property, which must be defined as `Symbol.iterator`.\r\n\r\nIf you want to be able to iterate over all objects you can add it as a prototype of Object:\r\n\r\n    Object.prototype[Symbol.iterator] = function*() { \r\n        for(p of Reflect.ownKeys(this)){ yield this[p]; }\r\n    }\r\n\r\nThis would enable you to iterate over the values of an object with a for...of loop, for example:\r\n\r\n    for(val of obj) { console.log(&#39;Value is:&#39; + val ) }\r\n\r\n**Caution**: As of writing this answer (June 2018) all other browsers, but IE, support generators and `for...of` iteration via `Symbol.iterator`"},{"score":5,"body_markdown":"While the top-rated answer is correct, here is an alternate use case i.e if you are iterating over an object and want to create an array in the end. Use `.map` instead of `forEach` \r\n\r\n    const newObj = Object.keys(obj).map(el =&gt; {\r\n        //ell will hold keys \r\n       // Getting the value of the keys should be as simple as obj[el]\r\n    })\r\n"},{"score":27,"body_markdown":"\r\n    if(Object.keys(obj).length) {\r\n        Object.keys(obj).forEach(key =&gt; {\r\n            console.log(&quot;\\n&quot; + key + &quot;: &quot; + obj[key]);\r\n        });\r\n    }\r\n\r\n    // *** Explanation line by line ***\r\n\r\n    // Explaining the bellow line\r\n    // It checks if obj has at least one property. Here is how:\r\n    // Object.keys(obj) will return an array with all keys in obj.\r\n    // Keys are just the regular incremental numbers starting from 0.\r\n    // If there is no keys in obj, it will return empty array = []\r\n    // Then it will get its length. At this point, it checks: \r\n    // If it has at least one element, it means it&#39;s bigger than 0 \r\n    // which evaluates to true and the bellow code will be executed.\r\n    // Else means it&#39;s length = 0 which evaluates to false\r\n    // NOTE: you can use Object.hasOwnProperty() instead of Object.keys(obj).length\r\n    if(Object.keys(obj).length) {\r\n\r\n        // Explaining the bellow line\r\n        // Just like in the previous line, this returns an array with\r\n        // all keys in obj (because if code execution got here, it means \r\n        // obj has keys.) \r\n        // Then just invoke built-in javascript forEach() to loop\r\n        // over each key in returned array and calls a call back function \r\n        // on each array element (key), using ES6 arrow function (=&gt;)\r\n        // Or you can just use a normal function ((key) { blah blah }).\r\n        Object.keys(obj).forEach(key =&gt; {\r\n\r\n            // The bellow line prints out all keys with their \r\n            // respective value in obj.\r\n            // key comes from the returned array in Object.keys(obj)\r\n            // obj[key] returns the value of key in obj\r\n            console.log(&quot;\\n&quot; + key + &quot;: &quot; + obj[key]);\r\n        });\r\n    }\r\n\r\n"},{"score":1,"body_markdown":"Check this link it will help &lt;https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_state_forin&gt;\r\n\r\n```\r\nvar person = {fname:&quot;John&quot;, lname:&quot;Doe&quot;, age:25}; \r\n  \r\n  var text = &quot;&quot;;\r\n  var x;\r\n  for (x in person) {\r\n    text += person[x] + &quot; &quot;; // where x will be fname,lname,age\r\n   }\r\nConsole.log(text);\r\n```"},{"score":0,"body_markdown":"# Check type\r\n\r\nYou can check how propt represent object propertis by\r\n\r\n    typeof propt\r\n\r\nto discover that it&#39;s just a string (name of property). It come up with every property in the object due the way of how [`for-in`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in) js &quot;build-in&quot; loop works.\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var obj = {\r\n        name: &quot;Simon&quot;,\r\n        age: &quot;20&quot;,\r\n        clothing: {\r\n            style: &quot;simple&quot;,\r\n            hipster: false\r\n        }\r\n    }\r\n\r\n    for(var propt in obj){\r\n        console.log(typeof propt,  propt + &#39;: &#39; + obj[propt]);\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":2,"body_markdown":"You can access the nested properties of object using `for...in` and `forEach` loop. \r\n\r\n`for...in`:\r\n--\r\n```js\r\nfor (const key in info) {\r\n\tconsoled.log(info[key]);\r\n}\r\n```   \r\n`forEach`:\r\n--\r\n\r\n```js\r\nObject.keys(info).forEach(function(prop) {\r\n\tconsole.log(info[prop]);\r\n\t// cities: Array[3], continent: &quot;North America&quot;, images: Array[3], name: &quot;Canada&quot;\r\n\t// &quot;prop&quot; is the property name\r\n\t// &quot;data[prop]&quot; is the property value\r\n});\r\n```"}],"score":2122}