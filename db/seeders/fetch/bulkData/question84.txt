{"body":"I have a script that uses `$(document).ready`, but it doesn&#39;t use anything else from jQuery. I&#39;d like to lighten it up by removing the jQuery dependency.\r\n\r\nHow can I implement my own `$(document).ready` functionality without using jQuery? I know that  using `window.onload` will not be the same, as `window.onload` fires after all images, frames, etc. have been loaded.\r\n","title":"$(document).ready equivalent without jQuery","answers":[{"score":1532,"body_markdown":"There is a standards based replacement,`DOMContentLoaded` that is supported by over [98% of browsers](http://caniuse.com/#search=DOMContentLoaded), though not IE8:\r\n\r\n    document.addEventListener(&quot;DOMContentLoaded&quot;, function(event) { \r\n      //do work\r\n    });\r\n \r\n\r\n\r\njQuery&#39;s native function is much more complicated than just window.onload, as depicted below.  \r\n\r\n    function bindReady(){\r\n    \tif ( readyBound ) return;\r\n    \treadyBound = true;\r\n    \r\n    \t// Mozilla, Opera and webkit nightlies currently support this event\r\n    \tif ( document.addEventListener ) {\r\n    \t\t// Use the handy event callback\r\n    \t\tdocument.addEventListener( &quot;DOMContentLoaded&quot;, function(){\r\n    \t\t\tdocument.removeEventListener( &quot;DOMContentLoaded&quot;, arguments.callee, false );\r\n    \t\t\tjQuery.ready();\r\n    \t\t}, false );\r\n    \r\n    \t// If IE event model is used\r\n    \t} else if ( document.attachEvent ) {\r\n    \t\t// ensure firing before onload,\r\n    \t\t// maybe late but safe also for iframes\r\n    \t\tdocument.attachEvent(&quot;onreadystatechange&quot;, function(){\r\n    \t\t\tif ( document.readyState === &quot;complete&quot; ) {\r\n    \t\t\t\tdocument.detachEvent( &quot;onreadystatechange&quot;, arguments.callee );\r\n    \t\t\t\tjQuery.ready();\r\n    \t\t\t}\r\n    \t\t});\r\n    \r\n    \t\t// If IE and not an iframe\r\n    \t\t// continually check to see if the document is ready\r\n    \t\tif ( document.documentElement.doScroll &amp;&amp; window == window.top ) (function(){\r\n    \t\t\tif ( jQuery.isReady ) return;\r\n    \r\n    \t\t\ttry {\r\n    \t\t\t\t// If IE is used, use the trick by Diego Perini\r\n    \t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\r\n    \t\t\t\tdocument.documentElement.doScroll(&quot;left&quot;);\r\n    \t\t\t} catch( error ) {\r\n    \t\t\t\tsetTimeout( arguments.callee, 0 );\r\n    \t\t\t\treturn;\r\n    \t\t\t}\r\n    \r\n    \t\t\t// and execute any waiting functions\r\n    \t\t\tjQuery.ready();\r\n    \t\t})();\r\n    \t}\r\n    \r\n    \t// A fallback to window.onload, that will always work\r\n    \tjQuery.event.add( window, &quot;load&quot;, jQuery.ready );\r\n    }\r\n"},{"score":-1,"body_markdown":"The ready function in `jQuery` does a number of things. Frankly, I don&#39;t see that point of replacing it unless you have amazingly small output from your website. `jQuery` is a pretty tiny library, and it handles all sorts of cross-browser things you&#39;ll need later.\r\n\r\nAnyway, there&#39;s little point in posting it here, just open up `jQuery` and look at the `bindReady` method.\r\n\r\nIt starts by calling either `document.addEventListener(&quot;DOMContentLoaded&quot;)` or `document.attachEvent(&#39;onreadystatechange&#39;)` depending on the event model, and goes on from there.\r\n"},{"score":91,"body_markdown":"Place your `&lt;script&gt;/*JavaScript code*/&lt;/script&gt;` right **before the closing** `&lt;/body&gt;` tag.\r\n\r\nAdmittedly, this might not suit everyone&#39;s purposes since it requires changing the HTML file rather than just doing something in the JavaScript file a la `document.ready`, but still...\r\n"},{"score":13,"body_markdown":"I was recently using this for a mobile site. This is John Resig&#39;s simplified version from &quot;Pro JavaScript Techniques&quot;. It depends on addEvent.\r\n\r\n    var ready = ( function () {\r\n      function ready( f ) {\r\n        if( ready.done ) return f();\r\n \r\n        if( ready.timer ) {\r\n          ready.ready.push(f);\r\n        } else {\r\n          addEvent( window, &quot;load&quot;, isDOMReady );\r\n          ready.ready = [ f ];\r\n          ready.timer = setInterval(isDOMReady, 13);\r\n        }\r\n      };\r\n\r\n      function isDOMReady() {\r\n        if( ready.done ) return false;\r\n\r\n        if( document &amp;&amp; document.getElementsByTagName &amp;&amp; document.getElementById &amp;&amp; document.body ) {\r\n          clearInterval( ready.timer );\r\n          ready.timer = null;\r\n          for( var i = 0; i &lt; ready.ready.length; i++ ) {\r\n            ready.ready[i]();\r\n          }\r\n          ready.ready = null;\r\n          ready.done = true;\r\n        }\r\n      }\r\n\r\n      return ready;\r\n    })();"},{"score":354,"body_markdown":"Edit:\r\n\r\nHere is a viable replacement for jQuery ready\r\n---------------------------------------------\r\n\r\n    function ready(callback){\r\n        // in case the document is already rendered\r\n        if (document.readyState!=&#39;loading&#39;) callback();\r\n        // modern browsers\r\n        else if (document.addEventListener) document.addEventListener(&#39;DOMContentLoaded&#39;, callback);\r\n        // IE &lt;= 8\r\n        else document.attachEvent(&#39;onreadystatechange&#39;, function(){\r\n            if (document.readyState==&#39;complete&#39;) callback();\r\n        });\r\n    }\r\n    \r\n    ready(function(){\r\n        // do something\r\n    });\r\n\r\n\r\nTaken from\r\nhttps://plainjs.com/javascript/events/running-code-when-the-document-is-ready-15/\r\n\r\n[Another good domReady function here][1] taken from https://stackoverflow.com/a/9899701/175071\r\n\r\n\r\n-------------\r\n\r\n\r\n\r\n\r\nAs the accepted answer was very far from complete, I stitched together a &quot;ready&quot; function like `jQuery.ready()` based on jQuery 1.6.2 source:\r\n\r\n    var ready = (function(){\r\n\r\n        var readyList,\r\n            DOMContentLoaded,\r\n            class2type = {};\r\n            class2type[&quot;[object Boolean]&quot;] = &quot;boolean&quot;;\r\n            class2type[&quot;[object Number]&quot;] = &quot;number&quot;;\r\n            class2type[&quot;[object String]&quot;] = &quot;string&quot;;\r\n            class2type[&quot;[object Function]&quot;] = &quot;function&quot;;\r\n            class2type[&quot;[object Array]&quot;] = &quot;array&quot;;\r\n            class2type[&quot;[object Date]&quot;] = &quot;date&quot;;\r\n            class2type[&quot;[object RegExp]&quot;] = &quot;regexp&quot;;\r\n            class2type[&quot;[object Object]&quot;] = &quot;object&quot;;\r\n\r\n        var ReadyObj = {\r\n            // Is the DOM ready to be used? Set to true once it occurs.\r\n            isReady: false,\r\n            // A counter to track how many items to wait for before\r\n            // the ready event fires. See #6781\r\n            readyWait: 1,\r\n            // Hold (or release) the ready event\r\n            holdReady: function( hold ) {\r\n                if ( hold ) {\r\n                    ReadyObj.readyWait++;\r\n                } else {\r\n                    ReadyObj.ready( true );\r\n                }\r\n            },\r\n            // Handle when the DOM is ready\r\n            ready: function( wait ) {\r\n                // Either a released hold or an DOMready/load event and not yet ready\r\n                if ( (wait === true &amp;&amp; !--ReadyObj.readyWait) || (wait !== true &amp;&amp; !ReadyObj.isReady) ) {\r\n                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\r\n                    if ( !document.body ) {\r\n                        return setTimeout( ReadyObj.ready, 1 );\r\n                    }\r\n\r\n                    // Remember that the DOM is ready\r\n                    ReadyObj.isReady = true;\r\n                    // If a normal DOM Ready event fired, decrement, and wait if need be\r\n                    if ( wait !== true &amp;&amp; --ReadyObj.readyWait &gt; 0 ) {\r\n                        return;\r\n                    }\r\n                    // If there are functions bound, to execute\r\n                    readyList.resolveWith( document, [ ReadyObj ] );\r\n\r\n                    // Trigger any bound ready events\r\n                    //if ( ReadyObj.fn.trigger ) {\r\n                    //    ReadyObj( document ).trigger( &quot;ready&quot; ).unbind( &quot;ready&quot; );\r\n                    //}\r\n                }\r\n            },\r\n            bindReady: function() {\r\n                if ( readyList ) {\r\n                    return;\r\n                }\r\n                readyList = ReadyObj._Deferred();\r\n\r\n                // Catch cases where $(document).ready() is called after the\r\n                // browser event has already occurred.\r\n                if ( document.readyState === &quot;complete&quot; ) {\r\n                    // Handle it asynchronously to allow scripts the opportunity to delay ready\r\n                    return setTimeout( ReadyObj.ready, 1 );\r\n                }\r\n\r\n                // Mozilla, Opera and webkit nightlies currently support this event\r\n                if ( document.addEventListener ) {\r\n                    // Use the handy event callback\r\n                    document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );\r\n                    // A fallback to window.onload, that will always work\r\n                    window.addEventListener( &quot;load&quot;, ReadyObj.ready, false );\r\n\r\n                // If IE event model is used\r\n                } else if ( document.attachEvent ) {\r\n                    // ensure firing before onload,\r\n                    // maybe late but safe also for iframes\r\n                    document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );\r\n\r\n                    // A fallback to window.onload, that will always work\r\n                    window.attachEvent( &quot;onload&quot;, ReadyObj.ready );\r\n\r\n                    // If IE and not a frame\r\n                    // continually check to see if the document is ready\r\n                    var toplevel = false;\r\n\r\n                    try {\r\n                        toplevel = window.frameElement == null;\r\n                    } catch(e) {}\r\n\r\n                    if ( document.documentElement.doScroll &amp;&amp; toplevel ) {\r\n                        doScrollCheck();\r\n                    }\r\n                }\r\n            },\r\n            _Deferred: function() {\r\n                var // callbacks list\r\n                    callbacks = [],\r\n                    // stored [ context , args ]\r\n                    fired,\r\n                    // to avoid firing when already doing so\r\n                    firing,\r\n                    // flag to know if the deferred has been cancelled\r\n                    cancelled,\r\n                    // the deferred itself\r\n                    deferred  = {\r\n\r\n                        // done( f1, f2, ...)\r\n                        done: function() {\r\n                            if ( !cancelled ) {\r\n                                var args = arguments,\r\n                                    i,\r\n                                    length,\r\n                                    elem,\r\n                                    type,\r\n                                    _fired;\r\n                                if ( fired ) {\r\n                                    _fired = fired;\r\n                                    fired = 0;\r\n                                }\r\n                                for ( i = 0, length = args.length; i &lt; length; i++ ) {\r\n                                    elem = args[ i ];\r\n                                    type = ReadyObj.type( elem );\r\n                                    if ( type === &quot;array&quot; ) {\r\n                                        deferred.done.apply( deferred, elem );\r\n                                    } else if ( type === &quot;function&quot; ) {\r\n                                        callbacks.push( elem );\r\n                                    }\r\n                                }\r\n                                if ( _fired ) {\r\n                                    deferred.resolveWith( _fired[ 0 ], _fired[ 1 ] );\r\n                                }\r\n                            }\r\n                            return this;\r\n                        },\r\n\r\n                        // resolve with given context and args\r\n                        resolveWith: function( context, args ) {\r\n                            if ( !cancelled &amp;&amp; !fired &amp;&amp; !firing ) {\r\n                                // make sure args are available (#8421)\r\n                                args = args || [];\r\n                                firing = 1;\r\n                                try {\r\n                                    while( callbacks[ 0 ] ) {\r\n                                        callbacks.shift().apply( context, args );//shifts a callback, and applies it to document\r\n                                    }\r\n                                }\r\n                                finally {\r\n                                    fired = [ context, args ];\r\n                                    firing = 0;\r\n                                }\r\n                            }\r\n                            return this;\r\n                        },\r\n\r\n                        // resolve with this as context and given arguments\r\n                        resolve: function() {\r\n                            deferred.resolveWith( this, arguments );\r\n                            return this;\r\n                        },\r\n\r\n                        // Has this deferred been resolved?\r\n                        isResolved: function() {\r\n                            return !!( firing || fired );\r\n                        },\r\n\r\n                        // Cancel\r\n                        cancel: function() {\r\n                            cancelled = 1;\r\n                            callbacks = [];\r\n                            return this;\r\n                        }\r\n                    };\r\n\r\n                return deferred;\r\n            },\r\n            type: function( obj ) {\r\n                return obj == null ?\r\n                    String( obj ) :\r\n                    class2type[ Object.prototype.toString.call(obj) ] || &quot;object&quot;;\r\n            }\r\n        }\r\n        // The DOM ready check for Internet Explorer\r\n        function doScrollCheck() {\r\n            if ( ReadyObj.isReady ) {\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // If IE is used, use the trick by Diego Perini\r\n                // http://javascript.nwbox.com/IEContentLoaded/\r\n                document.documentElement.doScroll(&quot;left&quot;);\r\n            } catch(e) {\r\n                setTimeout( doScrollCheck, 1 );\r\n                return;\r\n            }\r\n\r\n            // and execute any waiting functions\r\n            ReadyObj.ready();\r\n        }\r\n        // Cleanup functions for the document ready method\r\n        if ( document.addEventListener ) {\r\n            DOMContentLoaded = function() {\r\n                document.removeEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );\r\n                ReadyObj.ready();\r\n            };\r\n\r\n        } else if ( document.attachEvent ) {\r\n            DOMContentLoaded = function() {\r\n                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\r\n                if ( document.readyState === &quot;complete&quot; ) {\r\n                    document.detachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );\r\n                    ReadyObj.ready();\r\n                }\r\n            };\r\n        }\r\n        function ready( fn ) {\r\n            // Attach the listeners\r\n            ReadyObj.bindReady();\r\n\r\n            var type = ReadyObj.type( fn );\r\n\r\n            // Add the callback\r\n            readyList.done( fn );//readyList is result of _Deferred()\r\n        }\r\n        return ready;\r\n    })();\r\n\r\nHow to use:\r\n\r\n    &lt;script&gt;\r\n        ready(function(){\r\n            alert(&#39;It works!&#39;);\r\n        });\r\n        ready(function(){\r\n            alert(&#39;Also works!&#39;);\r\n        });\r\n    &lt;/script&gt;\r\n\r\nI am not sure how functional this code is, but it worked fine with my superficial tests. This took quite a while, so I hope you and others can benefit from it.\r\n\r\nPS.: I suggest [compiling][2] it.\r\n\r\nOr you can use http://dustindiaz.com/smallest-domready-ever:\r\n\r\n    function r(f){/in/.test(document.readyState)?setTimeout(r,9,f):f()}\r\n    r(function(){/*code to run*/});\r\n\r\nor the native function if you only need to support the new browsers (Unlike jQuery ready, this won&#39;t run if you add this after the page has loaded)\r\n\r\n    document.addEventListener(&#39;DOMContentLoaded&#39;,function(){/*fun code to run*/})\r\n\r\n\r\n  [1]: https://github.com/jfriend00/docReady\r\n  [2]: http://closure-compiler.appspot.com/home"},{"score":6,"body_markdown":"It is worth looking in *[Rock Solid addEvent()][1]* and http://www.braksator.com/how-to-make-your-own-jquery.\r\n\r\nHere is the code in case the site goes down\r\n\r\n    function addEvent(obj, type, fn) {\r\n        if (obj.addEventListener) {\r\n            obj.addEventListener(type, fn, false);\r\n            EventCache.add(obj, type, fn);\r\n        }\r\n        else if (obj.attachEvent) {\r\n            obj[&quot;e&quot;+type+fn] = fn;\r\n            obj[type+fn] = function() { obj[&quot;e&quot;+type+fn]( window.event ); }\r\n            obj.attachEvent( &quot;on&quot;+type, obj[type+fn] );\r\n            EventCache.add(obj, type, fn);\r\n        }\r\n        else {\r\n            obj[&quot;on&quot;+type] = obj[&quot;e&quot;+type+fn];\r\n        }\r\n    }\r\n\r\n    var EventCache = function(){\r\n        var listEvents = [];\r\n        return {\r\n            listEvents : listEvents,\r\n            add : function(node, sEventName, fHandler){\r\n                listEvents.push(arguments);\r\n            },\r\n            flush : function(){\r\n                var i, item;\r\n                for(i = listEvents.length - 1; i &gt;= 0; i = i - 1){\r\n                    item = listEvents[i];\r\n                    if(item[0].removeEventListener){\r\n                        item[0].removeEventListener(item[1], item[2], item[3]);\r\n                    };\r\n                    if(item[1].substring(0, 2) != &quot;on&quot;){\r\n                        item[1] = &quot;on&quot; + item[1];\r\n                    };\r\n                    if(item[0].detachEvent){\r\n                        item[0].detachEvent(item[1], item[2]);\r\n                    };\r\n                    item[0][item[1]] = null;\r\n                };\r\n            }\r\n        };\r\n    }();\r\n\r\n    // Usage\r\n    addEvent(window, &#39;unload&#39;, EventCache.flush);\r\n    addEvent(window, &#39;load&#39;, function(){alert(&quot;I&#39;m ready&quot;);});\r\n\r\n  [1]: http://www.dustindiaz.com/rock-solid-addevent/\r\n\r\n\r\n"},{"score":67,"body_markdown":"Poor man&#39;s solution:\r\n\r\n    var checkLoad = function() {   \r\n        document.readyState !== &quot;complete&quot; ? setTimeout(checkLoad, 11) : alert(&quot;loaded!&quot;);   \r\n    };  \r\n            \r\n    checkLoad();  \r\n[View Fiddle][1]\r\n\r\n \r\nAdded this one, a bit better I guess, own scope, and non recursive\r\n\r\n    (function(){\r\n        var tId = setInterval(function() {\r\n            if (document.readyState == &quot;complete&quot;) onComplete()\r\n        }, 11);\r\n        function onComplete(){\r\n            clearInterval(tId);    \r\n            alert(&quot;loaded!&quot;);    \r\n        };\r\n    })()\r\n\r\n\r\n[View Fiddle][2]\r\n\r\n\r\n  [1]: http://jsfiddle.net/squadjot/s4EzY/\r\n  [2]: http://jsfiddle.net/squadjot/XD7ZF/"},{"score":3,"body_markdown":"How about this solution?\r\n\r\n    // other onload attached earlier\r\n    window.onload=function() {\r\n       alert(&#39;test&#39;);\r\n    };\r\n    \r\n    tmpPreviousFunction=window.onload ? window.onload : null;\r\n    \r\n    // our onload function\r\n    window.onload=function() {\r\n       alert(&#39;another message&#39;);\r\n       \r\n       // execute previous one\r\n       if (tmpPreviousFunction) tmpPreviousFunction();\r\n    };"},{"score":11,"body_markdown":"The jQuery answer was pretty useful to me. With a little refactory it fitted my needs well.\r\nI hope it helps anybody else.\r\n\r\n    function onReady ( callback ){\r\n        var addListener = document.addEventListener || document.attachEvent,\r\n            removeListener =  document.removeEventListener || document.detachEvent\r\n            eventName = document.addEventListener ? &quot;DOMContentLoaded&quot; : &quot;onreadystatechange&quot;\r\n    \r\n        addListener.call(document, eventName, function(){\r\n            removeListener( eventName, arguments.callee, false )\r\n            callback()\r\n        }, false )\r\n    }"},{"score":7,"body_markdown":"Just add this to the bottom of your HTML page...\r\n\r\n    &lt;script&gt;\r\n        Your_Function();\r\n    &lt;/script&gt;\r\n\r\nBecause, HTML documents are parsed by top-bottom.\r\n"},{"score":213,"body_markdown":"Three options:\r\n\r\n 1. If `script` is the last tag of the body, the DOM would be ready before script tag executes\r\n 2. When the DOM is ready, &quot;readyState&quot; will change to &quot;complete&quot;\r\n 3. Put everything under &#39;DOMContentLoaded&#39; event listener\r\n\r\n***onreadystatechange***\r\n\r\n      document.onreadystatechange = function () {\r\n         if (document.readyState == &quot;complete&quot;) {\r\n         // document is ready. Do your stuff here\r\n       }\r\n     }\r\n\r\nSource: [MDN][1]\r\n\r\n***DOMContentLoaded***\r\n\r\n    document.addEventListener(&#39;DOMContentLoaded&#39;, function() {\r\n       console.log(&#39;document is ready. I can sleep now&#39;);\r\n    });\r\n\r\n***Concerned about stone age browsers:***\r\nGo to the jQuery source code and use the `ready` function. In that case you are not parsing+executing the whole library you&#39;re are doing only a very small part of it.\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/API/document.readyState\r\n"},{"score":-1,"body_markdown":"This was a good https://stackoverflow.com/a/11810957/185565 poor man&#39;s solution. One comment considered a counter to bail out in case of emergency. This is my modification.\r\n\r\n    function doTheMagic(counter) {\r\n      alert(&quot;It worked on &quot; + counter);\r\n    }\r\n    \r\n    // wait for document ready then call handler function\r\n    var checkLoad = function(counter) {\r\n      counter++;\r\n      if (document.readyState != &quot;complete&quot; &amp;&amp; counter&lt;1000) {\r\n        var fn = function() { checkLoad(counter); };\r\n        setTimeout(fn,10);\r\n      } else doTheMagic(counter);\r\n    };\r\n    checkLoad(0);\r\n\r\n"},{"score":-7,"body_markdown":"If you want to support **[Internet&amp;nbsp;Explorer 7+][1] (no quirks, compatibility and other pain), last [Chrome][2], last [Safari][3], last Firefox and no iframes** - this will be enough:\r\n\r\n    is_loaded = false\r\n    callbacks = []\r\n\r\n    loaded = -&gt;\r\n      is_loaded = true\r\n      for i in [0...callbacks.length]\r\n        callbacks[i].call document\r\n      callbacks = []\r\n\r\n    content_loaded = -&gt;\r\n      document.removeEventListener &quot;DOMContentLoaded&quot;, content_loaded, true\r\n      loaded()\r\n\r\n    state_changed = -&gt;\r\n      if document.readyState is &quot;complete&quot;\r\n        document.detachEvent &quot;onreadystatechange&quot;, state_changed\r\n        loaded()\r\n\r\n    if !!document.addEventListener\r\n      document.addEventListener &quot;DOMContentLoaded&quot;, content_loaded, true\r\n    else\r\n      document.attachEvent &quot;onreadystatechange&quot;, state_changed\r\n\r\n    dom_ready = (callback) -&gt;\r\n      if is_loaded\r\n        callback.call document\r\n      else\r\n        callbacks.push callback\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Internet_Explorer_7\r\n  [2]: http://en.wikipedia.org/wiki/Google_Chrome\r\n  [3]: http://en.wikipedia.org/wiki/Safari_%28web_browser%29\r\n"},{"score":13,"body_markdown":"Cross-browser (old browsers too) and a simple solution:\r\n\r\n    var docLoaded = setInterval(function () {\r\n    \tif(document.readyState !== &quot;complete&quot;) return;\r\n    \tclearInterval(docLoaded);\r\n\r\n        /*\r\n\t\t    Your code goes here i.e. init()\r\n\t\t*/\r\n    }, 30);\r\n\r\n[Showing alert in jsfiddle][1]\r\n\r\n  [1]: https://jsfiddle.net/z6Lq6oxg/\r\n"},{"score":36,"body_markdown":"I use this:\r\n\r\n    document.addEventListener(&quot;DOMContentLoaded&quot;, function(event) { \r\n        //Do work\r\n    });\r\n\r\nNote: This probably only works with newer browsers, especially these: http://caniuse.com/#feat=domcontentloaded\r\n"},{"score":0,"body_markdown":"If you are loading jQuery near the bottom of BODY, but are having trouble with code that writes out jQuery(&amp;lt;func&gt;) or jQuery(document).ready(&amp;lt;func&gt;), check out [jqShim][1] on Github.\r\n\r\nRather than recreate its own document ready function, it simply holds onto the functions until jQuery is available then proceeds with jQuery as expected. The point of moving jQuery to the bottom of body is to speed up page load, and you can still accomplish it by inlining the jqShim.min.js in the head of your template.\r\n\r\nI ended up writing this code to make moving all the scripts in [WordPress][2] to the footer, and just this shim code now sits directly in the header.\r\n\r\n  [1]: https://github.com/withjam/jqshim-head\r\n  [2]: http://en.wikipedia.org/wiki/WordPress\r\n\r\n"},{"score":-1,"body_markdown":"Edit of the edit of @duskwuff to support [Internet&amp;nbsp;Explorer&amp;nbsp;8][1] too. The difference is a new call to the function test of the regex and the setTimeout with an anonymous function.\r\n\r\nAlso, I set the timeout to 99.\r\n\r\n    function ready(f){/in/.test(document.readyState)?setTimeout(function(){ready(f);},99):f();}\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Internet_Explorer_8\r\n"},{"score":3,"body_markdown":"We found a quick-and-dirty cross browser implementation of ours that may do the trick for most simple cases with a minimal implementation:\r\n\r\n    window.onReady = function onReady(fn){\r\n\t\tdocument.body ? fn() : setTimeout(function(){ onReady(fn);},50);\r\n\t};\r\n"},{"score":1,"body_markdown":"The setTimeout/setInterval solutions presented here will only work in specific circumstances.\r\n\r\nThe problem shows up especially in older Internet Explorer versions up to 8.\r\n\r\nThe variables affecting the success of these setTimeout/setInterval solutions are:\r\n\r\n    1) dynamic or static HTML\r\n    2) cached or non cached requests\r\n    3) size of the complete HTML document\r\n    4) chunked or non chunked transfer encoding\r\n\r\nthe original (native Javascript) code solving this specific issue is here:\r\n\r\n    https://github.com/dperini/ContentLoaded\r\n    http://javascript.nwbox.com/ContentLoaded (test)\r\n\r\nthis is the code from which the jQuery team have built their implementation.\r\n"},{"score":22,"body_markdown":"Really, if you care about **[Internet&amp;nbsp;Explorer&amp;nbsp;9+][1]** only, this code would be enough to replace `jQuery.ready`:\r\n\r\n        document.addEventListener(&quot;DOMContentLoaded&quot;, callback);\r\n\r\n------------------------\r\n\r\nIf you worry about [Internet&amp;nbsp;Explorer&amp;nbsp;6][2] and some really strange and rare browsers, this will work:\r\n\r\n    domReady: function (callback) {\r\n        // Mozilla, Opera and WebKit\r\n        if (document.addEventListener) {\r\n            document.addEventListener(&quot;DOMContentLoaded&quot;, callback, false);\r\n            // If Internet Explorer, the event model is used\r\n        } else if (document.attachEvent) {\r\n            document.attachEvent(&quot;onreadystatechange&quot;, function() {\r\n                if (document.readyState === &quot;complete&quot; ) {\r\n                    callback();\r\n                }\r\n            });\r\n            // A fallback to window.onload, that will always work\r\n        } else {\r\n            var oldOnload = window.onload;\r\n            window.onload = function () {\r\n                oldOnload &amp;&amp; oldOnload();\r\n                callback();\r\n            }\r\n        }\r\n    },\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Internet_Explorer_9\r\n  [2]: http://en.wikipedia.org/wiki/Internet_Explorer_6\r\n"},{"score":4,"body_markdown":"This cross-browser code will call a function once the DOM is ready:\r\n\r\n    var domReady=function(func){\r\n    \tvar scriptText=&#39;(&#39;+func+&#39;)();&#39;;\r\n    \tvar scriptElement=document.createElement(&#39;script&#39;);\r\n    \tscriptElement.innerText=scriptText;\r\n    \tdocument.body.appendChild(scriptElement);\r\n    };\r\n\r\nHere&#39;s how it works:\r\n\r\n1. The first line of `domReady` calls the [`toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString) method of the function to get a string representation of the function you pass in and wraps it in an expression that immediately calls the function.\r\n2. The rest of `domReady` creates a script element with the expression and appends it to the `body` of the document.\r\n3. The browser runs script tags appended to `body` after the DOM is ready.\r\n\r\n\r\nFor example, if you do this: `domReady(function(){alert();});`, the following will appended to the `body` element:\r\n\r\n     &lt;script&gt;(function (){alert();})();&lt;/script&gt;\r\n\r\nNote that this works only for user-defined functions. The following won&#39;t work: `domReady(alert);`"},{"score":18,"body_markdown":"This question was asked quite a long time ago.  For anyone just seeing this question, there is now a site called [&quot;you might not need jquery&quot;][1]  which breaks down - by level of IE support required - all the functionality of jquery and provides some alternative, smaller libraries.\r\n\r\nIE8 document ready script according to [you might not need jquery][1]\r\n\r\n    function ready(fn) {\r\n        if (document.readyState != &#39;loading&#39;)\r\n            fn();\r\n        else if (document.addEventListener)\r\n            document.addEventListener(&#39;DOMContentLoaded&#39;, fn);\r\n        else\r\n            document.attachEvent(&#39;onreadystatechange&#39;, function() {\r\n                if (document.readyState != &#39;loading&#39;)\r\n                    fn();\r\n            });\r\n    }\r\n\r\n\r\n  [1]: http://youmightnotneedjquery.com/"},{"score":9,"body_markdown":"Here is the **smallest code snippet to test DOM ready** which works across all browsers (even IE 8):\r\n\r\n    r(function(){\r\n        alert(&#39;DOM Ready!&#39;);\r\n    });\r\n    function r(f){/in/.test(document.readyState)?setTimeout(&#39;r(&#39;+f+&#39;)&#39;,9):f()}\r\n\r\nSee this [answer](https://stackoverflow.com/questions/9899372/pure-javascript-equivalent-to-jquerys-ready-how-to-call-a-function-when-the/30319853#30319853)."},{"score":-4,"body_markdown":"In short, instead of the $(document).ready() used in jQuery, we can use a JavaScript method:\r\n\r\n    &lt;script&gt;\r\n        document.addEventListener(&quot;DOMContentLoaded&quot;, function_name, false);\r\n        function function_name(){\r\n            statements;\r\n        }\r\n    &lt;/script&gt;\r\n\r\nThus, when the page is ready i.e. DOMContentLoaded only then the function function_name() will be invoked.\r\n"},{"score":0,"body_markdown":"For IE9+:\r\n\r\n    function ready(fn) {\r\n      if (document.readyState != &#39;loading&#39;){\r\n        fn();\r\n      } else {\r\n        document.addEventListener(&#39;DOMContentLoaded&#39;, fn);\r\n      }\r\n    }"},{"score":4,"body_markdown":"It&#39;s always good to use JavaScript equivalents as compared to jQuery. One reason is one fewer library to depend on and they are much faster than the jQuery equivalents.\r\n\r\nOne fantastic reference for jQuery equivalents is http://youmightnotneedjquery.com/.\r\n\r\nAs far as your question is concerned, I took the below code from the above link :)\r\nOnly caveat is it only works with [Internet&amp;nbsp;Explorer&amp;nbsp;9][1] and later.\r\n\r\n    function ready(fn) {\r\n        if (document.readyState != &#39;loading&#39;) {\r\n            fn();\r\n        }\r\n        else {\r\n            document.addEventListener(&#39;DOMContentLoaded&#39;, fn);\r\n        }\r\n    }\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Internet_Explorer_9\r\n"},{"score":1,"body_markdown":"Here&#39;s what I use, it&#39;s fast and covers all bases I think; works for everything except IE&lt;9.\r\n\r\n    (() =&gt; { function fn() {\r\n    \t// &quot;On document ready&quot; commands:\r\n    \tconsole.log(document.readyState);\r\n    };  \r\n      if (document.readyState != &#39;loading&#39;) {fn()}\r\n      else {document.addEventListener(&#39;DOMContentLoaded&#39;, fn)}\r\n    })();\r\n\r\nThis seems to catch all cases:\r\n\r\n - fires immediately if the DOM is already ready (if the DOM is not &quot;loading&quot;,    but either &quot;interactive&quot; or &quot;complete&quot;)\r\n - if  the DOM is still loading, it sets up an event listener for when the DOM\r\n   is available (interactive).\r\n\r\nThe DOMContentLoaded event is available in IE9 and everything else, so I personally think it&#39;s OK to use this. Rewrite the arrow function declaration to a regular anonymous function if you&#39;re not transpiling your code from ES2015  to ES5.\r\n\r\nIf you want to wait until all assets are loaded, all images displayed etc then use window.onload instead."},{"score":-3,"body_markdown":"The following approach ensures a script functionality only runs when the document is ready, even if the script is loaded asynchronously.\r\n\r\nUnlike JQuery&#39;s `$(document).ready`, `DOMContentLoaded` will not fire if the script is loaded dynamically afterwards.\r\n\r\n    (function ready() {\r\n        if (!document.body) {return setTimeout(ready, 50);}\r\n        // Document is ready here\r\n    })();\r\n\r\nThe same solution applies to any condition we want a script to be executed after. Say we are asynchronously loading JQuery and another custom script that requires JQuery. We don&#39;t know in advance which of the two will load first, but we can ensure that our custom script waits for JQuery to be present:\r\n\r\n    (function ready() {\r\n        if (!window.$) {return setTimeout(ready, 50);}\r\n        // JQuery is ready here\r\n    })();\r\n"},{"score":0,"body_markdown":"   \r\n\r\n    function onDocReady(fn){ \r\n    \t$d.readyState!==&quot;loading&quot; ? fn():document.addEventListener(&#39;DOMContentLoaded&#39;,fn);\r\n    }\r\n        \r\n    function onWinLoad(fn){\r\n    \t$d.readyState===&quot;complete&quot;) ? fn(): window.addEventListener(&#39;load&#39;,fn);\r\n    } \r\n\r\n  \r\n\r\n**onDocReady** provides a callback when the HTML dom is ready to fully  access/parse/manipulate.\r\n\r\n**onWinLoad** provides a callback when everything has loaded (images etc)\r\n\t\r\n - These functions can be called whenever you want.\r\n - Supports multiple &quot;listeners&quot;. \r\n - Will work in any browser.\r\n\r\n\r\n"},{"score":2,"body_markdown":"If you don&#39;t have to support very old browsers, here is a way to do it even when your external script is loaded with *async* attribute:\r\n\r\n    HTMLDocument.prototype.ready = new Promise(function(resolve) {\r\n       if(document.readyState != &quot;loading&quot;)\r\n          resolve();\r\n       else\r\n          document.addEventListener(&quot;DOMContentLoaded&quot;, function() {\r\n             resolve();\r\n          });\r\n    });\r\n\r\n    document.ready.then(function() {\r\n       console.log(&quot;document.ready&quot;);\r\n    });"},{"score":3,"body_markdown":"I simply use:\r\n\r\n    setTimeout(function(){\r\n        //reference/manipulate DOM here\r\n    });\r\n\r\nAnd unlike `document.addEventListener(&quot;DOMContentLoaded&quot; //etc` as in the very top answer, it works as far back as IE9 -- http://caniuse.com/#search=DOMContentLoaded only indicates as recently as IE11. \r\n\r\nInterestingly I stumbled upon this `setTimeout` solution in 2009: https://stackoverflow.com/questions/1381481/is-checking-for-the-readiness-of-the-dom-overkill, which probably could have been worded slightly better, as I meant &quot;is it overkill to use various frameworks&#39; more complicated approaches to check for the readiness of the DOM&quot;.\r\n\r\nMy best explanation for why this technique works is that, when the script with such a setTimeout has been reached, the DOM is in the middle of being parsed, so execution of the code within the setTimeout gets deferred until that operation is finished."},{"score":-1,"body_markdown":"Try this:\r\n\r\n    function ready(callback){\r\n\t    if(typeof callback === &quot;function&quot;){\r\n\t\t    document.addEventListener(&quot;DOMContentLoaded&quot;, callback);\r\n\t\t    window.addEventListener(&quot;load&quot;, callback);\r\n\t    }else{\r\n\t\t    throw new Error(&quot;Sorry, I can not run this!&quot;);\r\n\t    }\r\n    }\r\n    ready(function(){\r\n        console.log(&quot;It worked!&quot;);\r\n    });"},{"score":0,"body_markdown":"    (function(f){\r\n      if(document.readyState != &quot;loading&quot;) f();\r\n      else document.addEventListener(&quot;DOMContentLoaded&quot;, f);\r\n    })(function(){\r\n      console.log(&quot;The Document is ready&quot;);\r\n    });"},{"score":0,"body_markdown":"Most vanilla JS Ready functions do NOT consider the scenario where the `DOMContentLoaded` handler is set *after*  the document is already loaded - Which means the function will *never run*. This can happen if you look for `DOMContentLoaded` within an `async` external script (`&lt;script async src=&quot;file.js&quot;&gt;&lt;/script&gt;`).\r\n\r\nThe code below checks for `DOMContentLoaded` only if the document&#39;s `readyState` isn&#39;t already `interactive` or `complete`.\r\n\r\n    var DOMReady = function(callback) {\r\n      document.readyState === &quot;interactive&quot; || document.readyState === &quot;complete&quot; ? callback() : document.addEventListener(&quot;DOMContentLoaded&quot;, callback());\r\n    };\r\n    DOMReady(function() {\r\n      //DOM ready!\r\n    });\r\n\r\nIf you want to support IE aswell:\r\n\r\n    var DOMReady = function(callback) {\r\n        if (document.readyState === &quot;interactive&quot; || document.readyState === &quot;complete&quot;) {\r\n            callback();\r\n        } else if (document.addEventListener) {\r\n            document.addEventListener(&#39;DOMContentLoaded&#39;, callback());\r\n        } else if (document.attachEvent) {\r\n            document.attachEvent(&#39;onreadystatechange&#39;, function() {\r\n                if (document.readyState != &#39;loading&#39;) {\r\n                    callback();\r\n                }\r\n            });\r\n        }\r\n    };\r\n    \r\n    DOMReady(function() {\r\n      // DOM ready!\r\n    });\r\n\r\n"},{"score":5,"body_markdown":"# Most minimal and 100% working\r\n\r\nI have picked the answer from [PlainJS][1] and it&#39;s working fine for me. It extends `DOMContentLoaded` so that it can be accepted at all the browsers.\r\n\r\n---\r\n\r\nThis function is the equivalent of jQuery&#39;s `$(document).ready()` method:\r\n\r\n    document.addEventListener(&#39;DOMContentLoaded&#39;, function(){\r\n        // do something\r\n    });\r\n\r\nHowever, in contrast to jQuery, this code will only run properly in modern browsers (IE &gt; 8) and it won&#39;t in case the document is already rendered at the time this script gets inserted (e.g. via Ajax). Therefore, we need to extend this a little bit:\r\n\r\n    function run() {\r\n        // do something\r\n    }\r\n\r\n    // in case the document is already rendered\r\n    if (document.readyState!=&#39;loading&#39;) run();\r\n    // modern browsers\r\n    else if (document.addEventListener) \r\n    document.addEventListener(&#39;DOMContentLoaded&#39;, run);\r\n    // IE &lt;= 8\r\n    else document.attachEvent(&#39;onreadystatechange&#39;, function(){\r\n        if (document.readyState==&#39;complete&#39;) run();\r\n    });\r\n\r\nThis covers basically all possibilities and is a viable replacement for the jQuery helper.\r\n\r\n\r\n  [1]: https://plainjs.com/javascript/events/running-code-when-the-document-is-ready-15/"},{"score":11,"body_markdown":"It is year 2020 and `&lt;script&gt;` tag has `defer` attribute.\r\n\r\nfor example:\r\n\r\n    &lt;script src=&quot;demo_defer.js&quot; defer&gt;&lt;/script&gt;\r\nit specifies that the script is executed when the page has finished parsing.\r\n\r\nhttps://www.w3schools.com/tags/att_script_defer.asp"},{"score":1,"body_markdown":"# Comparison\r\n\r\nHere (in below snippet) is comparison of chosen available browser &quot;built-in&quot; methods and their execution sequence. Remarks\r\n\r\n * the `document.onload` (X) is not supported by any modern browser (event is never [fired](https://stackoverflow.com/q/5135638/860099))\r\n * if you use `&lt;body onload=&quot;bodyOnLoad()&quot;&gt;` (F) and at the same time `window.onload` (E) then only first one will be executed (because it override second one)\r\n * event handler given in `&lt;body onload=&quot;...&quot;&gt;` (F)  is wrapped by additional `onload` function\r\n * `document.onreadystatechange` (D) not override `document .addEventListener(&#39;readystatechange&#39;...)` (C) probably cecasue `onXYZevent-like` methods are independent than `addEventListener` queues (which allows add multiple listeners). Probably nothing happens between execution this two handlers.\r\n * all scripts write their timestamp in console - but scripts which also have access to `div` write their timestamps also in body (click &quot;Full Page&quot; link after script execution to see it).\r\n * solutions `readystatechange` (C,D) are executed multiple times by browser but for different document states:\r\n* *loading* - the document is loading (no fired in snippet)\r\n* *interactive* - the document is parsed, fired before `DOMContentLoaded`\r\n* *complete* - the document and resources are loaded, fired before `body/window onload`\r\n\r\n\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;html&gt;\r\n\r\n    &lt;head&gt;\r\n      &lt;script&gt;\r\n        // solution A\r\n        console.log(`[timestamp: ${Date.now()}] A: Head script`) ;\r\n        \r\n        // solution B\r\n        document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {\r\n          print(`[timestamp: ${Date.now()}] B: DOMContentLoaded`);\r\n        });\r\n\r\n        // solution C\r\n        document.addEventListener(&#39;readystatechange&#39;, () =&gt; {\r\n          print(`[timestamp: ${Date.now()}] C: ReadyState: ${document.readyState}`);\r\n        });\r\n       \r\n        // solution D\r\n        document.onreadystatechange = s=&gt; {print(`[timestamp: ${Date.now()}] D: document.onreadystatechange ReadyState: ${document.readyState}`)};\r\n        \r\n        // solution E (never executed)\r\n        window.onload = () =&gt; {\r\n          print(`E: &lt;body onload=&quot;...&quot;&gt; override this handler`);\r\n        };\r\n\r\n        // solution F\r\n        function bodyOnLoad() {\r\n          print(`[timestamp: ${Date.now()}] F: &lt;body onload=&#39;...&#39;&gt;`);      \r\n          infoAboutOnLoad(); // additional info\r\n        }\r\n        \r\n        // solution X\r\n        document.onload = () =&gt; {print(`document.onload is never fired`)};\r\n\r\n\r\n\r\n        // HELPERS\r\n\r\n        function print(txt) { \r\n          console.log(txt);\r\n          if(mydiv) mydiv.innerHTML += txt.replace(&#39;&lt;&#39;,&#39;&amp;lt;&#39;).replace(&#39;&gt;&#39;,&#39;&amp;gt;&#39;) + &#39;&lt;br&gt;&#39;;\r\n        }\r\n        \r\n        function infoAboutOnLoad() {\r\n          console.log(&quot;window.onload (after  override):&quot;, (&#39;&#39;+document.body.onload).replace(/\\s+/g,&#39; &#39;));\r\n          console.log(`body.onload==window.onload --&gt; ${document.body.onload==window.onload}`);\r\n        }\r\n                \r\n        console.log(&quot;window.onload (before override):&quot;, (&#39;&#39;+document.body.onload).replace(/\\s+/g,&#39; &#39;));\r\n\r\n      &lt;/script&gt;\r\n    &lt;/head&gt;\r\n\r\n    &lt;body onload=&quot;bodyOnLoad()&quot;&gt;\r\n      &lt;div id=&quot;mydiv&quot;&gt;&lt;/div&gt;\r\n\r\n      &lt;!-- this script must te at the bottom of &lt;body&gt; --&gt;\r\n      &lt;script&gt;\r\n        // solution G\r\n        print(`[timestamp: ${Date.now()}] G: &lt;body&gt; bottom script`);\r\n      &lt;/script&gt;\r\n    &lt;/body&gt;\r\n\r\n    &lt;/html&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"Works in all known browsers (tested via BrowserStack). IE6+, Safari 1+, Chrome 1+, Opera, etc. Uses `DOMContentLoaded`, with fallbacks to `document.documentElement.doScroll()` and `window.onload`.\r\n\r\n```\r\n/*! https://github.com/Kithraya/DOMContentLoaded v1.2.6 | MIT License */\r\n\r\nDOMContentLoaded.version = &quot;1.2.6&quot;;\r\n\r\nfunction DOMContentLoaded() { &quot;use strict&quot;;\r\n\t\r\n\tvar ael = &#39;addEventListener&#39;, rel = &#39;removeEventListener&#39;, aev = &#39;attachEvent&#39;, dev = &#39;detachEvent&#39;;\r\n\tvar alreadyRun = false, // for use in the idempotent function ready()\r\n\t    funcs = arguments;\r\n\t\r\n\t// old versions of JS return &#39;[object Object]&#39; for null.\r\n\tfunction type(obj) { return (obj === null) ? &#39;null&#39; : Object.prototype.toString.call(obj).slice(8,-1).toLowerCase() }\r\n\tfunction microtime() { return + new Date() } \r\n\t\r\n\t /* document.readyState === &#39;complete&#39; reports correctly in every browser I have tested, including IE.\r\n\t\tBut IE6 to 10 don&#39;t return the correct readyState values as per the spec:\r\n\t\treadyState is sometimes &#39;interactive&#39;, even when the DOM isn&#39;t accessible in IE6/7 so checking for the onreadystatechange event like jQuery does is not optimal\r\n\t\treadyState is complete at basically the same time as &#39;window.onload&#39; (they&#39;re functionally equivalent, within a few tenths of a second)\r\n\t\tAccessing undefined properties of a defined object (document) will not throw an error (in case readyState is undefined).\r\n\t */\r\n\t\r\n\t// Check for IE &lt; 11 via conditional compilation\r\n\t/// values: 5?: IE5, 5.5?: IE5.5, 5.6/5.7: IE6/7, 5.8: IE8, 9: IE9, 10: IE10, 11*: (IE11 older doc mode), undefined: IE11 / NOT IE\r\n\tvar jscript_version = Number( new Function(&quot;/*@cc_on return @_jscript_version; @*\\/&quot;)() ) || NaN;\r\n\t\r\n\t// check if the DOM has already loaded\r\n\tif (document.readyState === &#39;complete&#39;) { ready(null); return; }  // here we send null as the readyTime, since we don&#39;t know when the DOM became ready.\r\n\t\r\n\tif (jscript_version &lt; 9) { doIEScrollCheck(); return; } // For IE&lt;9 poll document.documentElement.doScroll(), no further actions are needed.\r\n\t\r\n\t /* \r\n\t\tChrome, Edge, Firefox, IE9+, Opera 9+, Safari 3.1+, Android Webview, Chrome for Android, Edge Mobile, \r\n\t\tFirefox for Android 4+, Opera for Android, iOS Safari, Samsung Internet, etc, support addEventListener\r\n\t\tAnd IE9+ supports &#39;DOMContentLoaded&#39; \r\n\t */\r\n\t\t\r\n\tif (document[ael]) {\r\n\t    document[ael](&quot;DOMContentLoaded&quot;, ready, false); \r\n\t    window[ael](&quot;load&quot;, ready, false); // fallback to the load event in case addEventListener is supported, but not DOMContentLoaded\r\n\t} else \r\n\tif (aev in window) { window[aev](&#39;onload&#39;, ready);\r\n\t    /* Old Opera has a default of window.attachEvent being falsy, so we use the in operator instead\r\n\t\t   https://dev.opera.com/blog/window-event-attachevent-detachevent-script-onreadystatechange/\r\n\r\n\t\t   Honestly if somebody is using a browser so outdated AND obscure (like Opera 7 where neither addEventListener \r\n\t       nor &quot;DOMContLoaded&quot; is supported, they deserve to wait for the full page).\r\n\t       I CBA testing whether readyState === &#39;interactive&#39; is truly interactive in browsers designed in 2003. I just assume it isn&#39;t (like in IE6-8). \r\n\t\t*/\r\n\t} else { // fallback to queue window.onload that will always work\r\n\t   addOnload(ready);\r\n\t}\r\n\t\r\n\t\r\n\t// This function allows us to preserve any original window.onload handlers (in super old browsers where this is even necessary), \r\n\t// while keeping the option to chain onloads, and dequeue them.\r\n\t\r\n\tfunction addOnload(fn) { var prev = window.onload; // old window.onload, which could be set by this function, or elsewhere\r\n\t\t\r\n\t\t// we add a function queue list to allow for dequeueing \r\n\t\t// addOnload.queue is the queue of functions that we will run when when the DOM is ready\r\n\t\tif ( type( addOnload.queue ) !== &#39;array&#39;) { addOnload.queue = [];\r\n\t\t\tif ( type(prev) === &#39;function&#39;) { addOnload.queue.push( prev ); } // add the previously defined event handler\r\n\t\t}\r\n\t\t\r\n\t\tif (typeof fn === &#39;function&#39;) { addOnload.queue.push(fn) }\r\n\r\n\t\twindow.onload = function() { // iterate through the queued functions\r\n\t\t\tfor (var i = 0; i &lt; addOnload.queue.length; i++) { addOnload.queue[i]() } \r\n\t\t};\r\n\t}\t\r\n\r\n\t// remove a queued window.onload function from the chain (simplified); \r\n\t\r\n\tfunction dequeueOnload(fn) { var q = addOnload.queue, i = 0;\r\n\t\r\n\t\t// sort through the queued functions in addOnload.queue until we find `fn`\r\n\t\tif (type( q ) === &#39;array&#39;) {\t\t// if found, remove from the queue\r\n\t\t\tfor (; i &lt; q.length; i++) { ;;(fn === q[i]) ? q.splice(i, 1) : 0; } // void( (fn === q[i]) ? q.splice(i, 1) : 0 ) \r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction ready(ev) { // idempotent event handler function\r\n\t    if (alreadyRun) {return} alreadyRun = true; \r\n\t\t\r\n\t\t// this time is when the DOM has loaded (or if all else fails, when it was actually possible to inference the DOM has loaded via a &#39;load&#39; event)\r\n\t\t// perhaps this should be `null` if we have to inference readyTime via a &#39;load&#39; event, but this functionality is better.\r\n\t\tvar readyTime = microtime(); \r\n\t\t\r\n\t\tdetach(); // detach any event handlers\r\n\t\t\t\t\t\t\r\n\t\t// run the functions\r\n\t\tfor (var i=0; i &lt; funcs.length; i++) {\tvar func = funcs[i];\r\n\t\t\t\r\n\t\t\tif (type(func) === &#39;function&#39;) {\r\n\t\t\t\tfunc.call(document, { &#39;readyTime&#39;: (ev === null ? null : readyTime), &#39;funcExecuteTime&#39;: microtime() }, func); \r\n\t\t\t\t// jquery calls &#39;ready&#39; with `this` being set to document, so we&#39;ll do the same. \r\n\t\t\t}\t\t\r\n\t\t}\r\n\t}\r\n\r\n\tfunction detach() {\r\n\t    if (document[rel]) { \r\n\t\t\tdocument[rel](&quot;DOMContentLoaded&quot;, ready); window[rel](&quot;load&quot;, ready);\r\n\t    } else\r\n\t\tif (dev in window) { window[dev](&quot;onload&quot;, ready); } \r\n\t    else {\r\n\t\t\tdequeueOnload(ready);\r\n\t    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t}\r\n\t\r\n\tfunction doIEScrollCheck() { // for use in IE &lt; 9 only.\r\n\t    if ( window.frameElement ) { \r\n\t\t\t// we&#39;re in an &lt;iframe&gt; or similar\r\n\t\t\t// the document.documentElemeent.doScroll technique does not work if we&#39;re not at the top-level (parent document)\r\n\r\n\t\t\ttry { window.attachEvent(&quot;onload&quot;, ready); } catch (e) { } // attach to onload if were in an &lt;iframe&gt; in IE as there&#39;s no way to tell otherwise\r\n\t\t\t\r\n\t\t\treturn;\r\n\t\t} \r\n\t\ttry {\r\n\t\t    document.documentElement.doScroll(&#39;left&#39;);\t// when this statement no longer throws, the DOM is accessible in old IE\r\n\t\t} catch(error) {\r\n\t\t    setTimeout(function() {\r\n\t\t\t\t(document.readyState === &#39;complete&#39;) ? ready() : doIEScrollCheck();\r\n\t\t    }, 50);\r\n\t\t    return;\r\n\t\t}\r\n\t\tready();\r\n\t}\r\n}\r\n```\r\n\r\nUsage:\r\n\r\n```\r\n&lt;script&gt;\r\nDOMContentLoaded(function(e) { console.log(e) });\r\n&lt;/script&gt;"},{"score":0,"body_markdown":"Nowadays you should use modules. Put your code into the default function of a module and import the function into a script element.\r\n\r\n`client.js`:\r\n~~~javascript\r\nexport default function ()\r\n{\r\n  alert (&quot;test&quot;);\r\n}\r\n~~~\r\n\r\n`index.html`:\r\n~~~html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n  &lt;head&gt;\r\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\r\n    &lt;title&gt;test&lt;/title&gt;\r\n  &lt;/head&gt;\r\n  &lt;body&gt;\r\n    &lt;script type=&quot;module&quot;&gt;\r\n      import main from &#39;./client.js&#39;;\r\n      main ();\r\n    &lt;/script&gt;\r\n  &lt;/body&gt;\r\n&lt;/html&gt;\r\n~~~\r\n"}],"score":2116}