{"body":"I&#39;m trying to write a function that either accepts a list of strings, or a single string. If it&#39;s a string, then I want to convert it to an array with just the one item so I can loop over it without fear of an error. \r\n\r\nSo how do I check if the variable is an array?\r\n\r\n---\r\n\r\nI&#39;ve rounded up the various solutions below and created a [jsperf test](https://jsperf.com/js-isarray-comparison/16). They&#39;re all fast, so just use `Array.isArray` -- it&#39;s [well-supported](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray#Browser_compatibility) now and [works across frames](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray#instanceof_vs_isArray).","title":"How to check if an object is an array?","answers":[{"score":1960,"body_markdown":"The method given in the ECMAScript standard to find the class of Object is to use the `toString` method from `Object.prototype`.\r\n\r\n    if( Object.prototype.toString.call( someVar ) === &#39;[object Array]&#39; ) {\r\n        alert( &#39;Array!&#39; );\r\n    }\r\n\r\nOr you could use `typeof` to test if it is a String:\r\n\r\n    if( typeof someVar === &#39;string&#39; ) {\r\n        someVar = [ someVar ];\r\n    }\r\n\r\nOr if you&#39;re not concerned about performance, you could just do a `concat` to a new empty Array.\r\n\r\n    someVar = [].concat( someVar );\r\n\r\nThere&#39;s also the constructor which you can query directly:\r\n\r\n    if (somevar.constructor.name == &quot;Array&quot;) {\r\n        // do something\r\n    }\r\n\r\n---\r\n\r\nCheck out a [thorough treatment][1] from [@T.J. Crowder&#39;s][2] blog, as posted in his comment below.\r\n\r\nCheck out this [benchmark][3] to get an idea which method performs better: http://jsben.ch/#/QgYAV\r\n\r\n\r\nFrom [@Bharath][4] convert string to array using Es6 for the question asked:\r\n\r\n    const convertStringToArray = (object) =&gt; {\r\n       return (typeof object === &#39;string&#39;) ? Array(object) : object \r\n    }\r\n\r\nsuppose: \r\n\r\n    let m = &#39;bla&#39;\r\n    let n = [&#39;bla&#39;,&#39;Meow&#39;]\r\n    let y = convertStringToArray(m)\r\n    let z = convertStringToArray(n)\r\n    console.log(&#39;check y: &#39;+JSON.stringify(y)) . // check y: [&#39;bla&#39;]\r\n    console.log(&#39;check y: &#39;+JSON.stringify(z)) . // check y: [&#39;bla&#39;,&#39;Meow&#39;]\r\n\r\n\r\n  [1]: http://blog.niftysnippets.org/2010/09/say-what.html\r\n  [2]: https://stackoverflow.com/users/157247/t-j-crowder\r\n  [3]: http://jsben.ch/#/QgYAV\r\n  [4]: https://stackoverflow.com/users/8432239/bharath?tab=profile"},{"score":1290,"body_markdown":"I would first check if your implementation supports `isArray`:\r\n\r\n    if (Array.isArray)\r\n        return Array.isArray(v);\r\n\r\nYou could also try using the `instanceof` operator\r\n\r\n    v instanceof Array"},{"score":5,"body_markdown":"If the only two kinds of values that could be passed to this function are a string or an array of strings, keep it simple and use a `typeof` check for the string possibility:\r\n\r\n    function someFunc(arg) {\r\n        var arr = (typeof arg == &quot;string&quot;) ? [arg] : arg;\r\n    }\r\n\r\n"},{"score":5,"body_markdown":"The best solution I&#39;ve seen is a cross-browser replacement for typeof. Check Angus Croll&#39;s solution [here][1].\r\n\r\nThe TL;DR version is below, but the article is a great discussion of the issue so you should read it if you have time.\r\n\r\n    Object.toType = function(obj) {\r\n        return ({}).toString.call(obj).match(/\\s([a-z|A-Z]+)/)[1].toLowerCase();\r\n    }\r\n    // ... and usage:\r\n    Object.toType([1,2,3]); //&quot;array&quot; (all browsers)\r\n    \r\n    // or to test...\r\n    var shouldBeAnArray = [1,2,3];\r\n    if(Object.toType(shouldBeAnArray) === &#39;array&#39;){/* do stuff */};\r\n\r\n\r\n  [1]: https://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/"},{"score":303,"body_markdown":"jQuery also offers an [`$.isArray()`](http://api.jquery.com/jQuery.isArray/) method:\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var a = [&quot;A&quot;, &quot;AA&quot;, &quot;AAA&quot;];\r\n\r\n    if($.isArray(a)) {\r\n      alert(&quot;a is an array!&quot;);\r\n    } else {\r\n      alert(&quot;a is not an array!&quot;);\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":10,"body_markdown":"I know, that people are looking for some kind of raw javascript approach.\r\nBut if you want think less about, take a look here: http://underscorejs.org/#isArray\r\n\r\n    _.isArray(object) \r\n\r\nReturns true if object is an Array.\r\n\r\n    (function(){ return _.isArray(arguments); })();\r\n    =&gt; false\r\n    _.isArray([1,2,3]);\r\n    =&gt; true"},{"score":15,"body_markdown":"I would make a function to test the type of object you are dealing with...\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function whatAmI(me){ return Object.prototype.toString.call(me).split(/\\W/)[2]; }\r\n\r\n    // tests\r\n    console.log(\r\n      whatAmI([&quot;aiming&quot;,&quot;@&quot;]),\r\n      whatAmI({living:4,breathing:4}),\r\n      whatAmI(function(ing){ return ing+&quot; to the global window&quot; }),\r\n      whatAmI(&quot;going to do with you?&quot;)\r\n    );\r\n\r\n    // output: Array Object Function String\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nthen you can write a simple if statement...\r\n\r\n    if(whatAmI(myVar) === &quot;Array&quot;){\r\n        // do array stuff\r\n    } else { // could also check `if(whatAmI(myVar) === &quot;String&quot;)` here to be sure\r\n        // do string stuff\r\n    }"},{"score":32,"body_markdown":"Simple function to check this:\r\n\r\n    function isArray(object)\r\n    {\r\n        return object.constructor === Array;\r\n    }\r\n"},{"score":17,"body_markdown":"As MDN says [in here][1]:\r\n\r\n&gt; use **Array.isArray** or **Object.prototype.toString.call** to differentiate\r\n&gt; regular objects from arrays\r\n\r\nLike this:\r\n\r\n - `Object.prototype.toString.call(arr) === &#39;[object Array]&#39;`, or\r\n\r\n - `Array.isArray(arr)`\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/typeof#Normal_cases"},{"score":34,"body_markdown":"Array.isArray works fast, but it isn&#39;t supported by all versions of browsers.\r\nSo you could make an exception for others and use universal method:\r\n\r\n        Utils = {};    \r\n        Utils.isArray = (&#39;isArray&#39; in Array) ? \r\n            Array.isArray : \r\n            function (value) {\r\n                return Object.prototype.toString.call(value) === &#39;[object Array]&#39;;\r\n            }"},{"score":5,"body_markdown":"Here&#39;s my lazy approach:\r\n\r\n    if (Array.prototype.array_ === undefined) {\r\n      Array.prototype.array_ = true;\r\n    }\r\n\r\n    // ...\r\n\r\n    var test = [],\r\n        wat = {};\r\n\r\n    console.log(test.array_ === true); // true\r\n    console.log(wat.array_ === true);  // false\r\n\r\n\r\nI know it&#39;s sacrilege to &quot;mess with&quot; the prototype, but [it appears to perform significantly better than the recommended `toString` method](http://jsperf.com/isarray-approaches).\r\n\r\n**Note:** A pitfall of this approach is that it [wont work across `iframe` boundaries](http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/), but for my use case this is not an issue."},{"score":15,"body_markdown":"You can check the type of your variable whether it is an array with;\r\n\r\n    var myArray=[];\r\n    \r\n    if(myArray instanceof Array)\r\n    {\r\n    ....\r\n    }"},{"score":0,"body_markdown":"Since I don&#39;t like any Object.prototype-calls, I searched for another solution. Especially because the solutions of ChaosPandion won&#39;t always work, and the solution of MidnightTortoise with `isArray()` doesn&#39;t work with arrays coming from the DOM (like *getElementsByTagName*). And finally I found an easy and cross-browser solution, which probably also would have worked with Netscape 4. ;)\r\n\r\nIt&#39;s just these 4 lines (checking any object `h`):\r\n\r\n    function isArray(h){\r\n        if((h.length!=undefined&amp;&amp;h[0]!=undefined)||(h.length===0&amp;&amp;h[0]===undefined)){\r\n            return true;\r\n        }\r\n        else{ return false; }\r\n    }\r\n\r\nI already tested these arrays (all return true):\r\n\r\n    1) array=d.getElementsByName(&#39;some_element&#39;); //&#39;some_element&#39; can be a real or unreal element\r\n    2) array=[];\r\n    3) array=[10];\r\n    4) array=new Array();\r\n    5) array=new Array();\r\n       array.push(&quot;whatever&quot;);\r\n\r\nCan anybody confirm that this works for all cases? Or does anybody find a case where my solution don&#39;t work?"},{"score":11,"body_markdown":"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/isArray\r\n\r\n    Array.isArray = Array.isArray || function (vArg) {\r\n        return Object.prototype.toString.call(vArg) === &quot;[object Array]&quot;;\r\n    };"},{"score":4,"body_markdown":"    A = [1,2,3]\r\n    console.log(A.map==[].map)\r\nIn search for shortest version here is what I got so far.\r\n\r\n\r\nNote, there is no perfect function that will always detect all possible combinations. **It is better to know all abilities and limitations of your tools than expect a magic tool.**"},{"score":4,"body_markdown":"\r\n    function isArray(value) {\r\n        if (value) {\r\n            if (typeof value === &#39;object&#39;) {\r\n                return (Object.prototype.toString.call(value) == &#39;[object Array]&#39;)\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    var ar = [&quot;ff&quot;,&quot;tt&quot;]\r\n    alert(isArray(ar))\r\n\r\n"},{"score":5,"body_markdown":"There is a nice example in Stoyan Stefanov&#39;s book [JavaScript Patterns][1] which suppose to handle all possible problems as well as utilize ECMAScript 5 method [Array.isArray()][2].\r\n\r\nSo here it is:\r\n\r\n    if (typeof Array.isArray === &quot;undefined&quot;) {\r\n        Array.isArray = function (arg) {\r\n            return Object.prototype.toString.call(arg) === &quot;[object Array]&quot;;\r\n        };\r\n    }\r\n\r\nBy the way, if you are using jQuery, you can use it&#39;s method [$.isArray()][3]\r\n\r\n\r\n  [1]: http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\r\n  [3]: http://api.jquery.com/jQuery.isArray/"},{"score":1181,"body_markdown":"In modern browsers you can do:\r\n\r\n    Array.isArray(obj)\r\n([Supported by][1] Chrome 5, Firefox 4.0, IE 9, Opera 10.5 and Safari 5)\r\n\r\nFor backward compatibility you can add the following:\r\n    \r\n    // only implement if no native implementation is available\r\n    if (typeof Array.isArray === &#39;undefined&#39;) {\r\n      Array.isArray = function(obj) {\r\n        return Object.prototype.toString.call(obj) === &#39;[object Array]&#39;;\r\n      }\r\n    };\r\n\r\nIf you use jQuery you can use `jQuery.isArray(obj)` or `$.isArray(obj)`. If you use underscore you can use `_.isArray(obj)`.\r\n\r\nIf you don&#39;t need to detect arrays created in different frames you can also just use `instanceof`:\r\n\r\n    obj instanceof Array\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"},{"score":4,"body_markdown":"A simple function for testing if an input value is an array is the following:\r\n\r\n    function isArray(value)\r\n    {\r\n      return Object.prototype.toString.call(value) === &#39;[object Array]&#39;;\r\n    }\r\n\r\nThis works cross browser, and with older browsers. This is [pulled from T.J. Crowders&#39; blog post](http://blog.niftysnippets.org/2010/09/say-what.html)"},{"score":12,"body_markdown":"This is my attempt to improve on [this answer][1] taking into account the comments:\r\n\r\n    var isArray = myArray &amp;&amp; myArray.constructor === Array;\r\n\r\nIt gets rid of the if/else, and accounts for the possibility of the array being null or undefined\r\n\r\n  [1]: https://stackoverflow.com/a/12268916/34806"},{"score":13,"body_markdown":"I do this in a very simple way. Works for me. Any drawbacks?\r\n\r\n    Array.prototype.isArray = true;\r\n    \r\n    a=[]; b={};\r\n    a.isArray  // true\r\n    b.isArray  // (undefined -&gt; false)"},{"score":1,"body_markdown":"I know this is an old question but here is a solution that I came up with and have been using for my projects...\r\n\r\n    function isArray (o) {\r\n        return typeof o === &quot;object&quot; &amp;&amp; o.length !== undefined;\r\n    }\r\n\r\n    isArray({}); // false\r\n    isArray(1); // false\r\n    isArray(&quot;str&quot;); // false\r\n    isArray(function(){}); // false\r\n\r\n    isArray([]); // true\r\n\r\n\r\nThe only pitfall is that it will give a false positive if your object happens to have a length property:\r\n\r\n    isArray({length:0}); // true\r\n\r\nIf you are okay with that drawback and know your pure objects won&#39;t have that property, it&#39;s a clean solution and should be faster than the Object.prototype.toString.call method."},{"score":1,"body_markdown":"    \r\n    var is_array = function (value) {\r\n       return value &amp;&amp;\r\n         typeof value === &#39;object&#39; &amp;&amp;\r\n         typeof value.length === &#39;number&#39; &amp;&amp;\r\n         typeof value.splice === &#39;function&#39; &amp;&amp;\r\n        !(value.propertyIsEnumerable(&#39;length&#39;));\r\n    };\r\n\r\nThis function has been taken from &quot;JS the good parts&quot; book, works perfect for me."},{"score":-4,"body_markdown":"     var length = 16;                               // Number\r\n     var lastName = &quot;Johnson&quot;;                      // String\r\n     var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];           // Array\r\n     var x = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;};\r\n     \r\n     Object.prototype.myCheck= function(){\r\n     if (this.constructor === Array){\r\n              alert(&#39;array&#39;);\r\n            }else if (this.constructor === Object)\r\n           {\r\n             alert(&#39;object&#39;);\r\n            }else if (this.constructor === Number)\r\n            {\r\n              alert(&#39;number&#39;);\r\n            }else if (this.constructor === String)\r\n            {\r\n              alert(&#39;string&#39;);\r\n            }\r\n\r\n     }\r\n     cars.myCheck();\r\n     lastName.myCheck();\r\n     length.myCheck();"},{"score":11,"body_markdown":"I have updated the [jsperf fiddle][1] with two alternative methods as well as error checking.\r\n\r\nIt turns out that the method defining a constant value in the &#39;Object&#39; and &#39;Array&#39; prototypes is faster than any of the other methods.  It is a somewhat surprising result.\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    /* Initialisation */\r\n    Object.prototype.isArray = function() {\r\n      return false;\r\n    };\r\n    Array.prototype.isArray = function() {\r\n      return true;\r\n    };\r\n    Object.prototype._isArray = false;\r\n    Array.prototype._isArray = true;\r\n\r\n    var arr = [&quot;1&quot;, &quot;2&quot;];\r\n    var noarr = &quot;1&quot;;\r\n\r\n    /* Method 1 (function) */\r\n    if (arr.isArray()) document.write(&quot;arr is an array according to function&lt;br/&gt;&quot;);\r\n    if (!noarr.isArray()) document.write(&quot;noarr is not an array according to function&lt;br/&gt;&quot;);\r\n    /* Method 2 (value) - **** FASTEST ***** */\r\n    if (arr._isArray) document.write(&quot;arr is an array according to member value&lt;br/&gt;&quot;);\r\n    if (!noarr._isArray) document.write(&quot;noarr is not an array according to member value&lt;br/&gt;&quot;);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThese two methods do not work if the variable takes the undefined value, but they do work if you are certain that they have a value.  With regards to checking with performance in mind if a value is an array or a single value, the second method looks like a valid fast method.  It is slightly faster than &#39;instanceof&#39; on Chrome, twice as fast as the second best method in Internet Explorer, Opera and Safari (on my machine).\r\n\r\n  [1]: http://jsperf.com/check-isarray/3 &quot;jsperf&quot;"},{"score":107,"body_markdown":"This is the fastest among all methods (all browsers supported):\r\n    \r\n    function isArray(obj){\r\n        return !!obj &amp;&amp; obj.constructor === Array;\r\n    }"},{"score":4,"body_markdown":"You can try this:\r\n\r\n    var arr = []; (or) arr = new Array();\r\n    var obj = {}; (or) arr = new Object();\r\n    \r\n    arr.constructor.prototype.hasOwnProperty(&#39;push&#39;) //true\r\n    \r\n    obj.constructor.prototype.hasOwnProperty(&#39;push&#39;) // false"},{"score":0,"body_markdown":"You can use this function to get data type.\r\n\r\n    var myAr  = [1,2];\r\n\r\n    checkType(myAr);\r\n\r\n    function checkType(data){\r\n      if(typeof data ===&#39;object&#39;){\r\n        if(Object.prototype.toString.call(data).indexOf(&#39;Array&#39;)!==(-1)){\r\n          return &#39;array&#39;;\r\n        } else{\r\n          return &#39;object&#39;;\r\n        }\r\n      } else {\r\n        return typeof data;\r\n      }\r\n    }\r\n\r\n    if(checkType(myAr) === &#39;array&#39;){console.log(&#39;yes, It is an array&#39;)};\r\n\r\n"},{"score":5,"body_markdown":"The following could be used if you know that your object doesn&#39;t have a concat method.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n&lt;!-- language: lang-js --&gt;\r\n    var arr = [];\r\n    if (typeof arr.concat === &#39;function&#39;) {\r\n        console.log(&quot;It&#39;s an array&quot;);\r\n    }\r\n&lt;!-- end snippet --&gt;"},{"score":5,"body_markdown":"This function will turn almost anything into an array:\r\n\r\n    function arr(x) {\r\n        if(x === null || x === undefined) {\r\n            return [];\r\n        }\r\n        if(Array.isArray(x)) {\r\n            return x;\r\n        }\r\n        if(isString(x) || isNumber(x)) {\r\n            return [x];\r\n        }\r\n        if(x[Symbol.iterator] !== undefined || x.length !== undefined) {\r\n            return Array.from(x);\r\n        }\r\n        return [x];\r\n    }\r\n\r\n    function isString(x) {\r\n        return Object.prototype.toString.call(x) === &quot;[object String]&quot;\r\n    }\r\n    \r\n    function isNumber(x) {\r\n        return Object.prototype.toString.call(x) === &quot;[object Number]&quot;\r\n    }\r\n\r\nIt uses some newer browser features so you may want to polyfill this for maximum support.\r\n\r\nExamples:\r\n\r\n    &gt; arr(null);\r\n    []\r\n    &gt; arr(undefined)\r\n    []\r\n    &gt; arr(3.14)\r\n    [ 3.14 ]\r\n    &gt; arr(1/0)\r\n    [ Infinity ]\r\n    &gt; gen = function*() { yield 1; yield 2; yield 3; }\r\n    [Function: gen]\r\n    &gt; arr(gen())\r\n    [ 1, 2, 3 ]\r\n    &gt; arr([4,5,6])\r\n    [ 4, 5, 6 ]\r\n    &gt; arr(&quot;foo&quot;)\r\n    [ &#39;foo&#39; ]\r\n\r\nN.B. strings will be converted into an array with a single element instead of an array of chars. Delete the `isString` check if you would prefer it the other way around.\r\n\r\nI&#39;ve used `Array.isArray` here because it&#39;s the [most robust](http://web.mit.edu/jwalden/www/isArray.html) and also simplest."},{"score":49,"body_markdown":"Imagine you have this **array below**: \r\n\r\n    var arr = [1,2,3,4,5];\r\n\r\nJavascript (new and older browsers):\r\n\r\n    function isArray(arr) {\r\n      return arr.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;\r\n    }\r\n\r\nor\r\n\r\n    function isArray(arr) {\r\n      return arr instanceof Array;\r\n    }\r\n\r\nor \r\n \r\n\r\n    function isArray(arr) {\r\n      return Object.prototype.toString.call(arr) === &#39;[object Array]&#39;;\r\n    }\r\n\r\nthen call it like this:\r\n\r\n    isArray(arr);\r\n\r\nJavascript (IE9+, Ch5+, FF4+, Saf5+, Opera10.5+) \r\n\r\n    Array.isArray(arr);\r\n\r\njQuery:\r\n\r\n    $.isArray(arr);\r\n\r\nAngular:\r\n\r\n    angular.isArray(arr);\r\n\r\nUnderscore and Lodash:\r\n\r\n    _.isArray(arr);\r\n\r\n"},{"score":5,"body_markdown":"easiest and fastest way to check if an Object is an Array or not.\r\n \r\n\r\n     var arr = [];\r\n      arr.constructor.name ===&#39;Array&#39;  //return true;\r\nor \r\n\r\n    arr.constructor ===Array //return true;\r\n\r\nor you can make a utility function:\r\n\r\n    function isArray(obj){ return obj &amp;&amp; obj.constructor ===Array}\r\n\r\nusage:\r\n\r\n    isArray(arr); //return true"},{"score":0,"body_markdown":"You can find with `push` like below:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\nfunction isArray(obj){\r\n   return (typeof obj.push=== &#39;function&#39;)?true:false;\r\n}\r\n\r\nvar array=new Array();\r\nor\r\nvar array=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];\r\nconsole.log(isArray(array));\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":18,"body_markdown":"There&#39;s just one line solution for this question\r\n\r\n    x instanceof Array\r\n\r\nwhere x is the variable it will return true if x is an array and false if it is not."},{"score":4,"body_markdown":"In your case you may use `concat` method of [Array][1] which can accept single objects as well as array (and even combined):\r\n\r\n    function myFunc(stringOrArray)\r\n    {\r\n      var arr = [].concat(stringOrArray);\r\n    \t\r\n      console.log(arr);\r\n      \r\n      arr.forEach(function(item, i)\r\n      {\r\n        console.log(i, &quot;=&quot;, item);\r\n      })\r\n    }\r\n\r\n    myFunc(&quot;one string&quot;);\r\n\r\n    myFunc([&quot;one string&quot;, &quot;second&quot;, &quot;third&quot;]);\r\n`concat` seems to be one of the oldest methods of Array (even IE 5.5 knows it well).\r\n\r\n\r\n  [1]: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat"},{"score":5,"body_markdown":"You could is isArray method but I would prefer to check with \r\n\r\n`Object.getPrototypeOf(yourvariable) === Array.prototype`\r\n\r\n"},{"score":-1,"body_markdown":"Here&#39;s what I use:\r\n\r\n    function isArray(input) {\r\n      if (input instanceof Array || Object.prototype.toString.call(input) === &#39;[object Array]&#39;) {\r\n            return true;\r\n      } else return false;\r\n    }"},{"score":2,"body_markdown":"Thankfully, ECMA 5 introduced `Array.isArray()` back in December 2009. If for some reason, you are using a version of JavaScript older than ECMA 5, please upgrade.\r\n\r\nIf you insist on it, though, then arrays do have certain properties that differentiate them from any other type. Properties that I haven&#39;t seen mentioned in any of the other answers. Let&#39;s get into some JavaScript politics.\r\n\r\nAn array is an object (`typeof [] === &quot;object&quot;`), but unlike traditional objects, they have a length property (`typeof ( {} ).length === &quot;undefined&quot;`). `null` is *also* an object (`typeof null === &quot;object&quot;`), but you can&#39;t access a property of `null` because `null` is *not* an object. This is a bug in the spec that goes all the way back to the very beginning of JavaScript, when objects had the type tag `0` and `null` was represented as a literal null pointer `0x00`, which caused the interpreter to confuse it with objects. \r\n\r\nUnfortunately, this doesn&#39;t account for `[]` vs `{length:0}`. So we must now turn to the prototype chain.\r\n\r\n`( [] ).__proto__ === Array.prototype &amp;&amp; ( [] ).__proto__ !== Object.prototype`.\r\n\r\nThus, without `Array.isArray()`, this is just about the closest we can get:\r\n\r\n    function is_array(array){\r\n        return array !== null\r\n            &amp;&amp; typeof array === &quot;object&quot;\r\n            &amp;&amp; array.__proto__ === Array.prototype;\r\n    }\r\n\r\n    [ [], [1,2,3], {length: 0}, {},\r\n      1, 0, Infinity, NaN, &quot;1&quot;, &quot;[1,2,3]&quot;,\r\n      null, undefined, [null], [undefined], {a:[]},\r\n      [{}], [{length: 0}], [Infinity], [NaN],\r\n      {__proto__: Array.prototype}\r\n    ].filter(is_array)\r\n    // Expected: [ [], [1,2,3], [null], [undefined], [{}], [{length: 0}], [Infinity], [NaN] ]\r\n    // Actual:   [ [], [1,2,3], [null], [undefined], [{}], [{length: 0}], [Infinity], [NaN], {__proto__: Array.prototype} ]\r\n\r\nThe object maliciously designed to look just like an array actually passes the turing test. However, replacing the prototype chain with the Array prototype chain is enough to make it act just like an array, effectively making it an array. The only thing in the world that can tell such an object is actually not an array, is `Array.isArray()`. But for the purposes you would usually be checking if an object is an array, said object should play nice with your code. Even the behavior when you change the length of the array artificially is the same: if the length is longer than the number of elements in the array, you WILL have &quot;empty slots&quot; of that special &quot;implicit undefined&quot; type that is somehow distinct from undefined while also being `=== undefined`; the very same type that is the reason we use `typeof obj !== &quot;undefined&quot;` to avoid throwing a `ReferenceError` because `obj === undefined` only *doesn&#39;t* throw an error if `obj` was explicitly defined as `undefined`.\r\n\r\n    a = {__proto__: Array.prototype}; // Array {}\r\n    a.push(5)\r\n    a // [5]\r\n    a.length = 5\r\n    a // [5, empty x 4]\r\n    b = a.map(n =&gt; n*n) // [25, empty x 4]\r\n    b.push(undefined)\r\n    b.push(undefined)\r\n    b // [25, empty x 4, undefined, undefined]\r\n    b[1] // undefined\r\n    b[1] === b[5] // true\r\n    Array.isArray(a) // false\r\n    Array.isArray(b) // true\r\n\r\nDon&#39;t use `is_array()`, though. It&#39;s one thing to reinvent the wheel for learning purposes. It&#39;s another thing to do it in production code. Don&#39;t even use it as a polyfill. Supporting old JS versions means supporting old browsers means encouraging the use of insecure software means putting the user at risk for malware."},{"score":-1,"body_markdown":"You can also check with array&#39;s  length property. When you will try to access length property of an array, it will return a number(0 for empty array) while if you try to access the length property of object it will return undefined.\r\n\r\n    if(Object.prototype.toString.call(arrayList) === &#39;[object Array]&#39;) {\r\n      console.log(&#39;Array!&#39;);\r\n    }\r\n"},{"score":2,"body_markdown":"Other methods also exist to check but I prefer the following method \r\nas my best to check (as you can easily check types of other objects).\r\n\r\n\t&gt; a = [1, 2]\r\n\t[ 1, 2 ]\r\n\t&gt;\r\n\t&gt; Object.prototype.toString.call(a).slice(8,).replace(/\\]$/, &#39;&#39;)\r\n\t&#39;Array&#39;\r\n\t&gt;\r\n    &gt; Object.prototype.toString.call([]).slice(8,-1) // best approach\r\n\t&#39;Array&#39;\r\n\r\nExplanation (with simple examples on Node REPL)&amp;raquo;\r\n\r\n\t&gt; o = {&#39;ok&#39;: 1}\r\n\t{ ok: 1 }\r\n\t&gt; a = [1, 2]\r\n\t[ 1, 2 ]\r\n\t&gt; typeof o\r\n\t&#39;object&#39;\r\n\t&gt; typeof a\r\n\t&#39;object&#39;\r\n\t&gt;\r\n\t&gt; Object.prototype.toString.call(o)\r\n\t&#39;[object Object]&#39;\r\n\t&gt; Object.prototype.toString.call(a)\r\n\t&#39;[object Array]&#39;\r\n\t&gt;\r\n\r\nObject or Array &amp;raquo;\r\n\r\n\t&gt; Object.prototype.toString.call(o).slice(8,).replace(/\\]$/, &#39;&#39;)\r\n\t&#39;Object&#39;\r\n\t&gt;\r\n\t&gt; Object.prototype.toString.call(a).slice(8,).replace(/\\]$/, &#39;&#39;)\r\n\t&#39;Array&#39;\r\n\t&gt;\r\n\r\nNull or Undefined &amp;raquo;\r\n\r\n\t&gt; Object.prototype.toString.call(undefined).slice(8,).replace(/\\]$/, &#39;&#39;)\r\n\t&#39;Undefined&#39;\r\n\t&gt; Object.prototype.toString.call(null).slice(8,).replace(/\\]$/, &#39;&#39;)\r\n\t&#39;Null&#39;\r\n\t&gt;\r\n\r\nString &amp;raquo;\r\n\r\n\t&gt; Object.prototype.toString.call(&#39;ok&#39;).slice(8,).replace(/\\]$/, &#39;&#39;)\r\n\t&#39;String&#39;\r\n\r\nNumber &amp;raquo;\r\n\r\n\t&gt; Object.prototype.toString.call(19).slice(8,).replace(/\\]$/, &#39;&#39;)\r\n\t&#39;Number&#39;\r\n\t&gt; Object.prototype.toString.call(19.0).slice(8,).replace(/\\]$/, &#39;&#39;)\r\n\t&#39;Number&#39;\r\n\t&gt; Object.prototype.toString.call(19.7).slice(8,).replace(/\\]$/, &#39;&#39;)\r\n\t&#39;Number&#39;\r\n\t&gt;\r\n\r\nI appreciate `@mpen`&#39;s suggestion to use -1 in place of regular expression as follows.\r\n\r\n\t&gt; Object.prototype.toString.call(12).slice(8,-1)\r\n\t&#39;Number&#39;\r\n\t&gt;\r\n\t&gt; Object.prototype.toString.call(12.0).slice(8,-1)\r\n\t&#39;Number&#39;\r\n\t&gt;\r\n\t&gt; Object.prototype.toString.call([]).slice(8,-1)\r\n\t&#39;Array&#39;\r\n\t&gt; Object.prototype.toString.call({}).slice(8,-1)\r\n\t&#39;Object&#39;\r\n\t&gt;\r\n\t&gt; Object.prototype.toString.call(&#39;&#39;).slice(8,-1)\r\n\t&#39;String&#39;\r\n\t&gt;\r\n\r\n\r\n"},{"score":0,"body_markdown":"there is a difference between checkout it&#39;s prototype and Array.isArray:\r\n\r\n    function isArray(obj){\r\n        return Object.getPrototypeOf(obj) === Array.prototype\r\n    }\r\n\r\nthis function  will directly check if an obj is an array\r\n\r\nbut for this Proxy object:\r\n\r\n    var arr = [1,2,3]\r\n    \r\n    var proxy = new Proxy(arr,{})\r\n    \r\n    console.log(Array.isArray(proxy)) // true\r\n\r\n`Array.isArray` will take it as Array."},{"score":0,"body_markdown":"Here&#39;s a code snippet that&#39;ll explain an important fact of arrays that should be known early on while learning JS (unlike me).\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // this functions puts a string inside an array\r\n    var stringInsideArray = function(input) {\r\n      if (typeof input === &#39;string&#39;) {\r\n        return [input];\r\n      }\r\n      else if (Array.isArray(input)) {\r\n        return input;\r\n      } \r\n      else {\r\n        throw new Error(&quot;Input is not a string!&quot;);\r\n      }\r\n    }\r\n\r\n    var output = stringInsideArray(&#39;hello&#39;);\r\n    console.log(&#39;step one output: &#39;, output); // [&quot;hello&quot;]\r\n\r\n    // use typeof method to verify output is an object\r\n    console.log(&#39;step two output: &#39;, typeof output); // object\r\n\r\n    // use Array.isArray() method to verify output is an array\r\n    console.log(&#39;step three output: &#39;, Array.isArray(output)); // true\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n[Arrays][1], are in fact, objects.\r\n\r\nUsing the [typeof][2] operator, the output of `stringInsideArray(&#39;hello&#39;)` proves that `[&quot;hello&quot;]` is **really** an object. This baffled me for the longest time because I assumed that arrays would be a JavaScript data type...\r\n\r\nThere are only 7 JS data types and arrays are [**NOT**][3] one of them.\r\n\r\nTo answer your question, using the [Array.isArray()][4] method determines that the `output` is an array.\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"},{"score":5,"body_markdown":"The best practice is to compare it using `constructor`, something like this\r\n\r\n    if(some_variable.constructor === Array){\r\n      // do something\r\n    }\r\n\r\nYou can use other methods too like `typeOf`, converting it to a string and then comparing but comparing it with dataType is always a better approach."},{"score":2,"body_markdown":"I know this is an old question, but i found the shortest answer now:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var x = [1,2,3]\r\n    console.log(x.map?1:0)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"`Array.isArray` is the way to go about this. For example:\r\n\r\n```\r\nvar arr = [&#39;tuna&#39;, &#39;chicken&#39;, &#39;pb&amp;j&#39;];\r\nvar obj = {sandwich: &#39;tuna&#39;, chips: &#39;cape cod&#39;};\r\n\r\n// Returns true\r\nArray.isArray(arr);\r\n\r\n// Return false\r\nArray.isArray(obj);\r\n\r\n```\r\n"},{"score":0,"body_markdown":"first you can check console.log(typeof Object)\r\n\r\nif the output is object then \r\nvar {data}=object ie just destructure the object according to the object keys. \r\nand the function can be like this.\r\n\r\n    const abc=(str1,str2=null)=&gt;{\r\n     \r\n    \r\n         var result=[];\r\n          result.push(str1);result.push(str2);\r\n          return result.join(&quot;&quot;);\r\n    \r\n    }\r\n\r\n"},{"score":1,"body_markdown":"Although there&#39;s some solid answers I would prefer a functional approach using a Functor. A Functor is just a fancy way to say that we will be passing a function to a value. (The suggestions that I&#39;ve seen are passing values to a function)\r\n\r\n\r\n**Create a TypeOf helper**\r\n```\r\nconst TypeOf = obj =&gt; Object.prototype.toString.call(obj).slice(8,-1);\r\n```\r\nThis is similar to typeof but now returns `Array` for `[]` and `Object` for `{}`. I like to think of it as a strict typeof. If you&#39;re working on the gmail application and performance is a concern then you can do something like this.\r\n\r\n```\r\nconst TypeOf = obj =&gt; (\r\n  Array.isArray(obj)\r\n   ? &quot;array&quot;\r\n    : obj === null // catch null edge case.  typeof null is an object :)\r\n   ? null\r\n    : typeof obj\r\n)\r\n```\r\n\r\nYou could stop here and call it a day, however you could make it a bit more powerful using composition.  You get a lot of benefits if you created a TypeBox Functor, again fancy word for passing a function to a value instead of passing a value to a function.\r\n\r\n**Create TypeBox**\r\n```\r\nconst TypeBox = (predicate, defaultValue) =&gt; {\r\n  const TypePredicate = value =&gt; ({\r\n     value,\r\n     map: cb =&gt; predicate(value)\r\n                ? TypePredicate(cb(value))\r\n                : TypePredicate(defaultValue)\r\n  });\r\n  return TypePredicate;\r\n}\r\n```\r\nThere&#39;s a lot going on here, but it&#39;s very powerful.  The TypeBox function uses a closure and returns our Functor.  Closures give you access to Lexical_Scope, think of it as a backpack that holds the things you want access to later. \r\n\r\n**Create ArrayBox**\r\n```\r\nconst ArrayBox = TypeOf(obj =&gt; TypeOf(obj) === &#39;Array&#39; ? obj : [obj]);\r\n```\r\nArrayBox is passing our `predicate` and `defaultValue` to `TypeOf` and will be available when we invoke/execute `ArrayBox`(name it whatever makes sense for your use case).\r\n\r\n**Now the fun part**\r\n\r\nIf the input is an Array, return it.\r\n```\r\nArrayBox([&quot;foo&quot;, &quot;bar&quot;]).value; // [&#39;foo&#39;, &#39;bar&#39;]\r\n```\r\n\r\nIf the input is not an array, return it in one\r\n```\r\nArrayBox(&quot;foo&quot;).value // [&quot;foo&quot;]\r\n```\r\n\r\nWhat&#39;s great about this approach is that it scales, is easy to test, and it uses composition.  You can compose the functions in any manner to get the desired result.\r\n\r\nThere&#39;s many other ways we could approach this using Either or Monads.\r\n"},{"score":4,"body_markdown":"    var a = [], b = {};\r\n    \r\n    console.log(a.constructor.name == &quot;Array&quot;);\r\n    console.log(b.constructor.name == &quot;Object&quot;);"},{"score":0,"body_markdown":"Exotic one\r\n-\r\n\r\nYou want to check if the parameter is string or not - so try\r\n\r\n    x===x+&#39;&#39;\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let isStr = x=&gt; x===x+&#39;&#39;;\r\n\r\n    console.log( isStr([]) );\r\n    console.log( isStr([&quot;aa&quot;,&quot;bb&quot;]) );\r\n    console.log( isStr(&quot;&quot;) );\r\n    console.log( isStr(&quot;abc&quot;) );\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"Array.isArray(obj), does not give very helpful results. I&#39;ve created a prototype method of Object, that seems to correctly determine whether and object is an array or not.\r\n\r\nThe only edge case that I know of where it fails is when item in the array is set to undefined.\r\n\r\n    Object.prototype.isArrayLike = function()\r\n    {\r\n\t    var length = this.length || Object.keys(this).length;\r\n\t    if (length === 0 || this.constructor.name === &quot;String&quot;)\r\n\t    \treturn false;\r\n\t    for (i = 0; i &lt; length; i++)\r\n\t    {\r\n\t\t    if (typeof this[i] === &quot;undefined&quot;)\r\n\t\t\t    return false;\r\n\t    }\r\n\t    return true;\r\n    };\r\n\r\n    var arr = [&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;, &#39;ddd&#39;];\r\n    var arr1 = {&quot;0&quot;:&#39;aaa&#39;, &quot;1&quot;:&#39;bbb&#39;, 2:&#39;ccc&#39;, 3:&#39;ddd&#39;};\r\n    var arr2 = {&quot;0&quot;:&#39;aaa&#39;, &quot;a&quot;:&#39;bbb&#39;, 2:&#39;ccc&#39;, 3:&#39;ddd&#39;};\r\n    var arr3 = &quot;qwerty&quot;;\r\n    var arr4 = [];\r\n    var arr5 = {0:&#39;aaa&#39;, 1:&#39;bbb&#39;, 2:&#39;ccc&#39;, 3:&#39;ddd&#39;};\r\n\r\n    console.log(&quot;arrayLike:&quot; + arr.isArrayLike());\r\n    console.log(&quot;Array.isArray(arr):&quot; + Array.isArray(arr));\r\n    // arrayLike: true\r\n    // Array.isArray(arr): true\r\n    console.log(&quot;arrayLike1:&quot; + arr1.isArrayLike());\r\n    console.log(&quot;Array.isArray(arr1):&quot; + Array.isArray(arr1));\r\n    // arrayLike1: true\r\n    // Array.isArray(arr1): false\r\n    console.log(&quot;arrayLike2:&quot; + arr2.isArrayLike());\r\n    console.log(&quot;Array.isArray(arr2):&quot; + Array.isArray(arr2));\r\n    // arrayLike2: false\r\n    // Array.isArray(arr2): false\r\n    console.log(&quot;arrayLike3:&quot; + arr3.isArrayLike());\r\n    console.log(&quot;Array.isArray(arr3):&quot; + Array.isArray(arr3));\r\n    // arrayLike3: false\r\n    // Array.isArray(arr3): false\r\n    console.log(&quot;arrayLike4:&quot; + arr4.isArrayLike());\r\n    console.log(&quot;Array.isArray(arr4):&quot; + Array.isArray(arr4));\r\n    // arrayLike4: false\r\n    // Array.isArray(arr4): true\r\n    console.log(&quot;arrayLike5:&quot; + arr5.isArrayLike());\r\n    console.log(&quot;Array.isArray(arr5):&quot; + Array.isArray(arr5));\r\n    // arrayLike5: false\r\n    // Array.isArray(arr5): true"}],"score":2910}