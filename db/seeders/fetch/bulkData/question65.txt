{"body":"I have a JavaScript object. Is there a built-in or accepted best practice way to get the length of this object?\r\n\r\n    const myObject = new Object();\r\n    myObject[&quot;firstname&quot;] = &quot;Gareth&quot;;\r\n    myObject[&quot;lastname&quot;] = &quot;Simpson&quot;;\r\n    myObject[&quot;age&quot;] = 21;\r\n\r\n","title":"Length of a JavaScript object","answers":[{"score":36,"body_markdown":"I&#39;m not a JavaScript expert, but it looks like you would have to loop through the elements and count them since Object doesn&#39;t have a length method:\r\n\r\n    var element_count = 0;\r\n    for (e in myArray) {  if (myArray.hasOwnProperty(e)) element_count++; }\r\n\r\n@palmsey: In fairness to the OP, the JavaScript documentation actually explicitly refer to using variables of type Object in this manner as &quot;associative arrays&quot;.\r\n"},{"score":20,"body_markdown":"Here&#39;s how and don&#39;t forget to check that the property is not on the prototype chain:\r\n\r\n    var element_count = 0;\r\n    for(var e in myArray)\r\n        if(myArray.hasOwnProperty(e))\r\n            element_count++;"},{"score":14,"body_markdown":"&gt;&gt; @palmsey: In fairness to the OP, the JavaScript documentation  actually explicitly refer to using variables of type Object in this manner as &quot;associative arrays&quot;.\r\n\r\nAnd in fairness to @palmsey he was quite correct. They aren&#39;t associative arrays; they&#39;re definitely objects :) - doing the job of an associative array. But as regards to the wider point, you definitely seem to have the right of it according to this rather fine article I found:\r\n\r\n*[JavaScript “Associative Arrays” Considered Harmful][1]*\r\n\r\nBut according to all this, [the accepted answer][2] itself is bad practice?\r\n\r\n&gt;&gt; Specify a prototype size() function for Object\r\n\r\nIf anything else has been added to Object .prototype, then the suggested code will fail:\r\n\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    Object.prototype.size = function () {\r\n      var len = this.length ? --this.length : -1;\r\n        for (var k in this)\r\n          len++;\r\n      return len;\r\n    }\r\n    Object.prototype.size2 = function () {\r\n      var len = this.length ? --this.length : -1;\r\n        for (var k in this)\r\n          len++;\r\n      return len;\r\n    }\r\n    var myArray = new Object();\r\n    myArray[&quot;firstname&quot;] = &quot;Gareth&quot;;\r\n    myArray[&quot;lastname&quot;] = &quot;Simpson&quot;;\r\n    myArray[&quot;age&quot;] = 21;\r\n    alert(&quot;age is &quot; + myArray[&quot;age&quot;]);\r\n    alert(&quot;length is &quot; + myArray.size());\r\n    &lt;/script&gt;\r\n\r\nI don&#39;t think that answer should be the accepted one as it can&#39;t be trusted to work if you have any other code running in the same execution context. To do it in a robust fashion, surely you would need to define the size method within myArray and check for the type of the members as you iterate through them.\r\n\r\n  [1]: http://andrewdupont.net/2006/05/18/javascript-associative-arrays-considered-harmful/\r\n  [2]: https://stackoverflow.com/questions/5223/length-of-javascript-associative-array#5234\r\n\r\n\r\n\r\n"},{"score":2722,"body_markdown":"The most robust answer (i.e. that captures the intent of what you&#39;re trying to do while causing the fewest bugs) would be:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n        Object.size = function(obj) {\r\n            var size = 0, key;\r\n            for (key in obj) {\r\n                if (obj.hasOwnProperty(key)) size++;\r\n            }\r\n            return size;\r\n        };\r\n\r\n        // Get the size of an object\r\n        const myObj = {}\r\n        var size = Object.size(myObj);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThere&#39;s a sort of convention in JavaScript that you [don&#39;t add things to Object.prototype][1], because it can break enumerations in various libraries. Adding methods to Object is usually safe, though.\r\n\r\n------------\r\n\r\n**Here&#39;s an update as of 2016 and [widespread deployment of ES5][2] and beyond.**  For IE9+ and all other modern ES5+ capable browsers, you can use [`Object.keys()`][3] so the above code just becomes:\r\n\r\n```\r\nvar size = Object.keys(myObj).length;\r\n```\r\n  \r\n\r\nThis doesn&#39;t have to modify any existing prototype since `Object.keys()` is now built-in.\r\n\r\n**Edit**: Objects can have symbolic properties that can not be returned via Object.key method. So the answer would be incomplete without mentioning them.\r\n\r\nSymbol type was added to the language to create unique identifiers for object properties. The main benefit of the Symbol type is the prevention of overwrites.\r\n\r\n`Object.keys` or `Object.getOwnPropertyNames` does not work for symbolic properties. To return them you need to use `Object.getOwnPropertySymbols`.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n      var person = {\r\n          [Symbol(&#39;name&#39;)]: &#39;John Doe&#39;,\r\n          [Symbol(&#39;age&#39;)]: 33,\r\n          &quot;occupation&quot;: &quot;Programmer&quot;\r\n        };\r\n        \r\n        const propOwn = Object.getOwnPropertyNames(person);\r\n        console.log(propOwn.length); // 1\r\n        \r\n        let propSymb = Object.getOwnPropertySymbols(person);\r\n        console.log(propSymb.length); // 2\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://stackoverflow.com/questions/10757455/object-prototype-is-verboten\r\n  [2]: http://kangax.github.io/compat-table/es5/\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"},{"score":1774,"body_markdown":"If you know you don&#39;t have to worry about `hasOwnProperty` checks, you can do this very simply:\r\n\r\n    Object.keys(myArray).length"},{"score":24,"body_markdown":"To not mess with the prototype or other code, you could build and extend your own object:\r\n\r\n    function Hash(){\r\n        var length=0;\r\n        this.add = function(key, val){\r\n             if(this[key] == undefined)\r\n             {\r\n               length++;\r\n             }\r\n             this[key]=val;\r\n        }; \r\n        this.length = function(){\r\n            return length;\r\n        };\r\n    }\r\n\r\n    myArray = new Hash();\r\n    myArray.add(&quot;lastname&quot;, &quot;Simpson&quot;);\r\n    myArray.add(&quot;age&quot;, 21);\r\n    alert(myArray.length()); // will alert 2\r\n\r\nIf you always use the add method, the length property will be correct. If you&#39;re worried that you or others forget about using it, you could add the property counter which the others have posted to the length method, too.\r\n\r\nOf course, you could always overwrite the methods. But even if you do, your code would probably fail noticeably, making it easy to debug. ;)"},{"score":15,"body_markdown":"For some cases it is better to just store the size in a separate variable. Especially, if you&#39;re adding to the array by one element in one place and can easily increment the size. It would obviously work much faster if you need to check the size often."},{"score":11,"body_markdown":"What about something like this --\r\n\r\n    function keyValuePairs() {\r\n        this.length = 0;\r\n        function add(key, value) { this[key] = value; this.length++; }\r\n        function remove(key) { if (this.hasOwnProperty(key)) { delete this[key]; this.length--; }}\r\n    }"},{"score":7,"body_markdown":"A variation on some of the above is:\r\n\r\n    var objLength = function(obj){    \r\n        var key,len=0;\r\n        for(key in obj){\r\n            len += Number( obj.hasOwnProperty(key) );\r\n        }\r\n        return len;\r\n    };\r\n\r\nIt is a bit more elegant way to integrate hasOwnProp.\r\n"},{"score":290,"body_markdown":"**Updated**: If you&#39;re using [Underscore.js][1] (recommended, it&#39;s lightweight!), then you can just do\r\n\r\n    _.size({one : 1, two : 2, three : 3});\r\n    =&gt; 3\r\n\r\n**If not**, and you don&#39;t want to mess around with Object properties for whatever reason, and are already using jQuery, a plugin is equally accessible:\r\n\r\n    $.assocArraySize = function(obj) {\r\n        // http://stackoverflow.com/a/6700/11236\r\n        var size = 0, key;\r\n        for (key in obj) {\r\n            if (obj.hasOwnProperty(key)) size++;\r\n        }\r\n        return size;\r\n    };\r\n\r\n\r\n\r\n  [1]: http://underscorejs.org/#size"},{"score":3,"body_markdown":"Below is a version of James Coglan&#39;s answer in CoffeeScript for those who have abandoned straight JavaScript :)\r\n\r\n    Object.size = (obj) -&gt;\r\n      size = 0\r\n      size++ for own key of obj\r\n      size"},{"score":6,"body_markdown":"Here&#39;s a different version of James Cogan&#39;s answer. Instead of passing an argument, just prototype out the Object class and make the code cleaner.\r\n\r\n    Object.prototype.size = function () {\r\n        var size = 0,\r\n            key;\r\n        for (key in this) {\r\n            if (this.hasOwnProperty(key)) size++;\r\n        }\r\n        return size;\r\n    };\r\n\r\n    var x = {\r\n        one: 1,\r\n        two: 2,\r\n        three: 3\r\n    };\r\n\r\n    x.size() === 3;\r\n\r\njsfiddle example: http://jsfiddle.net/qar4j/1/\r\n"},{"score":17,"body_markdown":"Here is a completely different solution that will only work in more modern browsers (Internet&amp;nbsp;Explorer&amp;nbsp;9+, Chrome, Firefox 4+, Opera 11.60+, and Safari 5.1+)\r\n\r\nSee [this jsFiddle][1].\r\n\r\nSetup your associative array class\r\n\r\n    /**\r\n     * @constructor\r\n     */\r\n    AssociativeArray = function () {};\r\n\r\n    // Make the length property work\r\n    Object.defineProperty(AssociativeArray.prototype, &quot;length&quot;, {\r\n        get: function () {\r\n            var count = 0;\r\n            for (var key in this) {\r\n                if (this.hasOwnProperty(key))\r\n                    count++;\r\n            }\r\n            return count;\r\n        }\r\n    });\r\n\r\nNow you can use this code as follows...\r\n\r\n    var a1 = new AssociativeArray();\r\n    a1[&quot;prop1&quot;] = &quot;test&quot;;\r\n    a1[&quot;prop2&quot;] = 1234;\r\n    a1[&quot;prop3&quot;] = &quot;something else&quot;;\r\n    alert(&quot;Length of array is &quot; + a1.length);\r\n\r\n\r\n\r\n\r\n\r\n  [1]: http://jsfiddle.net/QHDt7/ &quot;jsFiddle&quot;\r\n\r\n"},{"score":58,"body_markdown":"Here&#39;s the most cross-browser solution.\r\n\r\nThis is better than the accepted answer because it uses native Object.keys if exists.\r\nThus, it is the fastest for all modern browsers.\r\n\r\n\r\n    if (!Object.keys) {\r\n    \tObject.keys = function (obj) {\r\n    \t\tvar arr = [],\r\n    \t\t\tkey;\r\n    \t\tfor (key in obj) {\r\n    \t\t\tif (obj.hasOwnProperty(key)) {\r\n    \t\t\t\tarr.push(key);\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\treturn arr;\r\n    \t};\r\n    }\r\n    \r\n    Object.keys(obj).length;"},{"score":11,"body_markdown":"If we have the hash \r\n\r\n\r\n&gt; hash =  {&quot;a&quot; : &quot;b&quot;, &quot;c&quot;: &quot;d&quot;};\r\n\r\nwe can get the length using the length of the keys which is the length of the hash:\r\n\r\n&gt; keys(hash).length\r\n"},{"score":2,"body_markdown":"Like most JavaScript problems, there are many solutions.  You could extend the Object that for better or worse works like many other languages&#39; Dictionary (+ first class citizens). Nothing wrong with that, but another option is to construct a new Object that meets your specific needs. \r\n\r\n    function uberject(obj){\r\n        this._count = 0;\r\n        for(var param in obj){\r\n            this[param] = obj[param];\r\n            this._count++;\r\n        }\r\n    }\r\n\r\n    uberject.prototype.getLength = function(){\r\n        return this._count;\r\n    };\r\n\r\n    var foo = new uberject({bar:123,baz:456});\r\n    alert(foo.getLength());"},{"score":30,"body_markdown":"This method gets all your object&#39;s property names in an array, so you can get the length of that array which is equal to your object&#39;s keys&#39; length.\r\n\r\n    Object.getOwnPropertyNames({&quot;hi&quot;:&quot;Hi&quot;,&quot;msg&quot;:&quot;Message&quot;}).length; // =&gt; 2"},{"score":3,"body_markdown":"## Property\n\n    Object.defineProperty(Object.prototype, &#39;length&#39;, {\n        get: function () {\n            var size = 0, key;\n            for (key in this)\n                if (this.hasOwnProperty(key))\n                    size++;\n            return size;\n        }\n    });\n\n## Use\n\n    var o = {a: 1, b: 2, c: 3};\n    alert(o.length); // &lt;-- 3\n    o[&#39;foo&#39;] = 123;\n    alert(o.length); // &lt;-- 4"},{"score":1,"body_markdown":"**Simple solution:**\r\n\r\n      var myObject = {};      // ... your object goes here.\r\n\r\n      var length = 0;\r\n\r\n      for (var property in myObject) {\r\n        if (myObject.hasOwnProperty(property)){\r\n          length += 1;\r\n        }\r\n      };\r\n\r\n      console.log(length);    // logs 0 in my example."},{"score":10,"body_markdown":"If you are using [AngularJS][1] 1.x you can do things the AngularJS way by creating a filter and using the code from any of the other examples such as the following:\r\n\r\n    // Count the elements in an object\r\n    app.filter(&#39;lengthOfObject&#39;, function() {\r\n      return function( obj ) {\r\n        var size = 0, key;\r\n        for (key in obj) {\r\n          if (obj.hasOwnProperty(key)) size++;\r\n        }\r\n       return size;\r\n     }\r\n    })\r\n\r\n**Usage**\r\n\r\nIn your controller:\r\n\r\n    $scope.filterResult = $filter(&#39;lengthOfObject&#39;)($scope.object)\r\n\r\nOr in your view:\r\n\r\n    &lt;any ng-expression=&quot;object | lengthOfObject&quot;&gt;&lt;/any&gt;\r\n\r\n  [1]: http://en.wikipedia.org/wiki/AngularJS\r\n\r\n"},{"score":5,"body_markdown":"You can always do `Object.getOwnPropertyNames(myObject).length` to get the same result as `[].length` would give for normal array.\r\n"},{"score":8,"body_markdown":"If you don&#39;t care about supporting Internet Explorer 8 or lower, you can easily get the number of properties in an object by applying the following two steps:\r\n\r\n1. Run either [**`Object.keys()`**][1] to get an array that contains the names of only those properties that are [**enumerable**][2] or [**`Object.getOwnPropertyNames()`**][3] if you want to also include the names of properties that are not enumerable.\r\n2. Get the [**`.length`**][4] property of that array.\r\n\r\n-------------\r\n\r\nIf you need to do this more than once, you could wrap this logic in a function:\r\n\r\n    function size(obj, enumerablesOnly) {\r\n        return enumerablesOnly === false ?\r\n            Object.getOwnPropertyNames(obj).length :\r\n            Object.keys(obj).length;\r\n    }\r\n\r\nHow to use this particular function:\r\n\r\n    var myObj = Object.create({}, {\r\n        getFoo: {},\r\n        setFoo: {}\r\n    });\r\n    myObj.Foo = 12;\r\n\r\n    var myArr = [1,2,5,4,8,15];\r\n\r\n    console.log(size(myObj));        // Output : 1\r\n    console.log(size(myObj, true));  // Output : 1\r\n    console.log(size(myObj, false)); // Output : 3\r\n    console.log(size(myArr));        // Output : 6\r\n    console.log(size(myArr, true));  // Output : 6\r\n    console.log(size(myArr, false)); // Output : 7\r\n\r\nSee also [**this Fiddle**][5] for a demo.\r\n\r\n  [1]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\r\n  [2]: https://developer.mozilla.org/en/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\r\n  [4]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/length\r\n  [5]: https://jsfiddle.net/0x11tv73/5/\r\n"},{"score":14,"body_markdown":"If you need an associative data structure that exposes its size, better use a map instead of an object.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const myMap = new Map();\r\n\r\n    myMap.set(&quot;firstname&quot;, &quot;Gareth&quot;);\r\n    myMap.set(&quot;lastname&quot;, &quot;Simpson&quot;);\r\n    myMap.set(&quot;age&quot;, 21);\r\n\r\n    console.log(myMap.size); // 3\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":15,"body_markdown":"Use:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var myArray = new Object();\r\n    myArray[&quot;firstname&quot;] = &quot;Gareth&quot;;\r\n    myArray[&quot;lastname&quot;] = &quot;Simpson&quot;;\r\n    myArray[&quot;age&quot;] = 21;\r\n    obj = Object.keys(myArray).length;\r\n    console.log(obj)\r\n\r\n&lt;!-- end snippet --&gt;\r\n"},{"score":0,"body_markdown":"The solution work for many cases and cross browser:\r\n\r\n**Code**\r\n\r\n\r\n\r\n    var getTotal = function(collection) {\r\n    \r\n        var length = collection[&#39;length&#39;];\r\n        var isArrayObject =  typeof length == &#39;number&#39; &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= Math.pow(2,53) - 1; // Number.MAX_SAFE_INTEGER\r\n    \r\n        if(isArrayObject) {\r\n            return collection[&#39;length&#39;];\r\n        }\r\n    \r\n        i= 0;\r\n        for(var key in collection) {\r\n            if (collection.hasOwnProperty(key)) {\r\n                i++;\r\n            }\r\n        }\r\n    \r\n        return i;\r\n    };\r\n\r\n**Data Examples:**\r\n\r\n    // case 1\r\n    var a = new Object();\r\n    a[&quot;firstname&quot;] = &quot;Gareth&quot;;\r\n    a[&quot;lastname&quot;] = &quot;Simpson&quot;;\r\n    a[&quot;age&quot;] = 21;\r\n\r\n    //case 2\r\n    var b = [1,2,3];\r\n\r\n    // case 3\r\n    var c = {};\r\n    c[0] = 1;\r\n    c.two = 2;\r\n\r\n**Usage**\r\n\r\n    getLength(a); // 3\r\n    getLength(b); // 3\r\n    getLength(c); // 2"},{"score":5,"body_markdown":"You can simply use `Object.keys(obj).length` on any object to get its length. Object.keys returns an array containing all of the object *keys* (properties) which can come in handy for finding the length of that object using the length of the corresponding array. You can even write a *function* for this. Let&#39;s get *creative* and write a **method** for it as well (along with a more convienient getter property):\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function objLength(obj)\r\n    {\r\n      return Object.keys(obj).length;\r\n    }\r\n\r\n    console.log(objLength({a:1, b:&quot;summit&quot;, c:&quot;nonsense&quot;}));\r\n\r\n    // Works perfectly fine\r\n    var obj = new Object();\r\n    obj[&#39;fish&#39;] = 30;\r\n    obj[&#39;nullified content&#39;] = null;\r\n    console.log(objLength(obj));\r\n\r\n    // It also works your way, which is creating it using the Object constructor\r\n    Object.prototype.getLength = function() {\r\n       return Object.keys(this).length;\r\n    }\r\n    console.log(obj.getLength());\r\n\r\n// You can also write it as a method, which is more efficient as done so above\r\n\r\n    Object.defineProperty(Object.prototype, &quot;length&quot;, {get:function(){\r\n        return Object.keys(this).length;\r\n    }});\r\n    console.log(obj.length);\r\n    \r\n// probably the most effictive approach is done so and demonstrated above which sets a getter property called &quot;length&quot; for objects which returns the equivalent value of getLength(this) or this.getLength()\r\n\r\n&lt;!-- end snippet --&gt;\r\n"},{"score":19,"body_markdown":"We can find the length of Object by using:\r\n\r\n    Object.values(myObject).length\r\n"},{"score":4,"body_markdown":"A nice way to achieve this (Internet&amp;nbsp;Explorer&amp;nbsp;9+ only) is to define a magic getter on the length property:\r\n\r\n    Object.defineProperty(Object.prototype, &quot;length&quot;, {\r\n        get: function () {\r\n            return Object.keys(this).length;\r\n        }\r\n    });\r\n\r\nAnd you can just use it like so:\r\n\r\n    var myObj = { &#39;key&#39;: &#39;value&#39; };\r\n    myObj.length;\r\n\r\nIt would give `1`.\r\n\r\n\r\n\r\n\r\n"},{"score":27,"body_markdown":"Simply use this to get the `length`:\r\n\r\n    Object.keys(myObject).length"},{"score":11,"body_markdown":"    var myObject = new Object();\r\n    myObject[&quot;firstname&quot;] = &quot;Gareth&quot;;\r\n    myObject[&quot;lastname&quot;] = &quot;Simpson&quot;;\r\n    myObject[&quot;age&quot;] = 21;\r\n\r\n 1. Object.values(myObject).length\r\n 2. Object.entries(myObject).length\r\n 3. Object.keys(myObject).length"},{"score":-4,"body_markdown":"\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var myObject = new Object();\r\n    myObject[&quot;firstname&quot;] = &quot;Gareth&quot;;\r\n    myObject[&quot;lastname&quot;] = &quot;Simpson&quot;;\r\n    myObject[&quot;age&quot;] = 21;\r\n\r\n    var size = JSON.stringify(myObject).length;\r\n\r\n    document.write(size);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    JSON.stringify(myObject)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":15,"body_markdown":"The simplest way is like this:\r\n\r\n    Object.keys(myobject).length\r\n\r\nWhere myobject is the object of what you want the length of.\r\n"},{"score":17,"body_markdown":"\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script&gt;\r\n    myObj = {&quot;key1&quot; : &quot;Hello&quot;, &quot;key2&quot; : &quot;Goodbye&quot;};\r\n    var size = Object.keys(myObj).length;\r\n    console.log(size);\r\n    &lt;/script&gt;\r\n\r\n    &lt;p id=&quot;myObj&quot;&gt;The number of &lt;b&gt;keys&lt;/b&gt; in &lt;b&gt;myObj&lt;/b&gt; are: &lt;script&gt;document.write(size)&lt;/script&gt;&lt;/p&gt;\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThis works for me:\r\n\r\n    var size = Object.keys(myObj).length;"},{"score":0,"body_markdown":"`Object.keys` does **not** return the right result in case of object [inheritance][1]. To properly count object properties, including inherited ones, use `for-in`. For example, by the following function (related [question][2]):\r\n\r\n    var objLength = (o,i=0) =&gt; { for(p in o) i++; return i }\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var myObject = new Object();\r\n    myObject[&quot;firstname&quot;] = &quot;Gareth&quot;;\r\n    myObject[&quot;lastname&quot;] = &quot;Simpson&quot;;\r\n    myObject[&quot;age&quot;] = 21;\r\n\r\n    var child = Object.create(myObject);\r\n    child[&quot;sex&quot;] = &quot;male&quot;;\r\n\r\n    var objLength = (o,i=0) =&gt; { for(p in o) i++; return i }\r\n\r\n    console.log(&quot;Object.keys(myObject):&quot;, Object.keys(myObject).length, &quot;(OK)&quot;);\r\n    console.log(&quot;Object.keys(child)   :&quot;, Object.keys(child).length, &quot;(wrong)&quot;);\r\n    console.log(&quot;objLength(child)     :&quot;, objLength(child), &quot;(OK)&quot;);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\r\n  [2]: https://stackoverflow.com/a/54553880/860099\r\n"},{"score":-2,"body_markdown":"I had a similar need to calculate the bandwidth used by objects received over a websocket. Simply finding the length of the Stringified object was enough for me.\r\n\r\n    websocket.on(&#39;message&#39;, data =&gt; {\r\n        dataPerSecond += JSON.stringify(data).length;\r\n    }\r\n\r\n"},{"score":10,"body_markdown":"Use `Object.keys(myObject).length` to get the length of object/array\r\n    \r\n    var myObject = new Object();\r\n    myObject[&quot;firstname&quot;] = &quot;Gareth&quot;;\r\n    myObject[&quot;lastname&quot;] = &quot;Simpson&quot;;\r\n    myObject[&quot;age&quot;] = 21;\r\n        \r\n    console.log(Object.keys(myObject).length); //3"},{"score":11,"body_markdown":"    const myObject = new Object();\r\n    myObject[&quot;firstname&quot;] = &quot;Gareth&quot;;\r\n    myObject[&quot;lastname&quot;] = &quot;Simpson&quot;;\r\n    myObject[&quot;age&quot;] = 21;\r\n    \r\n    console.log(Object.keys(myObject).length)\r\n    \r\n    // o/p 3"},{"score":2,"body_markdown":"With the ECMAScript&amp;nbsp;6 in-built Reflect object, you can easily count the properties of an object:\r\n\r\n    Reflect.ownKeys(targetObject).length\r\n\r\nIt will give you the length of the target object&#39;s own properties (*important*).\r\n\r\n    Reflect.ownKeys(target)\r\n\r\n&gt; Returns an array of the target object&#39;s own (not inherited) property\r\n&gt; keys.\r\n\r\nNow, what does that mean? To explain this, let&#39;s see this example.\r\n\r\n    function Person(name, age){\r\n      this.name = name;\r\n      this.age = age;\r\n    }\r\n\r\n    Person.prototype.getIntro= function() {\r\n      return `${this.name} is ${this.age} years old!!`\r\n    }\r\n\r\n    let student = new Person(&#39;Anuj&#39;, 11);\r\n\r\n    console.log(Reflect.ownKeys(student).length) // 2\r\n    console.log(student.getIntro()) // Anuj is 11 years old!!\r\n\r\nYou can see here, it returned only its own properties while the object is still inheriting the property from its parent.\r\n\r\nFor more information, refer this: [Reflect API][1]\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\r\n\r\n\r\n\r\n"},{"score":0,"body_markdown":"    let myobject= {}\r\n    let isempty =  Object.values(myobject);\r\n    console.log(isempty)"},{"score":2,"body_markdown":"Simple one liner:\r\n    \r\n    Object.values({id:&quot;1&quot;,age:23,role_number:90}).length   // length : 3"}],"score":2489}