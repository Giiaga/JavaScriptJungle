{"body":"I have this string:\r\n\r\n    &quot;Test abc test test abc test test test abc test test abc&quot;\r\n\r\nDoing:\r\n\r\n    str = str.replace(&#39;abc&#39;, &#39;&#39;);\r\n\r\nseems to only remove the first occurrence of `abc` in the string above.\r\n\r\nHow can I replace **all** occurrences of it?\r\n\r\n\r\n\r\n","title":"How to replace all occurrences of a string?","answers":[{"score":719,"body_markdown":"Using a regular expression with the `g` flag set will replace all:\r\n\r\n    someString = &#39;the cat looks like a cat&#39;;\r\n    anotherString = someString.replace(/cat/g, &#39;dog&#39;);\r\n    // anotherString now contains &quot;the dog looks like a dog&quot;\r\n###[See here also][1]\r\n\r\n\r\n  [1]: http://www.tizag.com/javascriptT/javascript-string-replace.php"},{"score":72,"body_markdown":"Match against a global regular expression:\r\n\r\n    anotherString = someString.replace(/cat/g, &#39;dog&#39;);"},{"score":4567,"body_markdown":"**As of August 2020**, greenfield browsers have support for the [`String.replaceAll()` method][1] defined by the ECMAScript 2021 language specification. For older/legacy browser support, the below still applies.\r\n\r\n---\r\n\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    str = str.replace(/abc/g, &#39;&#39;);\r\n\r\nIn response to comment:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var find = &#39;abc&#39;;\r\n    var re = new RegExp(find, &#39;g&#39;);\r\n\r\n    str = str.replace(re, &#39;&#39;);\r\n\r\nIn response to [Click Upvote][2]&#39;s comment, you could simplify it even more:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function replaceAll(str, find, replace) {\r\n      return str.replace(new RegExp(find, &#39;g&#39;), replace);\r\n    }\r\n\r\n**Note:** Regular expressions contain special (meta) characters, and as such it is dangerous to blindly pass an argument in the `find` function above without pre-processing it to escape those characters.  This is covered in the [Mozilla Developer Network][3]&#39;s [JavaScript Guide on Regular Expressions][4], where they present the following utility function (which has changed at least twice since this answer was originally written, so make sure to check the MDN site for potential updates):\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function escapeRegExp(string) {\r\n      return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, &#39;\\\\$&amp;&#39;); // $&amp; means the whole matched string\r\n    }\r\n\r\nSo in order to make the `replaceAll()` function above safer, it could be modified to the following if you also include `escapeRegExp`:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function replaceAll(str, find, replace) {\r\n      return str.replace(new RegExp(escapeRegExp(find), &#39;g&#39;), replace);\r\n    }\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\r\n  [2]: https://stackoverflow.com/users/49153/click-upvote\r\n  [3]: https://developer.mozilla.org/en-US/\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping"},{"score":45,"body_markdown":"    str = str.replace(/abc/g, &#39;&#39;);\r\n\r\nOr try the replaceAll function from here:\r\n\r\nhttps://stackoverflow.com/questions/1137436/useful-javascript-methods-that-extends-built-in-objects/1137579#1137579\r\n\r\n    str = str.replaceAll(&#39;abc&#39;, &#39;&#39;); OR\r\n    \r\n    var search = &#39;abc&#39;;\r\n    str = str.replaceAll(search, &#39;&#39;);\r\n\r\n**EDIT:** Clarification about replaceAll availability\r\n\r\n\r\nThe &#39;replaceAll&#39; method is added to String&#39;s prototype. This means it will be available for all string objects/literals.\r\n\r\nE.g.\r\n\r\n    var output = &quot;test this&quot;.replaceAll(&#39;this&#39;, &#39;that&#39;);  //output is &#39;test that&#39;.\r\n    output = output.replaceAll(&#39;that&#39;, &#39;this&#39;); //output is &#39;test this&#39;\r\n\r\n "},{"score":37,"body_markdown":"Use a regular expression:\r\n\r\n    str.replace(/abc/g, &#39;&#39;);\r\n"},{"score":1887,"body_markdown":"**Update:** As of August 2020, you can use [`replaceAll`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll)\r\n as shown here:\r\n```js\r\nlet result = &quot;1 abc 2 abc 3&quot;.replaceAll(&quot;abc&quot;, &quot;xyz&quot;);\r\n// `result` is &quot;1 xyz 2 xyz 3&quot;\r\n```\r\n\r\n---\r\n\r\nFor older browsers:\r\n\r\n**Note: Don&#39;t use the following solution in performance critical code.**\r\n\r\nAs an alternative to regular expressions for a simple literal string, you could use\r\n\r\n    str = &quot;Test abc test test abc test...&quot;.split(&quot;abc&quot;).join(&quot;&quot;);\r\n\r\nThe general pattern is\r\n\r\n    str.split(search).join(replacement)\r\n\r\nThis used to be faster in some cases than using `replaceAll` and a regular expression, but that doesn&#39;t seem to be the case anymore in modern browsers. \r\n\r\nBenchmark: https://jsperf.com/replace-all-vs-split-join\r\n\r\nConclusion: If you have a performance critical use case (e.g processing hundreds of strings), use the Regexp method. But for most typical use cases, this is well worth not having to worry about special characters."},{"score":5,"body_markdown":"My implementation, very self explanatory\r\n\r\n    function replaceAll(string, token, newtoken) {\r\n        if(token!=newtoken)\r\n    \twhile(string.indexOf(token) &gt; -1) {\r\n     \t\tstring = string.replace(token, newtoken);\r\n    \t}\r\n    \treturn string;\r\n    }"},{"score":88,"body_markdown":"\r\n_**Update:**_\r\n\r\nIt&#39;s somewhat late for an update, but since I just stumbled on this question, and noticed that my previous answer is not one I&#39;m happy with. Since the question involved replaceing a single word, it&#39;s incredible nobody thought of using word boundaries (`\\b`)\r\n\r\n    &#39;a cat is not a caterpillar&#39;.replace(/\\bcat\\b/gi,&#39;dog&#39;);\r\n    //&quot;a dog is not a caterpillar&quot;\r\nThis is a simple regex that avoids replacing parts of words in most cases. However, a dash `-` is still considered a word boundary. So conditionals can be used in this case to avoid replacing strings like `cool-cat`:\r\n\r\n    &#39;a cat is not a cool-cat&#39;.replace(/\\bcat\\b/gi,&#39;dog&#39;);//wrong\r\n    //&quot;a dog is not a cool-dog&quot; -- nips\r\n    &#39;a cat is not a cool-cat&#39;.replace(/(?:\\b([^-]))cat(?:\\b([^-]))/gi,&#39;$1dog$2&#39;);\r\n    //&quot;a dog is not a cool-cat&quot;\r\n\r\n\r\n----------\r\n\r\n\r\nbasically, this question is the same as the question here:\r\nhttps://stackoverflow.com/questions/9499075/javascript-replace-with/9499926\r\n\r\n@Mike, check the answer I gave there... regexp isn&#39;t the only way to replace multiple occurrences of a subsrting, far from it. Think flexible, think split!\r\n\r\n    var newText = &quot;the cat looks like a cat&quot;.split(&#39;cat&#39;).join(&#39;dog&#39;);\r\n\r\nAlternatively, to prevent replacing word parts -which the approved answer will do, too! You can get around this issue using regular expressions that are, I admit, somewhat more complex and as an upshot of that, a tad slower, too:\r\n\r\n    var regText = &quot;the cat looks like a cat&quot;.replace(/(?:(^|[^a-z]))(([^a-z]*)(?=cat)cat)(?![a-z])/gi,&quot;$1dog&quot;);\r\n\r\nThe output is the same as the accepted answer, however, using the /cat/g expression on this string:\r\n\r\n    var oops = &#39;the cat looks like a cat, not a caterpillar or coolcat&#39;.replace(/cat/g,&#39;dog&#39;);\r\n    //returns &quot;the dog looks like a dog, not a dogerpillar or cooldog&quot; ?? \r\n\r\nOops indeed, this probably isn&#39;t what you want. What is, then? IMHO, a regex that only replaces &#39;cat&#39; conditionally. (ie not part of a word), like so:\r\n\r\n    var caterpillar = &#39;the cat looks like a cat, not a caterpillar or coolcat&#39;.replace(/(?:(^|[^a-z]))(([^a-z]*)(?=cat)cat)(?![a-z])/gi,&quot;$1dog&quot;);\r\n    //return &quot;the dog looks like a dog, not a caterpillar or coolcat&quot;\r\n\r\nMy guess is, this meets your needs. It&#39;s not fullproof, of course, but it should be enough to get you started. I&#39;d recommend reading some more on these pages. This&#39;ll prove useful in perfecting this expression to meet your specific needs.\r\n\r\n http://www.javascriptkit.com/jsref/regexp.shtml\r\n\r\n http://www.regular-expressions.info\r\n\r\n----\r\n\r\n__Final addition:__\r\n\r\nGiven that this question still gets a lot of views, I thought I might add an example of `.replace` used with a callback function. In this case, it dramatically simplifies the expression _and_ provides even more flexibility, like replacing with correct capitalisation or replacing both `cat` and `cats` in one go:\r\n\r\n    &#39;Two cats are not 1 Cat! They\\&#39;re just cool-cats, you caterpillar&#39;\r\n       .replace(/(^|.\\b)(cat)(s?\\b.|$)/gi,function(all,char1,cat,char2)\r\n        {\r\n           //check 1st, capitalize if required\r\n           var replacement = (cat.charAt(0) === &#39;C&#39; ? &#39;D&#39; : &#39;d&#39;) + &#39;og&#39;;\r\n           if (char1 === &#39; &#39; &amp;&amp; char2 === &#39;s&#39;)\r\n           {//replace plurals, too\r\n               cat = replacement + &#39;s&#39;;\r\n           }\r\n           else\r\n           {//do not replace if dashes are matched\r\n               cat = char1 === &#39;-&#39; || char2 === &#39;-&#39; ? cat : replacement;\r\n           }\r\n           return char1 + cat + char2;//return replacement string\r\n        });\r\n    //returns:\r\n    //Two dogs are not 1 Dog! They&#39;re just cool-cats, you caterpillar\r\n"},{"score":115,"body_markdown":"Here&#39;s a string prototype function based on the accepted answer:\r\n        \r\n    String.prototype.replaceAll = function (find, replace) {\r\n        var str = this;\r\n        return str.replace(new RegExp(find, &#39;g&#39;), replace);\r\n    };\r\n\r\n**EDIT** \r\n\r\nIf your `find` will contain special characters then you need to escape them:\r\n\r\n\r\n    String.prototype.replaceAll = function (find, replace) {\r\n        var str = this;\r\n        return str.replace(new RegExp(find.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, &#39;\\\\$&amp;&#39;), &#39;g&#39;), replace);\r\n    };\r\n\r\nFiddle: http://jsfiddle.net/cdbzL/"},{"score":16,"body_markdown":"I like this method (it looks a little cleaner):\r\n\r\n    text = text.replace(new RegExp(&quot;cat&quot;,&quot;g&quot;), &quot;dog&quot;); \r\n"},{"score":26,"body_markdown":"//loop it until number occurrences comes to 0. OR simply copy/paste\r\n\r\n\r\n        function replaceAll(find, replace, str) \r\n        {\r\n          while( str.indexOf(find) &gt; -1)\r\n          {\r\n            str = str.replace(find, replace);\r\n          }\r\n          return str;\r\n        }"},{"score":21,"body_markdown":"If what you want to find is already in a string, and you don&#39;t have a regex escaper handy, you can use join/split:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n        function replaceMulti(haystack, needle, replacement)\r\n        {\r\n            return haystack.split(needle).join(replacement);\r\n        }\r\n\r\n        someString = &#39;the cat looks like a cat&#39;;\r\n        console.log(replaceMulti(someString, &#39;cat&#39;, &#39;dog&#39;));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":2452,"body_markdown":"For the sake of completeness, I got to thinking about which method I should use to do this. There are basically two ways to do this as suggested by the other answers on this page.\r\n\r\n**Note:** In general, extending the built-in prototypes in JavaScript is generally not recommended. I am providing as extensions on the String prototype simply for purposes of illustration, showing different implementations of a hypothetical standard method on the `String` built-in prototype.\r\n\r\n----------\r\n\r\n### Regular Expression Based Implementation\r\n\r\n    String.prototype.replaceAll = function(search, replacement) {\r\n        var target = this;\r\n        return target.replace(new RegExp(search, &#39;g&#39;), replacement);\r\n    };\r\n\r\n### Split and Join (Functional) Implementation\r\n\r\n    String.prototype.replaceAll = function(search, replacement) {\r\n        var target = this;\r\n        return target.split(search).join(replacement);\r\n    };\r\n\r\n----------\r\n\r\nNot knowing too much about how regular expressions work behind the scenes in terms of efficiency, I tended to lean toward the split and join implementation in the past without thinking about performance. When I did wonder which was more efficient, and by what margin, I used it as an excuse to find out.\r\n\r\nOn my Chrome Windows&amp;nbsp;8 machine, **the regular expression based implementation is the fastest**, with the **split and join implementation being 53% slower**. Meaning the regular expressions are twice as fast for the lorem ipsum input I used.\r\n\r\nCheck out this [**benchmark**][jsperf] running these two implementations against each other.\r\n\r\n----------\r\n\r\nAs noted in the comment below by @ThomasLeduc and others, there could be an issue with the regular expression-based implementation if `search` contains certain characters which are reserved as [special characters in regular expressions][1]. The implementation assumes that the caller will escape the string beforehand or will only pass strings that are without the characters in the table in *[Regular Expressions][1]* (MDN).\r\n\r\nMDN also provides an implementation to escape our strings. It would be nice if this was also standardized as `RegExp.escape(str)`, but alas, it does not exist:\r\n\r\n    function escapeRegExp(str) {\r\n      return str.replace(/[.*+?^${}()|[\\]\\\\]/g, &quot;\\\\$&amp;&quot;); // $&amp; means the whole matched string\r\n    }\r\n\r\nWe could call `escapeRegExp` within our `String.prototype.replaceAll` implementation, however, I&#39;m not sure how much this will affect the performance (potentially even for strings for which the escape is not needed, like all alphanumeric strings).\r\n\r\n[jsperf]: http://jsben.ch/#/LFfWA\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters\r\n"},{"score":13,"body_markdown":"    var str = &quot;ff ff f f a de def&quot;;\r\n    str = str.replace(/f/g,&#39;&#39;);\r\n    alert(str);\r\n\r\nhttp://jsfiddle.net/ANHR9/"},{"score":5,"body_markdown":"For replacing all kind of characters, try this code:\r\n\r\n    Suppose we have need to send &quot; and \\ in my string, then we will convert it &quot; to \\&quot; and \\ to \\\\\r\n\r\nSo this method will solve this issue.\r\n\r\n    String.prototype.replaceAll = function (find, replace) {\r\n         var str = this;\r\n         return str.replace(new RegExp(find.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, &#39;\\\\$&amp;&#39;), &#39;g&#39;), replace);\r\n     };\r\n\r\n    var message = $(&#39;#message&#39;).val();\r\n                 message = message.replaceAll(&#39;\\\\&#39;, &#39;\\\\\\\\&#39;); /*it will replace \\ to \\\\ */\r\n                 message = message.replaceAll(&#39;&quot;&#39;, &#39;\\\\&quot;&#39;);   /*it will replace &quot; to \\\\&quot;*/\r\n\r\nI was using Ajax, and I had the need to send parameters in JSON format. Then my method is looking like this:\r\n\r\n     function sendMessage(source, messageID, toProfileID, userProfileID) {\r\n\r\n         if (validateTextBox()) {\r\n             var message = $(&#39;#message&#39;).val();\r\n             message = message.replaceAll(&#39;\\\\&#39;, &#39;\\\\\\\\&#39;);\r\n             message = message.replaceAll(&#39;&quot;&#39;, &#39;\\\\&quot;&#39;);\r\n             $.ajax({\r\n                 type: &quot;POST&quot;,\r\n                 async: &quot;false&quot;,\r\n                 contentType: &quot;application/json; charset=utf-8&quot;,\r\n                 url: &quot;services/WebService1.asmx/SendMessage&quot;,\r\n                 data: &#39;{&quot;source&quot;:&quot;&#39; + source + &#39;&quot;,&quot;messageID&quot;:&quot;&#39; + messageID + &#39;&quot;,&quot;toProfileID&quot;:&quot;&#39; + toProfileID + &#39;&quot;,&quot;userProfileID&quot;:&quot;&#39; + userProfileID + &#39;&quot;,&quot;message&quot;:&quot;&#39; + message + &#39;&quot;}&#39;,\r\n                 dataType: &quot;json&quot;,\r\n                 success: function (data) {\r\n                     loadMessageAfterSend(toProfileID, userProfileID);\r\n                     $(&quot;#&lt;%=PanelMessageDelete.ClientID%&gt;&quot;).hide();\r\n                     $(&quot;#message&quot;).val(&quot;&quot;);\r\n                     $(&quot;#delMessageContainer&quot;).show();\r\n                     $(&quot;#msgPanel&quot;).show();\r\n                 },\r\n                 error: function (result) {\r\n                     alert(&quot;message sending failed&quot;);\r\n                 }\r\n             });\r\n         }\r\n         else {\r\n             alert(&quot;Please type message in message box.&quot;);\r\n             $(&quot;#message&quot;).focus();\r\n\r\n         }\r\n     }\r\n\r\n     String.prototype.replaceAll = function (find, replace) {\r\n         var str = this;\r\n         return str.replace(new RegExp(find.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, &#39;\\\\$&amp;&#39;), &#39;g&#39;), replace);\r\n     };\r\n"},{"score":1,"body_markdown":"Try this:\r\n\r\n    String.prototype.replaceAll = function (sfind, sreplace) {\r\n        var str = this;\r\n\r\n        while (str.indexOf(sfind) &gt; -1) {\r\n            str = str.replace(sfind, sreplace);\r\n        }\r\n\r\n        return str;\r\n    };\r\n"},{"score":25,"body_markdown":"This is the **fastest** version that *doesn&#39;t use regular expressions*.\r\n\r\n[Revised jsperf](http://jsperf.com/replace-all-vs-split-join/10)\r\n\r\n    replaceAll = function(string, omit, place, prevstring) {\r\n      if (prevstring &amp;&amp; string === prevstring)\r\n        return string;\r\n      prevstring = string.replace(omit, place);\r\n      return replaceAll(prevstring, omit, place, string)\r\n    }\r\n\r\nIt is almost **twice** as fast as the split and join method.\r\n\r\nAs pointed out in a comment here, this will not work if your `omit` variable contains `place`, as in: `replaceAll(&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;)`, because it will always be able to replace another occurrence of the word.\r\n\r\nThere is another jsperf with variants on my recursive replace that go even faster (http://jsperf.com/replace-all-vs-split-join/12)!\r\n\r\n* Update July 27th 2017: It looks like RegExp now has the fastest performance in the recently released Chrome 59."},{"score":13,"body_markdown":"    while (str.indexOf(&#39;abc&#39;) !== -1)\r\n    {\r\n        str = str.replace(&#39;abc&#39;, &#39;&#39;);\r\n    }"},{"score":3,"body_markdown":"If using a library is an option for you then you will get the benefits of the testing and community support that goes with a library function. For example, the [string.js][1] library has a replaceAll() function that does what you&#39;re looking for:\r\n\r\n    // Include a reference to the string.js library and call it (for example) S.\r\n    str = S(str).replaceAll(&#39;abc&#39;, &#39;&#39;).s;\r\n\r\n  [1]: http://stringjs.com/\r\n"},{"score":10,"body_markdown":"If you are trying to ensure that the string you are looking for won&#39;t exist even after the replacement, you need to use a loop.\r\n\r\nFor example:\r\n\r\n    var str = &#39;test aabcbc&#39;;\r\n    str = str.replace(/abc/g, &#39;&#39;);\r\n\r\nWhen complete, you will still have &#39;test abc&#39;!\r\n\r\nThe simplest loop to solve this would be:\r\n\r\n    var str = &#39;test aabcbc&#39;;\r\n    while (str != str.replace(/abc/g, &#39;&#39;)){\r\n       str.replace(/abc/g, &#39;&#39;);\r\n    }\r\n\r\nBut that runs the replacement twice for each cycle. Perhaps (at risk of being voted down) that can be combined for a slightly more efficient but less readable form:\r\n\r\n    var str = &#39;test aabcbc&#39;;\r\n    while (str != (str = str.replace(/abc/g, &#39;&#39;))){}\r\n    // alert(str); alerts &#39;test &#39;!\r\n\r\nThis can be particularly useful when looking for duplicate strings.  \r\nFor example, if we have &#39;a,,,b&#39; and we wish to remove all duplicate commas.  \r\n[In that case, one could do .replace(/,+/g,&#39;,&#39;), but at some point the regex gets complex and slow enough to loop instead.]\r\n\r\n"},{"score":19,"body_markdown":"    function replaceAll(str, find, replace) {\r\n      var i = str.indexOf(find);\r\n      if (i &gt; -1){\r\n        str = str.replace(find, replace); \r\n        i = i + replace.length;\r\n        var st2 = str.substring(i);\r\n        if(st2.indexOf(find) &gt; -1){\r\n          str = str.substring(0,i) + replaceAll(st2, find, replace);\r\n        }       \r\n      }\r\n      return str;\r\n    }\r\n"},{"score":8,"body_markdown":"Just add `/g` &lt;br/&gt;\r\n\r\n    document.body.innerHTML = document.body.innerHTML.replace(&#39;hello&#39;, &#39;hi&#39;);\r\nto\r\n\r\n  \r\n    // Replace &#39;hello&#39; string with /hello/g regular expression.\r\n    document.body.innerHTML = document.body.innerHTML.replace(/hello/g, &#39;hi&#39;);\r\n\r\n`/g` means global"},{"score":32,"body_markdown":"Replacing single quotes:\r\n\r\n    function JavaScriptEncode(text){\r\n        text = text.replace(/&#39;/g,&#39;&amp;apos;&#39;)\r\n        // More encode here if required\r\n\r\n        return text;\r\n    }"},{"score":6,"body_markdown":"I use **p** to store the result from the previous recursion replacement:\r\n\r\n    function replaceAll(s, m, r, p) {\r\n        return s === p || r.contains(m) ? s : replaceAll(s.replace(m, r), m, r, s);\r\n    }\r\n\r\nIt will replace all occurrences in the string **s** until it is possible:\r\n\r\n    replaceAll(&#39;abbbbb&#39;, &#39;ab&#39;, &#39;a&#39;) → &#39;abbbb&#39; → &#39;abbb&#39; → &#39;abb&#39; → &#39;ab&#39; → &#39;a&#39;\r\n\t\r\nTo avoid infinite loop I check if the replacement **r** contains a match **m**:\r\n\t\r\n    replaceAll(&#39;abbbbb&#39;, &#39;a&#39;, &#39;ab&#39;) → &#39;abbbbb&#39;\r\n"},{"score":7,"body_markdown":"You can simply use below method\r\n\r\n    /**\r\n     * Replace all the occerencess of $find by $replace in $originalString\r\n     * @param  {originalString} input - Raw string.\r\n     * @param  {find} input - Target key word or regex that need to be replaced.\r\n     * @param  {replace} input - Replacement key word\r\n     * @return {String}       Output string\r\n     */\r\n    function replaceAll(originalString, find, replace) {\r\n      return originalString.replace(new RegExp(find, &#39;g&#39;), replace);\r\n    };"},{"score":7,"body_markdown":"The following function works for me:\r\n\r\n    String.prototype.replaceAllOccurence = function(str1, str2, ignore)\r\n    {\r\n        return this.replace(new RegExp(str1.replace(/([\\/\\,\\!\\\\\\^\\$\\{\\}\\[\\]\\(\\)\\.\\*\\+\\?\\|\\&lt;\\&gt;\\-\\&amp;])/g,&quot;\\\\$&amp;&quot;),(ignore?&quot;gi&quot;:&quot;g&quot;)),(typeof(str2)==&quot;string&quot;)?str2.replace(/\\$/g,&quot;$$$$&quot;):str2);\r\n    } ;\r\n\r\nNow call the functions like this:\r\n\r\n    &quot;you could be a Project Manager someday, if you work like this.&quot;.replaceAllOccurence (&quot;you&quot;, &quot;I&quot;);\r\n\r\nSimply copy and paste this code in your browser console to TEST.\r\n"},{"score":4,"body_markdown":"Here is the working code with prototype:\r\n\r\n    String.prototype.replaceAll = function(find, replace) {\r\n        var str = this;\r\n        return str.replace(new RegExp(find.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, &quot;\\\\$1&quot;), &#39;g&#39;), replace);\r\n    };"},{"score":4,"body_markdown":"   \r\n    function replaceAll(str, find, replace) {\r\n\t    var $r=&quot;&quot;;\r\n\t    while($r!=str){\t\r\n            $r = str;\r\n\t\t    str = str.replace(find, replace);\r\n\t    }\r\n\t    return str;\r\n    }"},{"score":10,"body_markdown":"Although people have mentioned the use of regex but there&#39;s a better approach if you want to replace the text irrespective of the case of the text. Like uppercase or lowercase. Use below syntax\r\n\r\n    //Consider below example\r\n    originalString.replace(/stringToBeReplaced/gi, &#39;&#39;);\r\n\r\n    //Output will be all the occurrences removed irrespective of casing.\r\n\r\nYou can refer the detailed example [here][1].\r\n\r\n\r\n  [1]: http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html"},{"score":41,"body_markdown":"Say you want to replace all the &#39;abc&#39; with &#39;x&#39;:\r\n\r\n    let some_str = &#39;abc def def lom abc abc def&#39;.split(&#39;abc&#39;).join(&#39;x&#39;)\r\n    console.log(some_str) //x def def lom x x def\r\n\r\nI was trying to think about something more simple than modifying the string prototype.\r\n"},{"score":2,"body_markdown":"This can be solved using regular expressions and the flag `g`, which means to not stop after finding the first match. Really, regular expressions are life savers!\r\n\r\n    function replaceAll(string, pattern, replacement) {\r\n        return string.replace(new RegExp(pattern, &quot;g&quot;), replacement);\r\n    }\r\n\r\n    // or if you want myString.replaceAll(&quot;abc&quot;, &quot;&quot;);\r\n    \r\n    String.prototype.replaceAll = function(pattern, replacement) {\r\n        return this.replace(new RegExp(pattern, &quot;g&quot;), replacement);\r\n    };"},{"score":5,"body_markdown":"Most people are likely doing this to encode a URL. To encode a URL, you shouldn&#39;t only consider spaces, but convert the entire string properly with `encodeURI`.\r\n\r\n    encodeURI(&quot;http://www.google.com/a file with spaces.html&quot;)\r\n\r\nto get:\r\n\r\n    http://www.google.com/a%20file%20with%20spaces.html"},{"score":41,"body_markdown":"Using `RegExp` in **JavaScript** could do the job for you, just simply do something like below code, don&#39;t forget the `/g` after which standout for **global**:\r\n\r\n    var str =&quot;Test abc test test abc test test test abc test test abc&quot;;\r\n    str = str.replace(/abc/g, &#39;&#39;);\r\n\r\nIf you think of reuse, create a function to do that for you, but it&#39;s not recommended as it&#39;s only one line function, but again if you heavily use this, you can write something like this:\r\n\r\n    String.prototype.replaceAll = String.prototype.replaceAll || function(string, replaced) {\r\n      return this.replace(new RegExp(string, &#39;g&#39;), replaced);\r\n    };\r\n\r\nand simply use it in your code over and over like below:\r\n\r\n    var str =&quot;Test abc test test abc test test test abc test test abc&quot;;\r\n    str = str.replaceAll(&#39;abc&#39;, &#39;&#39;);\r\nBut as I mention earlier, it won&#39;t make a huge difference in terms of lines to be written or performance, only caching the function may effect some faster performance on long strings and also a good practice of DRY code if you want to reuse."},{"score":5,"body_markdown":"In my apps, I use a custom function that is the most powerful for this purpose, and even wrapping the `split/join` solution in the simpler case, it is a little bit faster in `Chrome 60`and `Firefox 54`  ([`JSBEN.CH`][1]) than other solutions. My computer runs `Windows 7 64 bits`.\r\n\r\nThe advantage is that this custom function can handle many substitutions at the same time using strings or characters, which can be a shortcut for some applications.\r\n\r\nLike a `split/join` above solution, the solution below has no problem with escape characters, differently than regular expression approach.\r\n\r\n      function replaceAll(s,find,repl,caseOff,byChar){\r\n      if (arguments.length&lt;2)  return false; \r\n      var destDel = ! repl;       // if destDel delete all keys from target\r\n      var isString = !! byChar;   // if byChar, replace set of characters \r\n      if (typeof find !==typeof repl &amp;&amp; ! destDel)  return false; \r\n      if (isString  &amp;&amp;  (typeof find!==&quot;string&quot;))   return false; \r\n      \r\n      if (! isString &amp;&amp;  (typeof find===&quot;string&quot;))  {\r\n        return s.split(find).join(destDel?&quot;&quot;:repl);\r\n      }\r\n      \r\n      if ((! isString)  &amp;&amp;  ( ! Array.isArray(find) ||\r\n              ( ! Array.isArray(repl) &amp;&amp; ! destDel)   ))  return false;\r\n    \r\n         // if destOne replace all strings/characters by just one element\r\n      var destOne = destDel ? false : (repl.length===1);   \r\n    \r\n         // Generally source and destination should have the same size\r\n      if (! destOne &amp;&amp; ! destDel &amp;&amp; find.length!==repl.length)  return false    \r\n    \r\n      var prox,sUp,findUp,i,done;   \r\n      if (caseOff)  {    // case insensitive    \r\n           // Working with uppercase keys and target \r\n        sUp = s.toUpperCase();   \r\n        if (isString)\r\n           findUp = find.toUpperCase()   \r\n        else\r\n           findUp = find.map(function(el){  return el.toUpperCase();});    \r\n    \r\n      } else  {         // case sensitive\r\n         sUp = s;\r\n         findUp =find.slice();  // clone array/string\r\n      }  \r\n    \r\n      done = new Array(find.length);  // size: number of keys\r\n      done.fill(null);              \r\n      \r\n      var pos = 0;       // initial position in target s\r\n      var r = &quot;&quot;;   // initial result\r\n      var aux, winner;\r\n      while (pos &lt; s.length)  {       // Scanning the target\r\n         prox  = Number.MAX_SAFE_INTEGER;\r\n         winner = -1;  // no winner at start\r\n         for (i=0;i&lt;findUp.length;i++)   // find next occurence for each string\r\n           if (done[i]!==-1) {    // key still alive\r\n                 // Never search for the word/char or is over?\r\n             if (done[i]===null || done[i]&lt;pos)  { \r\n               aux = sUp.indexOf(findUp[i],pos);\r\n               done[i]=aux;  // Save the next occurrence\r\n             } else\r\n               aux = done[i]   // restore the position of last search\r\n             if (aux&lt;prox &amp;&amp; aux!==-1) {   // if next occurrence is minimum\r\n               winner = i;     // save it  \r\n               prox = aux;\r\n             }  \r\n           }  // not done\r\n    \r\n          if (winner===-1) {   // No matches forward\r\n             r += s.slice(pos);   \r\n             break;\r\n          } // no winner\r\n          \r\n          // found the character or string key in the target\r\n    \r\n          i = winner;  // restore the winner\r\n          r += s.slice(pos,prox);   // update piece before the match\r\n    \r\n                // Append the replacement in target \r\n          if (! destDel) r += repl[ destOne?0:i ];  \r\n          pos = prox + ( isString?1:findUp[i].length );       // go after match\r\n           \r\n      }  // loop\r\n      return r;  // return the resulting string\r\n    }\r\n\r\nThe documentation is below\r\n\r\n\r\n&gt;                replaceAll    \r\n&gt;      Syntax    \r\n&gt;      ======     \r\n&gt;           replaceAll(s,find,[ repl ,caseOff, byChar)     \r\n&gt;     \r\n&gt;      Parameters    \r\n&gt;      ==========    \r\n&gt;      \r\n&gt;        &quot;s&quot; is a string target of replacement.    \r\n&gt;        &quot;find&quot; can be a string or array of strings.     \r\n&gt;        &quot;repl&quot; should be the same type than &quot;find&quot; or empty     \r\n&gt;              \r\n&gt;       if &quot;find&quot; is a string, it is a simple replacement for      \r\n&gt;         all &quot;find&quot; occurrences in &quot;s&quot; by string &quot;repl&quot;    \r\n&gt;         \r\n&gt;       if &quot;find&quot; is an array, it will replaced each string in &quot;find&quot;    \r\n&gt;         that occurs in &quot;s&quot; for corresponding string in &quot;repl&quot; array.\r\n&gt;       The replace specs are independent: A replacement part cannot    \r\n&gt;         be replaced again. \r\n&gt;      \r\n&gt;           \r\n&gt;       if &quot;repl&quot; is empty all &quot;find&quot; occurrences in &quot;s&quot; will be deleted.   \r\n&gt;       if &quot;repl&quot; has only one character or element,    \r\n&gt;           all occurrences in &quot;s&quot; will be replaced for that one.   \r\n&gt;\r\n&gt;       &quot;caseOff&quot; is true if replacement is case insensitive     \r\n&gt;            (default is FALSE)\r\n&gt; \r\n&gt;       &quot;byChar&quot; is true when replacement is based on set of characters.    \r\n&gt;       Default is false   \r\n&gt;      \r\n&gt;       if &quot;byChar&quot;, it will be replaced in &quot;s&quot; all characters in &quot;find&quot;   \r\n&gt;       set of characters for corresponding character in  &quot;repl&quot;\r\n&gt;       set of characters   \r\n&gt;     \r\n&gt;      Return   \r\n&gt;      ======   \r\n&gt;       the function returns the new string after the replacement.  \r\n\r\nTo be fair, I ran the [benchmark][1] with no parameter test. \r\n\r\nHere is my test set, using `Node.js`\r\n\r\n    function l() { return console.log.apply(null, arguments); }\r\n    \r\n    var k=0;\r\n    l(++k,replaceAll(&quot;banana is a ripe fruit harvested near the river&quot;,\r\n          [&quot;ri&quot;,&quot;nea&quot;],[&quot;do&quot;,&quot;fa&quot;]));  //1\r\n    l(++k,replaceAll(&quot;banana is a ripe fruit harvested near the river&quot;,\r\n          [&quot;ri&quot;,&quot;nea&quot;],[&quot;do&quot;]));  //2\r\n    l(++k,replaceAll(&quot;banana is a ripe fruit harvested near the river&quot;,\r\n          [&quot;ri&quot;,&quot;nea&quot;]));  //3\r\n    l(++k,replaceAll(&quot;banana is a ripe fruit harvested near the river&quot;,\r\n         &quot;aeiou&quot;,&quot;&quot;,&quot;&quot;,true));  //4\r\n    l(++k,replaceAll(&quot;banana is a ripe fruit harvested near the river&quot;,\r\n          &quot;aeiou&quot;,&quot;a&quot;,&quot;&quot;,true));  //5\r\n    l(++k,replaceAll(&quot;banana is a ripe fruit harvested near the river&quot;,\r\n          &quot;aeiou&quot;,&quot;uoiea&quot;,&quot;&quot;,true));  //6\r\n    l(++k,replaceAll(&quot;banana is a ripe fruit harvested near the river&quot;,\r\n          &quot;aeiou&quot;,&quot;uoi&quot;,&quot;&quot;,true));  //7\r\n    l(++k,replaceAll(&quot;banana is a ripe fruit harvested near the river&quot;,\r\n          [&quot;ri&quot;,&quot;nea&quot;],[&quot;do&quot;,&quot;fa&quot;,&quot;leg&quot;]));  //8\r\n    l(++k,replaceAll(&quot;BANANA IS A RIPE FRUIT HARVESTED NEAR THE RIVER&quot;,\r\n          [&quot;ri&quot;,&quot;nea&quot;],[&quot;do&quot;,&quot;fa&quot;]));  //9\r\n    l(++k,replaceAll(&quot;BANANA IS A RIPE FRUIT HARVESTED NEAR THE RIVER&quot;,\r\n          [&quot;ri&quot;,&quot;nea&quot;],[&quot;do&quot;,&quot;fa&quot;],true)); //10\r\n    return;\r\n\r\nAnd the results:\r\n\r\n&gt; 1 &#39;banana is a dope fruit harvested far the dover&#39;   \r\n&gt; 2 &#39;banana is a dope fruit harvested dor the dover&#39;    \r\n&gt; 3 &#39;banana is a pe fruit harvested r the ver&#39;     \r\n&gt; 4 &#39;bnn s  rp frt hrvstd nr th rvr&#39;     \r\n&gt; 5 &#39;banana as a rapa fraat harvastad naar tha ravar&#39;    \r\n&gt; 6 &#39;bununu is u ripo frait hurvostod nour tho rivor&#39;      \r\n&gt; 7 false     \r\n&gt; 8 false      \r\n&gt; 9 &#39;BANANA IS A RIPE FRUIT HARVESTED NEAR THE RIVER&#39;     \r\n&gt; 10 &#39;BANANA IS A doPE FRUIT HARVESTED faR THE doVER&#39;      \r\n\r\n  [1]: http://jsben.ch/kdv27\r\n\r\n\r\n\r\n"},{"score":13,"body_markdown":"If the string contain similar pattern like `abccc`, you can use this:\r\n\r\n    str.replace(/abc(\\s|$)/g, &quot;&quot;)\r\n"},{"score":3,"body_markdown":"**In string first element search and replace** \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n&lt;!-- language: lang-js --&gt;\r\n\r\nvar str = &#39;[{&quot;id&quot;:1,&quot;name&quot;:&quot;karthikeyan.a&quot;,&quot;type&quot;:&quot;developer&quot;}]&#39;\r\nvar i = str.replace(&#39;&quot;[&#39;,&#39;[&#39;).replace(&#39;]&quot;&#39;,&#39;]&#39;);\r\nconsole.log(i,&#39;//first element search and replace&#39;)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n**In string global search and replace** \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n&lt;!-- language: lang-js --&gt;\r\n\r\nvar str = &#39;[{&quot;id&quot;:1,&quot;name&quot;:&quot;karthikeyan.a&quot;,&quot;type&quot;:&quot;developer&quot;}]&#39;\r\nvar j = str.replace(/\\&quot;\\[/g,&#39;[&#39;).replace(/\\]\\&quot;/g,&#39;]&#39;);\r\nconsole.log(j,&#39;//global search and replace&#39;)\r\n\r\n&lt;!-- end snippet --&gt;"},{"score":26,"body_markdown":"    str = str.replace(new RegExp(&quot;abc&quot;, &#39;g&#39;), &quot;&quot;);\r\n\r\nworked better for me than the above answers. so `new RegExp(&quot;abc&quot;, &#39;g&#39;)` creates a RegExp what matches all occurence (`&#39;g&#39;` flag) of the text (`&quot;abc&quot;`). The second part is what gets replaced to, in your case empty string (`&quot;&quot;`).\r\n`str` is the string, and we have to override it, as `replace(...)` just returns result, but not overrides. In some cases you might want to use that."},{"score":2,"body_markdown":"I just want to share my solution, based on some of the functional features of last versions of JavaScript:\r\n\r\n       var str = &quot;Test abc test test abc test test test abc test test abc&quot;;\r\n\r\n       var result = str.split(&#39; &#39;).reduce((a, b) =&gt; {\r\n          return b == &#39;abc&#39; ? a : a + &#39; &#39; + b;   })\r\n\r\n      console.warn(result)\r\n\r\n"},{"score":3,"body_markdown":"For **unique** replaceable values\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    String.prototype.replaceAll = function(search_array, replacement_array) {\r\n      //\r\n      var target = this;\r\n      //\r\n      search_array.forEach(function(substr, index) {\r\n        if (typeof replacement_array[index] != &quot;undefined&quot;) {\r\n          target = target.replace(new RegExp(substr, &#39;g&#39;), replacement_array[index])\r\n        }\r\n      });\r\n      //\r\n      return target;\r\n    };\r\n\r\n    //  Use:\r\n    var replacedString = &quot;This topic commented on :year. Talking :question.&quot;.replaceAll([&#39;:year&#39;, &#39;:question&#39;], [&#39;2018&#39;, &#39;How to replace all occurrences of a string in JavaScript&#39;]);\r\n//\r\nconsole.log(replacedString);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":5,"body_markdown":"In terms of performance related to the main answers [these are some online tests][1].\r\n\r\nWhile the following are some performance tests using `console.time()` (they work best in your own console, the time is very short to be seen in the snippet)\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    console.time(&#39;split and join&#39;);\r\n    &quot;javascript-test-find-and-replace-all&quot;.split(&#39;-&#39;).join(&#39; &#39;);\r\n    console.timeEnd(&#39;split and join&#39;)\r\n\r\n    console.time(&#39;regular expression&#39;);\r\n    &quot;javascript-test-find-and-replace-all&quot;.replace(new RegExp(&#39;-&#39;, &#39;g&#39;), &#39; &#39;);\r\n    console.timeEnd(&#39;regular expression&#39;);\r\n\r\n    console.time(&#39;while&#39;);\r\n    let str1 = &quot;javascript-test-find-and-replace-all&quot;;\r\n    while (str1.indexOf(&#39;-&#39;) !== -1) {\r\n        str1 = str1.replace(&#39;-&#39;, &#39; &#39;);\r\n    }\r\n    console.timeEnd(&#39;while&#39;);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe interesting thing to notice is that if you run them multiple time the results are always different even though the `RegExp` solution seems the fastest on average and the `while` loop solution the slowest.\r\n\r\n  [1]: http://jsben.ch/BVIHC"},{"score":12,"body_markdown":"The previous answers are way too complicated. Just use the replace function like this:\r\n\r\n    str.replace(/your_regex_pattern/g, replacement_string);\r\n\r\nExample:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var str = &quot;Test abc test test abc test test test abc test test abc&quot;;\r\n\r\n    var res = str.replace(/[abc]+/g, &quot;&quot;);\r\n\r\n    console.log(res);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"You can try like this:\r\n\r\nExample data:\r\n\r\n    var text = &quot;heloo,hai,hei&quot;\r\n\r\n    text = text.replace(/[,]+/g, &#39;&#39;)\r\n\r\nor\r\n\r\n```\r\ntext.forEach(function(value){\r\n  hasil = hasil.replace(&#39;,&#39;, &#39;&#39;)\r\n})```\r\n\r\n"},{"score":6,"body_markdown":"**Method 1**\r\n\r\nTry to implement a regular expression:\r\n\r\n&quot;Test abc test test abc test test test abc test test abc&quot;.replace(/\\abc/g, &#39; &#39;);\r\n\r\n**Method 2**\r\n\r\nSplit and join. Split with abc and join with empty space.\r\n\r\n&quot;Test abc test test abc test test test abc test test abc&quot;.split(&quot;abc&quot;).join(&quot; &quot;)\r\n\r\n"},{"score":2,"body_markdown":"The best solution, in order to replace any character we use the `indexOf()`, `includes()`, and `substring()` functions to replace the matched string with the provided string in the current string.\r\n\r\n * The [`String.indexOf()`][1] function is to find the `n`&lt;sup&gt;th&lt;/sup&gt; match index position.\r\n * The [`String.includes()`][2] method determines whether one string may be found within another string, returning true or false as appropriate.\r\n * [`String.substring()`][3] function is to get the parts of String(`preceding`,`exceding`). Add the replace String in-between these parts to generate final return String.\r\n\r\nThe following function allows to use any character.\r\n&lt;br /&gt;where as [`RegExp`][4] will not allow some special character like `**` and some characters need to be escaped, like `$`.\r\n\r\n```lang-javascript\r\nString.prototype.replaceAllMatches = function(obj) { // Obj format: { &#39;matchkey&#39; : &#39;replaceStr&#39; }\r\n    var retStr = this;\r\n    for (var x in obj) {\r\n        //var matchArray = retStr.match(new RegExp(x, &#39;ig&#39;));\r\n        //for (var i = 0; i &lt; matchArray.length; i++) {\r\n        var prevIndex = retStr.indexOf(x); // matchkey = &#39;*&#39;, replaceStr = &#39;$*&#39; While loop never ends.\r\n        while (retStr.includes(x)) {\r\n            retStr = retStr.replaceMatch(x, obj[x], 0);\r\n            var replaceIndex = retStr.indexOf(x);\r\n            if( replaceIndex &lt;  prevIndex + (obj[x]).length) {\r\n                break;\r\n            } else {\r\n                prevIndex = replaceIndex;\r\n            }\r\n        }\r\n    }\r\n    return retStr;\r\n};\r\nString.prototype.replaceMatch = function(matchkey, replaceStr, matchIndex) {\r\n    var retStr = this, repeatedIndex = 0;\r\n    //var matchArray = retStr.match(new RegExp(matchkey, &#39;ig&#39;));\r\n    //for (var x = 0; x &lt; matchArray.length; x++) {\r\n    for (var x = 0; (matchkey != null) &amp;&amp; (retStr.indexOf(matchkey) &gt; -1); x++) {\r\n        if (repeatedIndex == 0 &amp;&amp; x == 0) {\r\n            repeatedIndex = retStr.indexOf(matchkey);\r\n        } else { // matchIndex &gt; 0\r\n            repeatedIndex = retStr.indexOf(matchkey, repeatedIndex + 1);\r\n        }\r\n        if (x == matchIndex) {\r\n            retStr = retStr.substring(0, repeatedIndex) + replaceStr + retStr.substring(repeatedIndex + (matchkey.length));\r\n            matchkey = null; // To break the loop.\r\n        }\r\n    }\r\n    return retStr;\r\n};\r\n```\r\n\r\n---\r\n\r\nWe can also use the regular expression object for matching text with a pattern. The following are functions which will use the regular expression object.\r\n\r\nYou will get SyntaxError when you are using an *invalid* regular expression pattern like `&#39;**&#39;`.\r\n\r\n * The [`String.replace()`][5] function is used to replace the specified String with the given String.\r\n * The [`String.match()`][6] function is to find how many time the string is repeated.\r\n * The [`RegExp.prototype.test`][7] method executes a search for a match between a regular expression and a specified string. Returns true or false.\r\n\r\n```lang-javascript\r\nString.prototype.replaceAllRegexMatches = function(obj) { // Obj format: { &#39;matchkey&#39; : &#39;replaceStr&#39; }\r\n    var retStr = this;\r\n    for (var x in obj) {\r\n        retStr = retStr.replace(new RegExp(x, &#39;ig&#39;), obj[x]);\r\n    }\r\n    return retStr;\r\n};\r\n```\r\n&gt; Note that regular expressions are written without quotes.\r\n\r\n----\r\n\r\nExamples to use the above functions:\r\n\r\n```lang-javascript\r\nvar str = &quot;yash yas $dfdas.**&quot;;\r\nconsole.log(&#39;String: &#39;, str);\r\n\r\n// No need to escape any special character\r\nconsole.log(&#39;Index matched replace: &#39;, str.replaceMatch(&#39;as&#39;, &#39;*&#39;, 2));\r\nconsole.log(&#39;Index Matched replace: &#39;, str.replaceMatch(&#39;y&#39;, &#39;~&#39;, 1));\r\nconsole.log(&#39;All Matched replace: &#39;, str.replaceAllMatches({&#39;as&#39;: &#39;**&#39;, &#39;y&#39;:&#39;Y&#39;, &#39;$&#39;:&#39;-&#39;}));\r\nconsole.log(&#39;All Matched replace : &#39;, str.replaceAllMatches({&#39;**&#39;: &#39;~~&#39;, &#39;$&#39;:&#39;&amp;$&amp;&#39;, &#39;&amp;&#39;:&#39;%&#39;, &#39;~&#39;:&#39;&gt;&#39;}));\r\n\r\n// You need to escape some special Characters\r\nconsole.log(&#39;REGEX all matched replace: &#39;, str.replaceAllRegexMatches({&#39;as&#39; : &#39;**&#39;, &#39;y&#39;:&#39;Y&#39;, &#39;\\\\$&#39;:&#39;-&#39;}));\r\n```\r\n\r\nResult:\r\n\r\n```lang-none\r\nString:  yash yas $dfdas.**\r\nIndex Matched replace:  yash yas $dfd*.**\r\nIndex Matched replace:  yash ~as $dfdas.**\r\n\r\nAll Matched replace:  Y**h Y** -dfd**.**\r\nAll Matched replace:  yash yas %$%dfdas.&gt;&gt;\r\n\r\nREGEX All Matched replace:  Y**h Y** -dfd**.**\r\n```\r\n\r\n-------------------------------------\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\r\n  [5]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace\r\n  [6]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match\r\n  [7]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test\r\n"},{"score":1,"body_markdown":"The simplest solution -\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let str = &quot;Test abc test test abc test test test abc test test abc&quot;;\r\n\r\n    str = str.split(&quot; &quot;);\r\n    str = str.filter((ele, key)=&gt; ele!==&quot;abc&quot;)\r\n    str = str.join(&quot; &quot;)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nOr simply -\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    str = str.split(&quot; &quot;).filter((ele, key) =&gt; ele != &quot;abc&quot;).join(&quot; &quot;)\r\n\r\n&lt;!-- end snippet --&gt;\r\n"},{"score":6,"body_markdown":"This can be achieved using regular expressions. A few combinations that might help someone:\r\n\r\n    var word = &quot;this,\\\\ .is*a*test,    &#39;.and? / only /     &#39;a \\ test?&quot;;\r\n    var stri = &quot;This      is    a test         and only a        test&quot;;\r\n\r\n**To replace all non alpha characters,**\r\n\r\n    console.log(word.replace(/([^a-z])/g,&#39; &#39;).replace(/ +/g, &#39; &#39;)); \r\n    Result: [this is a test and only a test]\r\n\r\n**To replace multiple continuous spaces with one space,**\r\n\r\n    console.log(stri.replace(/  +/g,&#39; &#39;)); \r\n    Result: [This is a test and only a test]\r\n\r\n**To replace all * characters,**\r\n\r\n    console.log(word.replace(/\\*/g,&#39;&#39;)); \r\n    Result: [this,\\ .isatest,    &#39;.and? / only /     &#39;a  test?]\r\n\r\n**To replace question marks (?)**\r\n\r\n    console.log(word.replace(/\\?/g,&#39;#&#39;)); \r\n    Result: [this,\\ .is*a*test,    &#39;.and# / only /     &#39;a  test#]\r\n\r\n**To replace quotation marks,**\r\n\r\n    console.log(word.replace(/&#39;/g,&#39;#&#39;));  \r\n    Result: [this,\\ .is*a*test,    #.and? / only /     #a  test?]\r\n\r\n**To replace all &#39; characters,**\r\n\r\n    console.log(word.replace(/,/g,&#39;&#39;)); \r\n    Result: [this\\ .is*a*test    &#39;.and? / only /     &#39;a  test?]\r\n\r\n**To replace a specific word,**\r\n\r\n    console.log(word.replace(/test/g,&#39;&#39;)); \r\n    Result: [this,\\ .is*a*,    &#39;.and? / only /     &#39;a  ?]\r\n\r\n**To replace back-slash,**\r\n\r\n    console.log(word.replace(/\\\\/g,&#39;&#39;));  \r\n    Result: [this, .is*a*test,    &#39;.and? / only /     &#39;a  test?]\r\n\r\n**To replace forward slash,**\r\n\r\n    console.log(word.replace(/\\//g,&#39;&#39;));  \r\n    Result: [this,\\ .is*a*test,    &#39;.and?  only      &#39;a  test?]\r\n\r\n**To replace all spaces,**\r\n\r\n    console.log(word.replace(/ /g,&#39;#&#39;));  \r\n    Result: [this,\\#.is*a*test,####&#39;.and?#/#only#/#####&#39;a##test?]\r\n\r\n**To replace dots,**\r\n\r\n    console.log(word.replace(/\\./g,&#39;#&#39;)); \r\n    Result: [this,\\ #is*a*test,    &#39;#and? / only /     &#39;a  test?]\r\n\r\n"},{"score":1,"body_markdown":"     var myName = &#39;r//i//n//o//l////d&#39;;\r\n      var myValidName = myName.replace(new RegExp(&#39;\\//&#39;, &#39;g&#39;), &#39;&#39;); &gt; // rinold\r\n      console.log(myValidName);\r\n    \r\n    var myPetName = &#39;manidog&#39;;\r\n    var renameManiToJack = myPetName.replace(new RegExp(&#39;mani&#39;, &#39;g&#39;), &#39;jack&#39;); &gt; // jackdog\r\n\r\n"},{"score":60,"body_markdown":"These are the most common and readable methods.\r\n\r\n    var str = &quot;Test abc test test abc test test test abc test test abc&quot;\r\n\r\n**Method 1:**\r\n\r\n    str = str.replace(/abc/g, &quot;replaced text&quot;);\r\n\r\n**Method 2:**\r\n\r\n    str = str.split(&quot;abc&quot;).join(&quot;replaced text&quot;);\r\n\r\n**Method 3:**\r\n\r\n    str = str.replace(new RegExp(&quot;abc&quot;, &quot;g&quot;), &quot;replaced text&quot;);\r\n\r\n**Method 4:**\r\n\r\n    while(str.includes(&quot;abc&quot;)){\r\n        str = str.replace(&quot;abc&quot;, &quot;replaced text&quot;);\r\n    }\r\n\r\nOutput:\r\n\r\n    console.log(str);\r\n    // Test replaced text test test replaced text test test test replaced text test test replaced text\r\n\r\n\r\n"},{"score":5,"body_markdown":"I use split and join or this funcion\r\n\r\n    function replaceAll( text, busca, reemplaza ){\r\n      while (text.toString().indexOf(busca) != -1)\r\n          text = text.toString().replace(busca,reemplaza);\r\n      return text;\r\n    }"},{"score":2,"body_markdown":"This should work.\r\n\r\n    String.prototype.replaceAll = function (search, replacement) {\r\n        var str1 = this.replace(search, replacement);\r\n        var str2 = this;\r\n        while(str1 != str2) {\r\n            str2 = str1;\r\n            str1 = str1.replace(search, replacement);\r\n        }\r\n        return str1;\r\n    }\r\n\r\nExample:\r\n\r\n    Console.log(&quot;Steve is the best character in Minecraft&quot;.replaceAll(&quot;Steve&quot;, &quot;Alex&quot;));\r\n\r\n\r\n\r\n"},{"score":15,"body_markdown":"The simplest way to this without using any regex is split and join like the code here:\r\n\r\n    var str = &quot;Test abc test test abc test test test abc test test abc&quot;;\r\n    str.split(&#39;abc&#39;).join(&#39;&#39;)\r\n\r\n\r\n\r\n\r\n"},{"score":0,"body_markdown":"All the answers are accepted, you can do this by many ways. One of the trick to do this is this.\r\n\r\n   \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n     const str = &quot;Test abc test test abc test test test abc test test abc&quot;;\r\n        \r\n        const compare = &quot;abc&quot;;\r\n        arrayStr = str.split(&quot; &quot;);\r\n        arrayStr.forEach((element, index) =&gt; {\r\n          if (element == compare) {\r\n            arrayStr.splice(index, 1);\r\n          }\r\n        });\r\n        const newString = arrayStr.join(&quot; &quot;);\r\n        console.log(newString);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":64,"body_markdown":"For replacing a single time use:\r\n\r\n    var res = str.replace(&#39;abc&#39;, &quot;&quot;);\r\n    \r\nFor replacing multiple times use:\r\n\r\n    var res = str.replace(/abc/g, &quot;&quot;);"},{"score":6,"body_markdown":"Check this answer may it will help and I used in my project.\r\n\r\n    function replaceAll(searchString, replaceString, str) {\r\n       return str.split(searchString).join(replaceString);\r\n    }\r\n    replaceAll(&#39;abc&#39;, &#39;&#39;,&quot;Test abc test test abc test test test abc test test abc&quot; ); // &quot;Test  test test  test test test  test test &quot;"},{"score":1,"body_markdown":"You can do it without Regex, but you need to be careful if the replacement text contains the search text. \r\n\r\ne.g. \r\n\r\n    replaceAll(&quot;nihIaohi&quot;, &quot;hI&quot;, &quot;hIcIaO&quot;, true)\r\n\r\nSo here is a proper variant of replaceAll, including string-prototype:\r\n\r\n    function replaceAll(str, find, newToken, ignoreCase)\r\n    {\r\n        let i = -1;\r\n        \r\n        if (!str)\r\n        {\r\n            // Instead of throwing, act as COALESCE if find == null/empty and str == null\r\n            if ((str == null) &amp;&amp; (find == null))\r\n                return newToken;\r\n    \r\n            return str;\r\n        }\r\n    \r\n        if (!find) // sanity check \r\n            return str;\r\n    \r\n        ignoreCase = ignoreCase || false;\r\n        find = ignoreCase ? find.toLowerCase() : find;\r\n    \r\n        while ((\r\n            i = (ignoreCase ? str.toLowerCase() : str).indexOf(\r\n                find, i &gt;= 0 ? i + newToken.length : 0\r\n            )) !== -1\r\n        )\r\n        {\r\n            str = str.substring(0, i) +\r\n                newToken +\r\n                str.substring(i + find.length);\r\n        } // Whend \r\n    \r\n        return str;\r\n    }\r\n    \r\n\r\nOr, if you want to have a string-prototype function: \r\n\r\n    \r\n    String.prototype.replaceAll = function (find, replace) {\r\n        let str = this;\r\n    \r\n        let i = -1;\r\n        \r\n        if (!str)\r\n        {\r\n            // Instead of throwing, act as COALESCE if find == null/empty and str == null\r\n            if ((str == null) &amp;&amp; (find == null))\r\n                return newToken;\r\n    \r\n            return str;\r\n        }\r\n    \r\n        if (!find) // sanity check \r\n            return str;\r\n    \r\n        ignoreCase = ignoreCase || false;\r\n        find = ignoreCase ? find.toLowerCase() : find;\r\n    \r\n        while ((\r\n            i = (ignoreCase ? str.toLowerCase() : str).indexOf(\r\n                find, i &gt;= 0 ? i + newToken.length : 0\r\n            )) !== -1\r\n        )\r\n        {\r\n            str = str.substring(0, i) +\r\n                newToken +\r\n                str.substring(i + find.length);\r\n        } // Whend \r\n    \r\n        return str;\r\n    };\r\n\r\n"},{"score":3,"body_markdown":"```\r\nstr = &quot;Test abc test test abc test test test abc test test abc&quot;\r\n\r\nstr.split(&#39; &#39;).join().replace(/abc/g,&#39;&#39;).replace(/,/g, &#39; &#39;)\r\n```"},{"score":4,"body_markdown":"There is now a [finished proposal](https://github.com/tc39/proposal-string-replaceall) for integrating `String.prototype.replaceAll` into the official specification. Eventually, developers will not have to come up with their own implementations for `replaceAll` - instead, modern Javascript engines will support it natively.\r\n\r\nThe proposal is at stage 4, which [means](https://tc39.es/process-document/) that everything is complete, and all that&#39;s left is for browsers to start implementing it.\r\n\r\nIt [has shipped](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll#Browser_compatibility) in the latest versions of Chrome, Firefox, and Safari.\r\n\r\nHere are the implementation details:\r\n\r\n&gt; Per the current TC39 consensus, `String.prototype.replaceAll` behaves identically to `String.prototype.replace` in all cases, **except** for the following two cases:\r\n&gt;\r\n&gt; 1. If `searchValue` is a string, `String.prototype.replace` only replaces a single occurrence of the `searchValue`, whereas `String.prototype.replaceAll` replaces *all* occurrences of the `searchValue` (as if `.split(searchValue).join(replaceValue)` or a global &amp; properly-escaped regular expression had been used).\r\n&gt; 2. If `searchValue` is a non-global regular expression, `String.prototype.replace` replaces a single match, whereas `String.prototype.replaceAll` throws an exception. This is done to avoid the inherent confusion between the lack of a global flag (which implies &quot;do NOT replace all&quot;) and the name of the method being called (which strongly suggests &quot;replace all&quot;).\r\n&gt;\r\n&gt; Notably, `String.prototype.replaceAll` behaves just like `String.prototype.replace` if `searchValue` is a global regular expression.\r\n\r\nYou can see a spec-compliant polyfill [here](https://github.com/zloirock/core-js#stringreplaceall).\r\n\r\nIn supported environments, the following snippet will log `foo-bar-baz`, without throwing an error:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const str = &#39;foo bar baz&#39;;\r\n    console.log(\r\n      str.replaceAll(&#39; &#39;, &#39;-&#39;)\r\n    );\r\n\r\n&lt;!-- end snippet --&gt;"},{"score":12,"body_markdown":"As of August 2020 there is a [Stage 4 proposal][1] to ECMAScript that adds the [`replaceAll`][2] method to `String`.\r\n\r\nIt&#39;s now supported in **Chrome 85+, Edge 85+, Firefox 77+, Safari 13.1+**.\r\n\r\nThe usage is the same as the [`replace`][3] method:\r\n\r\n    String.prototype.replaceAll(searchValue, replaceValue)\r\n\r\nHere&#39;s an example usage:\r\n\r\n    &#39;Test abc test test abc test.&#39;.replaceAll(&#39;abc&#39;, &#39;foo&#39;); // -&gt; &#39;Test foo test test foo test.&#39;\r\n\r\n\r\n\r\n----------\r\n\r\n\r\nIt&#39;s supported in [most modern browsers][4], but there exist polyfills:\r\n\r\n - [core-js][5]\r\n - [es-shims][6]\r\n\r\n\r\nIt is supported in the [V8][7] engine behind an experimental flag `--harmony-string-replaceall`.\r\nRead more on the [V8 website][8].\r\n\r\n\r\n  [1]: https://tc39.es/proposal-string-replaceall/\r\n  [2]: https://github.com/tc39/proposal-string-replaceall\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace\r\n  [4]: https://caniuse.com/#search=replaceAll\r\n  [5]: https://github.com/zloirock/core-js#stringreplaceall\r\n  [6]: https://github.com/es-shims/String.prototype.replaceAll\r\n  [7]: https://v8.dev/\r\n  [8]: https://v8.dev/features/string-replaceall"},{"score":0,"body_markdown":"Check this. I&#39;m sure it will help you:\r\n\r\n    &lt;!DOCTYPE html&gt;\r\n    &lt;html&gt;\r\n    &lt;body&gt;\r\n    &lt;p&gt;Click the button to do a global search and replace for &quot;is&quot; in a string.&lt;/p&gt;\r\n    &lt;button onclick=&quot;myFunction()&quot;&gt;Try it&lt;/button&gt;\r\n    &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;\r\n    &lt;script&gt;\r\n    function myFunction() {\r\n      var str = &#39;Is this &quot;3&quot; dris &quot;3&quot;?&#39;;\r\n      var allvar= &#39;&quot;3&quot;&#39;;\r\n      var patt1 = new RegExp( allvar, &#39;g&#39; );\r\n      document.getElementById(&quot;demo&quot;).innerHTML = str.replace(patt1,&#39;&quot;5&quot;&#39;);\r\n    }\r\n    &lt;/script&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;\r\n\r\nHere is the [JSFiddle link][1].\r\n\r\n  [1]: https://jsfiddle.net/Wsmemon/23ykfjh8/41/\r\n\r\n\r\n\r\n\r\n\r\n"},{"score":3,"body_markdown":"In November 2019 a new feature is added to the JavaScript `string.prototype.replaceAll()`.\r\n\r\nCurrently it&#39;s only supported with babel.JS, but maybe in the future it can be implemented in all the browsers. For more information, [read here][1].\r\n\r\n  [1]: https://v8.dev/features/string-replaceall\r\n"},{"score":29,"body_markdown":"Performance\n-\n\nToday 27.12.2019 I perform tests on [macOS v10.13.6][1] (High Sierra) for the chosen solutions.\n\n**Conclusions**\n\n* The `str.replace(/abc/g, &#39;&#39;);` (**C**) is a good cross-browser fast solution for all strings.\n* Solutions based on `split-join` (**A,B**) or `replace` (**C,D**) are fast\n* Solutions based on `while` (**E,F,G,H**) are slow - usually ~4 times slower for small strings and about ~3000 times (!) slower for long strings\n* The recurrence solutions (**RA,RB**) are slow and do not work for long strings\n\nI also create my own solution. It looks like currently it is the shortest one which does the question job:\n\n    str.split`abc`.join``\n\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    str = &quot;Test abc test test abc test test test abc test test abc&quot;;\n    str = str.split`abc`.join``\n\n    console.log(str);\n\n&lt;!-- end snippet --&gt;\n\nDetails\n-\n\nThe tests were performed on Chrome 79.0, Safari 13.0.4 and Firefox 71.0 (64 bit). The tests `RA` and `RB` use recursion. Results\n\n[![Enter image description here][2]][2]\n\n## Short string - 55 characters ##\n\nYou can run tests on your machine [HERE](https://jsperf.com/remove-substring-small/1). Results for Chrome:\n\n[![Enter image description here][3]][3]\n\n## Long string: 275 000 characters ##\n\nThe recursive solutions **RA** and **RB** gives\n\n&gt; RangeError: Maximum call stack size exceeded\n\nFor 1M characters they even break Chrome\n\n[![enter image description here][4]][4]\n\nI try to perform tests for 1M characters for other solutions, but **E,F,G,H** takes so much time that browser ask me to break script so I shrink test string to 275K characters. You can run tests on your machine [HERE](https://jsperf.com/remove-substring-big/1). Results for Chrome\n\n[![enter image description here][5]][5]\n\nCode used in tests\n\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    var t=&quot;Test abc test test abc test test test abc test test abc&quot;; // .repeat(5000)\n    var log = (version,result) =&gt; console.log(`${version}: ${result}`);\n\n\n    function A(str) {\n      return str.split(&#39;abc&#39;).join(&#39;&#39;);\n    }\n\n    function B(str) {\n      return str.split`abc`.join``; // my proposition\n    }\n\n\n    function C(str) {\n      return str.replace(/abc/g, &#39;&#39;);\n    }\n\n    function D(str) {\n      return str.replace(new RegExp(&quot;abc&quot;, &quot;g&quot;), &#39;&#39;);\n    }\n\n    function E(str) {\n      while (str.indexOf(&#39;abc&#39;) !== -1) { str = str.replace(&#39;abc&#39;, &#39;&#39;); }\n      return str;\n    }\n\n    function F(str) {\n      while (str.indexOf(&#39;abc&#39;) !== -1) { str = str.replace(/abc/, &#39;&#39;); }\n      return str;\n    }\n\n    function G(str) {\n      while(str.includes(&quot;abc&quot;)) { str = str.replace(&#39;abc&#39;, &#39;&#39;); }\n      return str;\n    }\n\n    // src: https://stackoverflow.com/a/56989553/860099\n    function H(str)\n    {\n        let i = -1\n        let find = &#39;abc&#39;;\n        let newToken = &#39;&#39;;\n\n        if (!str)\n        {\n            if ((str == null) &amp;&amp; (find == null)) return newToken;\n            return str;\n        }\n\n        while ((\n            i = str.indexOf(\n                find, i &gt;= 0 ? i + newToken.length : 0\n            )) !== -1\n        )\n        {\n            str = str.substring(0, i) +\n                newToken +\n                str.substring(i + find.length);\n        }\n        return str;\n    }\n\n    // src: https://stackoverflow.com/a/22870785/860099\n    function RA(string, prevstring) {\n      var omit = &#39;abc&#39;;\n      var place = &#39;&#39;;\n      if (prevstring &amp;&amp; string === prevstring)\n        return string;\n      prevstring = string.replace(omit, place);\n      return RA(prevstring, string)\n    }\n\n    // src: https://stackoverflow.com/a/26107132/860099\n    function RB(str) {\n      var find = &#39;abc&#39;;\n      var replace = &#39;&#39;;\n      var i = str.indexOf(find);\n      if (i &gt; -1){\n        str = str.replace(find, replace);\n        i = i + replace.length;\n        var st2 = str.substring(i);\n        if(st2.indexOf(find) &gt; -1){\n          str = str.substring(0,i) + RB(st2, find, replace);\n        }\n      }\n      return str;\n    }\n\n\n\n\n    log(&#39;A &#39;, A(t));\n    log(&#39;B &#39;, B(t));\n    log(&#39;C &#39;, C(t));\n    log(&#39;D &#39;, D(t));\n    log(&#39;E &#39;, E(t));\n    log(&#39;F &#39;, F(t));\n    log(&#39;G &#39;, G(t));\n    log(&#39;H &#39;, H(t));\n    log(&#39;RA&#39;, RA(t)); // use reccurence\n    log(&#39;RB&#39;, RB(t)); // use reccurence\n\n&lt;!-- language: lang-html --&gt;\n\n    &lt;p style=&quot;color:red&quot;&gt;This snippet only presents codes used in tests. It not perform test itself!&lt;p&gt;\n\n&lt;!-- end snippet --&gt;\n\n\n  [1]: https://en.wikipedia.org/wiki/MacOS_High_Sierra\n  [2]: https://i.stack.imgur.com/si5UK.png\n  [3]: https://i.stack.imgur.com/Ctf18.png\n  [4]: https://i.stack.imgur.com/dNkYp.png\n  [5]: https://i.stack.imgur.com/0uEgk.png"},{"score":1,"body_markdown":"We can use the `replace` method in JavaScript:\r\n\r\n    var result = yourString.replace(&#39;regexPattern&#39;, &quot;replaceString&quot;);\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var str = &quot;Test abc test test abc test test test abc test test abc&quot;;\r\n\r\n    var expectedString = str.replace(/abc(\\s|$)/g, &quot;&quot;);\r\n\r\n    console.log(expectedString);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n"},{"score":1,"body_markdown":"I know this isnt the best way to do this, but you can try this:\r\n```\r\nvar annoyingString = &quot;Test abc test test abc test test test abc test test abc&quot;;\r\n\r\nwhile (annoyingString.includes(&quot;abc&quot;)) {\r\n    annoyingString = annoyingString.replace(&quot;abc&quot;, &quot;&quot;)\r\n}"},{"score":0,"body_markdown":"I added the function below to this perf test page in the &quot;library&quot; section:\r\n\r\nhttps://jsben.ch/LFfWA\r\n\r\n    function _replace(t, s, r){\r\n    \tvar i = t.indexOf(s);\r\n        if (i == -1) return t;\r\n        return t.slice(0, i) + r + _replace(t.slice(i + s.length, t.length), s,r);\r\n    }\r\n\r\n..and put this in as the test:\r\n\r\n    var replaced = _replace(testString, &#39;abc&#39;,&#39;123&#39;);\r\n\r\n.. and that function performs about 34% faster for me than split or regex. The idea / hope was to end up pasting smaller and smaller pieces of the string onto the stack and then building the entire result by unrolling the stack, thereby minimizing extra string copies and extra searches through the same string data and hopefully optimizing use of the CPU cache.\r\n\r\nPart of the thought was that if the string isn&#39;t too big, it may end up in the CPU cache; passing it and pasting pieces of it puts those bits into the cache, and then the searching can operate entirely using CPU cached data. Now whether or not that&#39;s actually what ends up happening I&#39;m sure is entirely js implementation dependant.\r\n\r\nThis isn&#39;t as fast as possible, but it&#39;s as fast as I could manage without mutable strings. Arrays in JavaScript probably have a pointer for each element, so, a solution involving a lot of array elements is not likely to be as CPU cache friendly as this.\r\n"},{"score":0,"body_markdown":"Starting from v85, chrome now supports `String.prototype.replaceAll` natively. Note this outperform all other proposed solutions and should be used once majorly supported.\r\n\r\nFeature status:\r\nhttps://chromestatus.com/feature/6040389083463680\r\n\r\n    str s = &quot;hello hello world&quot;;\r\n    s = s.replaceAll(&quot;hello&quot;, &quot;&quot;); // s is now &quot;world&quot;"},{"score":4,"body_markdown":"Here&#39;s very simple solution.\r\nYou can assign a new method to String object\r\n```\r\nString.prototype.replaceAll = function(search, replace){\r\n   return this.replace(new RegExp(search, &#39;g&#39;), replace)\r\n}\r\n\r\nvar str = &quot;Test abc test test abc test test test abc test test abc&quot;;\r\nstr = str.replaceAll(&#39;abc&#39;, &#39;&#39;);\r\n\r\nconsole.log(str) // -&gt; Test  test test  test test test  test test\r\n```"},{"score":1,"body_markdown":"Use Split and Join\r\n\r\n    var str  = &quot;Test abc test test abc test test test abc test test abc&quot;;\r\n    var replaced_str = str.split(&#39;abc&#39;).join(&#39;&#39;);"},{"score":0,"body_markdown":"I would suggest adding a global method for string class by appending it to prototype chain.\r\n\r\n    String.prototype.replaceAll = function(fromReplace, toReplace, {ignoreCasing} = {}) { return this.replace(new RegExp(fromReplace, ignoreCasing ? &#39;ig&#39;: &#39;g&#39;), toReplace);}\r\n\r\nand it can be used like\r\n\r\n    &#39;stringwithpattern&#39;.replaceAll(&#39;pattern&#39;,&#39;new-pattern&#39;)"},{"score":1,"body_markdown":"**In August 2020**\r\n\r\n&gt; No more regular expression stuff\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const str = &quot;Test abc test test abc test test test abc test test abc&quot;;\r\n    const modifiedStr = str.replaceAll(&#39;abc&#39;, &#39;&#39;);\r\n    console.log(modifiedStr);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll"},{"score":1,"body_markdown":"This solution combines some previous answers and conforms somewhat better to the proposed August 2020 standard solution. This solution is still viable for me in September 2020, as `String.replaceAll` is not available in the `node` binary I am using.\r\n\r\n---\r\n`RegExp.escape` is a separate issue to deal with, but is important here because the official proposed solution will automatically escape `string`-based `find` input. This `String.replaceAll` polyfill would not without the `RegExp.escape` logic.\r\n\r\nI have added an answer which doesn&#39;t polyfill `RegExp.Escape`, in the case that you don&#39;t want that.\r\n\r\n---\r\nIf you pass a `RegExp` to `find`, you _MUST_ include `g` as a flag. This polyfill won&#39;t provide a nice TypeError for you and will cause you a major bad time.\r\n\r\nIf you need exact standards conformance, for an application which is rigorously relying on the standard implementation, then I suggest using `babel` or some other tool to get you the &#39;right answer&#39; every time instead of SO dot com. That way you won&#39;t have any surprises.\r\n\r\n---\r\nCode:\r\n```\r\nif (!Object.prototype.hasOwnProperty.call(RegExp, &#39;escape&#39;)) {\r\n  RegExp.escape = function(string) {\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\r\n    // https://github.com/benjamingr/RegExp.escape/issues/37\r\n    return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, &#39;\\\\$&amp;&#39;); // $&amp; means the whole matched string\r\n  };\r\n}\r\n\r\nif (!Object.prototype.hasOwnProperty.call(String, &#39;replaceAll&#39;)) {\r\n  String.prototype.replaceAll = function(find, replace) {\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\r\n    // If you pass a RegExp to &#39;find&#39;, you _MUST_ include &#39;g&#39; as a flag.\r\n    // TypeError: &quot;replaceAll must be called with a global RegExp&quot; not included, will silently cause significant errors. _MUST_ include &#39;g&#39; as a flag for RegExp.\r\n    // String parameters to &#39;find&#39; do not require special handling.\r\n    // Does not conform to &quot;special replacement patterns&quot; when &quot;Specifying a string as a parameter&quot; for replace\r\n    // Does not conform to &quot;Specifying a function as a parameter&quot; for replace\r\n    return this.replace(\r\n          Object.prototype.toString.call(find) == &#39;[object RegExp]&#39; ?\r\n            find :\r\n            new RegExp(RegExp.escape(find), &#39;g&#39;),\r\n          replace\r\n        );\r\n  }\r\n}\r\n```\r\nCode, Minified:\r\n```\r\nObject.prototype.hasOwnProperty.call(RegExp,&quot;escape&quot;)||(RegExp.escape=function(e){return e.replace(/[.*+\\-?^${}()|[\\]\\\\]/g,&quot;\\\\$&amp;&quot;)}),Object.prototype.hasOwnProperty.call(String,&quot;replaceAll&quot;)||(String.prototype.replaceAll=function(e,t){return this.replace(&quot;[object RegExp]&quot;==Object.prototype.toString.call(e)?e:new RegExp(RegExp.escape(e),&quot;g&quot;),t)});\r\n```\r\n---\r\nExample:\r\n```\r\nconsole.log(\r\n  &#39;t*.STVAL&#39;\r\n    .replaceAll(\r\n      new RegExp(RegExp.escape(&#39;T*.ST&#39;), &#39;ig&#39;),\r\n      &#39;TEST&#39;\r\n    )\r\n);\r\n\r\nconsole.log(\r\n  &#39;t*.STVAL&#39;\r\n    .replaceAll(\r\n      &#39;t*.ST&#39;,\r\n      &#39;TEST&#39;\r\n    );\r\n);\r\n```\r\n---\r\nCode without `RegExp.Escape`:\r\n```\r\nif (!Object.prototype.hasOwnProperty.call(String, &#39;replaceAll&#39;)) {\r\n  String.prototype.replaceAll = function(find, replace) {\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\r\n    // If you pass a RegExp to &#39;find&#39;, you _MUST_ include &#39;g&#39; as a flag.\r\n    // TypeError: &quot;replaceAll must be called with a global RegExp&quot; not included, will silently cause significant errors. _MUST_ include &#39;g&#39; as a flag for RegExp.\r\n    // String parameters to &#39;find&#39; do not require special handling.\r\n    // Does not conform to &quot;special replacement patterns&quot; when &quot;Specifying a string as a parameter&quot; for replace\r\n    // Does not conform to &quot;Specifying a function as a parameter&quot; for replace\r\n    return this.replace(\r\n          Object.prototype.toString.call(find) == &#39;[object RegExp]&#39; ?\r\n            find :\r\n            new RegExp(find.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, &#39;\\\\$&amp;&#39;), &#39;g&#39;),\r\n          replace\r\n        );\r\n  }\r\n}\r\n```\r\nCode without `RegExp.Escape`, Minified:\r\n```\r\nObject.prototype.hasOwnProperty.call(String,&quot;replaceAll&quot;)||(String.prototype.replaceAll=function(e,t){return this.replace(&quot;[object RegExp]&quot;==Object.prototype.toString.call(e)?e:new RegExp(e.replace(/[.*+\\-?^${}()|[\\]\\\\]/g,&quot;\\\\$&amp;&quot;),&quot;g&quot;),t)});\r\n```\r\n---"}],"score":4636}