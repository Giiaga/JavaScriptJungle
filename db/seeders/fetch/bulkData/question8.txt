{"body":"Say I create an object as follows:\r\n```\r\nlet myObject = {\r\n  &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,\r\n  &quot;method&quot;: &quot;newURI&quot;,\r\n  &quot;regex&quot;: &quot;^http://.*&quot;\r\n};\r\n```\r\nWhat is the best way to remove the property `regex` to end up with new `myObject` as follows?\r\n```\r\nlet myObject = {\r\n  &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,\r\n  &quot;method&quot;: &quot;newURI&quot;\r\n};\r\n```","title":"How do I remove a property from a JavaScript object?","answers":[{"score":8566,"body_markdown":"Like this:\r\n    \r\n    delete myObject.regex;\r\n    // or,\r\n    delete myObject[&#39;regex&#39;];\r\n    // or,\r\n    var prop = &quot;regex&quot;;\r\n    delete myObject[prop];\r\n\r\nDemo\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var myObject = {\r\n        &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,\r\n        &quot;method&quot;: &quot;newURI&quot;,\r\n        &quot;regex&quot;: &quot;^http://.*&quot;\r\n    };\r\n    delete myObject.regex;\r\n\r\n    console.log(myObject);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nFor anyone interested in reading more about it, Stack Overflow user [kangax][1] has written an incredibly in-depth blog post about the `delete` statement on their blog, *[Understanding delete][2]*. It is highly recommended.\r\n\r\n  [1]: https://stackoverflow.com/users/130652/kangax\r\n  [2]: http://perfectionkills.com/understanding-delete/\r\n"},{"score":264,"body_markdown":"    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var myObject = {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;newURI&quot;, &quot;regex&quot;: &quot;^http://.*&quot;};\r\n        \r\n    delete myObject.regex;\r\n\r\n    console.log ( myObject.regex); // logs: undefined\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThis works in Firefox and Internet&amp;nbsp;Explorer, and I think it works in all others.\r\n"},{"score":237,"body_markdown":"The `delete` operator is used to remove properties from objects.\r\n\r\n    const obj = { foo: &quot;bar&quot; }\r\n    delete obj.foo\r\n    obj.hasOwnProperty(&quot;foo&quot;) // false\r\n\r\nNote that, for arrays, **this is not the same as removing an element**. To remove an element from an array, use `Array#splice` or `Array#pop`. For example:\r\n\r\n    arr // [0, 1, 2, 3, 4]\r\n    arr.splice(3,1); // 3\r\n    arr // [0, 1, 2, 4]\r\n\r\n# Details\r\n\r\n`delete` in JavaScript has a different function to that of the keyword in C and C++: it does not directly free memory. Instead, its sole purpose is to remove properties from objects.\r\n\r\nFor arrays, deleting a property corresponding to an index, creates a sparse array (ie. an array with a &quot;hole&quot; in it). Most browsers represent these missing array indices as &quot;empty&quot;.\r\n\r\n    var array = [0, 1, 2, 3]\r\n    delete array[2] // [0, 1, empty, 3]\r\n\r\nNote that `delete` does not relocate `array[3]` into `array[2]`.\r\n\r\nDifferent built-in functions in JavaScript handle sparse arrays differently.\r\n\r\n - `for...in` will skip the empty index completely. \r\n\r\n - A traditional `for` loop will return `undefined` for the value at the index.\r\n\r\n - Any method using `Symbol.iterator` will return `undefined` for the value at the index.\r\n\r\n - `forEach`, `map` and `reduce` will simply skip the missing index.\r\n\r\nSo, the `delete` operator should not be used for the common use-case of removing elements from an array. Arrays have a dedicated methods for removing elements and reallocating memory: `Array#splice()` and `Array#pop`.\r\n\r\n## Array#splice(start[, deleteCount[, item1[, item2[, ...]]]])\r\n\r\n`Array#splice` mutates the array, and returns any removed indices. `deleteCount` elements are removed from index `start`, and `item1, item2... itemN` are inserted into the array from index `start`. If `deleteCount` is omitted then elements from startIndex are removed to the end of the array.\r\n\r\n    let a = [0,1,2,3,4]\r\n    a.splice(2,2) // returns the removed elements [2,3]\r\n    // ...and `a` is now [0,1,4]\r\n\r\nThere is also a similarly named, but different, function on `Array.prototype`: `Array#slice`.\r\n\r\n## Array#slice([begin[, end]])\r\n\r\n`Array#slice` is non-destructive, and returns a new array containing the indicated indices from `start` to `end`. If `end` is left unspecified, it defaults to the end of the array. If `end` is positive, it specifies the zero-based **non-inclusive** index to stop at. If `end` is negative it, it specifies the index to stop at by counting back from the end of the array (eg. -1 will omit the final index). If `end &lt;= start`, the result is an empty array.\r\n\r\n    let a = [0,1,2,3,4]\r\n    let slices = [\r\n        a.slice(0,2),\r\n        a.slice(2,2),\r\n        a.slice(2,3),\r\n        a.slice(2,5) ]\r\n\r\n    //   a           [0,1,2,3,4]\r\n    //   slices[0]   [0 1]- - -   \r\n    //   slices[1]    - - - - -\r\n    //   slices[2]    - -[3]- -\r\n    //   slices[3]    - -[2 4 5]\r\n\r\n# Array#pop\r\n\r\n`Array#pop` removes the last element from an array, and returns that element. This operation changes the length of the array."},{"score":58,"body_markdown":"The term you have used in your question title `Remove a property from a JavaScript object`, can be interpreted in some different ways. The one is to remove it for whole the memory and the list of object keys or the other is just to remove it from your object. As it has been mentioned in some other answers, the `delete` keyword is the main part. Let&#39;s say you have your object like:\r\n\r\n    myJSONObject = {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;newURI&quot;, &quot;regex&quot;: &quot;^http://.*&quot;};\r\n\r\nIf you do:\r\n\r\n    console.log(Object.keys(myJSONObject));\r\n\r\nthe result would be:\r\n\r\n    [&quot;ircEvent&quot;, &quot;method&quot;, &quot;regex&quot;]\r\n\r\nYou can delete that specific key from your object keys like:\r\n\r\n    delete myJSONObject[&quot;regex&quot;];\r\n\r\nThen your objects key using `Object.keys(myJSONObject)` would be:\r\n\r\n    [&quot;ircEvent&quot;, &quot;method&quot;]\r\n\r\nBut the point is if you care about memory and you want to whole the object gets removed from the memory, it is recommended to set it to null before you delete the key:\r\n\r\n    myJSONObject[&quot;regex&quot;] = null;\r\n    delete myJSONObject[&quot;regex&quot;];\r\n\r\nThe other important point here is to be careful about your other references to the same object. For instance, if you create a variable like:\r\n\r\n    var regex = myJSONObject[&quot;regex&quot;];\r\n\r\nOr add it as a new pointer to another object like:\r\n\r\n    var myOtherObject = {};\r\n    myOtherObject[&quot;regex&quot;] = myJSONObject[&quot;regex&quot;];\r\n\r\nThen even if you remove it from your object `myJSONObject`, that specific object won&#39;t get deleted from the memory, since the `regex` variable and `myOtherObject[&quot;regex&quot;]` still have their values. Then how could we remove the object from the memory for sure?\r\n\r\nThe answer would be to **delete all the references you have in your code, pointed to that very object** and also **not use `var` statements to create new references to that object**. This last point regarding `var` statements, is one of the most crucial issues that we are usually faced with, because using `var` statements would prevent the created object from getting removed.\r\n\r\nWhich means in this case you won&#39;t be able to remove that object because you have created the `regex` variable via a `var` statement, and if you do:\r\n\r\n    delete regex; //False\r\n\r\nThe result would be `false`, which means that your delete statement haven&#39;t been executed as you expected. But if you had not created that variable before, and you only had `myOtherObject[&quot;regex&quot;]` as your last existing reference, you could have done this just by removing it like:\r\n\r\n    myOtherObject[&quot;regex&quot;] = null;\r\n    delete myOtherObject[&quot;regex&quot;];\r\n\r\n**In other words, a JavaScript object gets killed as soon as there is no reference left in your code pointed to that object.**\r\n\r\n\r\n----------\r\n\r\n\r\n**Update:**\r\nThanks to @AgentME:\r\n\r\n&gt; Setting a property to null before deleting it doesn&#39;t accomplish\r\n&gt; anything (unless the object has been sealed by Object.seal and the\r\n&gt; delete fails. That&#39;s not usually the case unless you specifically\r\n&gt; try).\r\n\r\nTo get more info on `Object.seal`: [Object.seal()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)"},{"score":982,"body_markdown":"Objects in JavaScript can be thought of as maps between keys and values. The `delete` operator is used to remove these keys, more commonly known as object properties, one at a time.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var obj = {\r\n      myProperty: 1    \r\n    }\r\n    console.log(obj.hasOwnProperty(&#39;myProperty&#39;)) // true\r\n    delete obj.myProperty\r\n    console.log(obj.hasOwnProperty(&#39;myProperty&#39;)) // false\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe `delete` operator does not directly free memory, and it differs from simply assigning the value of `null` or `undefined` to a property, in that the property *itself* is removed from the object. Note that if the *value* of a deleted property was a reference type (an object), and another part of your program still holds a reference to that object, then that object will, of course, not be garbage collected until all references to it have disappeared.\r\n\r\n`delete` will only work on properties whose descriptor marks them as configurable."},{"score":102,"body_markdown":"Another alternative is to use the [Underscore.js][1] library. \r\n\r\nNote that `_.pick()` and `_.omit()` both return a copy of the object and don&#39;t directly modify the original object. Assigning the result to the original object should do the trick (not shown).\r\n\r\nReference: [link][2] **_.pick(object, *keys)**\r\n\r\nReturn a copy of the object, filtered to only have values for the \r\nwhitelisted keys (or array of valid keys).\r\n\r\n    var myJSONObject = \r\n    {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;newURI&quot;, &quot;regex&quot;: &quot;^http://.*&quot;};\r\n\r\n    _.pick(myJSONObject, &quot;ircEvent&quot;, &quot;method&quot;);\r\n    =&gt; {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;newURI&quot;};\r\n\r\nReference: [link][3] **_.omit(object, *keys)**\r\n\r\nReturn a copy of the object, filtered to omit the \r\nblacklisted keys (or array of keys).\r\n    \r\n    var myJSONObject = \r\n    {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;newURI&quot;, &quot;regex&quot;: &quot;^http://.*&quot;};\r\n\r\n    _.omit(myJSONObject, &quot;regex&quot;);\r\n    =&gt; {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;newURI&quot;};\r\n\r\nFor arrays, `_.filter()` and `_.reject()` can be used in a similar manner. \r\n\r\n\r\n  [1]: https://underscorejs.org\r\n  [2]: http://underscorejs.org/#pick\r\n  [3]: http://underscorejs.org/#omit"},{"score":22,"body_markdown":"There are a lot of good answers here but I just want to chime in that when using delete to remove a property in JavaScript, it is often wise to first check if that property exists to prevent errors.\r\n\r\nE.g\r\n\r\n    var obj = {&quot;property&quot;:&quot;value&quot;, &quot;property2&quot;:&quot;value&quot;};\r\n\r\n    if (obj &amp;&amp; obj.hasOwnProperty(&quot;property2&quot;)) {\r\n      delete obj.property2;\r\n    } else {\r\n      //error handling\r\n    }\r\n\r\n\r\nDue to the dynamic nature of JavaScript there are often cases where you simply don&#39;t know if the property exists or not. Checking if obj exists before the &amp;&amp; also makes sure you don&#39;t throw an error due to calling the hasOwnProperty() function on an undefined object.\r\n\r\nSorry if this didn&#39;t add to your specific use case but I believe this to be a good design to adapt when managing objects and their properties."},{"score":22,"body_markdown":"This post is very old and I find it very helpful so I decided to share the unset function I wrote in case someone else see this post and think why it&#39;s not so simple as it in PHP unset function.\r\n\r\nThe reason for writing this new `unset` function, is to keep the index of all other variables in this hash_map. Look at the following example, and see how the index of &quot;test2&quot; did not change after removing a value from the hash_map.\r\n\r\n    function unset(unsetKey, unsetArr, resort){\r\n      var tempArr = unsetArr;\r\n      var unsetArr = {};\r\n      delete tempArr[unsetKey];\r\n      if(resort){\r\n        j = -1;\r\n      }\r\n      for(i in tempArr){\r\n        if(typeof(tempArr[i]) !== &#39;undefined&#39;){\r\n          if(resort){\r\n            j++;\r\n          }else{\r\n            j = i;\r\n          }\r\n          unsetArr[j] = tempArr[i];\r\n        }\r\n      }\r\n      return unsetArr;\r\n    }\r\n\r\n    var unsetArr = [&#39;test&#39;,&#39;deletedString&#39;,&#39;test2&#39;];\r\n\r\n    console.log(unset(&#39;1&#39;,unsetArr,true)); // output Object {0: &quot;test&quot;, 1: &quot;test2&quot;}\r\n    console.log(unset(&#39;1&#39;,unsetArr,false)); // output Object {0: &quot;test&quot;, 2: &quot;test2&quot;}\r\n"},{"score":46,"body_markdown":"ECMAScript 2015 (or ES6) came with built-in [Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect) object. It is possible to delete object property by calling [Reflect.deleteProperty()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty) function with target object and property key as parameters:\r\n\r\n    Reflect.deleteProperty(myJSONObject, &#39;regex&#39;);\r\n\r\nwhich is equivalent to:\r\n\r\n    delete myJSONObject[&#39;regex&#39;];\r\n\r\nBut if the property of the object is not configurable it cannot be deleted neither with deleteProperty function nor delete operator:\r\n\r\n    let obj = Object.freeze({ prop: &quot;value&quot; });\r\n    let success = Reflect.deleteProperty(obj, &quot;prop&quot;);\r\n    console.log(success); // false\r\n    console.log(obj.prop); // value\r\n\r\n[Object.freeze()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) makes all properties of object not configurable (besides other things). `deleteProperty` function (as well as [delete operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete)) returns `false` when tries to delete any of it&#39;s properties. If property is configurable it returns `true`, even if property does not exist.\r\n\r\nThe difference between `delete` and `deleteProperty` is when using strict mode:\r\n\r\n    &quot;use strict&quot;;\r\n\r\n    let obj = Object.freeze({ prop: &quot;value&quot; });\r\n    Reflect.deleteProperty(obj, &quot;prop&quot;); // false\r\n    delete obj[&quot;prop&quot;];\r\n    // TypeError: property &quot;prop&quot; is non-configurable and can&#39;t be deleted"},{"score":34,"body_markdown":"I personally use [Underscore.js][1] or [Lodash][2] for object and array manipulation:\r\n\r\n    myObject = _.omit(myObject, &#39;regex&#39;);\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Underscore.js\r\n  [2]: https://lodash.com\r\n"},{"score":44,"body_markdown":"Suppose you have an object that looks like this:\r\n\r\n    var Hogwarts = {\r\n        staff : [\r\n            &#39;Argus Filch&#39;,\r\n            &#39;Filius Flitwick&#39;,\r\n            &#39;Gilderoy Lockhart&#39;,\r\n            &#39;Minerva McGonagall&#39;,\r\n            &#39;Poppy Pomfrey&#39;,\r\n            ...\r\n        ],\r\n        students : [\r\n            &#39;Hannah Abbott&#39;,\r\n            &#39;Katie Bell&#39;,\r\n            &#39;Susan Bones&#39;,\r\n            &#39;Terry Boot&#39;,\r\n            &#39;Lavender Brown&#39;,\r\n            ...\r\n        ]\r\n    };\r\n\r\n###Deleting an object property\r\n\r\nIf you want to use the entire `staff` array, the proper way to do this, would be to do this:\r\n\r\n    delete Hogwarts.staff;\r\n\r\nAlternatively, you could also do this:\r\n\r\n    delete Hogwarts[&#39;staff&#39;];\r\n\r\nSimilarly, removing the entire students array would be done by calling `delete Hogwarts.students;` or `delete Hogwarts[&#39;students&#39;];`.\r\n\r\n###Deleting an array index\r\n\r\nNow, if you want to remove a single staff member or student, the procedure is a bit different, because both properties are arrays themselves.\r\n\r\nIf you know the index of your staff member, you could simply do this:\r\n\r\n    Hogwarts.staff.splice(3, 1);\r\n\r\nIf you do not know the index, you&#39;ll also have to do an index search:\r\n\r\n    Hogwarts.staff.splice(Hogwarts.staff.indexOf(&#39;Minerva McGonnagall&#39;) - 1, 1);\r\n\r\n------\r\n\r\n###Note\r\n\r\nWhile you technically can use `delete` for an array, using it would result in getting incorrect results when calling for example `Hogwarts.staff.length` later on. In other words, `delete` would remove the element, but it wouldn&#39;t update the value of `length` property. Using `delete` would also mess up your indexing.\r\n\r\nSo, when deleting values from an object, always first consider whether you&#39;re dealing with object properties or whether you&#39;re dealing with array values, and choose the appropriate strategy based on that.\r\n\r\nIf you want to experiment with this, you can use [**this Fiddle**][1] as a starting point.\r\n\r\n  [1]: http://jsfiddle.net/cb57dusv/46/\r\n"},{"score":13,"body_markdown":"If you want to delete a property deeply nested in the object then you can use the following recursive function with path to the property as the second argument:\r\n\r\n    var deepObjectRemove = function(obj, path_to_key){\r\n    \tif(path_to_key.length === 1){\r\n    \t\tdelete obj[path_to_key[0]];\r\n    \t\treturn true;\r\n    \t}else{\r\n    \t\tif(obj[path_to_key[0]])\r\n    \t\t\treturn deepObjectRemove(obj[path_to_key[0]], path_to_key.slice(1));\r\n    \t\telse\r\n    \t\t\treturn false;\r\n    \t}\r\n    };\r\n\r\nExample: \r\n\r\n    var a = {\r\n    \tlevel1:{\r\n    \t\tlevel2:{\r\n    \t\t\tlevel3: {\r\n    \t\t\t\tlevel4: &quot;yolo&quot;\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    };\r\n    \r\n    deepObjectRemove(a, [&quot;level1&quot;, &quot;level2&quot;, &quot;level3&quot;]);\r\n    console.log(a);\r\n    \r\n    //Prints {level1: {level2: {}}}"},{"score":16,"body_markdown":"Try the following method. Assign the `Object` property value to `undefined`. Then `stringify` the object and `parse`.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n     var myObject = {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;newURI&quot;, &quot;regex&quot;: &quot;^http://.*&quot;};\r\n\r\n    myObject.regex = undefined;\r\n    myObject = JSON.parse(JSON.stringify(myObject));\r\n\r\n    console.log(myObject);\r\n\r\n&lt;!-- end snippet --&gt;\r\n"},{"score":227,"body_markdown":"Old question, modern answer. Using object destructuring, an [ECMAScript&amp;nbsp;6][1] feature, it&#39;s as simple as:\r\n\r\n    const { a, ...rest } = { a: 1, b: 2, c: 3 };\r\n\r\nOr with the questions sample:\r\n\r\n    const myObject = {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;newURI&quot;, &quot;regex&quot;: &quot;^http://.*&quot;};\r\n    const { regex, ...newObject } = myObject;\r\n    console.log(newObject);\r\n\r\n[You can see it in action in the Babel try-out editor.](https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=true&amp;presets=es2015%2Cstage-0&amp;experimental=true&amp;loose=true&amp;spec=false&amp;code=const%20myObject%20%3D%20%7B%22ircEvent%22%3A%20%22PRIVMSG%22%2C%20%22method%22%3A%20%22newURI%22%2C%20%22regex%22%3A%20%22%5Ehttp%3A%2F%2F.*%22%7D%3B%0Aconst%20%7B%20regex%2C%20...newObject%20%7D%20%3D%20myObject%3B%0Aconsole.log(newObject)%3B)\r\n\r\n---\r\n\r\n**Edit:**\r\n\r\nTo reassign to the same variable, use a `let`:\r\n\r\n    let myObject = {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;newURI&quot;, &quot;regex&quot;: &quot;^http://.*&quot;};\r\n    ({ regex, ...myObject } = myObject);\r\n    console.log(myObject);\r\n\r\n\r\n  [1]: https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015\r\n"},{"score":17,"body_markdown":"Using [ramda#dissoc][1] you will get a new object without the attribute `regex`:\r\n\r\n    const newObject = R.dissoc(&#39;regex&#39;, myObject);\r\n    // newObject !== myObject\r\n\r\n  [1]: http://ramdajs.com/docs/#dissoc\r\n\r\nYou can also use other functions to achieve the same effect - omit, pick, ...\r\n\r\n\r\n"},{"score":25,"body_markdown":"Another solution, using **[`Array#reduce`][1]**.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var myObject = {\r\n      &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,\r\n      &quot;method&quot;: &quot;newURI&quot;,\r\n      &quot;regex&quot;: &quot;^http://.*&quot;\r\n    };\r\n\r\n    myObject = Object.keys(myObject).reduce(function(obj, key) {\r\n      if (key != &quot;regex&quot;) {           //key you want to remove\r\n        obj[key] = myObject[key];\r\n      }\r\n      return obj;\r\n    }, {});\r\n\r\n    console.log(myObject);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nHowever, it will **mutate** the original object. If you want to create a new object **without** the specified key, just assign the reduce function to a new variable, e.g.: \r\n\r\n(ES6)\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const myObject = {\r\n      ircEvent: &#39;PRIVMSG&#39;,\r\n      method: &#39;newURI&#39;,\r\n      regex: &#39;^http://.*&#39;,\r\n    };\r\n\r\n    const myNewObject = Object.keys(myObject).reduce((obj, key) =&gt; {\r\n      key !== &#39;regex&#39; ? obj[key] = myObject[key] : null;\r\n      return obj;\r\n    }, {});\r\n\r\n    console.log(myNewObject);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"},{"score":28,"body_markdown":"Using **delete** method is the best way to do that, as per MDN description, the delete operator removes a property from an object. So you can simply write:\r\n\r\n    delete myObject.regex;\r\n    // OR\r\n    delete myObject[&#39;regex&#39;];\r\n\r\n&gt; The delete operator removes a given property from an object. On\r\n&gt; successful deletion, it will return true, else false will be returned.\r\n&gt; However, it is important to consider the following scenarios:\r\n&gt; \r\n\r\n   &gt;  - If the property which you are trying to delete does not exist, delete\r\n   &gt; will not have any effect and will return true\r\n\r\n  &gt;  - If a property with the same name exists on the object&#39;s prototype\r\n  &gt; chain, then, after deletion, the object will use the property from the\r\n  &gt; prototype chain (in other words, delete only has an effect on own\r\n  &gt; properties).\r\n\r\n  &gt;  - Any property declared with var cannot be deleted from the global scope\r\n  &gt; or from a function&#39;s scope.\r\n\r\n&gt;  - As such, delete cannot delete any functions in the global scope (whether this is part from a function definition or a function  (expression). \r\n&gt;  - Functions which are part of an object (apart from the   \r\n&gt; global scope) can be deleted with delete.\r\n\r\n&gt;  - Any property declared with let or const cannot be deleted from the scope  within which they were defined. Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are created as non-configurable with methods like Object.defineProperty().\r\n\r\nThe following snippet gives another simple example:\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var Employee = {\r\n          age: 28,\r\n          name: &#39;Alireza&#39;,\r\n          designation: &#39;developer&#39;\r\n        }\r\n        \r\n        console.log(delete Employee.name);   // returns true\r\n        console.log(delete Employee.age);    // returns true\r\n        \r\n        // When trying to delete a property that does \r\n        // not exist, true is returned \r\n        console.log(delete Employee.salary); // returns true\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nFor more info about and seeing more example, visit the link below:\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete"},{"score":9,"body_markdown":"Dan&#39;s assertion that &#39;delete&#39; is very slow and the benchmark he posted were doubted. So I carried out the test myself in Chrome 59. It does seem that &#39;delete&#39; is about 30 times slower:\r\n\r\n    var iterationsTotal = 10000000;  // 10 million\r\n    var o;\r\n    var t1 = Date.now(),t2;\r\n    for (let i=0; i&lt;iterationsTotal; i++) {\r\n       o = {a:1,b:2,c:3,d:4,e:5};\r\n       delete o.a; delete o.b; delete o.c; delete o.d; delete o.e;\r\n    }\r\n    console.log ((t2=Date.now())-t1);  // 6135\r\n    for (let i=0; i&lt;iterationsTotal; i++) {\r\n       o = {a:1,b:2,c:3,d:4,e:5};\r\n       o.a = o.b = o.c = o.d = o.e = undefined;\r\n    }\r\n    console.log (Date.now()-t2);  // 205\r\n\r\nNote that I purposedly carried out more than one &#39;delete&#39; operations in one loop cycle to minimize the effect caused by the other operations."},{"score":8,"body_markdown":"Using lodash\r\n\r\n    import omit from &#39;lodash/omit&#39;;\r\n    \r\n    const prevObject = {test: false, test2: true};\r\n    // Removes test2 key from previous object\r\n    const nextObject = omit(prevObject, &#39;test2&#39;);\r\n\r\nUsing Ramda\r\n\r\n    R.omit([&#39;a&#39;, &#39;d&#39;], {a: 1, b: 2, c: 3, d: 4}); //=&gt; {b: 2, c: 3}"},{"score":8,"body_markdown":"# Object.assign() &amp; Object.keys() &amp; Array.map()\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const obj = {\r\n        &quot;Filters&quot;:[\r\n            {\r\n                &quot;FilterType&quot;:&quot;between&quot;,\r\n                &quot;Field&quot;:&quot;BasicInformationRow.A0&quot;,\r\n                &quot;MaxValue&quot;:&quot;2017-10-01&quot;,\r\n                &quot;MinValue&quot;:&quot;2017-09-01&quot;,\r\n                &quot;Value&quot;:&quot;Filters value&quot;\r\n            }\r\n        ]\r\n    };\r\n\r\n    let new_obj1 = Object.assign({}, obj.Filters[0]);\r\n    let new_obj2 = Object.assign({}, obj.Filters[0]);\r\n\r\n    /*\r\n\r\n    // old version\r\n\r\n    let shaped_obj1 = Object.keys(new_obj1).map(\r\n        (key, index) =&gt; {\r\n            switch (key) {\r\n                case &quot;MaxValue&quot;:\r\n                    delete new_obj1[&quot;MaxValue&quot;];\r\n                    break;\r\n                case &quot;MinValue&quot;:\r\n                    delete new_obj1[&quot;MinValue&quot;];\r\n                    break;\r\n            }\r\n            return new_obj1;\r\n        }\r\n    )[0];\r\n\r\n\r\n    let shaped_obj2 = Object.keys(new_obj2).map(\r\n        (key, index) =&gt; {\r\n            if(key === &quot;Value&quot;){\r\n                delete new_obj2[&quot;Value&quot;];\r\n            }\r\n            return new_obj2;\r\n        }\r\n    )[0];\r\n\r\n\r\n    */\r\n\r\n\r\n    // new version!\r\n\r\n    let shaped_obj1 = Object.keys(new_obj1).forEach(\r\n        (key, index) =&gt; {\r\n            switch (key) {\r\n                case &quot;MaxValue&quot;:\r\n                    delete new_obj1[&quot;MaxValue&quot;];\r\n                    break;\r\n                case &quot;MinValue&quot;:\r\n                    delete new_obj1[&quot;MinValue&quot;];\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    );\r\n\r\n    let shaped_obj2 = Object.keys(new_obj2).forEach(\r\n        (key, index) =&gt; {\r\n            if(key === &quot;Value&quot;){\r\n                delete new_obj2[&quot;Value&quot;];\r\n            }\r\n        }\r\n    );\r\n\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":5,"body_markdown":"I have used [lodash &quot;unset&quot;][1] to make it happen for nested object also.. only this need to write small logic to get path of property key which expected by omit method.  \r\n\r\n1. Method which returns property path as array \r\n\r\n   \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var a = {&quot;bool&quot;:{&quot;must&quot;:[{&quot;range&quot;:{&quot;price_index.final_price&quot;:{&quot;gt&quot;:&quot;450&quot;,&quot;lt&quot;:&quot;500&quot;}}},{&quot;bool&quot;:{&quot;should&quot;:[{&quot;term&quot;:{&quot;color_value.keyword&quot;:&quot;Black&quot;}}]}}]}};\r\n\r\n    function getPathOfKey(object,key,currentPath, t){\r\n         var currentPath = currentPath || [];\r\n\r\n        for(var i in object){\r\n    \t\tif(i == key){\r\n            t = currentPath;\r\n          }\r\n          else if(typeof object[i] == &quot;object&quot;){\r\n            currentPath.push(i)\r\n           return getPathOfKey(object[i], key,currentPath)\r\n          }\r\n        }\r\n    \tt.push(key);\r\n        return t;\r\n    }\r\n    document.getElementById(&quot;output&quot;).innerHTML =JSON.stringify(getPathOfKey(a,&quot;price_index.final_price&quot;))\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;div id=&quot;output&quot;&gt; \r\n\r\n    &lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n 1. Then just using [lodash unset][1] method remove property from object. \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var unset = require(&#39;lodash.unset&#39;);\r\n    unset(a,getPathOfKey(a,&quot;price_index.final_price&quot;));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://lodash.com/docs/4.17.4#unset"},{"score":9,"body_markdown":"# Property Removal in JavaScript\r\n\r\nThere are many different options presented on this page, not because most of the options are wrong—or because the answers are duplicates—but because the appropriate technique depends on the situation you&#39;re in and the goals of the tasks you and/or you team are trying to fulfill. To answer you question unequivocally, one needs to know:\r\n\r\n 1. The version of ECMAScript you&#39;re targeting\r\n 2. The range of object types you want to remove properties on and the type of property names you need to be able to omit (Strings only? Symbols? Weak references mapped from arbitrary objects? These have all been types of property pointers in JavaScript for years now)\r\n 3. The programming ethos/patterns you and your team use. Do you favor functional approaches and mutation is verboten on your team, or do you employ wild west mutative object-oriented techniques?\r\n 4. Are you looking to achieve this in pure JavaScript or are you willing &amp; able to use a 3rd-party library?\r\n\r\nOnce those four queries have been answered, there are essentially four categories of &quot;property removal&quot; in JavaScript to chose from in order to meet your goals. They are:\r\n\r\n## Mutative object property deletion, unsafe\r\n\r\nThis category is for operating on object literals or object instances when you want to retain/continue to use the original reference and aren&#39;t using stateless functional principles in your code. An example piece of syntax in this category:\r\n\r\n    &#39;use strict&#39;\r\n    const iLikeMutatingStuffDontI = { myNameIs: &#39;KIDDDDD!&#39;, [Symbol.for(&#39;amICool&#39;)]: true }\r\n    delete iLikeMutatingStuffDontI[Symbol.for(&#39;amICool&#39;)] // true\r\n    Object.defineProperty({ myNameIs: &#39;KIDDDDD!&#39;, &#39;amICool&#39;, { value: true, configurable: false })\r\n    delete iLikeMutatingStuffDontI[&#39;amICool&#39;] // throws\r\n\r\nThis category is the oldest, most straightforward &amp; most widely supported category of property removal. It supports `Symbol` &amp; array indexes in addition to strings and works in every version of JavaScript except for the very first release. However, it&#39;s mutative which violates some programming principles and has performance implications. It also can result in uncaught exceptions when used on [non-configurable properties in strict mode][1].\r\n\r\n## Rest-based string property omission\r\n\r\nThis category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don&#39;t need to account for Symbol keys:\r\n\r\n    const foo = { name: &#39;KIDDDDD!&#39;, [Symbol.for(&#39;isCool&#39;)]: true }\r\n    const { name, ...coolio } = foo // coolio doesn&#39;t have &quot;name&quot;\r\n    const { isCool, ...coolio2 } = foo // coolio2 has everything from `foo` because `isCool` doesn&#39;t account for Symbols :(\r\n\r\n\r\n## Mutative object property deletion, safe\r\n\r\nThis category is for operating on object literals or object instances when you want to retain/continue to use the original reference while guarding against exceptions being thrown on unconfigurable properties:\r\n\r\n    &#39;use strict&#39;\r\n    const iLikeMutatingStuffDontI = { myNameIs: &#39;KIDDDDD!&#39;, [Symbol.for(&#39;amICool&#39;)]: true }\r\n    Reflect.deleteProperty(iLikeMutatingStuffDontI, Symbol.for(&#39;amICool&#39;)) // true\r\n    Object.defineProperty({ myNameIs: &#39;KIDDDDD!&#39;, &#39;amICool&#39;, { value: true, configurable: false })\r\n    Reflect.deleteProperty(iLikeMutatingStuffDontI, &#39;amICool&#39;) // false\r\n\r\nIn addition, while mutating objects in-place isn&#39;t stateless, you can use the functional nature of `Reflect.deleteProperty` to do partial application and other functional techniques that aren&#39;t possible with `delete` statements.\r\n\r\n## Syntax-based string property omission\r\n\r\nThis category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don&#39;t need to account for Symbol keys:\r\n\r\n    const foo = { name: &#39;KIDDDDD!&#39;, [Symbol.for(&#39;isCool&#39;)]: true }\r\n    const { name, ...coolio } = foo // coolio doesn&#39;t have &quot;name&quot;\r\n    const { isCool, ...coolio2 } = foo // coolio2 has everything from `foo` because `isCool` doesn&#39;t account for Symbols :(\r\n\r\n## Library-based property omission\r\n\r\nThis category is generally allows for greater functional flexibility, including accounting for Symbols &amp; omitting more than one property in one statement:\r\n\r\n    const o = require(&quot;lodash.omit&quot;)\r\n    const foo = { [Symbol.for(&#39;a&#39;)]: &#39;abc&#39;, b: &#39;b&#39;, c: &#39;c&#39; }\r\n    const bar = o(foo, &#39;a&#39;) // &quot;&#39;a&#39; undefined&quot;\r\n    const baz = o(foo, [ Symbol.for(&#39;a&#39;), &#39;b&#39; ]) // Symbol supported, more than one prop at a time, &quot;Symbol.for(&#39;a&#39;) undefined&quot;\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete"},{"score":7,"body_markdown":"   **@johnstock**, we can also use JavaScript&#39;s prototyping concept to add method to objects to delete any passed key available in calling object.\r\n\r\nAbove answers are appreciated.\r\n\r\n    var myObject = {\r\n        &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,\r\n        &quot;method&quot;: &quot;newURI&quot;,\r\n        &quot;regex&quot;: &quot;^http://.*&quot;\r\n    };\r\n\r\n    // 1st and direct way \r\n    delete myObject.regex;  // delete myObject[&quot;regex&quot;]\r\n    console.log(myObject); // { ircEvent: &#39;PRIVMSG&#39;, method: &#39;newURI&#39; }\r\n\r\n     // 2 way -  by using the concept of JavaScript&#39;s prototyping concept\r\n    Object.prototype.removeFromObjectByKey = function(key) {\r\n         // If key exists, remove it and return true\r\n         if(this[key] !== undefined) {\r\n               delete this[key]\r\n               return true;\r\n         }\r\n         // Else return false\r\n         return false;\r\n    }\r\n\r\n    var isRemoved = myObject.removeFromObjectByKey(&#39;method&#39;)\r\n    console.log(myObject)  // { ircEvent: &#39;PRIVMSG&#39; }\r\n\r\n    // More examples\r\n    var obj = { a: 45, b: 56, c: 67}\r\n    console.log(obj) // { a: 45, b: 56, c: 67 }\r\n\r\n    // Remove key &#39;a&#39; from obj\r\n    isRemoved = obj.removeFromObjectByKey(&#39;a&#39;)\r\n    console.log(isRemoved); //true\r\n    console.log(obj); // { b: 56, c: 67 }\r\n\r\n    // Remove key &#39;d&#39; from obj which doesn&#39;t exist\r\n    var isRemoved = obj.removeFromObjectByKey(&#39;d&#39;)\r\n    console.log(isRemoved); // false\r\n    console.log(obj); // { b: 56, c: 67 }\r\n"},{"score":152,"body_markdown":"#[Spread Syntax][1] (ES6)\r\n\r\nTo whoever needs it...\r\n\r\nTo complete @Koen answer in this thread, in case you want to remove dynamic variable using the spread syntax, you can do it like so:\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const key = &#39;a&#39;;\r\n            \r\n    const { [key]: foo, ...rest } = { a: 1, b: 2, c: 3 };\r\n\r\n    console.log(foo);  // 1\r\n    console.log(rest); // { b: 2, c: 3 }\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\\* *`foo` will be a new variable with the value of `a` (which is 1).*\r\n\r\n&lt;br /&gt;\r\n***EXTENDED ANSWER*** &#128519;&lt;br /&gt;\r\nThere are few common ways to remove a property from an object.&lt;br /&gt;Each one has it&#39;s own pros and cons ([check this performance comparison][2]):\r\n\r\n[***Delete Operator***][3]&lt;br /&gt;\r\nReadable and short, however, it might not be the best choice if you are operating on a large number of objects as its performance is not optimized.\r\n\r\n    delete obj[key];\r\n&lt;br /&gt;\r\n[***Reassignment***][4]&lt;br /&gt;\r\nMore than 2X faster than `delete`, however the property is **not** deleted and can be iterated.\r\n\r\n    obj[key] = null;\r\n    obj[key] = false;\r\n    obj[key] = undefined;\r\n&lt;br /&gt;\r\n[***Spread Operator***][5]&lt;br /&gt;\r\nThis `ES6` operator allows us to return a brand new object, excluding any properties, without mutating the existing object. The downside is that it has the worse performance out of the above and not suggested to be used when you need to remove many properties at a time.\r\n\r\n    { [key]: val, ...rest } = obj;\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\r\n  [2]: https://jsperf.com/delete-vs-undefined-vs-null/16\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators\r\n  [5]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"},{"score":36,"body_markdown":"**To clone object without property:**\r\n\r\nFor example:\r\n    \r\n    let object = { a: 1, b: 2, c: 3 };   \r\n\r\nAnd we need to delete `a`.\r\n     \r\n1. With **explicit prop key**:\r\n```\r\n    const { a, ...rest } = object;\r\n    object = rest;\r\n```\r\n2. With **variable prop key**:   \r\n```   \r\n    const propKey = &#39;a&#39;;\r\n    const { [propKey]: propValue, ...rest } = object;\r\n    object = rest;\r\n```\r\n3. Cool **arrow function** &#128526;:\r\n```\r\n    const removePropery = (propKey, { [propKey]: propValue, ...rest }) =&gt; rest;\r\n\r\n    object = removePropery(&#39;a&#39;, object);\r\n```\r\n4. For **multiple properties**\r\n```\r\n    const removeProperties = (object, ...keys) =&gt; Object.entries(object).reduce((prev, [key, value]) =&gt; ({...prev, ...(!keys.includes(key) &amp;&amp; { [key]: value }) }), {})\r\n```\r\n***Usage***\r\n    \r\n    object = removeProperties(object, &#39;a&#39;, &#39;b&#39;) // result =&gt; { c: 3 }\r\n\r\n***Or***\r\n\r\n        const propsToRemove = [&#39;a&#39;, &#39;b&#39;]\r\n        object = removeProperties(object, ...propsToRemove) // result =&gt; { c: 3 }\r\n\r\n\r\n"},{"score":6,"body_markdown":"You can use filter like below\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var myObject = {\r\n        &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,\r\n        &quot;method&quot;: &quot;newURI&quot;,\r\n        &quot;regex&quot;: &quot;^http://.*&quot;\r\n    };\r\n\r\n    // way 1\r\n\r\n    let filter1 = {}\r\n      Object.keys({...myObject}).filter(d =&gt; {\r\n      if(d !== &#39;regex&#39;){\r\n        filter1[d] = myObject[d];\r\n      }\r\n    })\r\n\r\n    console.log(filter1)\r\n\r\n    // way 2\r\n\r\n    let filter2 = Object.fromEntries(Object.entries({...myObject}).filter(d =&gt; \r\n    d[0] !== &#39;regex&#39;\r\n    ))\r\n\r\n    console.log(filter2)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":3,"body_markdown":"\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let myObject = {\r\n        &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,\r\n        &quot;method&quot;: &quot;newURI&quot;,\r\n        &quot;regex&quot;: &quot;^http://.*&quot;\r\n    };\r\n\r\n\r\n    obj = Object.fromEntries(\r\n        Object.entries(myObject).filter(function (m){\r\n            return m[0] != &quot;regex&quot;/*or whatever key to delete*/\r\n        }\r\n    ))\r\n\r\n    console.log(obj)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nYou can also just treat the object like `a2d` array using `Object.entries`, and use splice to remove an element as you would in a normal array, or simply filter through the object, as one would an array, and assign the reconstructed object back to the original variable\r\n\r\n\r\n"},{"score":1,"body_markdown":"If you don&#39;t want to modify the original object.\r\n\r\n**Remove a property without mutating the object**\r\n\r\nIf mutability is a concern, you can create a completely new object by copying all the properties from the old, except the one you want to remove.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let myObject = {\r\n      &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,\r\n      &quot;method&quot;: &quot;newURI&quot;,\r\n      &quot;regex&quot;: &quot;^http://.*&quot;\r\n    };\r\n\r\n    let prop = &#39;regex&#39;;\r\n    const updatedObject = Object.keys(myObject).reduce((object, key) =&gt; {\r\n      if (key !== prop) {\r\n        object[key] = myObject[key]\r\n      }\r\n      return object\r\n    }, {})\r\n\r\n    console.log(updatedObject);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"}],"score":6367}