{"body":"\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = [];\r\n    // let&#39;s create 3 functions\r\n    for (var i = 0; i &lt; 3; i++) {\r\n      // and store them in funcs\r\n      funcs[i] = function() {\r\n        // each should log its value.\r\n        console.log(&quot;My value: &quot; + i);\r\n      };\r\n    }\r\n    for (var j = 0; j &lt; 3; j++) {\r\n      // and now let&#39;s run each one to see\r\n      funcs[j]();\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIt outputs this:\r\n\r\n&gt; My value: 3  \r\nMy value: 3  \r\nMy value: 3\r\n\r\nWhereas I&#39;d like it to output:\r\n&gt; My value: 0  \r\nMy value: 1  \r\nMy value: 2\r\n\r\n---\r\n\r\nThe same problem occurs when the delay in running the function is caused by using event listeners:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var buttons = document.getElementsByTagName(&quot;button&quot;);\r\n    // let&#39;s create 3 functions\r\n    for (var i = 0; i &lt; buttons.length; i++) {\r\n      // as event listeners\r\n      buttons[i].addEventListener(&quot;click&quot;, function() {\r\n        // each should log its value.\r\n        console.log(&quot;My value: &quot; + i);\r\n      });\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;button&gt;0&lt;/button&gt;\r\n    &lt;br /&gt;\r\n    &lt;button&gt;1&lt;/button&gt;\r\n    &lt;br /&gt;\r\n    &lt;button&gt;2&lt;/button&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n… or asynchronous code, e.g. using Promises:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // Some async wait function\r\n    const wait = (ms) =&gt; new Promise((resolve, reject) =&gt; setTimeout(resolve, ms));\r\n\r\n    for (var i = 0; i &lt; 3; i++) {\r\n      // Log `i` as soon as each promise resolves.\r\n      wait(i * 100).then(() =&gt; console.log(i));\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIt is also apparent in `for in` and `for of` loops:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const arr = [1,2,3];\r\n    const fns = [];\r\n\r\n    for(var i in arr){\r\n      fns.push(() =&gt; console.log(`index: ${i}`));\r\n    }\r\n\r\n    for(var v of arr){\r\n      fns.push(() =&gt; console.log(`value: ${v}`));\r\n    }\r\n\r\n    for(var f of fns){\r\n      f();\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nWhat’s the solution to this basic problem?","title":"JavaScript closure inside loops – simple practical example","answers":[{"score":390,"body_markdown":"Try:\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = [];\r\n        \r\n    for (var i = 0; i &lt; 3; i++) {\r\n        funcs[i] = (function(index) {\r\n            return function() {\r\n                console.log(&quot;My value: &quot; + index);\r\n            };\r\n        }(i));\r\n    }\r\n\r\n    for (var j = 0; j &lt; 3; j++) {\r\n        funcs[j]();\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n**Edit** (2014):\r\n\r\nPersonally I think @Aust&#39;s [more recent answer about using `.bind`](https://stackoverflow.com/a/19323214/918959) is the best way to do this kind of thing now. There&#39;s also lo-dash/underscore&#39;s `_.partial` when you don&#39;t need or want to mess with `bind`&#39;s `thisArg`."},{"score":2216,"body_markdown":"Well, the problem is that the variable `i`, within each of your anonymous functions, is bound to the same variable outside of the function.\r\n\r\n# ES6 solution: `let`\r\n\r\nECMAScript 6 (ES6) introduces new `let` and `const` keywords that are scoped differently than `var`-based variables. For example, in a loop with a `let`-based index, each iteration through the loop will have a new variable `i` with loop scope, so your code would work as you expect. There are many resources, but I&#39;d recommend [2ality&#39;s block-scoping post](http://www.2ality.com/2015/02/es6-scoping.html) as a great source of information.\r\n\r\n    for (let i = 0; i &lt; 3; i++) {\r\n      funcs[i] = function() {\r\n        console.log(&quot;My value: &quot; + i);\r\n      };\r\n    }\r\n\r\nBeware, though, that IE9-IE11 and Edge prior to Edge 14 support `let` but get the above wrong (they don&#39;t create a new `i` each time, so all the functions above would log 3 like they would if we used `var`). Edge 14 finally gets it right.\r\n\r\n---\r\n\r\n# ES5.1 solution: forEach\r\n\r\nWith the relatively widespread availability of the `Array.prototype.forEach` function (in 2015), it&#39;s worth noting that in those situations involving iteration primarily over an array of values, `.forEach()` provides a clean, natural way to get a distinct closure for every iteration. That is, assuming you&#39;ve got some sort of array containing values (DOM references, objects, whatever), and the problem arises of setting up callbacks specific to each element, you can do this:\r\n\r\n    var someArray = [ /* whatever */ ];\r\n    // ...\r\n    someArray.forEach(function(arrayElement) {\r\n      // ... code code code for this one element\r\n      someAsynchronousFunction(arrayElement, function() {\r\n        arrayElement.doSomething();\r\n      });\r\n    });\r\n\r\nThe idea is that each invocation of the callback function used with the `.forEach` loop will be its own closure. The parameter passed in to that handler is the array element specific to that particular step of the iteration. If it&#39;s used in an asynchronous callback, it won&#39;t collide with any of the other callbacks established at other steps of the iteration.\r\n\r\nIf you happen to be working in jQuery, the `$.each()` function gives you a similar capability.\r\n\r\n---\r\n\r\n# Classic solution: Closures\r\n\r\nWhat you want to do is bind the variable within each function to a separate, unchanging value outside of the function:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = [];\r\n\r\n    function createfunc(i) {\r\n      return function() {\r\n        console.log(&quot;My value: &quot; + i);\r\n      };\r\n    }\r\n\r\n    for (var i = 0; i &lt; 3; i++) {\r\n      funcs[i] = createfunc(i);\r\n    }\r\n\r\n    for (var j = 0; j &lt; 3; j++) {\r\n      // and now let&#39;s run each one to see\r\n      funcs[j]();\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nSince there is no block scope in JavaScript - only function scope - by wrapping the function creation in a new function, you ensure that the value of &quot;i&quot; remains as you intended.\r\n"},{"score":9,"body_markdown":"The reason your original example did not work is that all the closures you created in the loop referenced the same frame. In effect, having 3 methods on one object with only a single `i` variable. They all printed out the same value.\r\n"},{"score":74,"body_markdown":"What you need to understand is the scope of the variables in javascript is based on the function. This is an important difference than say c# where you have block scope, and just copying the variable to one inside the for will work.\r\n\r\nWrapping it in a function that evaluates returning the function like apphacker&#39;s answer will do the trick, as the variable now has the function scope.\r\n\r\nThere is also a let keyword instead of var, that would allow using the block scope rule. In that case defining a variable inside the for would do the trick. That said, the let keyword isn&#39;t a practical solution because of compatibility.\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = {};\r\n\r\n    for (var i = 0; i &lt; 3; i++) {\r\n      let index = i; //add this\r\n      funcs[i] = function() {\r\n        console.log(&quot;My value: &quot; + index); //change to the copy\r\n      };\r\n    }\r\n\r\n    for (var j = 0; j &lt; 3; j++) {\r\n      funcs[j]();\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":91,"body_markdown":"Another way of saying it is that the `i` in your function is bound at the time of executing the function, not the time of creating the function.\r\n\r\nWhen you create the closure, `i` is a reference to the variable defined in the outside scope, not a copy of it as it was when you created the closure. It will be evaluated at the time of execution.\r\n\r\nMost of the other answers provide ways to work around by creating another variable that won&#39;t change the value for you.\r\n\r\nJust thought I&#39;d add an explanation for clarity. For a solution, personally, I&#39;d go with Harto&#39;s since it is the most self-explanatory way of doing it from the answers here. Any of the code posted will work, but I&#39;d opt for a closure factory over having to write a pile of comments to explain why I&#39;m declaring a new variable(Freddy and 1800&#39;s) or have weird embedded closure syntax(apphacker)."},{"score":63,"body_markdown":"Here&#39;s another variation on the technique, similar to Bjorn&#39;s (apphacker), which lets you assign the variable value inside the function rather than passing it as a parameter, which might be clearer sometimes:\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n\r\n    var funcs = [];\r\n    for (var i = 0; i &lt; 3; i++) {\r\n        funcs[i] = (function() {\r\n            var index = i;\r\n            return function() {\r\n                console.log(&quot;My value: &quot; + index);\r\n            }\r\n        })();\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nNote that whatever technique you use, the `index` variable becomes a sort of static variable, bound to the returned copy of the inner function. I.e., changes to its value are preserved between calls. It can be very handy."},{"score":58,"body_markdown":"This describes the common mistake with using closures in JavaScript.\r\n\r\n\r\n\r\nA function defines a new environment\r\n------------------------------------\r\nConsider:\r\n\r\n\r\n    function makeCounter()\r\n    {\r\n      var obj = {counter: 0};\r\n      return {\r\n        inc: function(){obj.counter ++;},\r\n        get: function(){return obj.counter;}\r\n      };\r\n    }\r\n\r\n    counter1 = makeCounter();\r\n    counter2 = makeCounter();\r\n\r\n    counter1.inc();\r\n\r\n    alert(counter1.get()); // returns 1\r\n    alert(counter2.get()); // returns 0\r\n\r\n\r\nFor each time `makeCounter` is invoked, `{counter: 0}` results in a new object being created. Also, a new copy of `obj` \r\nis created as well to reference the new object. Thus, `counter1` and `counter2` are independent of each other.\r\n\r\nClosures in loops\r\n-----------------\r\nUsing a closure in a loop is tricky.\r\n\r\nConsider: \r\n\r\n    var counters = [];\r\n\r\n    function makeCounters(num)\r\n    {\r\n      for (var i = 0; i &lt; num; i++)\r\n      {\r\n        var obj = {counter: 0};\r\n        counters[i] = {\r\n          inc: function(){obj.counter++;},\r\n          get: function(){return obj.counter;}\r\n        }; \r\n      }\r\n    }\r\n\r\n    makeCounters(2);\r\n\r\n    counters[0].inc();\r\n\r\n    alert(counters[0].get()); // returns 1\r\n    alert(counters[1].get()); // returns 1\r\n\r\nNotice that `counters[0]` and `counters[1]` are *not* independent. In fact, they operate on the same `obj`!\r\n\r\nThis is because there is only one copy of `obj` shared across all iterations of the loop, perhaps for performance reasons.\r\nEven though `{counter: 0}` creates a new object in each iteration, the same copy of `obj` will just get updated with a\r\nreference to the newest object.\r\n\r\n\r\nSolution is to use another helper function:\r\n\r\n    function makeHelper(obj)\r\n    {\r\n      return {\r\n        inc: function(){obj.counter++;},\r\n        get: function(){return obj.counter;}\r\n      }; \r\n    }\r\n\r\n    function makeCounters(num)\r\n    {\r\n      for (var i = 0; i &lt; num; i++)\r\n      {\r\n        var obj = {counter: 0};\r\n        counters[i] = makeHelper(obj);\r\n      }\r\n    }\r\n\r\nThis works because local variables in the function scope directly, as well as function argument variables, are allocated \r\nnew copies upon entry.\r\n\r\n"},{"score":158,"body_markdown":"With ES6 now widely supported, the best answer to this question has changed.  ES6 provides the `let` and `const` keywords for this exact circumstance.  Instead of messing around with closures, we can just use `let` to set a loop scope variable like this:\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = [];\r\n    \r\n    for (let i = 0; i &lt; 3; i++) {          \r\n        funcs[i] = function() {            \r\n          console.log(&quot;My value: &quot; + i); \r\n        };\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n`val` will then point to an object that is specific to that particular turn of the loop, and will return the correct value without the additional closure notation.  This obviously significantly simplifies this problem.\r\n\r\n`const` is similar to `let` with the additional restriction that the variable name can&#39;t be rebound to a new reference after initial assignment.\r\n\r\nBrowser support is now here for those targeting the latest versions of browsers. `const`/`let` are currently supported in the latest Firefox, Safari, Edge and Chrome. It also is supported in Node, and you can use it anywhere by taking advantage of build tools like Babel.  You can see a working example here: http://jsfiddle.net/ben336/rbU4t/2/\r\n\r\nDocs here:\r\n\r\n- [const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)\r\n- [let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)\r\n\r\nBeware, though, that IE9-IE11 and Edge prior to Edge 14 support `let` but get the above wrong (they don&#39;t create a new `i` each time, so all the functions above would log 3 like they would if we used `var`). Edge 14 finally gets it right."},{"score":51,"body_markdown":"The most simple solution would be,\r\n\r\nInstead of using:\r\n\r\n    var funcs = [];\r\n    for(var i =0; i&lt;3; i++){\r\n    \tfuncs[i] = function(){\r\n    \t\talert(i);\r\n    \t}\r\n    }\r\n    \r\n    for(var j =0; j&lt;3; j++){\r\n    \tfuncs[j]();\r\n    }\r\n\r\nwhich alerts &quot;2&quot;, for 3 times. This is because anonymous functions created in for loop, shares same closure, and in that closure, the value of `i` is the same. Use this to prevent shared closure:\r\n\r\n    var funcs = [];\r\n    for(var new_i =0; new_i&lt;3; new_i++){\r\n    \t(function(i){\r\n    \t\tfuncs[i] = function(){\r\n    \t\t\talert(i);\r\n    \t\t}\r\n    \t})(new_i);\r\n    }\r\n    \r\n    for(var j =0; j&lt;3; j++){\r\n    \tfuncs[j]();\r\n    }\r\n\r\nThe idea behind this is, encapsulating the entire body of the for loop with an [IIFE][1] (Immediately-Invoked Function Expression) and passing `new_i` as a parameter and capturing it as `i`. Since the anonymous function is executed immediately, the `i` value is different for each function defined inside the anonymous function.\r\n\r\nThis solution seems to fit any such problem since it will require minimal changes to the original code suffering from this issue. In fact, this is by design, it should not be an issue at all!\r\n\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Immediately-invoked_function_expression"},{"score":32,"body_markdown":"&lt;h2&gt;try this shorter one&lt;/h2&gt;\r\n\r\n - no array\r\n\r\n - no extra for loop\r\n\r\n&lt;br/&gt;\r\n\r\n    for (var i = 0; i &lt; 3; i++) {\r\n        createfunc(i)();\r\n    }\r\n    \r\n    function createfunc(i) {\r\n        return function(){console.log(&quot;My value: &quot; + i);};\r\n    }\r\n\r\n[http://jsfiddle.net/7P6EN/][1]\r\n\r\n\r\n  [1]: http://jsfiddle.net/7P6EN/"},{"score":358,"body_markdown":"Another way that hasn&#39;t been mentioned yet is the use of [`Function.prototype.bind`][1]\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = {};\r\n    for (var i = 0; i &lt; 3; i++) {\r\n      funcs[i] = function(x) {\r\n        console.log(&#39;My value: &#39; + x);\r\n      }.bind(this, i);\r\n    }\r\n    for (var j = 0; j &lt; 3; j++) {\r\n      funcs[j]();\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**UPDATE**\r\n\r\nAs pointed out by @squint and @mekdev, you get better performance by creating the function outside the loop first and then binding the results within the loop.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function log(x) {\r\n      console.log(&#39;My value: &#39; + x);\r\n    }\r\n\r\n    var funcs = [];\r\n\r\n    for (var i = 0; i &lt; 3; i++) {\r\n      funcs[i] = log.bind(this, i);\r\n    }\r\n\r\n    for (var j = 0; j &lt; 3; j++) {\r\n      funcs[j]();\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\r\n"},{"score":275,"body_markdown":"Using an [Immediately-Invoked Function Expression](http://en.wikipedia.org/wiki/Immediately-invoked_function_expression), the simplest and most readable way to enclose an index variable:\r\n    \r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    for (var i = 0; i &lt; 3; i++) {\r\n\r\n        (function(index) {\r\n\r\n            console.log(&#39;iterator: &#39; + index);\r\n            //now you can also loop an ajax call here \r\n            //without losing track of the iterator value:   $.ajax({});\r\n        \r\n        })(i);\r\n\r\n    }\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThis sends the iterator `i` into the anonymous function of which we define as `index`.  This creates a closure, where the variable `i` gets saved for later use in any asynchronous functionality within the IIFE."},{"score":29,"body_markdown":"The main issue with the code shown by the OP is that `i` is never read until the second loop. To demonstrate, imagine seeing an error inside of the code\r\n\r\n    funcs[i] = function() {            // and store them in funcs\r\n        throw new Error(&quot;test&quot;);\r\n        console.log(&quot;My value: &quot; + i); // each should log its value.\r\n    };\r\n\r\nThe error actually does not occur until `funcs[someIndex]` is executed `()`. Using this same logic, it should be apparent that the value of `i` is also not collected until this point either. Once the original loop finishes, `i++` brings `i` to the value of `3` which results in the condition `i &lt; 3` failing and the loop ending. At this point, `i` is `3` and so when `funcs[someIndex]()` is used, and `i` is evaluated, it is 3 - every time.\r\n\r\nTo get past this, you must evaluate `i` as it is encountered. Note that this has already happened in the form of `funcs[i]` (where there are 3 unique indexes). There are several ways to capture this value. One is to pass it in as a parameter to a function which is shown in several ways already here. \r\n\r\nAnother option is to construct a function object which will be able to close over the variable. That can be accomplished thusly\r\n\r\n***[`jsFiddle Demo`](http://jsfiddle.net/QcUjH/)***\r\n\r\n    funcs[i] = new function() {   \r\n        var closedVariable = i;\r\n        return function(){\r\n            console.log(&quot;My value: &quot; + closedVariable); \r\n        };\r\n    };"},{"score":33,"body_markdown":"Here&#39;s a simple solution that uses `forEach` (works back to IE9):\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = [];\r\n    [0,1,2].forEach(function(i) {          // let&#39;s create 3 functions\r\n        funcs[i] = function() {            // and store them in funcs\r\n            console.log(&quot;My value: &quot; + i); // each should log its value.\r\n        };\r\n    })\r\n    for (var j = 0; j &lt; 3; j++) {\r\n        funcs[j]();                        // and now let&#39;s run each one to see\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nPrints:\r\n\r\n&gt;     My value: 0\r\n&gt;     My value: 1\r\n&gt;     My value: 2"},{"score":15,"body_markdown":"After reading through various solutions, I&#39;d like to add that the reason those solutions work is to rely on the concept of **scope chain**. It&#39;s the way JavaScript resolve a variable during execution.  \r\n \r\n- Each function definition forms a scope consisting of all the local \r\n variables declared by `var` and its `arguments`.   \r\n- If we have inner function defined inside another (outer) function, this \r\n forms a chain, and will be used during execution   \r\n- When a function gets executed, the runtime evaluates variables by searching the **scope chain**. If a variable can be found in a certain point of the chain it will stop searching and use it, otherwise it continues until the global scope reached which belongs to `window`.\r\n\r\nIn the initial code:\r\n\r\n    funcs = {};\r\n    for (var i = 0; i &lt; 3; i++) {         \r\n      funcs[i] = function inner() {        // function inner&#39;s scope contains nothing\r\n        console.log(&quot;My value: &quot; + i);    \r\n      };\r\n    }\r\n    console.log(window.i)                  // test value &#39;i&#39;, print 3\r\n\r\nWhen `funcs` gets executed, the scope chain will be `function inner -&gt; global`. Since the variable `i` cannot be found in `function inner` (neither declared using `var` nor passed as arguments), it continues to search, until the value of `i` is eventually found in the global scope which is `window.i`.\r\n\r\nBy wrapping it in an outer function either explicitly define a helper function like [harto](https://stackoverflow.com/a/750506) did or use an anonymous function like [Bjorn](https://stackoverflow.com/a/750495) did:\r\n\r\n    funcs = {};\r\n    function outer(i) {              // function outer&#39;s scope contains &#39;i&#39;\r\n      return function inner() {      // function inner, closure created\r\n       console.log(&quot;My value: &quot; + i);\r\n      };\r\n    }\r\n    for (var i = 0; i &lt; 3; i++) {\r\n      funcs[i] = outer(i);\r\n    }\r\n    console.log(window.i)          // print 3 still\r\nWhen `funcs` gets executed, now the scope chain will be `function inner -&gt; function outer`. This time `i` can be found in the outer function&#39;s scope which is executed 3 times in the for loop, each time has value `i` bound correctly. It won&#39;t use the value of `window.i` when inner executed.\r\n\r\n\r\nMore detail can be found [here][1]  \r\n[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures\r\n\r\nIt includes the common mistake in creating closure in the loop as what we have here, as well as why we need closure and the performance consideration."},{"score":10,"body_markdown":"I&#39;m surprised no one yet has suggested using the `forEach` function to better avoid (re)using local variables. In fact, I&#39;m not using `for(var i ...)` at all anymore for this reason.\r\n\r\n\r\n    [0,2,3].forEach(function(i){ console.log(&#39;My value:&#39;, i); });\r\n    // My value: 0\r\n    // My value: 2\r\n    // My value: 3\r\n\r\n// edited to use `forEach` instead of map."},{"score":170,"body_markdown":"Bit late to the party, but I was exploring this issue today and noticed that many of the answers don&#39;t completely address how Javascript treats scopes, which is essentially what this boils down to.\n\nSo as many others mentioned, the problem is that the inner function is referencing the same `i` variable. So why don&#39;t we just create a new local variable each iteration, and have the inner function reference that instead?\n\n&lt;!-- begin snippet: js hide: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    //overwrite console.log() so you can see the console output\n    console.log = function(msg) {document.body.innerHTML += &#39;&lt;p&gt;&#39; + msg + &#39;&lt;/p&gt;&#39;;};\n\n    var funcs = {};\n    for (var i = 0; i &lt; 3; i++) {\n        var ilocal = i; //create a new local variable\n        funcs[i] = function() {\n            console.log(&quot;My value: &quot; + ilocal); //each should reference its own local variable\n        };\n    }\n    for (var j = 0; j &lt; 3; j++) {\n        funcs[j]();\n    }\n\n&lt;!-- end snippet --&gt;\n\nJust like before, where each inner function outputted the last value assigned to `i`, now each inner function just outputs the last value assigned to `ilocal`. But shouldn&#39;t each iteration have it&#39;s own `ilocal`?\n\nTurns out, that&#39;s the issue. Each iteration is sharing the same scope, so every iteration after the first is just overwriting `ilocal`. From [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#No_block_scope):\n\n&gt; Important: JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. In other words, block statements do not introduce a scope. Although &quot;standalone&quot; blocks are valid syntax, you do not want to use standalone blocks in JavaScript, because they don&#39;t do what you think they do, if you think they do anything like such blocks in C or Java.\n\nReiterated for emphasis:\n\n&gt;## JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script\n\nWe can see this by checking `ilocal` before we declare it in each iteration:\n\n&lt;!-- begin snippet: js hide: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    //overwrite console.log() so you can see the console output\n    console.log = function(msg) {document.body.innerHTML += &#39;&lt;p&gt;&#39; + msg + &#39;&lt;/p&gt;&#39;;};\n\n    var funcs = {};\n    for (var i = 0; i &lt; 3; i++) {\n      console.log(ilocal);\n      var ilocal = i;\n    }\n\n&lt;!-- end snippet --&gt;\n\nThis is exactly why this bug is so tricky. Even though you are redeclaring a variable, Javascript won&#39;t throw an error, and JSLint won&#39;t even throw a warning. This is also why the best way to solve this is to take advantage of closures, which is essentially the idea that in Javascript, inner functions have access to outer variables because inner scopes &quot;enclose&quot; outer scopes.\n\n![Closures][1]\n\nThis also means that inner functions &quot;hold onto&quot; outer variables and keep them alive, even if the outer function returns. To utilize this, we create and call a wrapper function purely to make a new scope, declare `ilocal` in the new scope, and return an inner function that uses `ilocal` (more explanation below):\n\n&lt;!-- begin snippet: js hide: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    //overwrite console.log() so you can see the console output\n    console.log = function(msg) {document.body.innerHTML += &#39;&lt;p&gt;&#39; + msg + &#39;&lt;/p&gt;&#39;;};\n\n    var funcs = {};\n    for (var i = 0; i &lt; 3; i++) {\n        funcs[i] = (function() { //create a new scope using a wrapper function\n            var ilocal = i; //capture i into a local var\n            return function() { //return the inner function\n                console.log(&quot;My value: &quot; + ilocal);\n            };\n        })(); //remember to run the wrapper function\n    }\n    for (var j = 0; j &lt; 3; j++) {\n        funcs[j]();\n    }\n\n&lt;!-- end snippet --&gt;\n\nCreating the inner function inside a wrapper function gives the inner function a private environment that only it can access, a &quot;closure&quot;. Thus, every time we call the wrapper function we create a new inner function with it&#39;s own separate environment, ensuring that the `ilocal` variables don&#39;t collide and overwrite each other. A few minor optimizations gives the final answer that many other SO users gave:\n\n&lt;!-- begin snippet: js hide: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    //overwrite console.log() so you can see the console output\n    console.log = function(msg) {document.body.innerHTML += &#39;&lt;p&gt;&#39; + msg + &#39;&lt;/p&gt;&#39;;};\n\n    var funcs = {};\n    for (var i = 0; i &lt; 3; i++) {\n        funcs[i] = wrapper(i);\n    }\n    for (var j = 0; j &lt; 3; j++) {\n        funcs[j]();\n    }\n    //creates a separate environment for the inner function\n    function wrapper(ilocal) {\n        return function() { //return the inner function\n            console.log(&quot;My value: &quot; + ilocal);\n        };\n    }\n\n&lt;!-- end snippet --&gt;\n\n\n**Update**\n\nWith ES6 now mainstream, we can now use the new `let` keyword to create block-scoped variables:\n\n&lt;!-- begin snippet: js hide: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    //overwrite console.log() so you can see the console output\n    console.log = function(msg) {document.body.innerHTML += &#39;&lt;p&gt;&#39; + msg + &#39;&lt;/p&gt;&#39;;};\n\n    var funcs = {};\n    for (let i = 0; i &lt; 3; i++) { // use &quot;let&quot; to declare &quot;i&quot;\n        funcs[i] = function() {\n            console.log(&quot;My value: &quot; + i); //each should reference its own local variable\n        };\n    }\n    for (var j = 0; j &lt; 3; j++) { // we can use &quot;var&quot; here without issue\n        funcs[j]();\n    }\n\n&lt;!-- end snippet --&gt;\n\nLook how easy it is now! For more information see [this answer](https://stackoverflow.com/a/16661498/1852456), which my info is based off of.\n\n  [1]: https://i.stack.imgur.com/60fH9.png"},{"score":2,"body_markdown":"This is a problem often encountered with asynchronous code, the variable `i` is mutable and at the time at which the function call is made the code using `i` will be executed and `i` will have mutated to its last value, thus meaning all functions created within the loop will create a [closure][1] and `i` will be equal to 3 (the upper bound + 1 of the `for` loop.\r\n\r\nA workaround to this, is to create a function that will hold the value of `i` for each iteration and force a copy `i` (as it is a primitive, think of it as a snapshot if it helps you).\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"},{"score":4,"body_markdown":"You could use a declarative module for lists of data such as [query-js][1](*). In these situations I personally find a declarative approach less surprising\r\n\r\n    var funcs = Query.range(0,3).each(function(i){\r\n         return  function() {\r\n            console.log(&quot;My value: &quot; + i);\r\n        };\r\n    });\r\n\r\nYou could then use your second loop and get the expected result or you could do \r\n\r\n    funcs.iterate(function(f){ f(); });\r\n\r\n(*) I&#39;m the author of query-js and therefor biased towards using it, so don&#39;t take my words as a recommendation for said library only for the declarative approach :)\r\n\r\n  [1]: https://github.com/runefs/query-js"},{"score":4,"body_markdown":"I prefer to use `forEach` function, which has its own closure with creating a pseudo range:\r\n\r\n\tvar funcs = [];\r\n\r\n\tnew Array(3).fill(0).forEach(function (_, i) { // creating a range\r\n\t    funcs[i] = function() {            \r\n            // now i is safely incapsulated \r\n\t        console.log(&quot;My value: &quot; + i);\r\n\t    };\r\n\t});\r\n\r\n\tfor (var j = 0; j &lt; 3; j++) {\r\n\t    funcs[j](); // 0, 1, 2\r\n\t}\r\n\r\nThat looks uglier than ranges in other languages, but IMHO less monstrous than other solutions."},{"score":4,"body_markdown":"And yet another solution: instead of creating another loop, just bind the `this` to the return function.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = [];\r\n\r\n    function createFunc(i) {\r\n      return function() {\r\n        console.log(&#39;My value: &#39; + i); //log value of i.\r\n      }.call(this);\r\n    }\r\n\r\n    for (var i = 1; i &lt;= 5; i++) {  //5 functions\r\n      funcs[i] = createFunc(i);     // call createFunc() i=5 times\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nBy binding ***this***, solves the problem as well."},{"score":8,"body_markdown":"First of all, understand what&#39;s wrong with this code:\r\n\r\n    var funcs = [];\r\n    for (var i = 0; i &lt; 3; i++) {          // let&#39;s create 3 functions\r\n        funcs[i] = function() {            // and store them in funcs\r\n            console.log(&quot;My value: &quot; + i); // each should log its value.\r\n        };\r\n    }\r\n    for (var j = 0; j &lt; 3; j++) {\r\n        funcs[j]();                        // and now let&#39;s run each one to see\r\n    }\r\n\r\nHere when the `funcs[]` array is being initialized, `i` is being incremented, the `funcs` array is initialized and the size of `func` array becomes 3,  so `i = 3,`. \r\nNow when the `funcs[j]()` is called, it is again using the variable `i`, which has already been incremented to 3.\r\n\r\nNow to solve this, we have many options. Below are two of them:\r\n\r\n1. We can initialize `i` with `let` or initialize a new variable `index` with `let` and make it equal to `i`. So when the call is being made, `index` will be used and its scope will end after initialization. And for calling, `index` will be initialized again:\r\n\r\n        var funcs = [];\r\n        for (var i = 0; i &lt; 3; i++) {          \r\n    \t    let index = i;\r\n            funcs[i] = function() {            \r\n                console.log(&quot;My value: &quot; + index); \r\n            };\r\n        }\r\n        for (var j = 0; j &lt; 3; j++) {\r\n            funcs[j]();                        \r\n        }\r\n\r\n2. Other Option can be to introduce a `tempFunc` which returns the actual function:\r\n\r\n        var funcs = [];\r\n        function tempFunc(i){\r\n    \t    return function(){\r\n    \t        console.log(&quot;My value: &quot; + i);\r\n    \t    };\r\n        }\r\n        for (var i = 0; i &lt; 3; i++) {  \r\n            funcs[i] = tempFunc(i);                 \t\t\t\t\t\r\n        }\r\n        for (var j = 0; j &lt; 3; j++) {\r\n            funcs[j]();                        \r\n        }"},{"score":3,"body_markdown":"Your code doesn&#39;t work, because what it does is:\r\n\r\n    Create variable `funcs` and assign it an empty array;  \r\n    Loop from 0 up until it is less than 3 and assign it to variable `i`;\r\n        Push to variable `funcs` next function:  \r\n            // Only push (save), but don&#39;t execute\r\n            **Write to console current value of variable `i`;**\r\n  \r\n    // First loop has ended, i = 3;\r\n\r\n    Loop from 0 up until it is less than 3 and assign it to variable `j`;\r\n        Call `j`-th function from variable `funcs`:  \r\n            **Write to console current value of variable `i`;**  \r\n            // Ask yourself NOW! What is the value of i?\r\n\r\nNow the question is, what is the value of variable `i` when the function is called? Because the first loop is created with the condition of `i &lt; 3`, it stops immediately when the condition is false, so it is `i = 3`. \r\n\r\nYou need to understand that, in time when your functions are created, none of their code is executed, it is only saved for later. And so when they are called later, the interpreter executes them and asks: &quot;What is the current value of `i`?&quot;\r\n\r\nSo, your goal is to first save the value of `i` to function and only after that save the function to `funcs`. This could be done for example this way:\r\n\r\n    var funcs = [];\r\n    for (var i = 0; i &lt; 3; i++) {          // let&#39;s create 3 functions\r\n        funcs[i] = function(x) {            // and store them in funcs\r\n            console.log(&quot;My value: &quot; + x); // each should log its value.\r\n        }.bind(null, i);\r\n    }\r\n    for (var j = 0; j &lt; 3; j++) {\r\n        funcs[j]();                        // and now let&#39;s run each one to see\r\n    }\r\n\r\nThis way, each function will have it&#39;s own variable `x` and we set this `x` to the value of `i` in each iteration.\r\n\r\nThis is only one of the multiple ways to solve this problem."},{"score":13,"body_markdown":"With new features of ES6 block level scoping is managed:\r\n\r\n    var funcs = [];\r\n    for (let i = 0; i &lt; 3; i++) {          // let&#39;s create 3 functions\r\n        funcs[i] = function() {            // and store them in funcs\r\n            console.log(&quot;My value: &quot; + i); // each should log its value.\r\n        };\r\n    }\r\n    for (let j = 0; j &lt; 3; j++) {\r\n        funcs[j]();                        // and now let&#39;s run each one to see\r\n    }\r\n\r\n\r\nThe code in OP&#39;s question is replaced with **[`let`][1]** instead of **`var`**.\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let"},{"score":0,"body_markdown":"Let&#39;s take advantage of [`new Function`][1]. Thus `i` stops to be a variable of a [closure][2] and becomes just a part of the text:\r\n\r\n    var funcs = [];\r\n    for (var i = 0; i &lt; 3; i++) {\r\n        var functionBody = &#39;console.log(&quot;My value: &#39; + i + &#39;&quot;);&#39;;\r\n        funcs[i] = new Function(functionBody);\r\n    }\r\n\r\n    for (var j = 0; j &lt; 3; j++) {\r\n        funcs[j]();\r\n    }\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"},{"score":24,"body_markdown":"JavaScript functions &quot;close over&quot; the scope they have access to upon declaration, and retain access to that scope even as variables in that scope change.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = []\r\n\r\n    for (var i = 0; i &lt; 3; i += 1) {\r\n      funcs[i] = function () {\r\n        console.log(i)\r\n      }\r\n    }\r\n\r\n    for (var k = 0; k &lt; 3; k += 1) {\r\n      funcs[k]()\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nEach function in the array above closes over the global scope (global, simply because that happens to be the scope they&#39;re declared in).\r\n\r\nLater those functions are invoked logging the most current value of `i` in the global scope. That&#39;s the magic, and frustration, of closure.\r\n\r\n**&quot;JavaScript Functions close over the scope they are declared in, and retain access to that scope even as variable values inside of that scope change.&quot;**\r\n\r\nUsing `let` instead of `var` solves this by creating a new scope each time the `for` loop runs, creating a separated scope for each function to close over. Various other techniques do the same thing with extra functions.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = []\r\n\r\n    for (let i = 0; i &lt; 3; i += 1) {\r\n      funcs[i] = function () {\r\n        console.log(i)\r\n      }\r\n    }\r\n\r\n    for (var k = 0; k &lt; 3; k += 1) {\r\n      funcs[k]()\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n(`let` makes variables block scoped. Blocks are denoted by curly braces, but in the case of the for loop the initialization variable, `i` in our case, is considered to be declared in the braces.)"},{"score":8,"body_markdown":"Use [closure][1] structure, this would reduce your extra for loop. You can do it in a single for loop:\r\n\r\n    var funcs = [];\r\n    for (var i = 0; i &lt; 3; i++) {     \r\n      (funcs[i] = function() {         \r\n        console.log(&quot;My value: &quot; + i); \r\n      })(i);\r\n    }\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"},{"score":3,"body_markdown":"Many solutions seem correct but they don&#39;t mention it&#39;s called [`Currying`][1] which is a functional programming design pattern for situations like here. 3-10 times faster than bind depending on the browser.\r\n\r\n    var funcs = [];\r\n    for (var i = 0; i &lt; 3; i++) {      // let&#39;s create 3 functions\r\n      funcs[i] = curryShowValue(i);\r\n    }\r\n    for (var j = 0; j &lt; 3; j++) {\r\n      funcs[j]();                      // and now let&#39;s run each one to see\r\n    }\r\n    \r\n    function curryShowValue(i) {\r\n      return function showValue() {\r\n        console.log(&quot;My value: &quot; + i);\r\n      }\r\n    }\r\n\r\nSee [the performance gain in different browsers][2].\r\n\r\n\r\n  [1]: https://www.sitepoint.com/currying-in-functional-javascript/\r\n  [2]: https://jsperf.com/bind-vs-curry"},{"score":2,"body_markdown":"**COUNTER BEING A PRIMITIVE**\r\n\r\nLet&#39;s define callback functions as follows:\r\n\r\n    // ****************************\r\n    // COUNTER BEING A PRIMITIVE\r\n    // ****************************\r\n    function test1() {\r\n        for (var i=0; i&lt;2; i++) {\r\n            setTimeout(function() {\r\n                console.log(i);\r\n            });\r\n        }\r\n    }\r\n    test1();\r\n    // 2\r\n    // 2\r\n\r\nAfter timeout completes it will print 2 for both. This is because the callback function accesses the value based on the [lexical scope][1], where it was function was defined.\r\n\r\nTo pass and preserve the value while callback was defined, we can create a [closure][2], to preserve the value before the callback is invoked. This can be done as follows:\r\n\r\n    function test2() {\r\n        function sendRequest(i) {\r\n            setTimeout(function() {\r\n                console.log(i);\r\n            });\r\n        }\r\n        \r\n        for (var i = 0; i &lt; 2; i++) {\r\n            sendRequest(i);\r\n        }\r\n    }\r\n    test2();\r\n    // 1\r\n    // 2\r\n\r\nNow what&#39;s special about this is &quot;The primitives are passed by value and copied. Thus when the closure is defined, they keep the value from the previous loop.&quot;\r\n\r\n**COUNTER BEING AN OBJECT**\r\n\r\nSince closures have access to parent function variables via reference, this approach would differ from that for primitives.\r\n\r\n    // ****************************\r\n    // COUNTER BEING AN OBJECT\r\n    // ****************************\r\n    function test3() {\r\n        var index = { i: 0 };\r\n        for (index.i=0; index.i&lt;2; index.i++) {\r\n            setTimeout(function() {\r\n                console.log(&#39;test3: &#39; + index.i);\r\n            });\r\n        }\r\n    }\r\n    test3();\r\n    // 2\r\n    // 2\r\n\r\nSo, even if a closure is created for the variable being passed as an object, the value of the loop index will not be preserved. This is to show that the values of an object are not copied whereas they are accessed via reference.\r\n\r\n    function test4() {\r\n        var index = { i: 0 };\r\n        function sendRequest(index, i) {\r\n            setTimeout(function() {\r\n                console.log(&#39;index: &#39; + index);\r\n                console.log(&#39;i: &#39; + i);\r\n                console.log(index[i]);\r\n            });\r\n        }\r\n        \r\n        for (index.i=0; index.i&lt;2; index.i++) {\r\n            sendRequest(index, index.i);\r\n        }\r\n    }\r\n    test4();\r\n    // index: { i: 2}\r\n    // 0\r\n    // undefined\r\n    \r\n    // index: { i: 2}\r\n    // 1\r\n    // undefined\r\n\r\n\r\n  [1]: https://stackoverflow.com/q/1047454/7032856\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"},{"score":-2,"body_markdown":"Already many valid answers to this question. Not many using a functional approach though. Here is an alternative solution using the `forEach` method, which works well with callbacks and closures:\r\n\r\n`let arr = [1,2,3];`\r\n\r\n`let myFunc = (val, index) =&gt; { \r\n    console.log(&#39;val: &#39;+val+&#39;\\nindex: &#39;+index);\r\n};`\r\n\r\n`arr.forEach(myFunc);`"},{"score":9,"body_markdown":"This question really shows the history of JavaScript! Now we can avoid block scoping with arrow functions and handle loops directly from DOM nodes using Object methods.\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const funcs = [1, 2, 3].map(i =&gt; () =&gt; console.log(i));\r\n    funcs.map(fn =&gt; fn())\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n    const buttons = document.getElementsByTagName(&quot;button&quot;);\r\n    Object\r\n      .keys(buttons)\r\n      .map(i =&gt; buttons[i].addEventListener(&#39;click&#39;, () =&gt; console.log(i)));\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;button&gt;0&lt;/button&gt;&lt;br&gt;\r\n    &lt;button&gt;1&lt;/button&gt;&lt;br&gt;\r\n    &lt;button&gt;2&lt;/button&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n"},{"score":7,"body_markdown":"&gt; We will check , what actually happens when you declare `var` and `let`\r\n&gt; one by one.\r\n\r\n**Case1** : **using `var`**\r\n---------------------------\r\n\r\n    &lt;script&gt;\r\n       var funcs = [];\r\n       for (var i = 0; i &lt; 3; i++) {\r\n         funcs[i] = function () {\r\n            debugger;\r\n            console.log(&quot;My value: &quot; + i);\r\n         };\r\n       }\r\n       console.log(funcs);\r\n    &lt;/script&gt;\r\n\r\nNow open your **chrome console window** by pressing **F12** and refresh the page.\r\nExpend every 3 functions inside the array.You will see an property called `[[Scopes]]`.Expand that one. You will see one \r\narray object called `&quot;Global&quot;`,expand that one. You will find a property `&#39;i&#39;` declared into the object which having value 3.\r\n\r\n[![enter image description here][1]][1]\r\n\r\n[![enter image description here][2]][2]\r\n\r\n**Conclusion:** \r\n\r\n1. When you declare a variable using `&#39;var&#39;` outside a function ,it becomes global variable(you can check by typing `i` or \r\n`window.i` in console window.It will return 3).\r\n2. The annominous function you declared will not call and check the value inside the function unless you invoke the \r\nfunctions.\r\n3. When you invoke the function , `console.log(&quot;My value: &quot; + i)` takes the value from its `Global` object and display the \r\nresult.\r\n\r\n**CASE2 : using let**\r\n---------------------\r\n\r\nNow replace the `&#39;var&#39;` with `&#39;let&#39;`\r\n\r\n    &lt;script&gt;\r\n        var funcs = [];\r\n        for (let i = 0; i &lt; 3; i++) {\r\n            funcs[i] = function () {\r\n               debugger;\r\n               console.log(&quot;My value: &quot; + i);\r\n            };\r\n        }\r\n        console.log(funcs);\r\n    &lt;/script&gt;\r\n\r\nDo the same thing, Go to the scopes . Now you will see two objects `&quot;Block&quot;` and `&quot;Global&quot;`. Now expand `Block` object , you \r\nwill see &#39;i&#39; is defined there , and the strange thing is that , for every functions , the value if `i` is different (0 , 1, 2). \r\n\r\n[![enter image description here][3]][3]\r\n\r\n**Conclusion:**\r\n\r\nWhen you declare variable using `&#39;let&#39;` even outside the function but inside the loop , this variable will not be a Global \r\nvariable , it will become a `Block` level variable which is only available for the same function only.That is the reason , we \r\nare getting value of `i` different for each function when we invoke the functions.\r\n\r\nFor more detail about how closer works , please go through the awesome video tutorial https://youtu.be/71AtaJpJHw0\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/f6I2J.png\r\n  [2]: https://i.stack.imgur.com/kF3Yv.png\r\n  [3]: https://i.stack.imgur.com/HGqXU.png"},{"score":0,"body_markdown":"While this question is old and answered,  I have yet another fairly interesting solution:\r\n\r\n    var funcs = [];\r\n    \r\n    for (var i = 0; i &lt; 3; i++) {     \r\n      funcs[i] = function() {          \r\n        console.log(&quot;My value: &quot; + i); \r\n     };\r\n    }\r\n    \r\n    for (var i = 0; i &lt; 3; i++) {\r\n      funcs[i]();\r\n    }\r\n\r\nThe change is so small it&#39;s almost difficult to see what I did. I switched the second iterator from a j to an i. This somehow refreshes the state of i in time to give you the desired result. I did this by accident but it makes sense considering previous answers.\r\n\r\nI wrote this up to point out this small, yet very important difference. Hope that helps to clear up some confusion for other learners like me.\r\n\r\nNote: I am not sharing this because I think it&#39;s the right answer. This is a flakey solution that probably will break under certain circumstances. Actually, I&#39;m quite amazed that it really works.\r\n"},{"score":0,"body_markdown":"Let&#39;s say you don&#39;t use es6;\r\nYou can use IFFY function:\r\n\r\n    var funcs = [];\r\n    for (var i = 0; i &lt; 13; i++) {      \r\n    funcs[i] = (function(x) {\r\n    console.log(&quot;My value: &quot; + i)})(i);}\r\n\r\nBut it will be different.\r\n"},{"score":0,"body_markdown":"Ok. I read through all of the answers. Even though there is a good explanation here - I just could not get this to work. So I went looking on the internet. The person at https://dzone.com/articles/why-does-javascript-loop-only-use-last-value had an answer which is not presented here. So I thought I&#39;d post a short example. This made a lot more sense to me.\r\n\r\nThe long and short of it is that the LET command is nice but is only now being used. HOWEVER, the LET command is really just a TRY-CATCH combo. This works all the way back to IE3 (I believe). Using the TRY-CATCH combo - life is simple and good. Probably why the EMCScript people decided to use it. It also does not need a setTimeout() function. So no time is lost. Basically, you need one TRY-CATCH combo per FOR loop. Here is an example:\r\n\r\n        for( var i in myArray ){\r\n           try{ throw i }\r\n           catch(ii){\r\n    // Do whatever it is you want to do with ii\r\n              }\r\n           }\r\n\r\nIf you have more than one FOR loop, you just put a TRY-CATCH combo for each one. Also, personally, I always use the double letter of whatever FOR variable I am using. So &quot;ii&quot; for &quot;i&quot; and so on. I am using this technique in a routine to send mouseover commands to a different routine.\r\n"},{"score":-1,"body_markdown":"Why not simply call each function inside the first (and only) loop just after they were created, such as:\r\n\r\n\r\n     var funcs = [];\r\n        for (var i = 0; i &lt; 3; i++) {\r\n        // let&#39;s create 3 functions\r\n        funcs[i] = function() {\r\n        // and store them in funcs\r\n        console.log(&quot;My value: &quot; + i); // each should log its value.\r\n        };\r\n        funcs[i]();// and now let&#39;s run each one to see\r\n        }"},{"score":3,"body_markdown":"    var funcs = [];\r\n    for (var i = 0; i &lt; 3; i++) {      // let&#39;s create 3 functions\r\n      funcs[i] = function(param) {          // and store them in funcs\r\n        console.log(&quot;My value: &quot; + param); // each should log its value.\r\n      };\r\n    }\r\n    for (var j = 0; j &lt; 3; j++) {\r\n      funcs[j](j);                      // and now let&#39;s run each one to see with j\r\n    }"},{"score":0,"body_markdown":"This proves how ugly javascript is with regard to how &#39;closure&#39; and &#39;non-closure&#39; works.\r\n\r\nIn the case of:\r\n\r\n    var funcs = [];\r\n\r\n    for (var i = 0; i &lt; 3; i++) {      // let&#39;s create 3 functions\r\n      funcs[i] = function() {          // and store them in funcs\r\n        console.log(&quot;My value: &quot; + i); // each should log its value.\r\n      };\r\n    }\r\n\r\nfuncs[i] is a global function, and &#39;console.log(&quot;My value: &quot; + i);&#39; is printing global variable i\r\n\r\nIn the case of \r\n\r\n    var funcs = [];\r\n\r\n    function createfunc(i) {\r\n        return function() { console.log(&quot;My value: &quot; + i); };\r\n    }\r\n    \r\n    for (var i = 0; i &lt; 3; i++) {\r\n        funcs[i] = createfunc(i);\r\n    }\r\n\r\nbecause of this twisted closure design of javascript, &#39;console.log(&quot;My value: &quot; + i);&#39; is printing the i from outer function &#39;createfunc(i)&#39;\r\n\r\nall because javascript can not design something decent like the &#39;static&#39; variable inside a function like what C programming language is doing!"},{"score":1,"body_markdown":"Just change the var keyword to let. \r\n\r\nvar is function scoped.\r\n\r\nlet is block scoped.\r\n\r\nWhen you start you code the for loop will iterate and assign the value of i to 3, which will remain 3 throughout your code. I suggest you to read more about scopes in node (let,var,const and others)\r\n\r\n    funcs = [];\r\n    for (let i = 0; i &lt; 3; i++) {      // let&#39;s create 3 functions\r\n      funcs[i] =async function() {          // and store them in funcs\r\n        await console.log(&quot;My value: &quot; + i); // each should log its value.\r\n      };\r\n    }\r\n    for (var j = 0; j &lt; 3; j++) {\r\n      funcs[j]();                      // and now let&#39;s run each one to see\r\n    }\r\n\r\n"},{"score":0,"body_markdown":"      asyncIterable = [1,2,3,4,5,6,7,8];\r\n    \r\n      (async function() {\r\n           for await (let num of asyncIterable) {\r\n             console.log(num);\r\n           }\r\n        })();"},{"score":3,"body_markdown":"Use let(blocked-scope) instead of var.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = [];\r\n    for (let i = 0; i &lt; 3; i++) {      \r\n      funcs[i] = function() {          \r\n        console.log(&quot;My value: &quot; + i); \r\n      };\r\n    }\r\n    for (var j = 0; j &lt; 3; j++) {\r\n      funcs[j]();                      \r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"With the support of `ES6`, the best way to this is to use `let` and `const` keywords for this exact circumstance. So `var` variable get `hoisted` and with the end of loop the value of `i` gets updated for all the `closures`..., we can just use `let` to set a loop scope variable like this:\r\n\r\n    var funcs = [];\r\n    for (let i = 0; i &lt; 3; i++) {          \r\n        funcs[i] = function() {            \r\n          console.log(&quot;My value: &quot; + i); \r\n        };\r\n    }"},{"score":4,"body_markdown":"Till ES5, This problem can only be solved using **closure**.\r\n\r\nBut now in ES6, we have block level scope variables. Changing **var** to **let** in first **for loop** will solve the problem.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var funcs = [];\r\n    for (let i = 0; i &lt; 3; i++) {      // let&#39;s create 3 functions\r\n      funcs[i] = function() {          // and store them in funcs\r\n        console.log(&quot;My value: &quot; + i); // each should log its value.\r\n      };\r\n    }\r\n    for (var j = 0; j &lt; 3; j++) {\r\n      funcs[j]();                      // and now let&#39;s run each one to see\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":3,"body_markdown":"If you&#39;re having this sort of problem with a `while` loop, rather than a `for` loop, for example:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var i = 0;\r\n    while (i &lt; 5) {\r\n      setTimeout(function() {\r\n        console.log(i);\r\n      }, i * 1000);\r\n      i++;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe technique to close over the current value is a bit different. Declare a block-scoped variable with `const` inside the `while` block, and assign the current `i` to it. Then, wherever the variable is being used asynchronously, replace `i` with the new block-scoped variable:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var i = 0;\r\n    while (i &lt; 5) {\r\n      const thisIterationI = i;\r\n      setTimeout(function() {\r\n        console.log(thisIterationI);\r\n      }, i * 1000);\r\n      i++;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nFor older browsers that don&#39;t support block-scoped variables, you can use an IIFE called with `i`:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var i = 0;\r\n    while (i &lt; 5) {\r\n      (function(innerI) {\r\n        setTimeout(function() {\r\n          console.log(innerI);\r\n        }, innerI * 1000);\r\n      })(i);\r\n      i++;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf the asynchronous action to be invoked happens to be `setTimeout` like the above, you can also call `setTimeout` with a *third* parameter to indicate the argument to call the passed function with:\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var i = 0;\r\n    while (i &lt; 5) {\r\n      setTimeout(\r\n        (thisIterationI) =&gt; { // Callback\r\n          console.log(thisIterationI);\r\n        },\r\n        i * 1000, // Delay\r\n        i // Gets passed to the callback; becomes thisIterationI\r\n      );\r\n      i++;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"}],"score":2917}