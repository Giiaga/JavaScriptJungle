{"body":"&gt; **Mod note**: This question is about why Postman is not subject to CORS restrictions in the same way an XMLHttpRequest is. This question is **not** about how to fix a &quot;No &#39;Access-Control-Allow-Origin&#39;...&quot; error.\r\n\r\n&gt; **Please stop posting**:\r\n&gt;\r\n&gt; - CORS configurations for every language/framework under the sun. Instead [find your relevant language/framework&#39;s question](https://stackoverflow.com/search?q=how+to+enable+CORS+is%3Aquestion&amp;mixed=1).\r\n&gt; - 3rd party services that allow a request to circumvent CORS\r\n&gt; - Command line options for turning off CORS for various browsers\r\n\r\n---\r\n\r\nI am trying to do authorization using [JavaScript][1] by connecting to the [RESTful][2] [API][3] built-in [Flask][4]. However, when I make the request, I get the following error:\r\n\r\n&gt; XMLHttpRequest cannot load http://myApiUrl/login. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;null&#39; is therefore not allowed access.\r\n\r\nI know that the API or remote resource must set the header, but why did it work when I made the request via the Chrome extension [Postman][5]?\r\n\r\nThis is the request code:\r\n\r\n    $.ajax({\r\n        type: &quot;POST&quot;,\r\n        dataType: &#39;text&#39;,\r\n        url: api,\r\n        username: &#39;user&#39;,\r\n        password: &#39;pass&#39;,\r\n        crossDomain : true,\r\n        xhrFields: {\r\n            withCredentials: true\r\n        }\r\n    })\r\n        .done(function( data ) {\r\n            console.log(&quot;done&quot;);\r\n        })\r\n        .fail( function(xhr, textStatus, errorThrown) {\r\n            alert(xhr.responseText);\r\n            alert(textStatus);\r\n        });\r\n\r\n  [1]: http://en.wikipedia.org/wiki/JavaScript\r\n  [2]: http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services\r\n  [3]: http://en.wikipedia.org/wiki/Application_programming_interface\r\n  [4]: https://en.wikipedia.org/wiki/Flask_%28web_framework%29\r\n  [5]: https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop\r\n","title":"Why does my JavaScript code receive a &quot;No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource&quot; error, while Postman does not?","answers":[{"score":1404,"body_markdown":"If I understood it right you are doing an [XMLHttpRequest][1] to a different domain than your page is on. So the browser is blocking it as it usually allows a request in the same origin for security reasons. You need to do something different when you want to do a cross-domain request. A tutorial about how to achieve that is *[Using CORS][2]*.\r\n\r\nWhen you are using postman they are not restricted by this policy. Quoted from *[Cross-Origin XMLHttpRequest][3]*:\r\n\r\n&gt; Regular web pages can use the XMLHttpRequest object to send and receive data from remote servers, but they&#39;re limited by the same origin policy. Extensions aren&#39;t so limited. An extension can talk to remote servers outside of its origin, as long as it first requests cross-origin permissions.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/XMLHttpRequest\r\n  [2]: http://www.html5rocks.com/en/tutorials/cors/\r\n  [3]: http://developer.chrome.com/extensions/xhr.html\r\n"},{"score":269,"body_markdown":"&gt; **WARNING:** Using `Access-Control-Allow-Origin: *` can make your API/website vulnerable to [cross-site request forgery][1] (CSRF) attacks. Make certain you [understand the risks](https://stackoverflow.com/questions/43154170/is-it-safe-to-enable-cors-to-for-a-public-and-readonly-webservice) before using this code.\r\n\r\nIt&#39;s very simple to solve if you are using [PHP][2]. Just add the following script in the beginning of your PHP page which handles the request:\r\n\r\n    &lt;?php header(&#39;Access-Control-Allow-Origin: *&#39;); ?&gt;\r\n\r\nIf you are using [Node-red][3] you have to allow [CORS][4] in the `node-red/settings.js` file by un-commenting the following lines:\r\n\r\n    // The following property can be used to configure cross-origin resource sharing\r\n    // in the HTTP nodes.\r\n    // See https://github.com/troygoode/node-cors#configuration-options for\r\n    // details on its contents. The following is a basic permissive set of options:\r\n    httpNodeCors: {\r\n     origin: &quot;*&quot;,\r\n     methods: &quot;GET,PUT,POST,DELETE&quot;\r\n    },\r\n\r\nIf you are using [Flask][5] same as the question; you have first to install `flask-cors`\r\n\r\n    $ pip install -U flask-cors\r\n\r\nThen include the Flask cors in your application.\r\n\r\n    from flask_cors import CORS\r\n\r\nA simple application will look like:\r\n\r\n    from flask import Flask\r\n    from flask_cors import CORS\r\n\r\n    app = Flask(__name__)\r\n    CORS(app)\r\n\r\n    @app.route(&quot;/&quot;)\r\n    def helloWorld():\r\n      return &quot;Hello, cross-origin-world!&quot;\r\n\r\nFor more details, you can check the [Flask documentation][6].\r\n\r\n\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Cross-site_request_forgery\r\n  [2]: http://en.wikipedia.org/wiki/PHP\r\n  [3]: https://en.wikipedia.org/wiki/Node-RED\r\n  [4]: https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\r\n  [5]: http://flask.pocoo.org/\r\n  [6]: https://flask-cors.readthedocs.io/en/latest/\r\n\r\n"},{"score":68,"body_markdown":"Because &lt;br/&gt;\n**$.ajax({type: &quot;POST&quot;** - calls **OPTIONS** &lt;br/&gt;\n**$.post(** - Calls **POST** &lt;br/&gt;\n\nBoth are different. Postman calls &quot;POST&quot; properly, but when we call it, it will be &quot;OPTIONS&quot;.\n\n**For C# web services - [Web API][1]**\n\nPlease add the following code in your *web.config* file under &amp;lt;system.webServer&amp;gt; tag. This will work:\n\n    &lt;httpProtocol&gt;\n        &lt;customHeaders&gt;\n            &lt;add name=&quot;Access-Control-Allow-Origin&quot; value=&quot;*&quot; /&gt;\n        &lt;/customHeaders&gt;\n    &lt;/httpProtocol&gt;\n\nPlease make sure you are not doing any mistake in the Ajax call\n\n### jQuery\n\n    $.ajax({\n        url: &#39;http://mysite.microsoft.sample.xyz.com/api/mycall&#39;,\n        headers: {\n            &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;\n        },\n        type: &quot;POST&quot;, /* or type:&quot;GET&quot; or type:&quot;PUT&quot; */\n        dataType: &quot;json&quot;,\n        data: {\n        },\n        success: function (result) {\n            console.log(result);\n        },\n        error: function () {\n            console.log(&quot;error&quot;);\n        }\n    });\n\n**Note:** If you are looking for downloading content **from a third-party website** then **this will not help you**.  You can try the following code, but not JavaScript.\n\n    System.Net.WebClient wc = new System.Net.WebClient();\n    string str = wc.DownloadString(&quot;http://mysite.microsoft.sample.xyz.com/api/mycall&quot;);\n\n  [1]: https://en.wikipedia.org/wiki/ASP.NET_MVC_Framework#Apache_License_2.0_release\n\n\n\n"},{"score":17,"body_markdown":"In the below investigation as API, I use http://example.com instead of http://myApiUrl/login from your question, because this first one working.\r\n\r\nI assume that your page is on http://my-site.local:8088[.](https://stackoverflow.com/a/55584963/860099)\r\n\r\nThe reason why you see different results is that Postman:\r\n\r\n- set header `Host=example.com` (your API)\r\n- NOT set header `Origin`\r\n\r\nThis is similar to browsers&#39; way of sending requests when the site and API has the same domain (browsers also set the header item `Referer=http://my-site.local:8088`, however I don&#39;t see it in Postman). **When `Origin` header is *not* set, usually servers allow such requests by default.**\r\n\r\n[![Enter image description here][1]][1]\r\n\r\nThis is the standard way how Postman sends requests. But a browser sends requests differently when **your site and API have different domains**, and then [CORS][2] occurs and the browser automatically:\r\n\r\n- sets header `Host=example.com` (yours as API)\r\n- sets header `Origin=http://my-site.local:8088` (your site)\r\n\r\n(The header `Referer` has the same value as `Origin`). And now in Chrome&#39;s *Console &amp; Networks* tab you will see:\r\n\r\n[![Enter image description here][3]][3]\r\n\r\n[![Enter image description here][4]][4]\r\n\r\nWhen you have **`Host != Origin`** this is CORS, and when the server detects such a request, it usually **blocks it by default**.\r\n\r\n`Origin=null` is set when you open HTML content from a local directory, and it sends a request. The same situation is when you send a request inside an `&lt;iframe&gt;`, like in the below snippet (but here the `Host` header is not set at all) - in general, everywhere the HTML specification says opaque origin, you can translate that to `Origin=null`. More information about this you can find [here](https://stackoverflow.com/questions/42239643/when-do-browsers-send-the-origin-header-when-do-browsers-set-the-origin-to-null/42242802#42242802).\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    fetch(&#39;http://example.com/api&#39;, {method: &#39;POST&#39;});\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    Look on chrome-console &gt; network tab\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf you do not use a simple CORS request, usually the browser automatically also sends an OPTIONS request before sending the main request - more information is [here](https://stackoverflow.com/questions/10093053/access-control-request-headers-is-added-to-header-in-ajax-request-with-jquery/55584963#55584963). The snippet below shows it:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    fetch(&#39;http://example.com/api&#39;, {\r\n      method: &#39;POST&#39;,\r\n      headers: { &#39;Content-Type&#39;: &#39;application/json&#39;}\r\n    });\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    Look in chrome-console -&gt; network tab to &#39;api&#39; request.\r\n    This is the OPTIONS request (the server does not allow sending a POST request)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nYou can change the configuration of your server to allow CORS requests.\r\n\r\nHere is an example configuration which turns on **CORS on nginx** (nginx.conf file) - be very careful with setting `always/&quot;$http_origin&quot;` for nginx and `&quot;*&quot;` for Apache - this will unblock CORS from any domain.\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    location ~ ^/index\\.php(/|$) {\r\n       ...\r\n        add_header &#39;Access-Control-Allow-Origin&#39; &quot;$http_origin&quot; always;\r\n        add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39; always;\r\n        if ($request_method = OPTIONS) {\r\n            add_header &#39;Access-Control-Allow-Origin&#39; &quot;$http_origin&quot;; # DO NOT remove THIS LINES (doubled with outside &#39;if&#39; above)\r\n            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\r\n            add_header &#39;Access-Control-Max-Age&#39; 1728000; # cache preflight value for 20 days\r\n            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\r\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;My-First-Header,My-Second-Header,Authorization,Content-Type,Accept,Origin&#39;;\r\n            add_header &#39;Content-Length&#39; 0;\r\n            add_header &#39;Content-Type&#39; &#39;text/plain charset=UTF-8&#39;;\r\n            return 204;\r\n        }\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nHere is an example configuration which turns on **CORS on Apache** (.htaccess file)\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    # ------------------------------------------------------------------------------\r\n    # | Cross-domain Ajax requests                                                 |\r\n    # ------------------------------------------------------------------------------\r\n\r\n    # Enable cross-origin Ajax requests.\r\n    # http://code.google.com/p/html5security/wiki/CrossOriginRequestSecurity\r\n    # http://enable-cors.org/\r\n\r\n    # &lt;IfModule mod_headers.c&gt;\r\n    #    Header set Access-Control-Allow-Origin &quot;*&quot;\r\n    # &lt;/IfModule&gt;\r\n\r\n    # Header set Header set Access-Control-Allow-Origin &quot;*&quot;\r\n    # Header always set Access-Control-Allow-Credentials &quot;true&quot;\r\n\r\n    Access-Control-Allow-Origin &quot;http://your-page.com:80&quot;\r\n    Header always set Access-Control-Allow-Methods &quot;POST, GET, OPTIONS, DELETE, PUT&quot;\r\n    Header always set Access-Control-Allow-Headers &quot;My-First-Header,My-Second-Header,Authorization, content-type, csrf-token&quot;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://i.stack.imgur.com/XLrRg.png\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\r\n  [3]: https://i.stack.imgur.com/oZkcL.png\r\n  [4]: https://i.stack.imgur.com/8ITev.png\r\n\r\n\r\n\r\n"},{"score":12,"body_markdown":"Applying a CORS restriction is a security feature defined by a server and implemented by a **browser**. \r\n\r\n&gt; The browser looks at the CORS policy of the server and respects it.\r\n\r\nHowever, the Postman tool does not bother about the CORS policy of the server.\r\n\r\nThat is why the CORS error appears in the browser, but not in Postman.\r\n\r\n\r\n"},{"score":-1,"body_markdown":"If you use .NET as your middle tier, check the route attribute clearly, for example,\r\n\r\nI had issue when it was like this, \r\n\r\n    [Route(&quot;something/{somethingLong: long}&quot;)] //Space.\r\nFixed it by this, \r\n\r\n    [Route(&quot;something/{somethingLong:long}&quot;)] //No space"},{"score":8,"body_markdown":"Encountered the same error in different use case. \r\n\r\n**Use Case:** In chrome when tried to call Spring **REST** end point in angular.\r\n\r\n[![enter image description here][1]][1]\r\n\r\n**Solution:** Add **@CrossOrigin(&quot;*&quot;)** annotation on top of respective Controller Class.\r\n\r\n[![enter image description here][2]][2]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/1hYm6.png\r\n  [2]: https://i.stack.imgur.com/xiHSO.png"},{"score":0,"body_markdown":"Only for .NET Core Web API project, add following changes:\r\n\r\n1. Add the following code after the `services.AddMvc()` line in the `ConfigureServices()` method of the Startup.cs file:\r\n\r\n```\r\nservices.AddCors(allowsites=&gt;{allowsites.AddPolicy(&quot;AllowOrigin&quot;, options =&gt; options.AllowAnyOrigin());\r\n            });\r\n```\r\n2. Add the following code after `app.UseMvc()` line in the `Configure()` method of the Startup.cs file:\r\n```\r\napp.UseCors(options =&gt; options.AllowAnyOrigin());\r\n```\r\n3. Open the controller which you want to access outside the domain and add this following attribute at the controller level:\r\n```\r\n[EnableCors(&quot;AllowOrigin&quot;)]\r\n```"},{"score":3,"body_markdown":"If you want to bypass that restriction when fetching the contents with fetch API or XMLHttpRequest in javascript, you can use a proxy server so that it sets the header `Access-Control-Allow-Origin` to `*`.\r\n\r\n```\r\nconst express = require(&#39;express&#39;);\r\nconst request = require(&#39;request&#39;);\r\n\r\nconst app = express();\r\n\r\napp.use((req, res, next) =&gt; {\r\n  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\r\n  next();\r\n});\r\n\r\napp.get(&#39;/fetch&#39;, (req, res) =&gt; {\r\n  request(\r\n    { url: req.query.url },\r\n    (error, response, body) =&gt; {\r\n      if (error || response.statusCode !== 200) {\r\n        return res.status(500).send(&#39;error&#39;);\r\n      }\r\n      res.send(body);\r\n    }\r\n  )\r\n});\r\n\r\nconst PORT = process.env.PORT || 3000;\r\napp.listen(PORT, () =&gt; console.log(`listening on ${PORT}`));\r\n```\r\n\r\nAbove is a sample code( node Js required ) which can act as a proxy server. For eg: If I want to fetch `https://www.google.com` normally a CORS error is thrown, but now since the request is sent through the proxy server hosted locally at port 3000, the proxy server adds the `Access-Control-Allow-Origin` header in the response and there wont be any issue.\r\n\r\nSend a GET request to http://localhost:3000/fetch?url=`Your URL here` , instead of directly sending the request to the URl you want to fetch.\r\n\r\n`Your URL here` stands for the URL you wish to fetch eg: `https://www.google.com`"},{"score":-1,"body_markdown":"Are you using Webfonts from Google, Typekit, etc?\r\nThere are multiple ways you could use Webfonts like @font-face or CSS3 methods, some browsers like Firefox &amp; IE may refuse to embed the font when it’s coming from some non-standard 3rd party URL (like your blog) for same security reason.\r\n\r\nIn order to fix an issue for your WordPress blog, just put below into your .htaccess file.\r\n\r\n    &lt;IfModule mod_headers.c&gt;\r\n      &lt;FilesMatch &quot;\\.(ttf|ttc|otf|eot|woff|woff2|font.css|css|js)$&quot;&gt;\r\n      Header set Access-Control-Allow-Origin &quot;*&quot;\r\n      &lt;/FilesMatch&gt;\r\n    &lt;/IfModule&gt;\r\n\r\nSource : https://crunchify.com/how-to-fix-access-control-allow-origin-issue-for-your-https-enabled-wordpress-site-and-maxcdn/"}],"score":2631}