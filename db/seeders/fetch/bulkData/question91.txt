{"body":"I&#39;m looking for a good JavaScript equivalent of the C/PHP `printf()` or for C#/Java programmers, `String.Format()` (`IFormatProvider` for .NET).\r\n\r\nMy basic requirement is a thousand separator format for numbers for now, but something that handles lots of combinations (including dates) would be good.\r\n\r\nI realize Microsoft&#39;s [Ajax][1] library provides a version of `String.Format()`, but we don&#39;t want the entire overhead of that framework.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Ajax_%28programming%29\r\n","title":"JavaScript equivalent to printf/String.Format","answers":[{"score":1207,"body_markdown":"From ES6 on you could use template strings:\r\n\r\n    let soMany = 10;\r\n    console.log(`This is ${soMany} times easier!`);\r\n    // &quot;This is 10 times easier!\r\n\r\nSee Kim&#39;s [answer](https://stackoverflow.com/a/32202320/2430448) below for details. \r\n\r\n---\r\n\r\n# Otherwise: \r\n\r\nTry [sprintf() for JavaScript](https://github.com/alexei/sprintf.js).\r\n\r\n\r\n----------\r\n\r\nIf you really want to do a simple format method on your own, don’t do the replacements successively but do them simultaneously.\r\n\r\nBecause most of the other proposals that are mentioned fail when a replace string of previous replacement does also contain a format sequence like this:\r\n\r\n    &quot;{0}{1}&quot;.format(&quot;{1}&quot;, &quot;{0}&quot;)\r\n\r\nNormally you would expect the output to be `{1}{0}` but the actual output is `{1}{1}`. So do a simultaneously replacement instead like in [fearphage’s suggestion](https://stackoverflow.com/questions/610406/javascript-printf-string-format/4673436#4673436)."},{"score":8,"body_markdown":"There is &quot;sprintf&quot; for JavaScript which you can find at http://www.webtoolkit.info/javascript-sprintf.html.\r\n"},{"score":15,"body_markdown":"I&#39;ll add my own discoveries which I&#39;ve found since I asked:\r\n\r\n- [number_format (for thousand separator/currency formatting)][1]\r\n- [sprintf (same author as above)][2]\r\n\r\n\r\nSadly it seems sprintf doesn&#39;t handle thousand separator formatting like .NET&#39;s string format.\r\n\r\n  [1]: http://locutus.io/php/strings/number_format/index.html\r\n  [2]: http://locutus.io/php/strings/sprintf/index.html"},{"score":11,"body_markdown":"If you are looking to handle the thousands separator, you should really use toLocaleString() from the JavaScript [Number][1] class since it will format the string for the user&#39;s region.\r\n\r\nThe JavaScript [Date][2] class can format localized dates and times.\r\n\r\n  [1]: http://www.hunlock.com/blogs/The_Complete_Javascript_Number_Reference\r\n  [2]: http://www.hunlock.com/blogs/Javascript_Dates-The_Complete_Reference\r\n"},{"score":14,"body_markdown":"I use a small library called [String.format for JavaScript][1] which supports most of the format string capabilities (including format of numbers and dates), and uses the .NET syntax. The script itself is smaller than 4 kB, so it doesn&#39;t create much of overhead.\r\n\r\n\r\n  [1]: http://www.masterdata.se/r/string_format_for_javascript/"},{"score":113,"body_markdown":"I use this simple function:\r\n\r\n    String.prototype.format = function() {\r\n    \tvar formatted = this;\r\n    \tfor( var arg in arguments ) {\r\n    \t\tformatted = formatted.replace(&quot;{&quot; + arg + &quot;}&quot;, arguments[arg]);\r\n    \t}\r\n    \treturn formatted;\r\n    };\r\n\r\nThat&#39;s very similar to string.format:\r\n\r\n    &quot;{0} is dead, but {1} is alive!&quot;.format(&quot;ASP&quot;, &quot;ASP.NET&quot;)\r\n"},{"score":21,"body_markdown":"+1 Zippo with the exception that the function body needs to be as below or otherwise it appends the current string on every iteration:\r\n\r\n    String.prototype.format = function() {\r\n        var formatted = this;\r\n        for (var arg in arguments) {\r\n            formatted = formatted.replace(&quot;{&quot; + arg + &quot;}&quot;, arguments[arg]);\r\n        }\r\n        return formatted;\r\n    };\r\n"},{"score":31,"body_markdown":"JavaScript programmers can use String.prototype.sprintf at https://github.com/ildar-shaimordanov/jsxt/blob/master/js/String.js. Below is example:\r\n\r\n    var d = new Date();\r\n    var dateStr = &#39;%02d:%02d:%02d&#39;.sprintf(\r\n        d.getHours(), \r\n        d.getMinutes(), \r\n        d.getSeconds());\r\n\r\n"},{"score":173,"body_markdown":"jsxt, Zippo\r\n\r\nThis option fits better.\r\n\r\n    String.prototype.format = function() {\r\n        var formatted = this;\r\n        for (var i = 0; i &lt; arguments.length; i++) {\r\n    \t\tvar regexp = new RegExp(&#39;\\\\{&#39;+i+&#39;\\\\}&#39;, &#39;gi&#39;);\r\n            formatted = formatted.replace(regexp, arguments[i]);\r\n        }\r\n        return formatted;\r\n    };\r\n\r\nWith this option I can replace strings like these:\r\n\r\n    &#39;The {0} is dead. Don\\&#39;t code {0}. Code {1} that is open source!&#39;.format(&#39;ASP&#39;, &#39;PHP&#39;);\r\n\r\nWith your code the second {0} wouldn&#39;t be replaced. ;)"},{"score":1419,"body_markdown":"Building on the previously suggested solutions:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // First, checks if it isn&#39;t implemented yet.\r\n    if (!String.prototype.format) {\r\n      String.prototype.format = function() {\r\n        var args = arguments;\r\n        return this.replace(/{(\\d+)}/g, function(match, number) { \r\n          return typeof args[number] != &#39;undefined&#39;\r\n            ? args[number]\r\n            : match\r\n          ;\r\n        });\r\n      };\r\n    }\r\n\r\n`&quot;{0} is dead, but {1} is alive! {0} {2}&quot;.format(&quot;ASP&quot;, &quot;ASP.NET&quot;)`\r\n\r\noutputs\r\n\r\n&gt; ASP is dead, but ASP.NET is alive! ASP {2}\r\n\r\n\r\n----------\r\n\r\n\r\nIf you prefer not to modify `String`&#39;s prototype:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    if (!String.format) {\r\n      String.format = function(format) {\r\n        var args = Array.prototype.slice.call(arguments, 1);\r\n        return format.replace(/{(\\d+)}/g, function(match, number) { \r\n          return typeof args[number] != &#39;undefined&#39;\r\n            ? args[number] \r\n            : match\r\n          ;\r\n        });\r\n      };\r\n    }\r\n\r\nGives you the much more familiar:\r\n\r\n`String.format(&#39;{0} is dead, but {1} is alive! {0} {2}&#39;, &#39;ASP&#39;, &#39;ASP.NET&#39;);`\r\n\r\nwith the same result:\r\n\r\n&gt; ASP is dead, but ASP.NET is alive! ASP {2}"},{"score":51,"body_markdown":"Here&#39;s a *minimal* implementation of sprintf in JavaScript: it only does &quot;%s&quot; and &quot;%d&quot;, but I have left space for it to be extended. It is useless to the OP, but other people who stumble across this thread coming from Google might benefit from it.\r\n\r\n    function sprintf() {\r\n        var args = arguments,\r\n        string = args[0],\r\n        i = 1;\r\n        return string.replace(/%((%)|s|d)/g, function (m) {\r\n            // m is the matched format, e.g. %s, %d\r\n            var val = null;\r\n            if (m[2]) {\r\n                val = m[2];\r\n            } else {\r\n                val = args[i];\r\n                // A switch statement so that the formatter can be extended. Default is %s\r\n                switch (m) {\r\n                    case &#39;%d&#39;:\r\n                        val = parseFloat(val);\r\n                        if (isNaN(val)) {\r\n                            val = 0;\r\n                        }\r\n                        break;\r\n                }\r\n                i++;\r\n            }\r\n            return val;\r\n        });\r\n    }\r\n\r\nExample:\r\n\r\n    alert(sprintf(&#39;Latitude: %s, Longitude: %s, Count: %d&#39;, 41.847, -87.661, &#39;two&#39;));\r\n    // Expected output: Latitude: 41.847, Longitude: -87.661, Count: 0\r\n\r\nIn contrast with similar solutions in previous replies, this one does all substitutions *in one go*, so it will not replace parts of previously replaced values.\r\n"},{"score":9,"body_markdown":"The [PHPJS project][1] has written JavaScript implementations for many of PHP&#39;s functions. Since PHP&#39;s `sprintf()` function is basically the same as C&#39;s `printf()`, [their JavaScript implementation of it][2] should satisfy your needs.\r\n\r\n  [1]: http://phpjs.org/\r\n  [2]: http://phpjs.org/functions/sprintf\r\n"},{"score":1,"body_markdown":"`arg` function: \r\n\r\n    /**\r\n     * Qt stil arg()\r\n     * var scr = &quot;&lt;div id=&#39;%1&#39; class=&#39;%2&#39;&gt;&lt;/div&gt;&quot;.arg(&quot;mydiv&quot;).arg(&quot;mydivClass&quot;);\r\n     */\r\n    String.prototype.arg = function() {\r\n        var signIndex = this.indexOf(&quot;%&quot;);\r\n        var result = this;\r\n        if (signIndex &gt; -1 &amp;&amp; arguments.length &gt; 0) {\r\n            var argNumber = this.charAt(signIndex + 1);\r\n            var _arg = &quot;%&quot;+argNumber;\r\n            var argCount = this.split(_arg);\r\n            for (var itemIndex = 0; itemIndex &lt; argCount.length; itemIndex++) {\r\n                result = result.replace(_arg, arguments[0]);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n"},{"score":1,"body_markdown":"There is also `Globalize.format` in the [jQuery Globalize][1] project, the official globalization service for jQuery UI. IT&#39;s nice when you need culture-aware formatting. \r\n\r\n\r\n  [1]: https://github.com/jquery/globalize"},{"score":332,"body_markdown":"Number Formatting in JavaScript\r\n===============================\r\n\r\nI got to this question page hoping to find how to **format numbers** in JavaScript, without introducing yet another library.  Here&#39;s what I&#39;ve found:\r\n\r\nRounding floating-point numbers\r\n----\r\nThe equivalent of `sprintf(&quot;%.2f&quot;, num)` in JavaScript seems to be `num.toFixed(2)`, which formats `num` to 2 decimal places, with rounding (but see @ars265&#39;s comment about `Math.round` below).\r\n\r\n    (12.345).toFixed(2); // returns &quot;12.35&quot; (rounding!)\r\n    (12.3).toFixed(2); // returns &quot;12.30&quot; (zero padding)\r\n\r\n\r\nExponential form\r\n----\r\nThe equivalent of `sprintf(&quot;%.2e&quot;, num)` is `num.toExponential(2)`.  \r\n\r\n    (33333).toExponential(2); // &quot;3.33e+4&quot;\r\n\r\nHexadecimal and other bases\r\n----\r\nTo print numbers in base B, try `num.toString(B)`.  JavaScript supports automatic conversion to and from bases 2 through 36 (in addition, some browsers have [limited support for base64 encoding](https://developer.mozilla.org/en-US/docs/DOM/window.btoa)).\r\n\r\n    (3735928559).toString(16); // to base 16: &quot;deadbeef&quot;\r\n    parseInt(&quot;deadbeef&quot;, 16); // from base 16: 3735928559\r\n\r\nReference Pages\r\n----\r\n\r\n[Quick tutorial on JS number formatting](http://www.mredkj.com/javascript/numberFormat.html)\r\n\r\n[Mozilla reference page for toFixed()](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Number/toFixed) (with links to toPrecision(), toExponential(), toLocaleString(), ...)"},{"score":14,"body_markdown":"Very elegant:\r\n\r\n    String.prototype.format = function (){\r\n    \tvar args = arguments;\r\n    \treturn this.replace(/\\{\\{|\\}\\}|\\{(\\d+)\\}/g, function (curlyBrack, index) {\r\n    \t\treturn ((curlyBrack == &quot;{{&quot;) ? &quot;{&quot; : ((curlyBrack == &quot;}}&quot;) ? &quot;}&quot; : args[index]));\r\n    \t});\r\n    };\r\n\r\n    // Usage:\r\n    &quot;{0}{1}&quot;.format(&quot;{1}&quot;, &quot;{0}&quot;)\r\n\r\nCredit goes to &lt;del&gt;[(broken link)][1]&lt;/del&gt; https://gist.github.com/0i0/1519811\r\n\r\n\r\n  [1]: http://technoblogia.net/2011/11/08/%D7%98%D7%99%D7%A4-%D7%A4%D7%95%D7%A0%D7%A7%D7%A6%D7%99%D7%99%D7%AA-%D7%A2%D7%96%D7%A8-%D7%91-javascript-%D7%9C%D7%A2%D7%99%D7%A6%D7%95%D7%91-%D7%9E%D7%97%D7%A8%D7%95%D7%96%D7%95%D7%AA/"},{"score":5,"body_markdown":"I have a slightly longer formatter for JavaScript [here][1]...  \r\n\r\nYou can do formatting several ways:\r\n\r\n * `String.format(input, args0, arg1, ...)`\r\n * `String.format(input, obj)`\r\n * `&quot;literal&quot;.format(arg0, arg1, ...)`\r\n * `&quot;literal&quot;.format(obj)`\r\n\r\nAlso, if you have say a ObjectBase.prototype.format (such as with [DateJS][2]) it will use that.\r\n\r\nExamples...\r\n\r\n    var input = &quot;numbered args ({0}-{1}-{2}-{3})&quot;;\r\n    console.log(String.format(input, &quot;first&quot;, 2, new Date()));\r\n    //Outputs &quot;numbered args (first-2-Thu May 31 2012...Time)-{3})&quot;\r\n\r\n    console.log(input.format(&quot;first&quot;, 2, new Date()));\r\n    //Outputs &quot;numbered args(first-2-Thu May 31 2012...Time)-{3})&quot;\r\n\r\n    console.log(input.format(\r\n        &quot;object properties ({first}-{second}-{third:yyyy-MM-dd}-{fourth})&quot;\r\n        ,{\r\n            &#39;first&#39;:&#39;first&#39;\r\n            ,&#39;second&#39;:2\r\n            ,&#39;third&#39;:new Date() //assumes Date.prototype.format method\r\n        }\r\n    ));\r\n    //Outputs &quot;object properties (first-2-2012-05-31-{3})&quot;\r\n\r\nI&#39;ve also aliased with .asFormat and have some detection in place in case there&#39;s already a string.format (such as with MS Ajax Toolkit (I hate that library).\r\n\r\n  [1]: https://github.com/tracker1/core-js/blob/master/js-extensions/100-String.format.js\r\n  [2]: http://www.datejs.com/\r\n"},{"score":0,"body_markdown":"This one works with {0}, {1} and {}.\r\n\r\n    String.prototype.format = function format()\r\n    {                                                                                                               \r\n      var msg = this;\r\n      for(var i in arguments)\r\n        msg = msg.replace(/\\{\\}/,arguments[i]).replace(new RegExp(&#39;\\\\{&#39;+i+&#39;\\\\}&#39;,&#39;g&#39;),arguments[i]);\r\n      return msg;\r\n    }"},{"score":2,"body_markdown":"I did not see the `String.format` variant:\r\n\r\n\tString.format = function (string) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1, arguments.length);\r\n\t\treturn string.replace(/{(\\d+)}/g, function (match, number) {\r\n\t\t\treturn typeof args[number] != &quot;undefined&quot; ? args[number] : match;\r\n\t\t});\r\n\t};\r\n"},{"score":7,"body_markdown":"One very slightly different version, the one I prefer (this one uses {xxx} tokens rather than {0} numbered arguments, this is much more self-documenting and suits localization much better):\r\n\r\n    String.prototype.format = function(tokens) {\r\n      var formatted = this;\r\n      for (var token in tokens)\r\n        if (tokens.hasOwnProperty(token))\r\n          formatted = formatted.replace(RegExp(&quot;{&quot; + token + &quot;}&quot;, &quot;g&quot;), tokens[token]);\r\n      return formatted;\r\n    };\r\n\r\nA variation would be:\r\n\r\n      var formatted = l(this);\r\n\r\nthat calls an l() localization function first."},{"score":21,"body_markdown":"I want to share my solution for the &#39;problem&#39;. I haven&#39;t re-invented the wheel but tries to find a solution based on what JavaScript already does. The advantage is, that you get all implicit conversions for free. Setting the prototype property $ of String gives a very nice and compact syntax (see examples below). It is maybe not the most efficient way, but in most cases dealing with output it does not have to be super optimized.\r\n\r\n    String.form = function(str, arr) {\r\n        var i = -1;\r\n        function callback(exp, p0, p1, p2, p3, p4) {\r\n            if (exp==&#39;%%&#39;) return &#39;%&#39;;\r\n            if (arr[++i]===undefined) return undefined;\r\n            exp  = p2 ? parseInt(p2.substr(1)) : undefined;\r\n            var base = p3 ? parseInt(p3.substr(1)) : undefined;\r\n            var val;\r\n            switch (p4) {\r\n                case &#39;s&#39;: val = arr[i]; break;\r\n                case &#39;c&#39;: val = arr[i][0]; break;\r\n                case &#39;f&#39;: val = parseFloat(arr[i]).toFixed(exp); break;\r\n                case &#39;p&#39;: val = parseFloat(arr[i]).toPrecision(exp); break;\r\n                case &#39;e&#39;: val = parseFloat(arr[i]).toExponential(exp); break;\r\n                case &#39;x&#39;: val = parseInt(arr[i]).toString(base?base:16); break;\r\n                case &#39;d&#39;: val = parseFloat(parseInt(arr[i], base?base:10).toPrecision(exp)).toFixed(0); break;\r\n            }\r\n            val = typeof(val)==&#39;object&#39; ? JSON.stringify(val) : val.toString(base);\r\n            var sz = parseInt(p1); /* padding size */\r\n            var ch = p1 &amp;&amp; p1[0]==&#39;0&#39; ? &#39;0&#39; : &#39; &#39;; /* isnull? */\r\n            while (val.length&lt;sz) val = p0 !== undefined ? val+ch : ch+val; /* isminus? */\r\n           return val;\r\n        }\r\n        var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\r\n        return str.replace(regex, callback);\r\n    }\r\n\r\n    String.prototype.$ = function() {\r\n        return String.form(this, Array.prototype.slice.call(arguments));\r\n    }\r\n\r\nHere are a few examples:\r\n\r\n    String.format(&quot;%s %s&quot;, [ &quot;This is a string&quot;, 11 ])\r\n    console.log(&quot;%s %s&quot;.$(&quot;This is a string&quot;, 11))\r\n    var arr = [ &quot;12.3&quot;, 13.6 ]; console.log(&quot;Array: %s&quot;.$(arr));\r\n    var obj = { test:&quot;test&quot;, id:12 }; console.log(&quot;Object: %s&quot;.$(obj));\r\n    console.log(&quot;%c&quot;, &quot;Test&quot;);\r\n    console.log(&quot;%5d&quot;.$(12)); // &#39;   12&#39;\r\n    console.log(&quot;%05d&quot;.$(12)); // &#39;00012&#39;\r\n    console.log(&quot;%-5d&quot;.$(12)); // &#39;12   &#39;\r\n    console.log(&quot;%5.2d&quot;.$(123)); // &#39;  120&#39;\r\n    console.log(&quot;%5.2f&quot;.$(1.1)); // &#39; 1.10&#39;\r\n    console.log(&quot;%10.2e&quot;.$(1.1)); // &#39;   1.10e+0&#39;\r\n    console.log(&quot;%5.3p&quot;.$(1.12345)); // &#39; 1.12&#39;\r\n    console.log(&quot;%5x&quot;.$(45054)); // &#39; affe&#39;\r\n    console.log(&quot;%20#2x&quot;.$(&quot;45054&quot;)); // &#39;    1010111111111110&#39;\r\n    console.log(&quot;%6#2d&quot;.$(&quot;111&quot;)); // &#39;     7&#39;\r\n    console.log(&quot;%6#16d&quot;.$(&quot;affe&quot;)); // &#39; 45054&#39;\r\n"},{"score":0,"body_markdown":"You can use this function\r\n\t\t\r\n\r\n                String.prototype.format = function (args) {\r\n    \t\t\tvar str = this;\r\n    \t\t\treturn str.replace(String.prototype.format.regex, function(item) {\r\n    \t\t\t\tvar intVal = parseInt(item.substring(1, item.length - 1));\r\n    \t\t\t\tvar replace;\r\n    \t\t\t\tif (intVal &gt;= 0) {\r\n    \t\t\t\t\treplace = args[intVal];\r\n    \t\t\t\t} else if (intVal === -1) {\r\n    \t\t\t\t\treplace = &quot;{&quot;;\r\n    \t\t\t\t} else if (intVal === -2) {\r\n    \t\t\t\t\treplace = &quot;}&quot;;\r\n    \t\t\t\t} else {\r\n    \t\t\t\t\treplace = &quot;&quot;;\r\n    \t\t\t\t}\r\n    \t\t\t\treturn replace;\r\n    \t\t\t});\r\n    \t\t};\r\n    \t\tString.prototype.format.regex = new RegExp(&quot;{-?[0-9]+}&quot;, &quot;g&quot;);\r\n    \t\t\r\n    \t\t// Sample usage.\r\n    \t\tvar str = &quot;She {1} {0}{2} by the {0}{3}. {-1}^_^{-2}&quot;;\r\n    \t\tstr = str.format([&quot;sea&quot;, &quot;sells&quot;, &quot;shells&quot;, &quot;shore&quot;]);\r\n    \t\talert(str);"},{"score":2,"body_markdown":"For use with jQuery.ajax() success functions.  Pass only a single argument and string replace with the properties of that object as {propertyName}:\r\n\r\n\r\n    String.prototype.format = function () {\r\n        var formatted = this;\r\n        for (var prop in arguments[0]) {\r\n            var regexp = new RegExp(&#39;\\\\{&#39; + prop + &#39;\\\\}&#39;, &#39;gi&#39;);\r\n            formatted = formatted.replace(regexp, arguments[0][prop]);\r\n        }\r\n        return formatted;\r\n    };\r\n\r\nExample:\r\n\r\n\tvar userInfo = (&quot;Email: {Email} - Phone: {Phone}&quot;).format({ Email: &quot;someone@somewhere.com&quot;, Phone: &quot;123-123-1234&quot; });"},{"score":2,"body_markdown":"With sprintf.js in place - one can make a nifty little format-thingy \r\n\r\n    String.prototype.format = function(){\r\n        var _args = arguments \r\n        Array.prototype.unshift.apply(_args,[this])\r\n        return sprintf.apply(undefined,_args)\r\n    }   \r\n    // this gives you:\r\n    &quot;{%1$s}{%2$s}&quot;.format(&quot;1&quot;, &quot;0&quot;)\r\n    // {1}{0}"},{"score":24,"body_markdown":"Adding to `zippoxer`&#39;s answer, I use this function:\r\n\r\n    String.prototype.format = function () {\r\n        var a = this, b;\r\n        for (b in arguments) {\r\n            a = a.replace(/%[a-z]/, arguments[b]);\r\n        }\r\n        return a; // Make chainable\r\n    };\r\n\r\n    var s = &#39;Hello %s The magic number is %d.&#39;;\r\n    s.format(&#39;world!&#39;, 12); // Hello World! The magic number is 12.\r\n\r\nI also have a non-prototype version which I use more often for its Java-like syntax:\r\n\r\n    function format() {\r\n        var a, b, c;\r\n        a = arguments[0];\r\n        b = [];\r\n        for(c = 1; c &lt; arguments.length; c++){\r\n            b.push(arguments[c]);\r\n        }\r\n        for (c in b) {\r\n            a = a.replace(/%[a-z]/, b[c]);\r\n        }\r\n        return a;\r\n    }\r\n    format(&#39;%d ducks, 55 %s&#39;, 12, &#39;cats&#39;); // 12 ducks, 55 cats\r\n\r\n## ES 2015 update\r\n\r\nAll the cool new stuff in ES 2015 makes this a lot easier:\r\n\r\n    function format(fmt, ...args){\r\n        return fmt\r\n            .split(&quot;%%&quot;)\r\n            .reduce((aggregate, chunk, i) =&gt;\r\n                aggregate + chunk + (args[i] || &quot;&quot;), &quot;&quot;);\r\n    }\r\n\r\n    format(&quot;Hello %%! I ate %% apples today.&quot;, &quot;World&quot;, 44);\r\n    // &quot;Hello World, I ate 44 apples today.&quot;\r\n\r\nI figured that since this, like the older ones, doesn&#39;t actually parse the letters, it might as well just use a single token `%%`. This has the benefit of being obvious and not making it difficult to use a single `%`. However, if you need `%%` for some reason, you would need to replace it with itself:\r\n\r\n    format(&quot;I love percentage signs! %%&quot;, &quot;%%&quot;);\r\n    // &quot;I love percentage signs! %%&quot;"},{"score":0,"body_markdown":"[bobjs][1] can do this:\r\n\r\n    var sFormat = &quot;My name is {0} and I am {1} years old.&quot;; \r\n    var result = bob.string.formatString(sFormat, &quot;Bob&quot;, 29); \r\n    console.log(result); \r\n    //output: \r\n    //========== \r\n    // My name is Bob and I am 29 years old. \r\n\r\n\r\n  [1]: http://www.bobjs.com"},{"score":0,"body_markdown":"    String.prototype.repeat = function(n) { \r\n        return new Array(++n).join(this); \r\n    };\r\n\r\n    String.prototype.pad = function(requiredLength, paddingStr, paddingType) {    \r\n        var n = requiredLength - this.length; \r\n\r\n        if (n) {\r\n            paddingType = paddingType ? paddingType.toLowerCase() : &#39;&#39;;\r\n            paddingStr = paddingStr || &#39; &#39;;\r\n            paddingStr = paddingStr.repeat( Math.ceil(n / paddingStr.length) ).substr(0, n);\r\n\r\n            if (paddingType == &#39;both&#39;) {\r\n                n /= 2;\r\n                return paddingStr.substr( 0, Math.ceil(n) ) + this + paddingStr.substr( 0, Math.floor(n) );\r\n            }   \r\n\r\n            if (paddingType == &#39;left&#39;) {\r\n                return paddingStr + this;\r\n            }\r\n\r\n            return this + paddingStr;\r\n        } \r\n\r\n        return this; \r\n    }; \r\n      \r\n    // синтаксис аналогичен printf\r\n    // &#39;Привет, %s!&#39;.format(&#39;мир&#39;) -&gt; &quot;Привет, мир!&quot;\r\n    // &#39;%.1s.%.1s. %s&#39;.format(&#39;Иван&#39;, &#39;Иванович&#39;, &#39;Иванов&#39;) -&gt; &quot;И.И. Иванов&quot;\r\n    String.prototype.format = function() {\r\n        var i = 0, \r\n            params = arguments;\r\n\r\n        return this.replace(/%(?:%|(?:(|[+-]+)(|0|&#39;.+?)([1-9]\\d*)?(?:\\.([1-9]\\d*))?)?(s|d|f))/g, function(match, sign, padding, width, precision, type) {\r\n            if (match == &#39;%%&#39;) { \r\n                return &#39;%&#39;; \r\n            }\r\n\r\n            var v = params[i++];\r\n\r\n            if (type == &#39;d&#39;) { \r\n                v = Math.round(v); \r\n            }\r\n            else if (type == &#39;f&#39;) {\r\n                v = v.toFixed(precision ? precision : 6);\r\n            }\r\n\r\n            if (/\\+/.test(sign) &amp;&amp; v &gt; 0) {\r\n                v = &#39;+&#39; + v;\r\n            }\r\n\r\n            v += &#39;&#39;;\r\n\r\n            if (type != &#39;f&#39; &amp;&amp; precision) {\r\n                v = v.substr(0, precision);\r\n            }\r\n\r\n            if (width) {\r\n                v = v.pad(width, padding == &#39;&#39; ? &#39; &#39; : padding[0] == &quot;&#39;&quot; ? padding.substr(1) : padding, /-/.test(sign) ? &#39;right&#39; : &#39;left&#39;); \r\n            }\r\n\r\n            return v;\r\n        });\r\n    };\r\n\r\n    // this.name = &#39;Вася&#39;;\r\n    // console.log( &#39;Привет, ${name}!&#39;.template(this) );\r\n    // &quot;Привет, Вася!&quot;\r\n    String.prototype.template = function(context) {\r\n        return this.replace(/\\$\\{(.*?)\\}/g, function(match, name) {\r\n            return context[name];\r\n        });\r\n    };"},{"score":-1,"body_markdown":"This is an implementation of https://stackoverflow.com/a/4673436/1258486 for CoffeeScript.\r\n\r\nhttps://gist.github.com/eces/5669361\r\n\r\n    if String.prototype.format is undefined\r\n      String.prototype.format = () -&gt;\r\n        _arguments = arguments\r\n        this.replace /{(\\d+)}/g, (match, number) -&gt;\r\n          if typeof _arguments[number] isnt &#39;undefined&#39; then _arguments[number] else match"},{"score":1,"body_markdown":"I needed a function which could format a price (given in cents) in a way preferred by the user, and the tricky part is that the format is specified by the user -- and I do not expect my users to understand printf-like syntax, or regexps, etc.\r\nMy solution is somewhat similar to that used in Basic, so the user just marks with # places for digits, for example:\r\n\r\n    simple_format(1234567,&quot;$ ###,###,###.##&quot;)\r\n    &quot;$ 12,345.67&quot;\r\n    simple_format(1234567,&quot;### ### ###,## pln&quot;)\r\n    &quot;12 345,67 pln&quot;\r\n\r\nI believe this is quite easy to understand by user, and quite easy to implement:\r\n\r\n    function simple_format(integer,format){\r\n      var text = &quot;&quot;;\r\n      for(var i=format.length;i--;){\r\n        if(format[i]==&#39;#&#39;){\r\n          text = (integer%10) + text;\r\n          integer=Math.floor(integer/10);\r\n          if(integer==0){\r\n            return format.substr(0,i).replace(/#(.*#)?/,&quot;&quot;)+text;\r\n          }\r\n        }else{\r\n          text = format[i] + text;\r\n        }\r\n      }\r\n      return text;\r\n    }\r\n\r\n"},{"score":512,"body_markdown":"It&#39;s funny because Stack&amp;nbsp;Overflow actually has their own formatting function for the `String` prototype called `formatUnicorn`. Try it! Go into the console and type something like:\r\n\r\n    &quot;Hello, {name}, are you feeling {adjective}?&quot;.formatUnicorn({name:&quot;Gabriel&quot;, adjective: &quot;OK&quot;});\r\n\r\n![Firebug][1]\r\n\r\nYou get this output:\r\n\r\n`Hello, Gabriel, are you feeling OK?`\r\n\r\nYou can use objects, arrays, and strings as arguments! I got its code and reworked it to produce a new version of `String.prototype.format`:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    String.prototype.formatUnicorn = String.prototype.formatUnicorn ||\r\n    function () {\r\n        &quot;use strict&quot;;\r\n        var str = this.toString();\r\n        if (arguments.length) {\r\n            var t = typeof arguments[0];\r\n            var key;\r\n            var args = (&quot;string&quot; === t || &quot;number&quot; === t) ?\r\n                Array.prototype.slice.call(arguments)\r\n                : arguments[0];\r\n    \r\n            for (key in args) {\r\n                str = str.replace(new RegExp(&quot;\\\\{&quot; + key + &quot;\\\\}&quot;, &quot;gi&quot;), args[key]);\r\n            }\r\n        }\r\n    \r\n        return str;\r\n    };\r\n\r\nNote the clever `Array.prototype.slice.call(arguments)` call -- that means if you throw in arguments that are strings or numbers, not a single JSON-style object, you get C#&#39;s [`String.Format`](https://msdn.microsoft.com/en-us/library/system.string.format(v=vs.110).aspx#Starting) behavior almost exactly.\r\n\r\n    &quot;a{0}bcd{1}ef&quot;.formatUnicorn(&quot;foo&quot;, &quot;bar&quot;); // yields &quot;aFOObcdBARef&quot;\r\n\r\nThat&#39;s because `Array`&#39;s `slice` will force whatever&#39;s in `arguments` into an `Array`, whether it was originally or not, and the `key` will be the index (0, 1, 2...) of each array element coerced into a string (eg, &quot;0&quot;, so `&quot;\\\\{0\\\\}&quot;` for your first regexp pattern).\r\n\r\nNeat.\r\n\r\n[1]: http://i.stack.imgur.com/jYeIc.png\r\n"},{"score":9,"body_markdown":"I use this one:\r\n\r\n    String.prototype.format = function() {\r\n    \tvar newStr = this, i = 0;\r\n    \twhile (/%s/.test(newStr))\r\n    \t\tnewStr = newStr.replace(&quot;%s&quot;, arguments[i++])\r\n    \t\t\r\n    \treturn newStr;\r\n    }\r\n\r\nThen I call it:\r\n\r\n    &quot;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;&quot;.format(&quot;Header&quot;, &quot;Just a test!&quot;);"},{"score":75,"body_markdown":"For [Node.js][1] users there is [`util.format`][2] which has printf-like functionality:\r\n\r\n    util.format(&quot;%s world&quot;, &quot;Hello&quot;)\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Node.js\r\n  [2]: https://nodejs.org/api/util.html#util_util_format_format_args\r\n"},{"score":9,"body_markdown":"I have a solution very close to Peter&#39;s, but it deals with number and object case.\r\n\r\n    if (!String.prototype.format) {\r\n      String.prototype.format = function() {\r\n        var args;\r\n        args = arguments;\r\n        if (args.length === 1 &amp;&amp; args[0] !== null &amp;&amp; typeof args[0] === &#39;object&#39;) {\r\n          args = args[0];\r\n        }\r\n        return this.replace(/{([^}]*)}/g, function(match, key) {\r\n          return (typeof args[key] !== &quot;undefined&quot; ? args[key] : match);\r\n        });\r\n      };\r\n    }\r\n\r\nMaybe it could be even better to deal with the all deeps cases, but for my needs this is just fine.\r\n\r\n    &quot;This is an example from {name}&quot;.format({name:&quot;Blaine&quot;});\r\n    &quot;This is an example from {0}&quot;.format(&quot;Blaine&quot;);\r\n\r\nPS: This function is very cool if you are using translations in templates frameworks like [AngularJS][1]:\r\n\r\n    &lt;h1&gt; {{(&#39;hello-message&#39;|translate).format(user)}} &lt;h1&gt;\r\n    &lt;h1&gt; {{(&#39;hello-by-name&#39;|translate).format( user ? user.name : &#39;You&#39; )}} &lt;h1&gt;\r\n\r\nWhere the en.json is something like\r\n\r\n    {\r\n        &quot;hello-message&quot;: &quot;Hello {name}, welcome.&quot;,\r\n        &quot;hello-by-name&quot;: &quot;Hello {0}, welcome.&quot;\r\n    }\r\n\r\n  [1]: http://en.wikipedia.org/wiki/AngularJS\r\n"},{"score":2,"body_markdown":"I didn&#39;t see [pyformat][1] in the list so I thought I&#39;d throw it in:\r\n\r\n    console.log(pyformat( &#39;The {} {} jumped over the {}&#39;\r\n                    , [&#39;brown&#39; ,&#39;fox&#39; ,&#39;foobar&#39;]\r\n                    ))\r\n    console.log(pyformat(&#39;The {0} {1} jumped over the {1}&#39;\r\n                    , [&#39;brown&#39; ,&#39;fox&#39; ,&#39;foobar&#39;]\r\n                    ))\r\n    console.log(pyformat(&#39;The {color} {animal} jumped over the {thing}&#39;\r\n                    , [] ,{color: &#39;brown&#39; ,animal: &#39;fox&#39; ,thing: &#39;foobaz&#39;}\r\n                    ))\r\n\r\n\r\n  [1]: https://www.npmjs.org/package/pyformat"},{"score":0,"body_markdown":"I started porting the `Java` `String.format` (actually new Formatter().format()) to javascript. The initial version is available at: \r\n\r\nhttps://github.com/RobAu/javascript.string.format\r\n\r\nYou can simple add the javscript and call `StringFormat.format(&quot;%.2f&quot;, [2.4]);` etc.\r\n\r\nPlease note it is NOT finished yet, but feedback is welcome :) "},{"score":5,"body_markdown":"Just in case someone needs a function to prevent polluting global scope, here is the function that does the same:\r\n\r\n      function _format (str, arr) {\r\n        return str.replace(/{(\\d+)}/g, function (match, number) {\r\n          return typeof arr[number] != &#39;undefined&#39; ? arr[number] : match;\r\n        });\r\n      };\r\n\r\n"},{"score":5,"body_markdown":"For those who like [Node.JS][1] and its [`util.format`][2] feature, I&#39;ve just extracted it out into its vanilla JavaScript form (with only functions that util.format uses):\r\n\r\n    exports = {};\r\n    \r\n    function isString(arg) {\r\n        return typeof arg === &#39;string&#39;;\r\n    }\r\n    function isNull(arg) {\r\n        return arg === null;\r\n    }\r\n    function isObject(arg) {\r\n        return typeof arg === &#39;object&#39; &amp;&amp; arg !== null;\r\n    }\r\n    function isBoolean(arg) {\r\n        return typeof arg === &#39;boolean&#39;;\r\n    }\r\n    function isUndefined(arg) {\r\n        return arg === void 0;\r\n    }\r\n    function stylizeNoColor(str, styleType) {\r\n        return str;\r\n    }\r\n    function stylizeWithColor(str, styleType) {\r\n        var style = inspect.styles[styleType];\r\n    \r\n        if (style) {\r\n            return &#39;\\u001b[&#39; + inspect.colors[style][0] + &#39;m&#39; + str +\r\n                &#39;\\u001b[&#39; + inspect.colors[style][3] + &#39;m&#39;;\r\n        } else {\r\n            return str;\r\n        }\r\n    }\r\n    function isFunction(arg) {\r\n        return typeof arg === &#39;function&#39;;\r\n    }\r\n    function isNumber(arg) {\r\n        return typeof arg === &#39;number&#39;;\r\n    }\r\n    function isSymbol(arg) {\r\n        return typeof arg === &#39;symbol&#39;;\r\n    }\r\n    function formatPrimitive(ctx, value) {\r\n        if (isUndefined(value))\r\n            return ctx.stylize(&#39;undefined&#39;, &#39;undefined&#39;);\r\n        if (isString(value)) {\r\n            var simple = &#39;\\&#39;&#39; + JSON.stringify(value).replace(/^&quot;|&quot;$/g, &#39;&#39;)\r\n                    .replace(/&#39;/g, &quot;\\\\&#39;&quot;)\r\n                    .replace(/\\\\&quot;/g, &#39;&quot;&#39;) + &#39;\\&#39;&#39;;\r\n            return ctx.stylize(simple, &#39;string&#39;);\r\n        }\r\n        if (isNumber(value)) {\r\n            // Format -0 as &#39;-0&#39;. Strict equality won&#39;t distinguish 0 from -0,\r\n            // so instead we use the fact that 1 / -0 &lt; 0 whereas 1 / 0 &gt; 0 .\r\n            if (value === 0 &amp;&amp; 1 / value &lt; 0)\r\n                return ctx.stylize(&#39;-0&#39;, &#39;number&#39;);\r\n            return ctx.stylize(&#39;&#39; + value, &#39;number&#39;);\r\n        }\r\n        if (isBoolean(value))\r\n            return ctx.stylize(&#39;&#39; + value, &#39;boolean&#39;);\r\n        // For some reason typeof null is &quot;object&quot;, so special case here.\r\n        if (isNull(value))\r\n            return ctx.stylize(&#39;null&#39;, &#39;null&#39;);\r\n        // es6 symbol primitive\r\n        if (isSymbol(value))\r\n            return ctx.stylize(value.toString(), &#39;symbol&#39;);\r\n    }\r\n    function arrayToHash(array) {\r\n        var hash = {};\r\n    \r\n        array.forEach(function (val, idx) {\r\n            hash[val] = true;\r\n        });\r\n    \r\n        return hash;\r\n    }\r\n    function objectToString(o) {\r\n        return Object.prototype.toString.call(o);\r\n    }\r\n    function isDate(d) {\r\n        return isObject(d) &amp;&amp; objectToString(d) === &#39;[object Date]&#39;;\r\n    }\r\n    function isError(e) {\r\n        return isObject(e) &amp;&amp;\r\n            (objectToString(e) === &#39;[object Error]&#39; || e instanceof Error);\r\n    }\r\n    function isRegExp(re) {\r\n        return isObject(re) &amp;&amp; objectToString(re) === &#39;[object RegExp]&#39;;\r\n    }\r\n    function formatError(value) {\r\n        return &#39;[&#39; + Error.prototype.toString.call(value) + &#39;]&#39;;\r\n    }\r\n    function formatPrimitiveNoColor(ctx, value) {\r\n        var stylize = ctx.stylize;\r\n        ctx.stylize = stylizeNoColor;\r\n        var str = formatPrimitive(ctx, value);\r\n        ctx.stylize = stylize;\r\n        return str;\r\n    }\r\n    function isArray(ar) {\r\n        return Array.isArray(ar);\r\n    }\r\n    function hasOwnProperty(obj, prop) {\r\n        return Object.prototype.hasOwnProperty.call(obj, prop);\r\n    }\r\n    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\r\n        var name, str, desc;\r\n        desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};\r\n        if (desc.get) {\r\n            if (desc.set) {\r\n                str = ctx.stylize(&#39;[Getter/Setter]&#39;, &#39;special&#39;);\r\n            } else {\r\n                str = ctx.stylize(&#39;[Getter]&#39;, &#39;special&#39;);\r\n            }\r\n        } else {\r\n            if (desc.set) {\r\n                str = ctx.stylize(&#39;[Setter]&#39;, &#39;special&#39;);\r\n            }\r\n        }\r\n        if (!hasOwnProperty(visibleKeys, key)) {\r\n            name = &#39;[&#39; + key + &#39;]&#39;;\r\n        }\r\n        if (!str) {\r\n            if (ctx.seen.indexOf(desc.value) &lt; 0) {\r\n                if (isNull(recurseTimes)) {\r\n                    str = formatValue(ctx, desc.value, null);\r\n                } else {\r\n                    str = formatValue(ctx, desc.value, recurseTimes - 1);\r\n                }\r\n                if (str.indexOf(&#39;\\n&#39;) &gt; -1) {\r\n                    if (array) {\r\n                        str = str.split(&#39;\\n&#39;).map(function (line) {\r\n                            return &#39;  &#39; + line;\r\n                        }).join(&#39;\\n&#39;).substr(2);\r\n                    } else {\r\n                        str = &#39;\\n&#39; + str.split(&#39;\\n&#39;).map(function (line) {\r\n                            return &#39;   &#39; + line;\r\n                        }).join(&#39;\\n&#39;);\r\n                    }\r\n                }\r\n            } else {\r\n                str = ctx.stylize(&#39;[Circular]&#39;, &#39;special&#39;);\r\n            }\r\n        }\r\n        if (isUndefined(name)) {\r\n            if (array &amp;&amp; key.match(/^\\d+$/)) {\r\n                return str;\r\n            }\r\n            name = JSON.stringify(&#39;&#39; + key);\r\n            if (name.match(/^&quot;([a-zA-Z_][a-zA-Z_0-9]*)&quot;$/)) {\r\n                name = name.substr(1, name.length - 2);\r\n                name = ctx.stylize(name, &#39;name&#39;);\r\n            } else {\r\n                name = name.replace(/&#39;/g, &quot;\\\\&#39;&quot;)\r\n                    .replace(/\\\\&quot;/g, &#39;&quot;&#39;)\r\n                    .replace(/(^&quot;|&quot;$)/g, &quot;&#39;&quot;)\r\n                    .replace(/\\\\\\\\/g, &#39;\\\\&#39;);\r\n                name = ctx.stylize(name, &#39;string&#39;);\r\n            }\r\n        }\r\n    \r\n        return name + &#39;: &#39; + str;\r\n    }\r\n    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\r\n        var output = [];\r\n        for (var i = 0, l = value.length; i &lt; l; ++i) {\r\n            if (hasOwnProperty(value, String(i))) {\r\n                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n                    String(i), true));\r\n            } else {\r\n                output.push(&#39;&#39;);\r\n            }\r\n        }\r\n        keys.forEach(function (key) {\r\n            if (!key.match(/^\\d+$/)) {\r\n                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n                    key, true));\r\n            }\r\n        });\r\n        return output;\r\n    }\r\n    function reduceToSingleString(output, base, braces) {\r\n        var length = output.reduce(function (prev, cur) {\r\n            return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, &#39;&#39;).length + 1;\r\n        }, 0);\r\n    \r\n        if (length &gt; 60) {\r\n            return braces[0] +\r\n                (base === &#39;&#39; ? &#39;&#39; : base + &#39;\\n &#39;) +\r\n                &#39; &#39; +\r\n                output.join(&#39;,\\n  &#39;) +\r\n                &#39; &#39; +\r\n                braces[1];\r\n        }\r\n    \r\n        return braces[0] + base + &#39; &#39; + output.join(&#39;, &#39;) + &#39; &#39; + braces[1];\r\n    }\r\n    function formatValue(ctx, value, recurseTimes) {\r\n        // Provide a hook for user-specified inspect functions.\r\n        // Check that value is an object with an inspect function on it\r\n        if (ctx.customInspect &amp;&amp;\r\n            value &amp;&amp;\r\n            isFunction(value.inspect) &amp;&amp;\r\n                // Filter out the util module, it&#39;s inspect function is special\r\n            value.inspect !== exports.inspect &amp;&amp;\r\n                // Also filter out any prototype objects using the circular check.\r\n            !(value.constructor &amp;&amp; value.constructor.prototype === value)) {\r\n            var ret = value.inspect(recurseTimes, ctx);\r\n            if (!isString(ret)) {\r\n                ret = formatValue(ctx, ret, recurseTimes);\r\n            }\r\n            return ret;\r\n        }\r\n    \r\n        // Primitive types cannot have properties\r\n        var primitive = formatPrimitive(ctx, value);\r\n        if (primitive) {\r\n            return primitive;\r\n        }\r\n    \r\n        // Look up the keys of the object.\r\n        var keys = Object.keys(value);\r\n        var visibleKeys = arrayToHash(keys);\r\n    \r\n        if (ctx.showHidden) {\r\n            keys = Object.getOwnPropertyNames(value);\r\n        }\r\n    \r\n        // This could be a boxed primitive (new String(), etc.), check valueOf()\r\n        // NOTE: Avoid calling `valueOf` on `Date` instance because it will return\r\n        // a number which, when object has some additional user-stored `keys`,\r\n        // will be printed out.\r\n        var formatted;\r\n        var raw = value;\r\n        try {\r\n            // the .valueOf() call can fail for a multitude of reasons\r\n            if (!isDate(value))\r\n                raw = value.valueOf();\r\n        } catch (e) {\r\n            // ignore...\r\n        }\r\n    \r\n        if (isString(raw)) {\r\n            // for boxed Strings, we have to remove the 0-n indexed entries,\r\n            // since they just noisey up the output and are redundant\r\n            keys = keys.filter(function (key) {\r\n                return !(key &gt;= 0 &amp;&amp; key &lt; raw.length);\r\n            });\r\n        }\r\n    \r\n        // Some type of object without properties can be shortcutted.\r\n        if (keys.length === 0) {\r\n            if (isFunction(value)) {\r\n                var name = value.name ? &#39;: &#39; + value.name : &#39;&#39;;\r\n                return ctx.stylize(&#39;[Function&#39; + name + &#39;]&#39;, &#39;special&#39;);\r\n            }\r\n            if (isRegExp(value)) {\r\n                return ctx.stylize(RegExp.prototype.toString.call(value), &#39;regexp&#39;);\r\n            }\r\n            if (isDate(value)) {\r\n                return ctx.stylize(Date.prototype.toString.call(value), &#39;date&#39;);\r\n            }\r\n            if (isError(value)) {\r\n                return formatError(value);\r\n            }\r\n            // now check the `raw` value to handle boxed primitives\r\n            if (isString(raw)) {\r\n                formatted = formatPrimitiveNoColor(ctx, raw);\r\n                return ctx.stylize(&#39;[String: &#39; + formatted + &#39;]&#39;, &#39;string&#39;);\r\n            }\r\n            if (isNumber(raw)) {\r\n                formatted = formatPrimitiveNoColor(ctx, raw);\r\n                return ctx.stylize(&#39;[Number: &#39; + formatted + &#39;]&#39;, &#39;number&#39;);\r\n            }\r\n            if (isBoolean(raw)) {\r\n                formatted = formatPrimitiveNoColor(ctx, raw);\r\n                return ctx.stylize(&#39;[Boolean: &#39; + formatted + &#39;]&#39;, &#39;boolean&#39;);\r\n            }\r\n        }\r\n    \r\n        var base = &#39;&#39;, array = false, braces = [&#39;{&#39;, &#39;}&#39;];\r\n    \r\n        // Make Array say that they are Array\r\n        if (isArray(value)) {\r\n            array = true;\r\n            braces = [&#39;[&#39;, &#39;]&#39;];\r\n        }\r\n    \r\n        // Make functions say that they are functions\r\n        if (isFunction(value)) {\r\n            var n = value.name ? &#39;: &#39; + value.name : &#39;&#39;;\r\n            base = &#39; [Function&#39; + n + &#39;]&#39;;\r\n        }\r\n    \r\n        // Make RegExps say that they are RegExps\r\n        if (isRegExp(value)) {\r\n            base = &#39; &#39; + RegExp.prototype.toString.call(value);\r\n        }\r\n    \r\n        // Make dates with properties first say the date\r\n        if (isDate(value)) {\r\n            base = &#39; &#39; + Date.prototype.toUTCString.call(value);\r\n        }\r\n    \r\n        // Make error with message first say the error\r\n        if (isError(value)) {\r\n            base = &#39; &#39; + formatError(value);\r\n        }\r\n    \r\n        // Make boxed primitive Strings look like such\r\n        if (isString(raw)) {\r\n            formatted = formatPrimitiveNoColor(ctx, raw);\r\n            base = &#39; &#39; + &#39;[String: &#39; + formatted + &#39;]&#39;;\r\n        }\r\n    \r\n        // Make boxed primitive Numbers look like such\r\n        if (isNumber(raw)) {\r\n            formatted = formatPrimitiveNoColor(ctx, raw);\r\n            base = &#39; &#39; + &#39;[Number: &#39; + formatted + &#39;]&#39;;\r\n        }\r\n    \r\n        // Make boxed primitive Booleans look like such\r\n        if (isBoolean(raw)) {\r\n            formatted = formatPrimitiveNoColor(ctx, raw);\r\n            base = &#39; &#39; + &#39;[Boolean: &#39; + formatted + &#39;]&#39;;\r\n        }\r\n    \r\n        if (keys.length === 0 &amp;&amp; (!array || value.length === 0)) {\r\n            return braces[0] + base + braces[1];\r\n        }\r\n    \r\n        if (recurseTimes &lt; 0) {\r\n            if (isRegExp(value)) {\r\n                return ctx.stylize(RegExp.prototype.toString.call(value), &#39;regexp&#39;);\r\n            } else {\r\n                return ctx.stylize(&#39;[Object]&#39;, &#39;special&#39;);\r\n            }\r\n        }\r\n    \r\n        ctx.seen.push(value);\r\n    \r\n        var output;\r\n        if (array) {\r\n            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\r\n        } else {\r\n            output = keys.map(function (key) {\r\n                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\r\n            });\r\n        }\r\n    \r\n        ctx.seen.pop();\r\n    \r\n        return reduceToSingleString(output, base, braces);\r\n    }\r\n    function inspect(obj, opts) {\r\n        // default options\r\n        var ctx = {\r\n            seen: [],\r\n            stylize: stylizeNoColor\r\n        };\r\n        // legacy...\r\n        if (arguments.length &gt;= 3) ctx.depth = arguments[2];\r\n        if (arguments.length &gt;= 4) ctx.colors = arguments[3];\r\n        if (isBoolean(opts)) {\r\n            // legacy...\r\n            ctx.showHidden = opts;\r\n        } else if (opts) {\r\n            // got an &quot;options&quot; object\r\n            exports._extend(ctx, opts);\r\n        }\r\n        // set default options\r\n        if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\r\n        if (isUndefined(ctx.depth)) ctx.depth = 2;\r\n        if (isUndefined(ctx.colors)) ctx.colors = false;\r\n        if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\r\n        if (ctx.colors) ctx.stylize = stylizeWithColor;\r\n        return formatValue(ctx, obj, ctx.depth);\r\n    }\r\n    exports.inspect = inspect;\r\n    \r\n    \r\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\r\n    inspect.colors = {\r\n        &#39;bold&#39;: [1, 22],\r\n        &#39;italic&#39;: [3, 23],\r\n        &#39;underline&#39;: [4, 24],\r\n        &#39;inverse&#39;: [7, 27],\r\n        &#39;white&#39;: [37, 39],\r\n        &#39;grey&#39;: [90, 39],\r\n        &#39;black&#39;: [30, 39],\r\n        &#39;blue&#39;: [34, 39],\r\n        &#39;cyan&#39;: [36, 39],\r\n        &#39;green&#39;: [32, 39],\r\n        &#39;magenta&#39;: [35, 39],\r\n        &#39;red&#39;: [31, 39],\r\n        &#39;yellow&#39;: [33, 39]\r\n    };\r\n    \r\n    // Don&#39;t use &#39;blue&#39; not visible on cmd.exe\r\n    inspect.styles = {\r\n        &#39;special&#39;: &#39;cyan&#39;,\r\n        &#39;number&#39;: &#39;yellow&#39;,\r\n        &#39;boolean&#39;: &#39;yellow&#39;,\r\n        &#39;undefined&#39;: &#39;grey&#39;,\r\n        &#39;null&#39;: &#39;bold&#39;,\r\n        &#39;string&#39;: &#39;green&#39;,\r\n        &#39;symbol&#39;: &#39;green&#39;,\r\n        &#39;date&#39;: &#39;magenta&#39;,\r\n        // &quot;name&quot;: intentionally not styling\r\n        &#39;regexp&#39;: &#39;red&#39;\r\n    };\r\n    \r\n    \r\n    var formatRegExp = /%[sdj%]/g;\r\n    exports.format = function (f) {\r\n        if (!isString(f)) {\r\n            var objects = [];\r\n            for (var j = 0; j &lt; arguments.length; j++) {\r\n                objects.push(inspect(arguments[j]));\r\n            }\r\n            return objects.join(&#39; &#39;);\r\n        }\r\n    \r\n        var i = 1;\r\n        var args = arguments;\r\n        var len = args.length;\r\n        var str = String(f).replace(formatRegExp, function (x) {\r\n            if (x === &#39;%%&#39;) return &#39;%&#39;;\r\n            if (i &gt;= len) return x;\r\n            switch (x) {\r\n                case &#39;%s&#39;:\r\n                    return String(args[i++]);\r\n                case &#39;%d&#39;:\r\n                    return Number(args[i++]);\r\n                case &#39;%j&#39;:\r\n                    try {\r\n                        return JSON.stringify(args[i++]);\r\n                    } catch (_) {\r\n                        return &#39;[Circular]&#39;;\r\n                    }\r\n                default:\r\n                    return x;\r\n            }\r\n        });\r\n        for (var x = args[i]; i &lt; len; x = args[++i]) {\r\n            if (isNull(x) || !isObject(x)) {\r\n                str += &#39; &#39; + x;\r\n            } else {\r\n                str += &#39; &#39; + inspect(x);\r\n            }\r\n        }\r\n        return str;\r\n    };\r\n\r\nHarvested from: https://github.com/joyent/node/blob/master/lib/util.js\r\n\r\n  [1]: http://nodejs.org\r\n  [2]: http://nodejs.org/api/util.html#util_util_format_format\r\n  [3]: http://nodejs.org/api/util.html#util_util_format_format"},{"score":54,"body_markdown":"I&#39;m surprised no one used [`reduce`][1], this is a native concise and powerful JavaScript function.\r\n\r\nES6 (EcmaScript2015)\r\n---\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    String.prototype.format = function() {\r\n      return [...arguments].reduce((p,c) =&gt; p.replace(/%s/,c), this);\r\n    };\r\n\r\n    console.log(&#39;Is that a %s or a %s?... No, it\\&#39;s %s!&#39;.format(&#39;plane&#39;, &#39;bird&#39;, &#39;SOman&#39;));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n&lt; ES6\r\n---\r\n\r\n    function interpolate(theString, argumentArray) {\r\n        var regex = /%s/;\r\n        var _r=function(p,c){return p.replace(regex,c);}\r\n        return argumentArray.reduce(_r, theString);\r\n    }\r\n\r\n    interpolate(&quot;%s, %s and %s&quot;, [&quot;Me&quot;, &quot;myself&quot;, &quot;I&quot;]); // &quot;Me, myself and I&quot;\r\n\r\nHow it works:\r\n\r\n&gt; _reduce_ applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var _r= function(p,c){return p.replace(/%s/,c)};\r\n\r\n    console.log(\r\n      [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].reduce(_r, &quot;[%s], [%s] and [%s]&quot;) + &#39;\\n&#39;,\r\n      [1, 2, 3].reduce(_r, &quot;%s+%s=%s&quot;) + &#39;\\n&#39;,\r\n      [&quot;cool&quot;, 1337, &quot;stuff&quot;].reduce(_r, &quot;%s %s %s&quot;)\r\n    );\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"},{"score":254,"body_markdown":"From ES6 on you could use **template strings**:\r\n\r\n    let soMany = 10;\r\n    console.log(`This is ${soMany} times easier!`);\r\n    // &quot;This is 10 times easier!\r\n\r\nBe aware that template strings are **surrounded by backticks** ` instead of (single) quotes.\r\n\r\n\r\nFor further information:\r\n\r\nhttps://developers.google.com/web/updates/2015/01/ES6-Template-Strings\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings\r\n\r\n*Note:\r\nCheck the mozilla-site to find a list of supported browsers.*"},{"score":6,"body_markdown":"For basic formatting: \r\n\r\n    var template = jQuery.validator.format(&quot;{0} is not a valid value&quot;);\r\n    var result = template(&quot;abc&quot;);"},{"score":2,"body_markdown":"    /**\r\n     * Format string by replacing placeholders with value from element with\r\n     * corresponsing index in `replacementArray`.\r\n     * Replaces are made simultaneously, so that replacement values like\r\n     * &#39;{1}&#39; will not mess up the function.\r\n     *\r\n     * Example 1:\r\n     * (&#39;{2} {1} {0}&#39;, [&#39;three&#39;, &#39;two&#39; ,&#39;one&#39;]) -&gt; &#39;one two three&#39;\r\n     *\r\n     * Example 2:\r\n     * (&#39;{0}{1}&#39;, [&#39;{1}&#39;, &#39;{0}&#39;]) -&gt; &#39;{1}{0}&#39;\r\n     */\r\n    function stringFormat(formatString, replacementArray) {\r\n        return formatString.replace(\r\n            /\\{(\\d+)\\}/g, // Matches placeholders, e.g. &#39;{1}&#39;\r\n            function formatStringReplacer(match, placeholderIndex) {\r\n                // Convert String to Number\r\n                placeholderIndex = Number(placeholderIndex);\r\n\r\n                // Make sure that index is within replacement array bounds\r\n                if (placeholderIndex &lt; 0 ||\r\n                    placeholderIndex &gt; replacementArray.length - 1\r\n                ) {\r\n                    return placeholderIndex;\r\n                }\r\n\r\n                // Replace placeholder with value from replacement array\r\n                return replacementArray[placeholderIndex];\r\n            }\r\n        );\r\n    }"},{"score":0,"body_markdown":"This is not an exact duplicate of `sprintf`; however, it is similar and more powerful: https://github.com/anywhichway/stringformatter\r\n\r\nFormat expressions using this library take the form of embedded Javascript objects, e.g.\r\n\r\n    format(&quot;I have {number: {currency: &quot;$&quot;, precision:2}}.&quot;,50.2); \r\n\r\nwill return `&quot;I have $50.20.&quot;`."},{"score":2,"body_markdown":"Using [Lodash][1] you can get template functionality:\r\n\r\nUse the ES template literal delimiter as an &quot;interpolate&quot; delimiter.\r\nDisable support by replacing the &quot;interpolate&quot; delimiter.\r\n\r\n    var compiled = _.template(&#39;hello ${ user }!&#39;);\r\n    compiled({ &#39;user&#39;: &#39;pebbles&#39; });\r\n    // =&gt; &#39;hello pebbles!\r\n\r\n\r\n  [1]: https://lodash.com/"},{"score":1,"body_markdown":"\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    String.prototype.format = function(){\r\n        var final = String(this);\r\n        for(let i=0; i&lt;arguments.length;i++){\r\n            final = final.replace(`%s${i+1}`, arguments[i])\r\n        }\r\n        return final || &#39;&#39;\r\n    }\r\n\r\n    console.log((&quot;hello %s2 how %s3 you %s1&quot;).format(&#39;hi&#39;, &#39;hello&#39;, &#39;how&#39;));\r\n\r\n\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;h1 id=&quot;text&quot;&gt;\r\n       \r\n    &lt;/h1&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":3,"body_markdown":"We can use a simple lightweight [String.Format][1] string operation library for Typescript.\r\n\r\n**String.Format():**\r\n\r\n    var id = image.GetId()\r\n    String.Format(&quot;image_{0}.jpg&quot;, id)\r\n    output: &quot;image_2db5da20-1c5d-4f1a-8fd4-b41e34c8c5b5.jpg&quot;;\r\n    \r\n\r\n**String Format for specifiers:**\r\n\r\n\r\n    var value = String.Format(&quot;{0:L}&quot;, &quot;APPLE&quot;); //output &quot;apple&quot;\r\n    \r\n    value = String.Format(&quot;{0:U}&quot;, &quot;apple&quot;); // output &quot;APPLE&quot;\r\n    \r\n    value = String.Format(&quot;{0:d}&quot;, &quot;2017-01-23 00:00&quot;); //output &quot;23.01.2017&quot;\r\n    \r\n    \r\n    value = String.Format(&quot;{0:s}&quot;, &quot;21.03.2017 22:15:01&quot;) //output &quot;2017-03-21T22:15:01&quot;\r\n    \r\n    value = String.Format(&quot;{0:n}&quot;, 1000000);\r\n    //output &quot;1.000.000&quot;\r\n    \r\n    value = String.Format(&quot;{0:00}&quot;, 1);\r\n    //output &quot;01&quot;\r\n\r\n\r\n**String Format for Objects including specifiers:**\r\n\r\n\r\n    var fruit = new Fruit();\r\n    fruit.type = &quot;apple&quot;;\r\n    fruit.color = &quot;RED&quot;;\r\n    fruit.shippingDate = new Date(2018, 1, 1);\r\n    fruit.amount = 10000;\r\n    \r\n    String.Format(&quot;the {type:U} is {color:L} shipped on {shippingDate:s} with an amount of {amount:n}&quot;, fruit);\r\n    // output: the APPLE is red shipped on 2018-01-01 with an amount of 10.000\r\n\r\n\r\n  [1]: https://github.com/sevensc/typescript-string-operations#stringformat\r\n\r\n"},{"score":0,"body_markdown":"    export function stringFormate (str: string, ...args: string[]) {\r\n         return args.reduce((acc, curr, i) =&gt; acc.replace(new RegExp(&quot;\\\\{&quot; + i + &quot;\\\\}&quot;, &#39;g&#39;), curr), str);\r\n    }"},{"score":1,"body_markdown":"In typescript create a file named `format.ts` and import it whatever you need to use formatting.\r\n\r\n```ts\r\n// contents of format.ts\r\n\r\ninterface String {\r\n  format(...args: any[]): string;\r\n}\r\n\r\nif (!String.prototype.format) {\r\n  String.prototype.format = function() {\r\n    let a = this;\r\n    let b: any;\r\n    // tslint:disable-next-line: forin\r\n    for (b in arguments) {\r\n      a = a.replace(/%[a-z]/, arguments[b]);\r\n    }\r\n    return a;\r\n  };\r\n}\r\n```\r\n\r\nTo format string use this code:\r\n\r\n```ts\r\nimport &#39;./format&#39;;\r\n\r\nconsole.log(&#39;Hello, %s!&#39;.format(&#39;World&#39;));\r\n```\r\n\r\n## Example\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    String.prototype.format = function() {\r\n      let a = this;\r\n      let b;\r\n      for (b in arguments) {\r\n        a = a.replace(/%[a-z]/, arguments[b]);\r\n      }\r\n      return a;\r\n    };\r\n\r\n    console.log(&#39;Hello, %s!&#39;.format(&#39;World&#39;));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":1,"body_markdown":"**another suggestion is you use the string template:**\r\n\r\n    const getPathDadosCidades = (id: string) =&gt;  `/clientes/${id}`\r\n\r\n    const getPathDadosCidades = (id: string, role: string) =&gt;  `/clientes/${id}/roles/${role}`"},{"score":0,"body_markdown":"Not the most recommended function in the world, but it works.\r\n\r\nIf you need sprintf, just copy &amp; paste this same function and change `return console.log(sb)` to just `return sb`.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    printf = function(s, /*args...*/) {\r\n    \ta = arguments;\r\n    \tal = a.length;\r\n    \t\r\n    \tif (al &lt;= 1) return -2;\r\n    \tif (al &gt;= 2 &amp;&amp; s.toLowerCase().search(/%[a-z]/) == -1) return -1;\r\n\r\n    \tsb = s;\r\n    \tfor (i = 1; i &lt;= al - 1; i++) {\r\n    \t\tsb = sb.replace(/%[a-z]/, a[i]);\r\n    \t}\r\n\r\n    \treturn console.log(sb);\r\n    }\r\n\r\n    var someString = &quot;Hello %s\\nIt&#39;s %s:%s %s now.\\nThe day is %s\\n&quot;;\r\n    printf(someString, &quot;StackOverflowUser&quot;, &quot;5&quot;, &quot;48&quot;, &quot;PM&quot;, &quot;beautiful&quot;);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"if you just need to format a string with **%s specifier** only\r\n\r\n    function _sprintf(message){\r\n        const regexp = RegExp(&#39;%s&#39;,&#39;g&#39;);\r\n        let match;\r\n        let index = 1;\r\n        while((match = regexp.exec(message)) !== null) {\r\n            let replacement = arguments[index];\r\n            if (replacement) {\r\n                let messageToArray = message.split(&#39;&#39;);\r\n                messageToArray.splice(match.index, regexp.lastIndex - match.index, replacement);\r\n                message = messageToArray.join(&#39;&#39;);\r\n                index++;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    \r\n        return message;\r\n    }\r\n\r\n    _sprintf(&quot;my name is %s, my age is %s&quot;, &quot;bob&quot;, 50); // my name is bob, my age is 50\r\n\r\n"},{"score":0,"body_markdown":"**sprintf()** function analog in JavaScript as **Vue filter** and **String.prototype.format()** extension:\r\n\r\n```JS\r\n/**\r\n * Returns a formatted string.\r\n *\r\n * @param template\r\n * @param values\r\n * @return string\r\n */\r\nString.format = function (template, ...values) {\r\n    let i = -1;\r\n\r\n    function callback(exp, p0, p1, p2, p3, p4) {\r\n        if (exp === &#39;%%&#39;) return &#39;%&#39;;\r\n        if (values[++i] === undefined) return undefined;\r\n\r\n        exp = p2 ? parseInt(p2.substr(1)) : undefined;\r\n\r\n        let base = p3 ? parseInt(p3.substr(1)) : undefined;\r\n        let val;\r\n\r\n        switch (p4) {\r\n            case &#39;s&#39;: val = values[i]; break;\r\n            case &#39;c&#39;: val = values[i][0]; break;\r\n            case &#39;f&#39;: val = parseFloat(values[i]).toFixed(exp); break;\r\n            case &#39;p&#39;: val = parseFloat(values[i]).toPrecision(exp); break;\r\n            case &#39;e&#39;: val = parseFloat(values[i]).toExponential(exp); break;\r\n            case &#39;x&#39;: val = parseInt(values[i]).toString(base ? base : 16); break;\r\n            case &#39;d&#39;: val = parseFloat(parseInt(values[i], base ? base : 10).toPrecision(exp)).toFixed(0); break;\r\n        }\r\n        val = typeof (val) == &#39;object&#39; ? JSON.stringify(val) : val.toString(base);\r\n        let sz = parseInt(p1); /* padding size */\r\n        let ch = p1 &amp;&amp; p1[0] === &#39;0&#39; ? &#39;0&#39; : &#39; &#39;; /* isnull? */\r\n\r\n        while (val.length &lt; sz) val = p0 !== undefined ? val + ch : ch + val; /* isminus? */\r\n\r\n        return val;\r\n    }\r\n\r\n    let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\r\n\r\n    return template.replace(regex, callback);\r\n}\r\n\r\nString.prototype.format = function() {\r\n    return String.format(this, ...arguments);\r\n}\r\n\r\nconst StringFormat = {\r\n    install: (Vue, options) =&gt; {\r\n        Vue.filter(&#39;format&#39;, function () {\r\n            return String.format(...arguments);\r\n        });\r\n    },\r\n};\r\n\r\nexport default StringFormat;\r\n```\r\n\r\nOriginal answer: https://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format/13439711#13439711"}],"score":2047}