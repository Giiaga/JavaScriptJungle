{"body":"Is there a regular expression to validate an email address in JavaScript?\r\n","title":"How to validate an email address in JavaScript","answers":[{"score":69,"body_markdown":"JavaScript can match a regular expression:\r\n\r\n    emailAddress.match( / some_regex /);\r\n\r\nHere&#39;s an [RFC22][1] regular expression for emails:\r\n\r\n    ^((?&gt;[a-zA-Z\\d!#$%&amp;&#39;*+\\-/=?^_`{|}~]+\\x20*|&quot;((?=[\\x01-\\x7f])[^&quot;\\\\]|\\\\[\\x01-\\x7f])*\r\n    &quot;\\x20*)*(?&lt;angle&gt;&lt;))?((?!\\.)(?&gt;\\.?[a-zA-Z\\d!#$%&amp;&#39;*+\\-/=?^_`{|}~]+)+|&quot;((?=[\\x01-\\x\r\n    7f])[^&quot;\\\\]|\\\\[\\x01-\\x7f])*&quot;)@(((?!-)[a-zA-Z\\d\\-]+(?&lt;!-)\\.)+[a-zA-Z]{2,}|\\[(((?(?&lt;\r\n    !\\[)\\.)(25[0-5]|2[0-4]\\d|[01]?\\d?\\d)){4}|[a-zA-Z\\d\\-]*[a-zA-Z\\d]:((?=[\\x01-\\x7f])\r\n    [^\\\\\\[\\]]|\\\\[\\x01-\\x7f])+)\\])(?(angle)&gt;)$\r\n\r\n  [1]: http://tools.ietf.org/html/rfc22\r\n"},{"score":5300,"body_markdown":"Using [regular expressions][1] is probably the best way. You can see a bunch of tests [here][2] (taken from [chromium][3])\r\n\r\n\r\n    function validateEmail(email) {\r\n        const re = /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n        return re.test(String(email).toLowerCase());\r\n    }\r\nHere&#39;s the example of regular expresion that accepts unicode:\r\n\r\n    const re = /^(([^&lt;&gt;()\\[\\]\\.,;:\\s@\\&quot;]+(\\.[^&lt;&gt;()\\[\\]\\.,;:\\s@\\&quot;]+)*)|(\\&quot;.+\\&quot;))@(([^&lt;&gt;()[\\]\\.,;:\\s@\\&quot;]+\\.)+[^&lt;&gt;()[\\]\\.,;:\\s@\\&quot;]{2,})$/i;\r\n\r\nBut keep in mind that one should not rely only upon JavaScript validation. JavaScript can easily be disabled. This should be validated on the server side as well.\r\n\r\nHere&#39;s an example of the above in action:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function validateEmail(email) {\r\n      const re = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\\&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\&quot;]+)*)|(\\&quot;.+\\&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n      return re.test(email);\r\n    }\r\n\r\n    function validate() {\r\n      const $result = $(&quot;#result&quot;);\r\n      const email = $(&quot;#email&quot;).val();\r\n      $result.text(&quot;&quot;);\r\n\r\n      if (validateEmail(email)) {\r\n        $result.text(email + &quot; is valid :)&quot;);\r\n        $result.css(&quot;color&quot;, &quot;green&quot;);\r\n      } else {\r\n        $result.text(email + &quot; is not valid :(&quot;);\r\n        $result.css(&quot;color&quot;, &quot;red&quot;);\r\n      }\r\n      return false;\r\n    }\r\n\r\n    $(&quot;#validate&quot;).on(&quot;click&quot;, validate);\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n\r\n    &lt;form&gt;\r\n      &lt;p&gt;Enter an email address:&lt;/p&gt;\r\n      &lt;input id=&#39;email&#39;&gt;\r\n      &lt;button type=&#39;submit&#39; id=&#39;validate&#39;&gt;Validate!&lt;/button&gt;\r\n    &lt;/form&gt;\r\n\r\n    &lt;h2 id=&#39;result&#39;&gt;&lt;/h2&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Regular_expression\r\n  [2]: http://jsfiddle.net/ghvj4gy9/embedded/result,js/\r\n  [3]: https://cs.chromium.org/chromium/src/third_party/blink/web_tests/fast/forms/resources/ValidityState-typeMismatch-email.js?q=ValidityState-typeMismatch-email.js&amp;sq=package:chromium&amp;dr"},{"score":407,"body_markdown":"Wow, there are lots of complexity here. If all you want to do is just catch the most obvious syntax errors, I would do something like this:\r\n\r\n    ^\\S+@\\S+$\r\n\r\nIt usually catches the most obvious errors that the user makes and assures that the form is mostly right, which is what JavaScript validation is all about.\r\n"},{"score":339,"body_markdown":"There&#39;s something you have to understand the second you decide to use a regular expression to validate emails: [It&#39;s probably not a good idea](http://ex-parrot.com/~pdw/Mail-RFC822-Address.html). Once you have come to terms with that, there are many implementations out there that can get you halfway there, [this article sums them up nicely.](http://www.regular-expressions.info/email.html)\r\n\r\nIn short, however, the only way to be absolutely, positively sure that what the user entered is in fact an email is to actually send an email and see what happens. Other than that it&#39;s all just guesses."},{"score":55,"body_markdown":"This was stolen from http://codesnippets.joyent.com/posts/show/1917\r\n\r\n    email = $(&#39;email&#39;);\r\n    filter = /^([a-zA-Z0-9_\\.\\-])+\\@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z0-9]{2,4})+$/;\r\n    if (filter.test(email.value)) {\r\n      // Yay! valid\r\n      return true;\r\n    }\r\n    else\r\n      {return false;}\r\n\r\n\r\n"},{"score":-7,"body_markdown":"Following regular expression:\r\n\r\n    /^([\\w]+)(.[\\w]+)*@([\\w]+)(.[\\w]{2,3}){1,2}$/;"},{"score":19,"body_markdown":"It&#39;s hard to get an email validator 100% correct. The only real way to get it correct would be to send a test email to the account. That said, there are a few basic checks that can help make sure that you&#39;re getting something reasonable.\r\n\r\nSome things to improve:\r\n\r\nInstead of new `RegExp`, just try writing the `regexp` out like this:\r\n\r\n    if (reg.test(/@/))\r\n\r\nSecond, check to make sure that a period comes after the `@` sign, and make sure that there are characters between the `@`s and periods. "},{"score":793,"body_markdown":"Just for completeness, [here you have another RFC 2822 compliant regex][1]\n\n&gt;The official standard is known as [RFC 2822][2]. It describes the syntax that valid email addresses must adhere to. You can (**but you shouldn&#39;t** &amp;mdash; [read on][1]) implement it with this regular expression:\n&gt;\n&gt; ``(?:[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*|&quot;(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])``\n&gt;\n&gt;(...) We get a more practical implementation of RFC 2822 if we omit the syntax using double quotes and square brackets. **It will still match 99.99% of all email addresses in actual use today.**\n&gt;\n&gt; ``[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?``\n&gt;\n&gt; A further change you could make is to allow any two-letter country code top level domain, and only specific generic top level domains. **This regex filters dummy email addresses like `asdf@adsf.adsf`**. You **will need to update it as new top-level domains are added**.\n&gt;\n&gt; ``[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[A-Z]{2}|com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum)\\b``\n&gt;\n&gt; So even when following official standards, there are still trade-offs to be made. ***Don&#39;t blindly copy regular expressions from online libraries or discussion forums. Always test them on your own data and with your own applications.***\n\n&lt;sub&gt;Emphasis mine&lt;/sub&gt;\n\n  [1]: http://www.regular-expressions.info/email.html\n  [2]: https://tools.ietf.org/html/rfc2822#section-3.4.1"},{"score":12,"body_markdown":"Here is a very good discussion about using regular expressions to validate email addresses; &quot;[Comparing E-mail Address Validating Regular Expressions][1]&quot;\r\n\r\nHere is the current top expression, that is JavaScript compatible, for reference purposes:\r\n\r\n    /^[-a-z0-9~!$%^&amp;*_=+}{\\&#39;?]+(\\.[-a-z0-9~!$%^&amp;*_=+}{\\&#39;?]+)*@([a-z0-9_][-a-z0-9_]*(\\.[-a-z0-9_]+)*\\.(aero|arpa|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|mobi|[a-z][a-z])|([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}))(:[0-9]{1,5})?$/i\r\n\r\n\r\n  [1]: http://fightingforalostcause.net/misc/2006/compare-email-regex.php"},{"score":12,"body_markdown":"Apparently, that&#39;s it:\r\n\r\n    /^([\\w\\!\\#$\\%\\&amp;\\&#39;\\*\\+\\-\\/\\=\\?\\^\\`{\\|\\}\\~]+\\.)*[\\w\\!\\#$\\%\\&amp;\\&#39;\\*\\+\\-\\/\\=\\?\\^\\`{\\|\\}\\~]+@((((([a-z0-9]{1}[a-z0-9\\-]{0,62}[a-z0-9]{1})|[a-z])\\.)+[a-z]{2,6})|(\\d{1,3}\\.){3}\\d{1,3}(\\:\\d{1,5})?)$/i\r\n\r\nTaken from http://fightingforalostcause.net/misc/2006/compare-email-regex.php on Oct 1 &#39;10.\r\n\r\nBut, of course, that&#39;s ignoring internationalization."},{"score":60,"body_markdown":"Correct validation of email address in compliance with the RFCs is not something that can be achieved with a one-liner regular expression. An article with the best solution I&#39;ve found in PHP is *[What is a valid email address?][1]*. Obviously, it has been ported to Java. &lt;strike&gt;I think the function is too complex to be ported and used in JavaScript.&lt;/strike&gt; JavaScript/node.js port: https://www.npmjs.com/package/email-addresses.\r\n\r\nA good practice is to validate your data on the client, but double-check the validation on the server. With this in mind, you can simply check whether a string looks like a valid email address on the client and perform the strict check on the server.\r\n\r\nHere&#39;s the JavaScript function I use to check if a string looks like a valid mail address:\r\n\r\n    function looksLikeMail(str) {\r\n        var lastAtPos = str.lastIndexOf(&#39;@&#39;);\r\n        var lastDotPos = str.lastIndexOf(&#39;.&#39;);\r\n        return (lastAtPos &lt; lastDotPos &amp;&amp; lastAtPos &gt; 0 &amp;&amp; str.indexOf(&#39;@@&#39;) == -1 &amp;&amp; lastDotPos &gt; 2 &amp;&amp; (str.length - lastDotPos) &gt; 2);\r\n    }\r\n\r\nExplanation:\r\n\r\n- `lastAtPos &lt; lastDotPos`: Last `@` should be before last `.` since `@` cannot be part of server name (as far as I know).\r\n\r\n- `lastAtPos &gt; 0`: There should be something (the email username) before the last `@`.\r\n\r\n- `str.indexOf(&#39;@@&#39;) == -1`: There should be no `@@` in the address. Even if `@` appears as the last character in email username, it has to be quoted so `&quot;` would be between that `@` and the last `@` in the address.\r\n\r\n- `lastDotPos &gt; 2`: There should be at least three characters before the last dot, for example `a@b.com`.\r\n\r\n- `(str.length - lastDotPos) &gt; 2`: There should be enough characters after the last dot to form a two-character domain. I&#39;m not sure if the brackets are necessary.\r\n\r\n  [1]: http://www.dominicsayers.com/isemail/\r\n"},{"score":225,"body_markdown":"HTML5 itself has email validation. If your browser supports HTML5 then you can use the following code.\r\n\r\n    &lt;form&gt;&lt;input type=&quot;email&quot; placeholder=&quot;me@example.com&quot; required&gt;\r\n        &lt;input type=&quot;submit&quot;&gt;\r\n    &lt;/form&gt;\r\n\r\n[jsFiddle][1] link\r\n\r\nFrom the [HTML5 spec](http://www.w3.org/TR/html5/forms.html#valid-e-mail-address):\r\n\r\n&gt; A **valid e-mail address** is a string that matches the `email` production of the following ABNF, the character set for which is Unicode.\r\n&gt;\r\n&gt;     email   = 1*( atext / &quot;.&quot; ) &quot;@&quot; label *( &quot;.&quot; label )\r\n&gt;     label   = let-dig [ [ ldh-str ] let-dig ]  ; limited to a length of 63 characters by RFC 1034 section 3.5\r\n&gt;     atext   = &lt; as defined in RFC 5322 section 3.2.3 &gt;\r\n&gt;     let-dig = &lt; as defined in RFC 1034 section 3.5 &gt;\r\n&gt;     ldh-str = &lt; as defined in RFC 1034 section 3.5 &gt;\r\n&gt;\r\n&gt; This requirement is a [willful violation](http://www.w3.org/TR/html5/introduction.html#willful-violation) of RFC 5322, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &quot;@&quot; character), too vague (after the &quot;@&quot; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.\r\n&gt;\r\n&gt; The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.\r\n&gt;\r\n&gt;     /^[a-zA-Z0-9.!#$%&amp;&#39;*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\r\n\r\n  [1]: http://jsfiddle.net/edwinthomas25/z6wev5L0/\r\n"},{"score":26,"body_markdown":"You should not use regular expressions to validate an input string to check if it&#39;s an email. It&#39;s too complicated and would not cover all the cases.\r\n\r\nNow since you can only cover 90% of the cases, write something like:\r\n\r\n    function isPossiblyValidEmail(txt) {\r\n       return txt.length &gt; 5 &amp;&amp; txt.indexOf(&#39;@&#39;)&gt;0;\r\n    }\r\n\r\nYou can refine it. For instance, &#39;aaa@&#39; is valid. But overall you get the gist. And don&#39;t get carried away... A simple 90% solution is better than 100% solution that does not work. \r\n\r\nThe world needs simpler code...\r\n"},{"score":923,"body_markdown":"I&#39;ve slightly modified [Jaymon&#39;s answer][1] for people who want really simple validation in the form of:\r\n\r\n    anystring@anystring.anystring\r\n\r\nThe regular expression:\r\n\r\n    /\\S+@\\S+\\.\\S+/\r\n\r\nExample JavaScript function:\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function validateEmail(email) \r\n        {\r\n            var re = /\\S+@\\S+\\.\\S+/;\r\n            return re.test(email);\r\n        }\r\n        \r\n    console.log(validateEmail(&#39;anystring@anystring.anystring&#39;));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n  [1]: https://stackoverflow.com/a/48800/4832311"},{"score":12,"body_markdown":"In contrast to *squirtle*, here is a complex solution, but it does a mighty fine job of validating emails properly:\r\n\r\n    function isEmail(email) { \r\n        return /^((([a-z]|\\d|[!#\\$%&amp;&#39;\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&amp;&#39;\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i.test(email);\r\n    } \r\n\r\nUse like so:&lt;br&gt;&lt;br&gt;\r\n\r\n    if (isEmail(&#39;youremail@yourdomain.com&#39;)){ console.log(&#39;This is email is valid&#39;); }\r\n"},{"score":6,"body_markdown":"Sectrean&#39;s solution works great, but it was failing my [linter][1]. So I added some escapes:\r\n\r\n    function validateEmail(email){ \r\n         var re = /^(([^&lt;&gt;()[]\\\\.,;:\\s@\\&quot;]+(\\.[^&lt;&gt;()[]\\\\.,;:\\s@\\&quot;]+)*)|(\\&quot;.+\\&quot;))@(([[0-9]{1,3}\\‌​.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; \r\n         return re.test(email); \r\n    }\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Lint_%28software%29\r\n"},{"score":-7,"body_markdown":"    function validateEmail(elementValue){        \r\n        var emailPattern = /^[a-zA-Z0-9._]+[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z]{2,4}$/;  \r\n        return emailPattern.test(elementValue);   \r\n      }   \r\n\r\nIt returns true if the email address is valid. Otherwise, it will return false.\r\n"},{"score":45,"body_markdown":"Do this:\r\n\r\n    [a-zA-Z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\r\n\r\nWhy?  **It&#39;s based on [RFC 2822][1]**, which is a standard ALL email addresses MUST adhere to.  And I&#39;m not sure why you&#39;d bother with something &quot;simpler&quot;... you&#39;re gonna copy and paste it anyway ;)\r\n\r\nOften when storing email addresses in the database I make them lowercase and, in practice, regexs can usually be marked case insensitive. In those cases this is slightly shorter:\r\n\r\n    [a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\r\n\r\nHere&#39;s an example of it being used in JavaScript (with the case insensitive flag `i` at the end).\r\n\r\n    var emailCheck=/^[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;\r\n    console.log( emailCheck.test(&#39;some.body@domain.co.uk&#39;) );\r\n\r\n**Note**:  \r\nTechnically some emails can include quotes in the section before the `@` symbol with escape characters inside the quotes (so your email user can be obnoxious and contain stuff like `@` and `&quot;...&quot;` as long as it&#39;s written in quotes). NOBODY DOES THIS EVER! It&#39;s obsolete. But, it IS included in the true [RFC 2822][1] standard, and omitted here.\r\n\r\nMore info: http://www.regular-expressions.info/email.html\r\n\r\n  [1]: https://www.ietf.org/rfc/rfc2822.txt"},{"score":97,"body_markdown":"In modern browsers you can build on top of @Sushil&#39;s answer with pure JavaScript and the [DOM][1]:\r\n\r\n    function validateEmail(value) {\r\n      var input = document.createElement(&#39;input&#39;);\r\n\r\n      input.type = &#39;email&#39;;\r\n      input.required = true;\r\n      input.value = value;\r\n        \r\n      return typeof input.checkValidity === &#39;function&#39; ? input.checkValidity() : /\\S+@\\S+\\.\\S+/.test(value);\r\n    }\r\n\r\nI&#39;ve put together an example in the fiddle http://jsfiddle.net/boldewyn/2b6d5/. Combined with feature detection and the bare-bones validation from [Squirtle&#39;s Answer][2], it frees you from the regular expression massacre and does not bork on old browsers.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Document_Object_Model\r\n  [2]: https://stackoverflow.com/a/9204568/324094"},{"score":10,"body_markdown":"\r\n\r\n    &lt;form name=&quot;validation&quot; onSubmit=&quot;return checkbae()&quot;&gt;\r\n        Please input a valid email address:&lt;br /&gt;\r\n\r\n        &lt;input type=&quot;text&quot; size=18 name=&quot;emailcheck&quot;&gt;\r\n        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;\r\n    &lt;/form&gt;\r\n\r\n    &lt;script language=&quot;JavaScript1.2&quot;&gt;\r\n        var testresults\r\n        function checkemail(){\r\n            var str = document.validation.emailcheck.value\r\n            var filter = /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i\r\n            if (filter.test(str))\r\n                testresults = true\r\n            else {\r\n                alert(&quot;Please input a valid email address!&quot;)\r\n                testresults = false\r\n            }\r\n            return (testresults)\r\n        }\r\n    &lt;/script&gt;\r\n\r\n    &lt;script&gt;\r\n        function checkbae(){\r\n            if (document.layers || document.getElementById || document.all)\r\n                return checkemail()\r\n            else\r\n                return true\r\n        }\r\n    &lt;/script&gt;\r\n"},{"score":11,"body_markdown":"My knowledge of [regular expressions][1] is not that good. That&#39;s why I check the general syntax with a simple regular expression first and check more specific options with other functions afterwards. This may not be not the best technical solution, but this way I&#39;m way more flexible and faster.\r\n\r\nThe most common errors I&#39;ve come across are spaces (especially at the beginning and end) and occasionally a double dot.\r\n\r\n    function check_email(val){\r\n        if(!val.match(/\\S+@\\S+\\.\\S+/)){ // Jaymon&#39;s / Squirtle&#39;s solution\r\n            // Do something\r\n            return false;\r\n        }\r\n        if( val.indexOf(&#39; &#39;)!=-1 || val.indexOf(&#39;..&#39;)!=-1){\r\n            // Do something\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    check_email(&#39;check@thiscom&#39;); // Returns false\r\n    check_email(&#39;check@this..com&#39;); // Returns false\r\n    check_email(&#39; check@this.com&#39;); // Returns false\r\n    check_email(&#39;check@this.com&#39;); // Returns true\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Regular_expression\r\n"},{"score":70,"body_markdown":"This is the correct RFC822 version.\r\n\r\n    function checkEmail(emailAddress) {\r\n      var sQtext = &#39;[^\\\\x0d\\\\x22\\\\x5c\\\\x80-\\\\xff]&#39;;\r\n      var sDtext = &#39;[^\\\\x0d\\\\x5b-\\\\x5d\\\\x80-\\\\xff]&#39;;\r\n      var sAtom = &#39;[^\\\\x00-\\\\x20\\\\x22\\\\x28\\\\x29\\\\x2c\\\\x2e\\\\x3a-\\\\x3c\\\\x3e\\\\x40\\\\x5b-\\\\x5d\\\\x7f-\\\\xff]+&#39;;\r\n      var sQuotedPair = &#39;\\\\x5c[\\\\x00-\\\\x7f]&#39;;\r\n      var sDomainLiteral = &#39;\\\\x5b(&#39; + sDtext + &#39;|&#39; + sQuotedPair + &#39;)*\\\\x5d&#39;;\r\n      var sQuotedString = &#39;\\\\x22(&#39; + sQtext + &#39;|&#39; + sQuotedPair + &#39;)*\\\\x22&#39;;\r\n      var sDomain_ref = sAtom;\r\n      var sSubDomain = &#39;(&#39; + sDomain_ref + &#39;|&#39; + sDomainLiteral + &#39;)&#39;;\r\n      var sWord = &#39;(&#39; + sAtom + &#39;|&#39; + sQuotedString + &#39;)&#39;;\r\n      var sDomain = sSubDomain + &#39;(\\\\x2e&#39; + sSubDomain + &#39;)*&#39;;\r\n      var sLocalPart = sWord + &#39;(\\\\x2e&#39; + sWord + &#39;)*&#39;;\r\n      var sAddrSpec = sLocalPart + &#39;\\\\x40&#39; + sDomain; // complete RFC822 email address spec\r\n      var sValidEmail = &#39;^&#39; + sAddrSpec + &#39;$&#39;; // as whole string\r\n      \r\n      var reValidEmail = new RegExp(sValidEmail);\r\n      \r\n      return reValidEmail.test(emailAddress);\r\n    }"},{"score":24,"body_markdown":"Simply check out if the entered email address is valid or not using HTML.\r\n\r\n    &lt;input type=&quot;email&quot;/&gt;\r\n\r\nThere isn&#39;t any need to write a function for validation.\r\n"},{"score":62,"body_markdown":"All email addresses contain an &#39;at&#39; (i.e. @) symbol. Test that necessary condition:\r\n\r\n    email.indexOf(&quot;@&quot;) &gt; 0\r\n\r\nDon&#39;t bother with anything more complicated. Even if you could perfectly determine whether an email is RFC-syntactically valid, that wouldn&#39;t tell you whether it belongs to the person who supplied it. That&#39;s what really matters.\r\n\r\nTo test that, send a validation message."},{"score":3,"body_markdown":"If you&#39;re using Closure you can use the built-in `goog.format.EmailAddress` type:\r\n\r\n&gt; [http://docs.closure-library.googlecode.com/git/class_goog_format_EmailAddress.html][1]\r\n\r\nFor example:\r\n\r\n    goog.format.EmailAddress.isValidAddrSpec(&quot;blah@blah.com&quot;)\r\n\r\nNote that by reading the source (linked above) you can see the comments state that IDN are not supported and that it only aims to cover _most_ addresses:\r\n\r\n    // This is a fairly naive implementation, but it covers 99% of use cases.\r\n    // For more details, see http://en.wikipedia.org/wiki/Email_address#Syntax\r\n    // TODO(mariakhomenko): we should also be handling i18n domain names as per\r\n    // http://en.wikipedia.org/wiki/Internationalized_domain_name\r\n\r\n\r\n  [1]: http://web.archive.org/web/20140130083649/http://docs.closure-library.googlecode.com/git/class_goog_format_EmailAddress.html"},{"score":18,"body_markdown":"This is how [node-validator][1] does it:\r\n\r\n    /^(?:[\\w\\!\\#\\$\\%\\&amp;\\&#39;\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&amp;\\&#39;\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/\r\n\r\n\r\n  [1]: https://github.com/chriso/validator.js"},{"score":-6,"body_markdown":"[W3Schools][1] gives a good simple and efficient script to validate an email:  \r\n\r\n    function validateEmail(email) {\r\n        var atpos=email.indexOf(&quot;@&quot;);\r\n        var dotpos=email.lastIndexOf(&quot;.&quot;);\r\n        if (atpos &lt; 1 || dotpos &lt; atpos+2 || dotpos+2 &gt;= email.length) {\r\n            alert(&quot;Not a valid e-mail address&quot;);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\nNote that you will have to remove spaces if there are any though, with something like this:\r\n\r\n    .replace(/ /g,&#39;&#39;)\r\n\r\nSource: *[JavaScript Form Validation][2]*\r\n\r\n  [1]: http://en.wikipedia.org/wiki/W3Schools\r\n  [2]: http://www.w3schools.com/js/js_form_validation.asp\r\n"},{"score":15,"body_markdown":"Use this code inside your validator function:\r\n\r\n    var emailID = document.forms[&quot;formName&quot;][&quot;form element id&quot;].value;\r\n    atpos = emailID.indexOf(&quot;@&quot;);\r\n    dotpos = emailID.lastIndexOf(&quot;.&quot;);\r\n    if (atpos &lt; 1 || ( dotpos - atpos &lt; 2 ))\r\n    {\r\n        alert(&quot;Please enter correct email ID&quot;)\r\n        return false;\r\n    }\r\n\r\nElse you can use [jQuery][1]. Inside rules define:\r\n\r\n    eMailId: {\r\n        required: true,\r\n        email: true\r\n    }\r\n\r\n  [1]: http://en.wikipedia.org/wiki/JQuery"},{"score":8,"body_markdown":"The regular expression provided by Microsoft within [ASP.NET MVC][1] is\r\n\r\n    /^[\\w-]+(\\.[\\w-]+)*@([a-z0-9-]+(\\.[a-z0-9-]+)*?\\.[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$/\r\n\r\nWhich I post here in case it&#39;s flawed - though it&#39;s always been perfect for my needs.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/ASP.NET_MVC_Framework\r\n"},{"score":3,"body_markdown":"    &lt;pre&gt;\r\n    **The personal_info part contains the following ASCII characters.\r\n    1.Uppercase (A-Z) and lowercase (a-z) English letters.\r\n    2.Digits (0-9).\r\n    3.Characters ! # $ % &amp; &#39; * + - / = ? ^ _ ` { | } ~\r\n    4.Character . ( period, dot or fullstop) provided that it is not the first or last character and it will not come one after the other.**\r\n    &lt;/pre&gt;\r\n    *Example of valid email id*\r\n    &lt;pre&gt;\r\n    yoursite@ourearth.com\r\n    my.ownsite@ourearth.org\r\n    mysite@you.me.net\r\n    xxxx@gmail.com\r\n    xxxxxx@yahoo.com\r\n    &lt;/pre&gt;\r\n    &lt;pre&gt;\r\n    xxxx.ourearth.com [@ is not present] \r\n    xxxx@.com.my [ tld (Top Level domain) can not start with dot &quot;.&quot; ]\r\n    @you.me.net [ No character before @ ]\r\n    xxxx123@gmail.b [ &quot;.b&quot; is not a valid tld ]\r\n    xxxx@.org.org [ tld can not start with dot &quot;.&quot; ]\r\n    .xxxx@mysite.org [ an email should not be start with &quot;.&quot; ]\r\n    xxxxx()*@gmail.com [ here the regular expression only allows character, digit, underscore and dash ]\r\n    xxxx..1234@yahoo.com [double dots are not allowed\r\n    &lt;/pre&gt;\r\n    **javascript mail code**\r\n    \r\n        function ValidateEmail(inputText)\r\n        {\r\n        var mailformat = /^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/;\r\n        if(inputText.value.match(mailformat))\r\n        {\r\n        document.form1.text1.focus();\r\n        return true;\r\n        }\r\n        else\r\n        {\r\n        alert(&quot;You have entered an invalid email address!&quot;);\r\n        document.form1.text1.focus();\r\n        return false;\r\n        }\r\n        }"},{"score":-4,"body_markdown":"Very simple in `JavaScript`. follow this code.\r\n\r\n    function validate(){\r\n        var email = document.getElementById(&#39;Email&#39;);\r\n        var filter = /^([a-zA-Z0-9_\\.\\-])+\\@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z0-9]{2,4})+$/;\r\n\r\n        if (!filter.test(email.value))\r\n        {\r\n            alert(&#39;Please Enter the valid email address&#39;);\r\n            email.focus;\r\n            return false;\r\n        }\r\n        else\r\n    {\r\n            return true;\r\n        }\r\n\r\n`HTML` code for this:\r\n\r\n    form name=&quot;form&quot;\r\n         enctype=&quot;multipart/form-data&quot;\r\n         name=&quot;form&quot;\r\n         action=&quot;register.php&quot;\r\n         method=&quot;POST&quot; onsubmit=&quot;return validate();&quot; &gt;\r\n        &lt;input type=&quot;text&quot; placeholder=&quot;Enter ur Email Id&quot; id=&quot;Email&quot; name=&quot;Email&quot; /&gt;\r\n        &lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;save&quot; name=&quot;Like&quot; class=&quot;button&quot; /&gt;\r\n    &lt;/form&gt;\r\n"},{"score":-1,"body_markdown":"One of my coworker shared this regex with me. I like it a lot.\r\n\r\n    function isValidEmailAddress (email) {\r\n        var validEmail = false;\r\n        if (email) {\r\n            email = email.trim().toLowerCase();\r\n            var pattern = /^[\\w-&#39;]+(\\.[\\w-&#39;]+)*@([a-zA-Z0-9]+[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*?\\.[a-zA-Z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$/;\r\n            validEmail = pattern.exec(email);\r\n        }\r\n\t\t\r\n        return validEmail;\r\n    }\r\n\r\n    if (typeof String.prototype.trim !== &#39;function&#39;) {\r\n        String.prototype.trim = function() {\r\n            return this.replace(/^\\s+|\\s+$/g, &#39;&#39;);\r\n        };\r\n    }"},{"score":-5,"body_markdown":"    function validatecontactEmail(email) { \r\n        \r\n     if (/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(email))  \r\n      {  \r\n        return (true)  \r\n      }  \r\n        \r\n        return (false)  \r\n    \r\n    }"},{"score":5,"body_markdown":"Here is a function I use for front end email validation. (The Regular Expression came from parsley.js)\r\n\r\n    &lt;!DOCTYPE html&gt;\r\n    &lt;html&gt;\r\n    &lt;head&gt;\r\n  \t    &lt;title&gt;Our Company&lt;/title&gt;\r\n\t    &lt;style&gt;\r\n\t\t    .form-style {\r\n\t\t\t    color: #ccc;\r\n\t\t    }\r\n\t    &lt;/style&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n  \t    &lt;h1&gt;Email Validation Form Example&lt;/h1&gt;\r\n\t    &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;emailInput&quot; class=&quot;form-style&quot;&gt;\r\n\t    &lt;script&gt;\r\n\t\t    function validateEmail(emailAddress) {\r\n\t\t\t    var regularExpression = /^((([a-z]|\\d|[!#\\$%&amp;&#39;\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&amp;&#39;\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))){2,6}$/i;\r\n\t\t\t     return regularExpression.test(emailAddress);\r\n\t\t    }\r\n\r\n\t\t    function showEmailValidationState(event) {\r\n\t\t        if (validateEmail(event.target.value)) {\r\n\t\t\t        document.getElementById(&quot;emailInput&quot;).style.color = &#39;black&#39;;\r\n\t\t        }\r\n\t        }\r\n    \tdocument.getElementById(&quot;emailInput&quot;).addEventListener(&quot;keyup&quot;, showEmailValidationState);\r\n    \t&lt;/script&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;\r\n"},{"score":1,"body_markdown":"If you are using AngularJS, just add `type=&quot;email&quot;` to the input element: \r\n\r\n&gt; https://docs.angularjs.org/api/ng/input/input%5Bemail%5D\r\n\r\nIn case there is no input element, it can be created dynamically:\r\n\r\n    var isEmail = $compile(&#39;&lt;input ng-model=&quot;m&quot; type=&quot;email&quot;&gt;&#39;)($rootScope.$new()).\r\n        controller(&#39;ngModel&#39;).$validators[&quot;email&quot;];\r\n\r\n    if (isEmail(&#39;email@gmail.com&#39;)) {\r\n      console.log(&#39;valid&#39;);\r\n    } "},{"score":-6,"body_markdown":"Validation regex for email:\r\n\r\n    var rex_email = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\\&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\&quot;]+)*)|(\\&quot;.+\\&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n    \r\n    if(email==&quot;&quot;) {\r\n        window.plugins.toast.showShortBottom( &quot;Please enter the details. &quot;, function(a) {\r\n            console.log(&#39;toast success: &#39; + a);\r\n        }, function(b) { });\r\n    } else if(!rex_email.test(email)) {\r\n        window.plugins.toast.showShortBottom( &quot;Please enter the valid email id. &quot;, function(a) {\r\n            console.log(&#39;toast success: &#39; + a);\r\n        }, function(b) { });\r\n    }"},{"score":1,"body_markdown":"I know its not regex but any way...\r\n\r\nThis is example with node and npm package [email-existence][1] this is ultimate checking if email exist and if its in the right form :)\r\n\r\nThis will ping the email if its responding if it got no response it will return false or else true.\r\n\r\n    function doesEmailExist(email) {\r\n        var emailExistence = require(&#39;email-existence&#39;);\r\n        return emailExistence.check(email,function (err,status) {\r\n                if (status) {\r\n                    return status;\r\n                }\r\n                else {\r\n                    throw new Error(&#39;Email does not exist&#39;);\r\n                }\r\n            });\r\n    }\r\n\r\n\r\n  [1]: https://www.npmjs.com/package/email-existence"},{"score":4,"body_markdown":"***Following Regex validations:***\r\n\r\n - No spacial characters before @ \r\n - (-) and (.) should not be together\r\n   after @ No special characters after @ 2 characters must before @\r\n   Email length should be less 128 characters\r\n\r\n&lt;!-- --&gt;\r\n\r\n    function validateEmail(email) {\r\n    var chrbeforAt = email.substr(0, email.indexOf(&#39;@&#39;));\r\n    if (!($.trim(email).length &gt; 127)) {\r\n        if (chrbeforAt.length &gt;= 2) {\r\n            var re = /^(([^&lt;&gt;()[\\]{}&#39;^?\\\\.,!|//#%*-+=&amp;;:\\s@\\&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\&quot;]+)*)|(\\&quot;.+\\&quot;))@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;\r\n    \t\t//var re = /[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;\r\n    \t\treturn re.test(email);\r\n        } else {\r\n            return false;\r\n        }\r\n    } else {\r\n        return false;\r\n    }\r\n    }"},{"score":1,"body_markdown":"***Following Regex validations:***\r\n\r\n- No spacial characters before @ \r\n- (-) and (.) should not be together after @ \r\n- No special characters after @ 2 characters must before @\r\n- Email length should be less 128 characters\r\n\r\n\t\tfunction validateEmail(email) {\r\n\t\t\tvar chrbeforAt = email.substr(0, email.indexOf(&#39;@&#39;));\r\n\t\t\tif (!($.trim(email).length &gt; 127)) {\r\n\t\t\t\tif (chrbeforAt.length &gt;= 2) {\r\n\t\t\t\t\tvar re = /^(([^&lt;&gt;()[\\]{}&#39;^?\\\\.,!|//#%*-+=&amp;;:\\s@\\&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\&quot;]+)*)|(\\&quot;.+\\&quot;))@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;\r\n\t\t\t\t\treturn re.test(email);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n"},{"score":-1,"body_markdown":"    \\b[a-z][\\w\\d_\\.]+@\\w+\\.[a-z]{2}[a-z]?\\.?[a-z]{,2}\\s\r\n\r\nIt allows:\r\n\r\n    abcxyz123@qwert.com    \r\n    abc123xyz@asdf.co.in   \r\n    abc1_xyz1@gmail1.com   \r\n    abc.xyz@gmail.com.in\r\n\r\n"},{"score":3,"body_markdown":"the best one :D (RFC-friendly &amp; no error &quot;too complex&quot;) :\r\n\r\n    function\tisMail(mail)\r\n    {\r\n        pattuser = /^([A-Z0-9_%+\\-!#$&amp;&#39;*\\/=?^`{|}~]+\\.?)*[A-Z0-9_%+\\-!#$&amp;&#39;*\\/=?^`{|}~]+$/i;\r\n        pattdomain = /^([A-Z0-9-]+\\.?)*[A-Z0-9-]+(\\.[A-Z]{2,9})+$/i;\r\n        \r\n        tab = mail.split(&quot;@&quot;);\r\n        if (tab.length != 2)\r\n            return false;\r\n        return (pattuser.test(tab[0]) &amp;&amp; pattdomain.test(tab[1]));\r\n    }"},{"score":1,"body_markdown":"If you want to use Jquery and want to have modern approach then use JQuery input mask with validation. \r\n\r\n[http://bseth99.github.io/projects/jquery-ui/5-jquery-masks.html][3] \r\n\r\n  [3]: http://bseth99.github.io/projects/jquery-ui/5-jquery-masks.html\r\n\r\nDemo on how simple jquery input mask is here: http://codepen.io/anon/pen/gpRyBp\r\n\r\n**Example of simple input mask for date forexample NOT full validation**\r\n\r\n     &lt;input id=&quot;date&quot; type=&quot;text&quot; placeholder=&quot;YYYY-MM-DD&quot;/&gt;\r\nand the script:\r\n    \r\n     $(&quot;#date&quot;).mask(&quot;9999-99-99&quot;,{placeholder:&quot;YYYY-MM-DD&quot;});"},{"score":5,"body_markdown":"The best practice is to either use HTML5 built-in email tag.\r\n\r\n    &lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;\r\n\r\nor the common email syntax as recognizing @ and . from the string is given below. \r\n\r\n    ^[a-zA-Z0-9_\\-.]+@[a-zA-Z0-9\\-]+\\.[a-zA-Z0-9\\-.]+$\r\n\r\n&gt; Note that this would still produce **invalid email** that will still match\r\n&gt; the regex, its almost impossible to catch them all but this will\r\n&gt; improve the situation a little.\r\n\r\n    \r\n\r\n    "},{"score":146,"body_markdown":"I have found this to be the best solution:\r\n\r\n    /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\r\n\r\nIt allows the following formats:\r\n\r\n&lt;pre&gt;\r\n1.  prettyandsimple@example.com\r\n2.  very.common@example.com\r\n3.  disposable.style.email.with+symbol@example.com\r\n4.  other.email-with-dash@example.com\r\n9.  #!$%&amp;&#39;*+-/=?^_`{}|~@example.org\r\n6.  &quot;()&lt;&gt;[]:,;@\\\\\\&quot;!#$%&amp;&#39;*+-/=?^_`{}| ~.a&quot;@example.org\r\n7.  &quot; &quot;@example.org (space between the quotes)\r\n8.  &#252;&#241;&#238;&#231;&#248;&#240;&#233;@example.com (Unicode characters in local part)\r\n9.  &#252;&#241;&#238;&#231;&#248;&#240;&#233;@&#252;&#241;&#238;&#231;&#248;&#240;&#233;.com (Unicode characters in domain part)\r\n10. Pel&#233;@example.com (Latin)\r\n11. δοκιμή@παράδειγμα.δοκιμή (Greek)\r\n12. 我買@屋企.香港 (Chinese)\r\n13. 甲斐@黒川.日本 (Japanese)\r\n14. чебурашка@ящик-с-апельсинами.рф (Cyrillic)\r\n&lt;/pre&gt;\r\n\r\nIt&#39;s clearly versatile and allows the all-important international characters, while still enforcing the basic anything@anything.anything format. It will block spaces which are technically allowed by RFC, but they are so rare that I&#39;m happy to do this."},{"score":1,"body_markdown":"This regexp prevents duplicate domain names like abc@abc.com.com.com.com, it will allow only domain two time like abc@abc.co.in. It also does not allow statring from number like 123abc@abc.com  \r\n\r\n    regexp: /^([a-zA-Z])+([a-zA-Z0-9_.+-])+\\@(([a-zA-Z])+\\.+?(com|co|in|org|net|edu|info|gov|vekomy))\\.?(com|co|in|org|net|edu|info|gov)?$/,  \r\nAll The Best !!!!!"},{"score":-4,"body_markdown":"Simple regex for email-Id\r\n\r\n     String EMAIL_PATTERN =&quot;^(([^&lt;&gt;()\\[\\]\\.,;:\\s@\\&quot;]+(\\.[^&lt;&gt;()\\[\\]\\.,;:\\s@\\&quot;]+)*)|(\\&quot;.+\\&quot;))@(([^&lt;&gt;()[\\]\\.,;:\\s@\\&quot;]+\\.)+[^&lt;&gt;()[\\]\\.,;:\\s@\\&quot;]{2,})$&quot;;"},{"score":4,"body_markdown":"Use the regular expression:\r\n\r\n&lt;!-- language: none --&gt;\r\n\r\n     /^[a-z][a-zA-Z0-9_.]*(\\.[a-zA-Z][a-zA-Z0-9_.]*)?@[a-z][a-zA-Z-0-9]*\\.[a-z]+(\\.[a-z]+)?$/\r\n\r\nExample:\r\n\r\n    function validateEmail(email) {\r\n        var re = /^[a-z][a-zA-Z0-9_.]*(\\.[a-zA-Z][a-zA-Z0-9_.]*)?@[a-z][a-zA-Z-0-9]*\\.[a-z]+(\\.[a-z]+)?$/;\r\n        return re.test(email);\r\n    }\r\n\r\nIt should allow only  @ ,  . , _\r\n"},{"score":6,"body_markdown":"I&#39;ve mixed @mevius and @Boldewyn Code to Create this ultimate code for email verification using JavaScript.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function ValidateEmail(email){\r\n     \r\n      var re = /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n     \r\n      var input = document.createElement(&#39;input&#39;);\r\n     \r\n      input.type = &#39;email&#39;;\r\n      input.value = email;\r\n     \r\n      return typeof input.checkValidity == &#39;function&#39; ? input.checkValidity() : re.test(email);\r\n     \r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nI have shared this code on my blog [here][1].\r\n\r\n\r\n  [1]: http://mycodingtricks.com/snippets/javascript/javascript-regex-email-validation/"},{"score":42,"body_markdown":"I&#39;m really looking forward to solve this problem.\r\nSo I modified email validation regular expression above \r\n\r\n* Original  \r\n`/^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/`\r\n\r\n* Modified  \r\n`/^(([^&lt;&gt;()\\[\\]\\.,;:\\s@\\&quot;]+(\\.[^&lt;&gt;()\\[\\]\\.,;:\\s@\\&quot;]+)*)|(\\&quot;.+\\&quot;))@(([^&lt;&gt;()\\.,;\\s@\\&quot;]+\\.{0,1})+[^&lt;&gt;()\\.,;:\\s@\\&quot;]{2,})$/`\r\n\r\nto pass the examples in [Wikipedia Email Address](https://en.wikipedia.org/wiki/Email_address#cite_note-20/syntax).\r\n\r\nAnd you can see the result in [here](http://regexr.com/3dnsr).\r\n\r\n[![enter image description here][1]][1]\r\n\r\n\r\n  [1]: http://i.stack.imgur.com/m2YBr.png"},{"score":3,"body_markdown":"If you are using ng-pattern and material this does the job. \r\n\r\n    vm.validateEmail = &#39;([a-zA-Z0-9_.]{1,})((@[a-zA-Z]{2,})[\\\\\\.]([a-zA-Z]{2}|[a-zA-Z]{3}))&#39;;"},{"score":1,"body_markdown":"Whoever is using @pvl solution and wants it to pass [ESLint Prefer-template](http://eslint.org/docs/rules/prefer-template) then here&#39;s a version where I used template literals instead of string concatenation.\r\n\r\n    validateEmail(email) {\r\n    \tlet sQtext = &#39;[^\\\\x0d\\\\x22\\\\x5c\\\\x80-\\\\xff]&#39;;\r\n    \tlet sDtext = &#39;[^\\\\x0d\\\\x5b-\\\\x5d\\\\x80-\\\\xff]&#39;;\r\n    \tlet sAtom = &#39;[^\\\\x00-\\\\x20\\\\x22\\\\x28\\\\x29\\\\x2c\\\\x2e\\\\x3a-\\\\x3c\\\\x3e\\\\x40\\\\x5b-\\\\x5d\\\\x7f-\\\\xff]+&#39;;\r\n    \tlet sQuotedPair = &#39;\\\\x5c[\\\\x00-\\\\x7f]&#39;;\r\n    \tlet sDomainLiteral = `\\\\x5b(${sDtext}|${sQuotedPair})*\\\\x5d`;\r\n    \tlet sQuotedString = `\\\\x22(${sQtext}|${sQuotedPair})*\\\\x22`;\r\n    \tlet sDomainRef = sAtom;\r\n    \tlet sSubDomain = `(${sDomainRef}|${sDomainLiteral})`;\r\n    \tlet sWord = `(${sAtom}|${sQuotedString})`;\r\n    \tlet sDomain = `${sSubDomain}(\\\\x2e${sSubDomain})*`;\r\n    \tlet sLocalPart = `${sWord}(\\\\x2e${sWord})*`;\r\n    \tlet sAddrSpec = `${sLocalPart}\\\\x40${sDomain}`; // complete RFC822 email address spec\r\n    \tlet sValidEmail = `^${sAddrSpec}$`; // as whole string\r\n    \r\n    \tlet reValidEmail = new RegExp(sValidEmail);\r\n    \r\n    \treturn reValidEmail.test(email);\r\n    }"},{"score":13,"body_markdown":"Regex for validating email address\r\n\r\n```\r\n[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])+\r\n```"},{"score":14,"body_markdown":"&lt;h2&gt;A solution that does not check the existence of the TLD is incomplete.&lt;/h2&gt;\r\n\r\nAlmost all answers to this questions suggest using Regex to validate emails addresses. I think Regex is only good for a rudimentary validation. It seems that the checking validation of email addresses is actually two separate problems:\r\n\r\n**1- Validation of email format:** Making sure if the email complies with the format and pattern of emails in RFC 5322 and if the TLD actually exists. A list of all valid TLDs can be found [here][1].\r\n\r\nFor example, although the address `example@example.ccc` will pass the regex, it is not a valid email, because `ccc` is not a top-level domain by IANA.\r\n\r\n**2- Making sure the email actually exists:** For doing this, **the only option** is [to send the users an email][2].\r\n\r\n\r\n  [1]: http://data.iana.org/TLD/tlds-alpha-by-domain.txt\r\n  [2]: https://davidcel.is/posts/stop-validating-email-addresses-with-regex/#just-send-them-an-email-already"},{"score":10,"body_markdown":"I was looking for a Regex in JS that passes all Email Address test cases:\r\n\r\n- `email@example.com\t` Valid email\r\n\r\n- `firstname.lastname@example.com`\tEmail contains dot in the address field\r\n\r\n- `email@subdomain.example.com`\tEmail contains dot with subdomain\r\n\r\n- `firstname+lastname@example.com`\t Plus sign is considered valid character\r\n\r\n- `email@192.0.2.123\t` Domain is valid IP address\r\n\r\n- `email@[192.0.2.123]`\tSquare bracket around IP address is considered valid\r\n\r\n- `“email”@example.com`\tQuotes around email is considered valid\r\n\r\n- `1234567890@example.com` Digits in address are valid\r\n\r\n- `email@domain-one.example` Dash in domain name is valid\r\n\r\n- `_______@example.com`\tUnderscore in the address field is valid\r\n\r\n- `email@example.name` `.name` is valid Top Level Domain name\r\n\r\n- `email@example.co.jp` Dot in Top Level Domain name also considered valid (using `co.jp` as example here)\r\n\r\n- `firstname-lastname@example.com\t` Dash in address field is valid\r\n\r\nHere we go :\r\n\r\nhttp://regexr.com/3f07j\r\n\r\nOR regex:\r\n\r\n    Regex = /(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@[*[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+]*/\r\n\r\n"},{"score":2,"body_markdown":"In nodeJS you can also use validator node module and simply use like that \r\n\r\nInstall the library with npm install validator\r\n\r\n    var validator = require(&#39;validator&#39;);\r\n \r\n    validator.isEmail(&#39;foo@bar.com&#39;); //=&gt; true \r\n\r\n    "},{"score":-1,"body_markdown":"If you define your regular expression as a string then all backslashes need to be escaped, so instead of &#39;\\w&#39; you should have &#39;\\\\w&#39;.\r\n\r\nAlternatively, define it as a regular expression:\r\n\r\n    var pattern = /^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$/; "},{"score":1,"body_markdown":"There are some complex RegEx written here, that also works.\r\n\r\nI tested this one and it works too:\r\n\r\n    [a-zA-Z0-9._]+[@]+[a-zA-Z0-9]+[.]+[a-zA-Z]{2,6}\r\n\r\nPlease test this here : http://www.regextester.com/?fam=97334\r\n\r\nHope this helps."},{"score":0,"body_markdown":"I&#39;d like to add a short note about non-ASCII characters. Rnevius&#39;s (and co.) solution is brilliant, but it allows to add Cyrillic, Japanese, Emoticons and other unicode symbols which may be restricted by some servers.\r\n\r\nThe code below will print `true` though it contains UTF-8 character `Ё`.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\nconsole.log (/^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/.test (&#39;Ё@example.org&#39;))\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIn my case all non-ASCII symbols are prohibited so I have modified the original expression to exclude all characters above U+007F:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n/^(([^\\u0080-\\uffff&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^\\u0080-\\uffff&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nMaybe this will help someone to prevent undesired behaviour."},{"score":2,"body_markdown":"How about creating a function which will test any string against emails&#39; pattern using regular expression in JavaScript, as we know email addresses can be quite different in different regions, like in UK and Australia it usually ends up with `.co.uk` or `.com.au`, so I tried to cover those as well, also check if the string passed to the function, something like this:\r\n\r\n    var isEmail = function(str) {\r\n      return typeof str===&#39;string&#39; &amp;&amp; /^[\\w+\\d+._]+\\@[\\w+\\d+_+]+\\.[\\w+\\d+._]{2,8}$/.test(str);\r\n    }\r\n\r\nand check if it&#39;s email like below:\r\n\r\n    isEmail(&#39;alex@example.com&#39;); //true\r\n    isEmail(&#39;alireza@test.co.uk&#39;); //true\r\n    isEmail(&#39;peter.example@yahoo.com.au&#39;); //true\r\n    isEmail(&#39;alex@example.com&#39;); //true\r\n    isEmail(&#39;peter_123@news.com&#39;); //true\r\n    isEmail(&#39;hello7___@ca.com.pt&#39;); //true\r\n    isEmail(&#39;example@example.co&#39;); //true\r\n    isEmail(&#39;hallo@example.coassjj#sswzazaaaa&#39;); //false\r\n    isEmail(&#39;hallo2ww22@example....caaaao&#39;); //false\r\n"},{"score":9,"body_markdown":"**Wikipedia standard mail syntax :**\r\n\r\nhttps://en.wikipedia.org/wiki/Email_address#Examples\r\nhttps://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte\r\n\r\n\tfunction validMail(mail)\r\n\t{\r\n\t\treturn /^(([^&lt;&gt;()\\[\\]\\.,;:\\s@\\&quot;]+(\\.[^&lt;&gt;()\\[\\]\\.,;:\\s@\\&quot;]+)*)|(\\&quot;.+\\&quot;))@(([^&lt;&gt;()\\.,;\\s@\\&quot;]+\\.{0,1})+([^&lt;&gt;()\\.,;:\\s@\\&quot;]{2,}|[\\d\\.]+))$/.test(mail);\r\n\t}\r\n\r\n\t// VALID MAILS\r\n\r\n\tvalidMail(&#39;Abc@example.com&#39;) // Return true\r\n\tvalidMail(&#39;Abc@example.com.&#39;) // Return true\r\n\tvalidMail(&#39;Abc@10.42.0.1&#39;) // Return true\r\n\tvalidMail(&#39;user@localserver&#39;) // Return true\r\n\tvalidMail(&#39;Abc.123@example.com&#39;) // Return true\r\n\tvalidMail(&#39;user+mailbox/department=shipping@example.com&#39;) // Return true\r\n\tvalidMail(&#39;&quot;very.(),:;&lt;&gt;[]\\&quot;.VERY.\\&quot;very@\\\\ \\&quot;very\\&quot;.unusual&quot;@strange.example.com&#39;) // Return true\r\n\tvalidMail(&#39;!#$%&amp;\\&#39;*+-/=?^_`.{|}~@example.com&#39;) // Return true\r\n\tvalidMail(&#39;&quot;()&lt;&gt;[]:,;@\\\\\\&quot;!#$%&amp;\\&#39;-/=?^_`{}| ~.a&quot;@example.org&#39;) // Return true\r\n\tvalidMail(&#39;&quot;Abc@def&quot;@example.com&#39;) // Return true\r\n\tvalidMail(&#39;&quot;Fred Bloggs&quot;@example.com&#39;) // Return true\r\n\tvalidMail(&#39;&quot;Joe.\\\\Blow&quot;@example.com&#39;) // Return true\r\n\tvalidMail(&#39;Lo&#239;c.Accentu&#233;@voil&#224;.fr&#39;) // Return true\r\n\tvalidMail(&#39;&quot; &quot;@example.org&#39;) // Return true\r\n\tvalidMail(&#39;user@[IPv6:2001:DB8::1]&#39;) // Return true\r\n\r\n\t// INVALID MAILS\r\n\r\n\tvalidMail(&#39;Abc.example.com&#39;) // Return false\r\n\tvalidMail(&#39;A@b@c@example.com&#39;) // Return false\r\n\tvalidMail(&#39;a&quot;b(c)d,e:f;g&lt;h&gt;i[j\\k]l@example.com&#39;) // Return false\r\n\tvalidMail(&#39;just&quot;not&quot;right@example.com&#39;) // Return false\r\n\tvalidMail(&#39;this is&quot;not\\allowed@example.com&#39;) // Return false\r\n\tvalidMail(&#39;this\\ still\\&quot;not\\\\allowed@example.com&#39;) // Return false\r\n\tvalidMail(&#39;john..doe@example.com&#39;) // Return false\r\n\tvalidMail(&#39;john.doe@example..com&#39;) // Return false\r\n\r\n**Show this test : https://regex101.com/r/LHJ9gU/1**"},{"score":2,"body_markdown":"ES6 sample\r\n\r\n    const validateEmail=(email)=&gt; /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/.test(email);"},{"score":0,"body_markdown":"Now ReactNative Version 0.46 Use Below code for email Validation.\r\n\r\n     validateEmail = (email) =&gt; {\r\n         var re = /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n         if (re.test(email)) {\r\n         } else {\r\n           alert(&#39;email: &#39; + &quot;Please enter valid emailID.&quot;)\r\n         }\r\n     }\r\n "},{"score":5,"body_markdown":"You can also try\r\n\r\n    var string = &quot;hmharsh3@gmail.com&quot;\r\n    var exp = /(\\w(=?@)\\w+\\.{1}[a-zA-Z]{2,})/i\r\n    alert(exp.test(string))"},{"score":14,"body_markdown":"Regex update 2018! try this\r\n\r\n    let val = &#39;email@domain.com&#39;;\r\n    if(/^[a-z0-9][a-z0-9-_\\.]+@([a-z]|[a-z0-9]?[a-z0-9-]+[a-z0-9])\\.[a-z0-9]{2,10}(?:\\.[a-z]{2,10})?$/.test(val)) {\r\n       console.log(&#39;passed&#39;);\r\n    }\r\n\r\ntypscript version complete\r\n\r\n    //\r\n    export const emailValid = (val:string):boolean =&gt; /^[a-z0-9][a-z0-9-_\\.]+@([a-z]|[a-z0-9]?[a-z0-9-]+[a-z0-9])\\.[a-z0-9]{2,10}(?:\\.[a-z]{2,10})?$/.test(val);\r\n\r\n\r\nmore info https://git.io/vhEfc"},{"score":1,"body_markdown":"     &lt;input type=&quot;email&quot; class=&quot;form-control&quot; required=&quot;required&quot; placeholder=&quot;Email Address&quot; name=&quot;Email&quot; id=&quot;Email&quot; autocomplete=&quot;Email&quot;&gt;\r\n     &lt;button class=&quot;btn-1 shadow-0 full-width&quot; type=&quot;button&quot; id=&quot;register&quot;&gt;Register account&lt;/button&gt;\r\n &lt;script&gt;\t\r\n\t           \r\n     $(&quot;#register&quot;).click(function(){\t\t\r\n\t\tvar rea = /^[a-zA-Z0-9.!#$%&amp;&#39;*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\r\n\t\tvar Email = $(&quot;#Email&quot;).val();\r\n\t\tvar x = rea.test(Email);\r\n\t\tif (!x) {\r\n\t\t\talert(&#39;Type Your valid Email&#39;);\r\n\t\t\treturn false;\r\n\t\t}\t\t\t\r\n     &lt;/script&gt;"},{"score":2,"body_markdown":"Here&#39;s a simple  regex that would just check for the basic format of an email e.g., `X@Y.C`:\r\n\r\n`\\S+@\\S+\\.\\S+`"},{"score":2,"body_markdown":"This question is more dificult to answer than seems at first sight.\r\n\r\nThere were loads of people around the world looking for &quot;the regex to rule them all&quot; but the truth is that there are tones of email providers.\r\n\r\nWhat&#39;s the problem? Well, &quot;a_z%@gmail.com cannot exists but it may exists an address like that through another provider &quot;a__z@provider.com.\r\n\r\nWhy? \r\nAccording to the RFC:\r\nhttps://en.wikipedia.org/wiki/Email_address#RFC_specification.\r\n\r\nI&#39;ll take an excerpt to facilitate the lecture:\r\n\r\n    The local-part of the email address may use any of these ASCII characters:\r\n    \r\n    - uppercase and lowercase Latin letters A to Z and a to z;\r\n    - digits 0 to 9;\r\n    - special characters !#$%&amp;&#39;*+-/=?^_`{|}~;\r\n    - dot ., provided that it is not the first or last character unless quoted, and provided also that it does not appear consecutively unless quoted (e.g. John..Doe@example.com is not allowed but &quot;John..Doe&quot;@example.com is allowed);[6]\r\n    Note that some mail servers wildcard local parts, typically the characters following a plus and less often the characters following a minus, so fred+bah@domain and fred+foo@domain might end up in the same inbox as fred+@domain or even as fred@domain. This can be useful for tagging emails for sorting, see below, and for spam control. Braces { and } are also used in that fashion, although less often.\r\n    - space and &quot;(),:;&lt;&gt;@[\\] characters are allowed with restrictions (they are only allowed inside a quoted string, as described in the paragraph below, and in addition, a backslash or double-quote must be preceded by a backslash);\r\n    - comments are allowed with parentheses at either end of the local-part; e.g. john.smith(comment)@example.com and (comment)john.smith@example.com are both equivalent to john.smith@example.com.\r\n\r\nSo, i can own an email address like that:\r\n\r\n    A__z/J0hn.sm{it!}h_comment@example.com.co\r\nIf you try this address i bet it will fail in all or the major part of regex posted all across the net. But remember this address follows the RFC rules so it&#39;s fair valid.\r\n\r\nImagine my frustration at not being able to register anywhere checked with those regex!!\r\n\r\n**The only one who really can validate an email address is the provider of the email address.**\r\n\r\nHow to deal with, so?\r\n\r\nIt doesn&#39;t matter if a user adds a non-valid e-mail in almost all cases. You can rely on HTML 5 input type=&quot;email&quot; that is running **near** to RFC, little chance to fail.\r\nHTML5 input type=&quot;email&quot; info: https://www.w3.org/TR/2012/WD-html-markup-20121011/input.email.html\r\n\r\nFor example, this is an RFC valid email:\r\n\r\n    &quot;very.(),:;&lt;&gt;[]\\&quot;.VERY.\\&quot;very@\\\\ \\&quot;very\\&quot;.unusual&quot;@strange.example.com\r\nBut the html5 validation will tell you that the text before @ must not contain &quot; or () chars for example, which is actually incorrect.\r\n\r\nAnyway, you should do this by accepting the email address and sending an email message to that email address, with a code/link the user must visit to confirm validity.\r\n\r\nA good practice while doing this is the &quot;enter your e-mail again&quot; input to avoid user typing errors. If this is not enough for you, add a pre-submit modal-window with a title &quot;is this your current e-mail?&quot;, then the mail entered by the user inside an h2 tag, you know, to show clearly which e-mail they entered, then a &quot;yes, submit&quot; button."},{"score":8,"body_markdown":"**How to write Particular Regular Expression in android or java.**\r\n\r\n1) `USER_NAME = &quot;^[A-Za-z0-9_-]{min number of character,max number of character}$&quot;;`\r\n\r\n2) `TELEPHONE = &quot;(^\\\\+)?[0-9()-]*&quot;;`\r\n\r\n3) `TELEPHONE_OPTIONAL = &quot;^($|(^\\\\+)?[0-9()-]*)$&quot;;`\r\n\r\n4) `EMAIL = &quot;[a-zA-Z0-9_\\\\.\\\\+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-\\\\.]+&quot;;`\r\n\r\n5) `EMAIL_OPTIONAL = &quot;^($|[a-zA-Z0-9_\\\\.\\\\+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-\\\\.]+)$&quot;;`\r\n\r\n6) `WEB_URL = &quot;^($|(http:\\\\/\\\\/|https:\\\\/\\\\/)?(www.)?([a-zA-Z0-9]+).[a-zA-Z0-9]*.[a-z]{3}.?([a-z]+)?)$&quot;;`\r\n\r\n7) `WEB_URL_YOUTUBE_BE = &quot;https?\\\\:\\\\/\\\\/(www\\\\.)?youtu(\\\\.)?be(\\\\.com)?\\\\/.*(\\\\?v=|\\\\/v\\\\/)?[a-zA-Z0-9_\\\\-]+&quot;;`\r\n\r\n8) `POSTAL_ADDRESS = &quot;[a-zA-Z\\\\d\\\\s\\\\-\\\\,\\\\#\\\\.\\\\+]+&quot;;`\r\n\r\n9) `FIELD_NOT_EMPTY = &quot;[^\\\\s]*&quot;;`\r\n\r\n10) `PINCODE = &quot;^([0-9]{6})?$&quot;;`\r\n\r\n11) `IFSC_CODE = &quot;^[^\\\\s]{4}\\\\d{7}$&quot;;`\r\n\r\n12) `SWIFT_CODE = &quot;^([0-9]{10})?$&quot;;`\r\n\r\n13) `PINCODE = &quot;^([0-9]{6})?$&quot;;`"},{"score":6,"body_markdown":"This is a JavaScript translation of the validation suggested by the official Rails guide used by thousands of websites:\r\n\r\n    /^([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})$/i\r\n\r\nRelatively simple but tests against most common errors.\r\n\r\nTested on a dataset of thousands of emails and it had zero false negatives/positives.\r\n\r\nExample usage:\r\n\r\n\r\n    const emailRegex = /^([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})$/i;\r\n\r\n    emailRegex.test(&#39;email@example.com&#39;);    // true\r\n\r\n    // Multi-word domains\r\n    emailRegex.test(&#39;email@example.co.uk&#39;);  // true\r\n    emailRegex.test(&#39;email@mail.gmail.com&#39;); // true\r\n\r\n    // Valid special characters\r\n    emailRegex.test(&#39;unusual+but+valid+email1900=/!#$%&amp;\\&#39;*+-/=?^_`.{|}~@example.com&#39;) // true\r\n\r\n    // Trailing dots\r\n    emailRegex.test(&#39;email@example.co.uk.&#39;); // false\r\n\r\n    // No domain\r\n    emailRegex.test(&#39;email@example&#39;);        // false\r\n\r\n    // Leading space\r\n    emailRegex.test(&#39; email@example.com&#39;);   // false\r\n\r\n    // Trailing space\r\n    emailRegex.test(&#39;email@example.com &#39;);   // false\r\n\r\n    // Incorrect domains\r\n    emailRegex.test(&#39;email@example,com &#39;);   // false\r\n\r\n    // Other invalid emails\r\n    emailRegex.test(&#39;invalid.email.com&#39;)        // false\r\n    emailRegex.test(&#39;invalid@email@domain.com&#39;) // false\r\n    emailRegex.test(&#39;email@example..com&#39;)       // false\r\n"},{"score":0,"body_markdown":"Here is a solution that works and includes validation/notification fuctionality in a form:\r\n\r\nYou can run it [at this link](https://codepen.io/aabiro/pen/eyGJMV)\r\n\r\n***JAVASCRIPT***\r\n\r\n    (function() {\r\n      &#39;use strict&#39;;\r\n\r\n      window.addEventListener(&#39;load&#39;, function() {\r\n        var form = document.getElementById(&#39;needs-validation&#39;);\r\n        form.addEventListener(&#39;submit&#39;, function(event) {\r\n          if (form.checkValidity() === false) {\r\n            event.preventDefault();\r\n          }\r\n          form.classList.add(&#39;was-validated&#39;);\r\n          event.preventDefault();              \r\n        }, false);\r\n      }, false);\r\n    })();\r\n\r\n\r\n***HTML***\r\n\r\n\r\n    &lt;p class=&#39;title&#39;&gt;\r\n        &lt;b&gt;Email validation&lt;/b&gt;\r\n      &lt;hr size=&quot;30px;&quot;&gt;\r\n    &lt;/p&gt;\r\n    &lt;br&gt;\r\n\r\n    &lt;form id=&quot;needs-validation&quot; novalidate&gt;\r\n      &lt;p class=&#39;form_text&#39;&gt;Try it out!&lt;/p&gt;\r\n      &lt;div class=&quot;form-row&quot;&gt;\r\n        &lt;div class=&quot;col-12&quot;&gt;\r\n          &lt;input type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;Email Address&quot; required&gt;\r\n            &lt;div class=&quot;invalid-feedback&quot;&gt;\r\n              Please enter a valid email address.\r\n            &lt;/div&gt;\r\n        &lt;/div&gt;\r\n      &lt;div class=&quot;row&quot;&gt;\r\n        &lt;div class=&quot;col-12&quot;&gt;\r\n          &lt;button type=&quot;submit&quot; \r\n              class=&quot;btn btn-default btn-block&quot;&gt;Sign up now\r\n          &lt;/button&gt;\r\n        &lt;/div&gt;\r\n       &lt;/div&gt;\r\n    &lt;/form&gt;\r\n\r\n\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":0,"body_markdown":"I wrote a JavaScript email validator which is fully compatile with PHP&#39;s `filter_var($value, FILTER_VALIDATE_EMAIL)` implementation.\r\n\r\nhttps://github.com/mpyw/FILTER_VALIDATE_EMAIL.js\r\n\r\n    import validateEmail from &#39;filter-validate-email&#39;\r\n\r\n    const value = &#39;...&#39;\r\n    const result = validateEmail(value)\r\n\r\nis equivalent to:\r\n\r\n    &lt;?php\r\n\r\n    $value = &#39;...&#39;;\r\n    $result = (bool)filter_var($value, FILTER_VALIDATE_EMAIL, FILTER_FLAG_EMAIL_UNICODE);\r\n\r\n"},{"score":-2,"body_markdown":"    function ValidateEmail(mail) \r\n    {\r\n      if (/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(myForm.emailAddr.value))\r\n      {\r\n        return (true)\r\n      }\r\n      alert(&quot;You have entered an invalid email address!&quot;)\r\n      return (false)\r\n    }\r\n\r\nRef URL: https://www.w3resource.com/javascript/form/email-validation.php"},{"score":-2,"body_markdown":"This works for me:\r\n\r\n    function Email(mail)\r\n    {\r\n     if (/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(myForm.emailAddr.value))\r\n      {\r\n        return (true)\r\n      }\r\n        alert(&quot;Invalid email address!&quot;)\r\n        return (false)\r\n    }"},{"score":-3,"body_markdown":"The personal_info part contains the following ASCII characters. \r\n\r\n 1. Uppercase (A-Z) and lowercase (a-z) English letters. Digits (0-9).\r\n 2. Characters ! # $&#160;% &amp; &#39; * + - / =&#160;? ^ _ ` { | } ~ \r\n 3. Character . ( period, dot or fullstop) provided that it is not the\r\n    first or last character and it will not come one after the other.\r\n\r\n \r\nThe domain name [for example com, org, net, in, us, info] part contains letters, digits, hyphens, and dots. \r\n\r\n   \r\n\r\n     function ValidateEmail(mail) \r\n    {\r\n     if (/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(myForm.emailAddr.value))\r\n      {\r\n        return (true)\r\n      }\r\n        alert(&quot;You have entered an invalid email address!&quot;)\r\n        return (false)\r\n    }\r\n\r\n"},{"score":-2,"body_markdown":"You could also use the New `Regex` class and make this way:\r\n\r\n`function validateEmail( str ) {\r\n    return new RegExp( /([\\w\\.\\-_]+)?\\w+@[\\w-_]+(\\.\\w+){1,}/, &#39;igm&#39; ).test( str );\r\n}` \r\n\r\nreference:\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"},{"score":2,"body_markdown":"Here is the recommended Regex pattern for HTML5 on MDN:\r\n\r\n&gt;Browsers that support the email input type automatically provide validation to ensure that only text that matches the standard format for Internet e-mail addresses is entered into the input box. Browsers that implement the specification should be using an algorithm equivalent to the following regular expression:\r\n\r\n    /^[a-zA-Z0-9.!#$%&amp;&#39;*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}\r\n    [a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\r\n\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#Validation"},{"score":0,"body_markdown":"You cold use https://github.com/chriso/validator.js and simply do:\r\n\r\n    var validator = require(&#39;validator&#39;);\r\n    \r\n    validator.isEmail(&#39;foo@bar.com&#39;); //=&gt; true\r\n\r\nNote that this can work on the client."},{"score":1,"body_markdown":"Here&#39;s how I do it. I&#39;m using match() to check for the standard email pattern and I&#39;m adding a class to the input text to notify the user accordingly. Hope that helps!\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $(document).ready(function(){\r\n      $(&#39;#submit&#39;).on(&#39;click&#39;, function(){\r\n          var email = $(&#39;#email&#39;).val();\r\n          var pat = /^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/;\r\n          if (email.match(pat)){\r\n            $(&#39;#email&#39;)\r\n              .addClass(&#39;input-valid&#39;);\r\n            return false;\r\n          } else {\r\n            $(&#39;#email&#39;)\r\n            \t.addClass(&#39;input-error&#39;)\r\n              .val(&#39;&#39;);\r\n            return false;\r\n          }\r\n      });\r\n    });\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n\r\n    .input-error {\r\n      border: 1px solid red;\r\n      color: red;\r\n    }\r\n\r\n    .input-valid {\r\n      border: 1px solid green;\r\n      color: green;\r\n    }\r\n\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;form&gt;\r\n        &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;name@service.xx&quot; class=&quot;&quot;&gt;\r\n        &lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;Send&quot;/&gt;\r\n    &lt;/form&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":-1,"body_markdown":"There is my version of an email validator. This code is done with object-oriented programming and realized as a class with static methods. You will find two versions of the validators: strict(`EmailValidator.validate`) and kind(`EmailValidator.validateKind`).\r\n\r\nThe first throws an error if an email is invalid and returns email otherwise. The second returns Boolean value that says if an email is valid. I prefer the strict version in most of the cases.\r\n\r\n```\r\nexport class EmailValidator {\r\n    /**\r\n     * @param {string} email\r\n     * @return {string}\r\n     * @throws {Error}\r\n     */\r\n    static validate(email) {\r\n        email = this.prepareEmail(email);\r\n\r\n        const isValid = this.validateKind(email);\r\n\r\n        if (isValid)\r\n            return email;\r\n\r\n        throw new Error(`Got invalid email: ${email}.`);\r\n    }\r\n\r\n    /**\r\n     * @param {string} email\r\n     * @return {boolean}\r\n     */\r\n    static validateKind(email) {\r\n        email = this.prepareEmail(email);\r\n\r\n        const regex = this.getRegex();\r\n\r\n        return regex.test(email);\r\n    }\r\n\r\n    /**\r\n     * @return {RegExp}\r\n     * @private\r\n     */\r\n    static getRegex() {\r\n        return /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n    }\r\n\r\n    /**\r\n     * @param {string} email\r\n     * @return {string}\r\n     * @private\r\n     */\r\n    static prepareEmail(email) {\r\n        return String(email).toLowerCase();\r\n    }\r\n}\r\n```\r\n\r\nTo validate an email you can follow these ways:\r\n\r\n```\r\n// First way.\r\n\r\ntry {\r\n    EmailValidator.validate(&#39;balovbohdan@gmail.com&#39;);\r\n} catch (e) {\r\n    console.error(e.message);\r\n}\r\n```\r\n\r\n```\r\n// Second way.\r\n\r\nconst email = &#39;balovbohdan@gmail.com&#39;;\r\nconst isValid = EmailValidator.validateKind(email);\r\n\r\nif (isValid)\r\n    console.log(`Email is valid: ${email}.`);\r\nelse\r\n    console.log(`Email is invalid: ${email}.`);\r\n```\r\n\r\n"},{"score":-1,"body_markdown":"I am using this function \r\n\r\n    /**\r\n     * @param {*} email\r\n     */\r\n    export const validateEmail = email =&gt; {\r\n    \treturn new RegExp(/[\\w-]+@([\\w-]+\\.)+[\\w-]+/gm).test(email);\r\n    };"},{"score":1,"body_markdown":"General email regex (RFC 5322 Official Standard): https://emailregex.com/\r\n\r\nJavaScript:\r\n\r\n```\r\n/^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\r\n```\r\n"},{"score":2,"body_markdown":"Search for the @ sign in the input field. "},{"score":0,"body_markdown":"If you want something a human can read and **maintain**, I would recommend [Masala Parser][1] (I&#39;m one of the creators of it).\r\n\r\n```js\r\nimport {C,Streams} from &#39;@masala/parser&#39;\r\n\r\nconst illegalCharset = &#39; @\\u00A0\\n\\t&#39;;\r\nconst extendedIllegalCharset = illegalCharset + &#39;.&#39;;\r\n\r\n\r\n// Assume &#39;nicolas@internal.masala.co.uk&#39;\r\nexport function simpleEmail() {\r\n\r\n    return C.charNotIn(illegalCharset).rep() // &#39;nicolas&#39;\r\n        .then(C.char(&#39;@&#39;))\r\n        .then(subDns())  //&#39;internal.masala.co.&#39;\r\n        .then(C.charNotIn(extendedIllegalCharset).rep()) //&#39;uk&#39;\r\n        .eos(); // Must be end of the char stream\r\n}\r\n\r\n// x@internal.masala.co.uk =&gt; extract &#39;internal.masala.co.&#39;\r\nfunction  subDns() {\r\n    return C.charNotIn(extendedIllegalCharset).rep().then(C.char(&#39;.&#39;)).rep()\r\n}\r\n\r\nfunction validateEmail(email:string) {\r\n    console.log(email + &#39;: &#39; + (simpleEmail().parse(Streams.ofString(email)).isAccepted()));\r\n}\r\n\r\n\r\nvalidateEmail(&#39;nicolas@internal.masala.co.uk&#39;); // True\r\nvalidateEmail(&#39;nz@co.&#39;); // False, trailing &quot;.&quot;\r\n```\r\n\r\nIf you want to accept the ultimate ugly email version, you can add in quotes in the first part:\r\n\r\n```js\r\n\r\nfunction inQuote() {\r\n    return C.char(&#39;&quot;&#39;)\r\n        .then(C.notChar(&#39;&quot;&#39;).rep())\r\n        .then(C.char(&#39;&quot;&#39;))\r\n}\r\n\r\nfunction allEmail() {\r\n\r\n    return inQuote().or(C.charNotIn(illegalCharset))\r\n        .rep() // repeat (inQuote or anyCharacter)\r\n        .then(C.char(&#39;@&#39;))\r\n        .then(subDns())\r\n        .then(C.charNotIn(extendedIllegalCharset).rep())\r\n        .eos() // Must be end of the character stream\r\n        // Create a structure\r\n        .map(function (characters) { return ({ email: characters.join(&#39;&#39;) }); });\r\n}\r\n```\r\n\r\n`&#39;&quot;nicolas&quot;&quot;love-quotes&quot;@masala.co.uk&#39;` is officially valid, but should it be in your system?\r\n\r\nAt least with Masala, you give yourself a chance to understand it. And so for the next year, colleague.\r\n\r\n  [1]: https://github.com/masala-oss/masala-parser\r\n\r\n"},{"score":2,"body_markdown":"I add my Regex - i solved for me more little issues like characters from other languages or capital letters \r\n\r\n    ^[a-zA-Z0-9][a-zA-Z0-9-_\\.]+@([a-zA-Z]|[a-zA-Z0-9]?[a-zA-Z0-9-]+[a-zA-Z0-9])\\.[a-zA-Z0-9]{2,10}(?:\\.[a-zA-Z]{2,10})?$"},{"score":1,"body_markdown":"Use the browser/runtime to handle parsing the input by prepending a protocol and pass it to the `URL` API, trapping any errors and check the resulting `username` and `hostname` properties of the result. It will handle basically all transformations and possibilities ([punycode][1] of character sets, etc). This only establishes that the input is parsable, not that is valid--that is only possible through checking if the destination machine receives messages for that alias. This provides a close (imo reasonable) guess though, and can be expanded to be more specific and realistic if you&#39;re comfortable both maintaining it and also risking invalid rejections. (Note it doesn&#39;t attempt to address IPv4 or IPv6 addresses, simply the broad range of customer-facing scenarios using a domain.)\r\n\r\n    function validEmail(email=&#39;&#39;){\r\n        var $0, url, isValid = false, emailPatternInput = /^[^@]{1,64}@[^@]{4,253}$/, emailPatternUrl = /^[^@]{1,64}@[a-z][a-z0-9\\.-]{3,252}$/i;\r\n    \temail = email.trim();\r\n        try{\r\n            url = new URL(&#39;http://&#39;+email);\r\n            $0 = `${url.username}@${url.hostname}`;\r\n    \t\tisValid = emailPatternInput.test( email );\r\n            if(!isValid) throw &#39;invalid email pattern on input:&#39; + email;\r\n            isValid = emailPatternUrl.test( $0 );\r\n            if(!isValid) throw &#39;invalid email pattern on url:&#39; + $0;\r\n            console.log(`email looks legit &quot;${email}&quot; checking url-parts: &quot;${$0 === email ? &#39;-SAME-&#39;:$0}&quot;`);\r\n        }catch(err){\r\n            console.error(`probably not an email address: &quot;${email}&quot;`, err);\r\n        };\r\n        return isValid;\r\n    }\r\n    \r\n    [&#39;user+this@はじめよう.みんな&#39;, &#39;stuff@things&#39;, &#39;user+that@host.com&#39;, &#39;Jean+Fran&#231;ois@anydomain.museum&#39;,&#39;هيا@יאללה&#39;, &#39;试@例子.测试.مثال.آزمایشی&#39;, &#39;not@@really&#39;, &#39;no&#39;].forEach(email=&gt;console.log(validEmail(email), email));\r\n\r\nThis is the both the simplest and most generally permissive example I can come up with. Please edit it in cases where it can be made to be more accurate while maintain its simplicity and reasonable generally permissive validity.\r\n\r\nAlso see MDN URL docs [URL][2], [window.URL][3] and Nodejs for [URL][4] APIs.\r\n\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Punycode\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/API/URL\r\n  [4]: https://nodejs.org/api/url.html\r\n\r\n"},{"score":-1,"body_markdown":"for email validation you can create your custom function and use regex syntax for validate email:\r\n\r\n    function validateEmail(email){\r\n            var reg = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/;\r\n            \r\n           //your custom code here to check your email address \r\n     \r\n    }\r\n"},{"score":0,"body_markdown":"These will work with the top used emails(**they match exactly the rules of each one**).\r\n&lt;br&gt;&lt;br&gt;\r\n**Gmail**\r\n&lt;br&gt;\r\n`/^[a-z]((?!\\.\\.)([a-z\\.])){4,28}[a-z0-9]@gmail.com$/i`\r\n&lt;br&gt;&lt;br&gt;\r\n**Yahoo**\r\n&lt;br&gt;\r\n`/^[a-z]((?!\\.\\.)([\\w\\.])){3,30}[\\w]@yahoo.com$/i`\r\n&lt;br&gt;&lt;br&gt;\r\n**Outlook**/**Hotmail**\r\n&lt;br&gt;\r\n`/[a-z]((?!\\.\\.)([\\w\\.])){0,62}[\\w]@(outlook.com|hotmail.com)$/i`"},{"score":1,"body_markdown":"You may try `RegExp`\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function isValidEmail( value ) {\r\n    \treturn /^[\\w\\-\\.\\+]+\\@[a-zA-Z0-9\\.\\-]+\\.[a-zA-z0-9]{2,5}$/.test( value );\r\n    }\r\n\r\n    console.log( isValidEmail(&quot;mymail@mydomain.com&quot;) )\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":-1,"body_markdown":"In my case i want to avoid ~ and # that&#39;s why i have use another solution [Click Here][1] For more information \r\n\r\n    function validEmail(email){\r\n      const regex = /^((?!\\.)[\\w-_.]*[^.])(@\\w+)(\\.\\w+(\\.\\w+)?[^.\\W])$/;\r\n      return regex.test(email);\r\n    }\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function validEmail(email){\r\n      const regex = /^((?!\\.)[\\w-_.]*[^.])(@\\w+)(\\.\\w+(\\.\\w+)?[^.\\W])$/;\r\n      return regex.test(email);\r\n    }\r\n\r\n    const emails = [\r\n    &#39;pio_pio@factory.com&#39;,\r\n    &#39;~pio_pio@factory.com&#39;,\r\n    &#39;pio_~pio@factory.com&#39;,\r\n    &#39;pio_#pio@factory.com&#39;,\r\n    &#39;pio_pio@#factory.com&#39;,\r\n    &#39;pio_pio@factory.c#om&#39;,\r\n    &#39;pio_pio@factory.c*om&#39;,\r\n    &#39;pio^_pio@factory.com&#39;\r\n    ]\r\n\r\n    for(const email of emails){\r\n      document.write(email+&#39; : &#39;+validEmail(email)+&#39;&lt;/br&gt;&#39;);\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://regex101.com/r/SOgUIV/1"},{"score":4,"body_markdown":"Use `W3C` especially created regular expression.\r\n\r\nReference with full explanation of the `RegEx`:\r\n\r\nhttps://www.w3resource.com/javascript/form/email-validation.php\r\n\r\n    /^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(emailValue)\r\n\r\nIf you use Node you can use this in the back-end as well as the front-end.\r\n\r\nI don&#39;t know other back-end languages so I cannot evaluate for other use cases."},{"score":4,"body_markdown":"Wow there are a lot of answers that contain slightly different regular expressions. I&#39;ve tried some many that I&#39;ve got different results and a variety of different issues with all of them.\r\n\r\nFor UI validation, I&#39;m good with the most basic check of [looking for an @ sign][1]. It&#39;s important to note, that I always do server-side validation with a standard &quot;validate email&quot; that contains a unique link for the user to confirm their email address.\r\n\r\n    if (email.indexOf(&#39;@&#39;) &gt; 0)\r\n\r\nI have purposely chosen 0 even with zero-based as it also ensures there is a single character before the @.\r\n\r\n\r\n  [1]: https://www.endyourif.com/validate-an-email-address-in-javascript/"},{"score":5,"body_markdown":"I prefer to keep it simple and keep my users happy.  I also prefer code which is easy to understand. RegEx is not.\r\n\r\n    function isValidEmail(value) {\r\n        const atLocation = value.lastIndexOf(&quot;@&quot;);\r\n        const dotLocation = value.lastIndexOf(&quot;.&quot;); \r\n        return (\r\n            atLocation &gt; 0 &amp;&amp;\r\n            dotLocation &gt; atLocation + 1 &amp;&amp;\r\n            dotLocation &lt; value.length - 1\r\n        );\r\n    };\r\n\r\n - Get the location of the last &quot;@&quot; and the last &quot;.&quot;\r\n - Make sure the &quot;@&quot; is not the first char (there is something before it) \r\n - Make sure the &quot;.&quot; is after the &quot;@&quot; and that there is at least one char between them\r\n - Make sure there is at least a single char after the &quot;.&quot;\r\n\r\nWill this allow invalid email addresses to pass?  Sure, but I don&#39;t think you need much more for a good user experience that allows you to enable/disable a button, display an error message, etc.  You only know for sure that an email address is valid when you attempt to send an email to that address."},{"score":0,"body_markdown":"If you get this error: Using regular expressions is security-sensitive.\r\n\r\nThen here is what you are looking for.This solution is free from &quot; Regular expression Denial of Service (ReDoS) &quot;\r\n\r\nRegex to validate emails without (ReDoS): \r\n\r\n    /^[a-z0-9](?!.*?[^\\na-z0-9]{2})[^\\s@]+@[^\\s@]+\\.[^\\s@]+[a-z0-9]$/\r\n\r\nPlease let me know if this solutions works for you.\r\nThanks."},{"score":0,"body_markdown":"```\r\nif (rules.isEmail) {\r\n            const pattern = /[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;\r\n            isValid = pattern.test(value) &amp;&amp; isValid\r\n        }\r\n```\r\nYou can use this for Email validaiton ."},{"score":4,"body_markdown":"Most of the answers here are not linter friendly, it&#39;s a mess! Some of them are also out-dated!\r\nAfter a lot of time spending, I decided to use an external library named `email-validator`, install it easily by npm for example and import/require it in your own project:\r\n\r\nhttps://www.npmjs.com/package/email-validator\r\n\r\n    //NodeJs\r\n    const validator = require(&quot;email-validator&quot;);\r\n    validator.validate(&quot;test@email.com&quot;); // true\r\n    \r\n    //TypeScript/JavaScript\r\n    import * as EmailValidator from &#39;email-validator&#39;;\r\n    EmailValidator.validate(&quot;test@email.com&quot;); // true\r\n"},{"score":0,"body_markdown":"         // Html form call function name at submit button\r\n    \r\n        &lt;form name=&quot;form1&quot; action=&quot;#&quot;&gt; \r\n        &lt;input type=&#39;text&#39; name=&#39;text1&#39;/&gt;\r\n        &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; \r\n        onclick=&quot;ValidateEmail(document.form1.text1)&quot;/&gt;\r\n       &lt;/from&gt;\r\n    \r\n        // Write the function name ValidateEmail below\r\n    \r\n        &lt;script&gt;\r\n         function ValidateEmail(inputText)\r\n        {\r\n      var mailformat = /^[a-zA-Z0-9.!#$%&amp;&#39;*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\r\n        if(inputText.value.match(mailformat))\r\n        {\r\n        alert(&quot;Valid email address!&quot;);\r\n        document.form1.text1.focus();\r\n        return true;\r\n        }\r\n        else\r\n       {\r\n        alert(&quot;You have entered an invalid email address!&quot;);\r\n        document.form1.text1.focus();\r\n        return false;\r\n        }\r\n        }\r\n       &lt;/script&gt;"}],"score":4639}