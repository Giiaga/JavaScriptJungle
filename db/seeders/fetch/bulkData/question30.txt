{"body":"I saw some code that seems to use an operator I don&#39;t recognize, in the form of two exclamation points, like so: `!!`. Can someone please tell me what this operator does?\r\n\r\nThe context in which I saw this was,\r\n\r\n    this.vertical = vertical !== undefined ? !!vertical : this.vertical;","title":"What is the !! (not not) operator in JavaScript?","answers":[{"score":2901,"body_markdown":"Converts `Object` to `boolean`. If it was falsey (e.g. `0`, `null`, `undefined`, etc.), it will be `false`, otherwise, `true`.\r\n\r\n    !oObject  // inverted boolean\r\n    !!oObject // non inverted boolean so true boolean representation\r\n\r\nSo `!!` is not an operator, it&#39;s just the `!` operator twice.\r\n\r\nReal World Example &quot;Test IE version&quot;:  \r\n\r\n    const isIE8 = !! navigator.userAgent.match(/MSIE 8.0/);  \r\n    console.log(isIE8); // returns true or false \r\n\r\nIf you ⇒\r\n  \r\n    console.log(navigator.userAgent.match(/MSIE 8.0/));  \r\n    // returns either an Array or null  \r\n\r\nBut if you ⇒\r\n\r\n    console.log(!!navigator.userAgent.match(/MSIE 8.0/));  \r\n    // returns either true or false"},{"score":55,"body_markdown":"It&#39;s just the logical NOT operator, twice - it&#39;s used to convert something to boolean, e.g.:\r\n\r\n    true === !!10\r\n\r\n    false === !!0"},{"score":27,"body_markdown":"It seems that the `!!` operator results in a double negation.\r\n\r\n    var foo = &quot;Hello World!&quot;;\r\n    \r\n    !foo // Result: false\r\n    !!foo // Result: true\r\n"},{"score":11,"body_markdown":"I suspect this is a leftover from C++ where people override the ! operator but not the bool operator.\r\n\r\nSo to get a negative(or positive) answer in that case you would first need to use the ! operator to get a boolean, but if you wanted to check the positive case would use !!."},{"score":104,"body_markdown":"`!!` converts the value to the right of it to its equivalent boolean value. (Think poor man&#39;s way of &quot;type-casting&quot;). Its *intent* is usually to convey to the reader that the code does not care *what* value is in the variable, but what it&#39;s [&quot;truth&quot; value][1] is.\r\n\r\n\r\n  [1]: http://11heavens.com/falsy-and-truthy-in-javascript"},{"score":32,"body_markdown":"It converts the suffix to a Boolean value. "},{"score":876,"body_markdown":"It&#39;s a horribly obscure way to do a type conversion.\r\n\r\n`!` is _NOT_.  So `!true` is `false`, and `!false` is `true`. `!0` is `true`, and `!1` is `false`.\r\n\r\nSo you&#39;re converting a value to a boolean, then inverting it, then inverting it again.\r\n\r\n    // Maximum Obscurity:\r\n    val.enabled = !!userId;\r\n    \r\n    // Partial Obscurity:\r\n    val.enabled = (userId != 0) ? true : false;\r\n    \r\n    // And finally, much easier to understand:\r\n    val.enabled = (userId != 0);"},{"score":27,"body_markdown":"It&#39;s a double `not` operation.  The first `!` converts the value to boolean and inverts its logical value.  The second `!` inverts the logical value back."},{"score":21,"body_markdown":"! is &quot;boolean not&quot;, which essentially typecasts the value of &quot;enable&quot; to its boolean opposite. The second ! flips this value. So, `!!enable` means &quot;not not enable,&quot; giving you the value of `enable` as a boolean."},{"score":75,"body_markdown":"`!!foo` applies the unary not operator twice and is used to cast to boolean type similar to the use of unary plus `+foo` to cast to number and concatenating an empty string `&#39;&#39;+foo` to cast to string.\r\n\r\nInstead of these hacks, you can also use the constructor functions corresponding to the primitive types (*without* using `new`) to explicitly cast values, ie\r\n\r\n    Boolean(foo) === !!foo\r\n    Number(foo)  === +foo\r\n    String(foo)  === &#39;&#39;+foo"},{"score":16,"body_markdown":"It&#39;s not a single operator, it&#39;s two.  It&#39;s equivalent to the following and is a quick way to cast a value to boolean. \r\n\r\n    val.enabled = !(!enable);"},{"score":9,"body_markdown":"Double boolean negation. Often used to check if value is not undefined."},{"score":25,"body_markdown":"It simulates the behavior of the `Boolean()` casting function.\r\nThe first `NOT` returns a Boolean value no matter what operand it is given. The second `NOT` negates that `Boolean` value and so gives the `true` Boolean value of a variable. The end result is the same as using the `Boolean()` function on a value."},{"score":-4,"body_markdown":"This is a really handy way to check for undefined, &quot;undefined&quot;, null, &quot;null&quot;, &quot;&quot;\r\n\r\n    if (!!var1 &amp;&amp; !!var2 &amp;&amp; !!var3 &amp;&amp; !!var4 ){\r\n       //... some code here\r\n    }\r\n\r\n"},{"score":482,"body_markdown":"`!!expr` returns a Boolean value (`true` or `false`) depending on the *truthiness* of the expression. It makes more sense when used on non-boolean types. Consider these examples, especially the 3rd example and onward:\r\n\r\n              !!false === false\r\n               !!true === true\r\n\r\n                  !!0 === false\r\n    !!parseInt(&quot;foo&quot;) === false // NaN is falsy\r\n                  !!1 === true\r\n                 !!-1 === true  // -1 is truthy\r\n              !!(1/0) === true  // Infinity is truthy\r\n\r\n                 !!&quot;&quot; === false // empty string is falsy\r\n              !!&quot;foo&quot; === true  // non-empty string is truthy\r\n            !!&quot;false&quot; === true  // ...even if it contains a falsy value\r\n\r\n         !!window.foo === false // undefined is falsy\r\n               !!null === false // null is falsy\r\n\r\n                 !!{} === true  // an (empty) object is truthy\r\n                 !![] === true  // an (empty) array is truthy; PHP programmers beware!"},{"score":164,"body_markdown":"**Brew some tea:**\r\n\r\n`!!` is not an operator. It is the double-use of `!` -- which is the logical &quot;not&quot; operator. \r\n\r\n----------\r\n\r\n**In theory:**\r\n\r\n**`!`** determines the &quot;truth&quot; of what a value is not:\r\n\r\n - The truth is that `false` is not `true` (that&#39;s why `!false` results\r\n   in **`true`**)\r\n   \r\n - The truth is that `true` is not `false` (that&#39;s why `!true` results\r\n   in **`false`**)\r\n\r\n----------\r\n\r\n**`!!`** determines the &quot;truth&quot; of what a value is *not* not:\r\n\r\n - The truth is that `true` is not *not* `true` (that&#39;s why `!!true` results in **`true`**)\r\n\r\n - The truth is that `false` is not *not* `false` (that&#39;s why `!!false` results in **`false`**)\r\n\r\n----------\r\n\r\nWhat we wish to determine in the comparison is the &quot;truth&quot; *about* the value of a reference, not the *value of* the reference itself. There is a use-case where we might want to know the truth about a value, even if we expect the value to be *`false`* (or falsey), or if we expect the value not to be typeof `boolean`. \r\n\r\n----------\r\n\r\n**In practice:**\r\n\r\nConsider a concise function which detects feature functionality (and in this case, platform compatibility) by way of **[dynamic typing][1]** (aka &quot;duck typing&quot;). We want to write a function that returns `true` if a user&#39;s browser supports the HTML5 `&lt;audio&gt;` element, but we don&#39;t want the function to throw an error if `&lt;audio&gt;` is undefined; and we don&#39;t want to use `try ... catch` to handle any possible errors (because they&#39;re gross); *and also* we don&#39;t want to use a check inside the function that won&#39;t consistently reveal the truth about the feature (for example, `document.createElement(&#39;audio&#39;)` will still create an element called `&lt;audio&gt;` even if HTML5 `&lt;audio&gt;` is not supported). \r\n\r\n----------\r\n\r\nHere are the three approaches:\r\n\r\n    // this won&#39;t tell us anything about HTML5 `&lt;audio&gt;` as a feature\r\n    var foo = function(tag, atr) { return document.createElement(tag)[atr]; }\r\n    \r\n    // this won&#39;t return true if the feature is detected (although it works just fine)\r\n    var bar = function(tag, atr) { return !document.createElement(tag)[atr]; }\r\n    \r\n    // this is the concise, feature-detecting solution we want\r\n    var baz = function(tag, atr) { return !!document.createElement(tag)[atr]; }\r\n\r\n    foo(&#39;audio&#39;, &#39;preload&#39;); // returns &quot;auto&quot;\r\n    bar(&#39;audio&#39;, &#39;preload&#39;); // returns false\r\n    baz(&#39;audio&#39;, &#39;preload&#39;); // returns true\r\n\r\n\r\nEach function accepts an argument for a `&lt;tag&gt;` and an `attribute` to look for, but they each return different values based on what the comparisons determine. \r\n\r\n**But wait, there&#39;s more!**\r\n\r\nSome of you probably noticed that in this specific example, one could simply check for a property using the slightly **[more performant][2]** means of checking if the object in question *has* a property. There are two ways to do this:\r\n\r\n    // the native `hasOwnProperty` method\r\n    var qux = function(tag, atr) { return document.createElement(tag).hasOwnProperty(atr); }\r\n    \r\n    // the `in` operator\r\n    var quux = function(tag, atr) { return atr in document.createElement(tag); }\r\n    \r\n    qux(&#39;audio&#39;, &#39;preload&#39;);  // returns true\r\n    quux(&#39;audio&#39;, &#39;preload&#39;); // returns true\r\n\r\n**We digress...**\r\n\r\nHowever rare these situations may be, there may exist a few scenarios where the most concise, most performant, and thus most preferred means of getting `true` from a non-boolean, possibly undefined value is indeed by using `!!`. Hopefully this ridiculously clears it up.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Type_system#Dynamic_typing\r\n  [2]: http://jsperf.com/hasownproperty-vs-comparison\r\n"},{"score":16,"body_markdown":"The `!!` construct is a simple way of turning any JavaScript expression into\r\nits Boolean equivalent. \r\n\r\nFor example: `!!&quot;he shot me down&quot; === true` and `!!0 === false`."},{"score":8,"body_markdown":"Tons of great answers here, but if you&#39;ve read down this far, this helped me to &#39;get it&#39;. Open the console on Chrome (etc), and start typing:\r\n\r\n    !(!(1))\r\n    !(!(0))\r\n    !(!(&#39;truthy&#39;)) \r\n    !(!(null))\r\n    !(!(&#39;&#39;))\r\n    !(!(undefined))\r\n    !(!(new Object())\r\n    !(!({}))\r\n    woo = &#39;hoo&#39;\r\n    !(!(woo))\r\n    ...etc, etc, until the light goes on ;)\r\n\r\n\r\nNaturally, these are all the same as merely typing !!someThing, but the added parentheses might help make it more understandable."},{"score":2,"body_markdown":"    a = 1;\r\n    alert(!a) // -&gt; false : a is not not defined\r\n    alert(!!a) // -&gt; true : a is not not defined\r\n\r\nFor `!a`, it checks whether `a` is **NOT** defined, while `!!a` checks if the variable is defined.\r\n\r\n`!!a` is the same as `!(!a)`. If `a` is defined, `a` is `true`, `!a` is `false`, and `!!a` is `true`."},{"score":4,"body_markdown":"here is a piece of code from angular js \r\n\r\n \r\n\r\n    var requestAnimationFrame = $window.requestAnimationFrame ||\r\n                                    $window.webkitRequestAnimationFrame ||\r\n                                    $window.mozRequestAnimationFrame;\r\n    \r\n     var rafSupported = !!requestAnimationFrame;\r\n\r\n\r\ntheir intention is to set rafSupported to true or false based on the availability of function in requestAnimationFrame \r\n\r\nit can be achieved by checking in following way in general:\r\n\r\n    if(typeof  requestAnimationFrame === &#39;function&#39;)\r\n    rafSupported =true;\r\n    else\r\n    rafSupported =false;\r\n\r\nthe short way could be using !!\r\n\r\n    rafSupported = !!requestAnimationFrame ;\r\n\r\nso if requestAnimationFrame was assigned a function\r\n then\r\n!requestAnimationFrame would be false and one more ! of it would be true\r\n\r\nif requestAnimationFrame was assinged undefined then\r\n!requestAnimationFrame would be true and one more ! of it would be false"},{"score":70,"body_markdown":"So many answers doing half the work. Yes, `!!X` could be read as &quot;the truthiness of X [represented as a boolean]&quot;. But `!!` isn&#39;t, practically speaking, so important for figuring out whether a single variable is (or even if many variables are) truthy or falsy. `!!myVar === true` is the same as just `myVar`. Comparing `!!X` to a &quot;real&quot; boolean isn&#39;t really useful.\n\nWhat you gain with `!!` is the ability to check the truthiness of multiple variables *against each other* in a repeatable, standardized (and JSLint friendly) fashion.\n\n### Simply casting :(\n\nThat is...\n\n* `0 === false` is `false`. \n* `!!0 === false` is `true`.\n\nThe above&#39;s not so useful. `if (!0)` gives you the same results as `if (!!0 === false)`. I can&#39;t think of a good case for casting a variable to boolean and then comparing to a &quot;true&quot; boolean.\n\nSee &quot;== and !=&quot; from [JSLint&#39;s directions](http://old.jslint.com/lint.html) (note: Crockford is moving his site around a bit; that link is liable to die at some point) for a little on why:\n\n&gt; The == and != operators do type coercion before comparing. This is bad because it causes &#39; \\t\\r\\n&#39; == 0 to be true. This can mask type errors. JSLint cannot reliably determine if == is being used correctly, so it is best to not use == and != at all and to always use the more reliable === and !== operators instead.\n&gt; \n&gt; If you only care that a value is truthy or falsy, then use the short form. Instead of  \n&gt; `    (foo != 0)`\n&gt; \n&gt; just say  \n&gt; `    (foo)`\n&gt; \n&gt; and instead of  \n&gt; `    (foo == 0)`\n&gt; \n&gt; say  \n&gt;`     (!foo)`\n\nNote that there are some [unintuitive cases](https://stackoverflow.com/a/3619813/1028230) where a boolean will be cast to a number (`true` is cast to `1` and `false` to `0`) when comparing a boolean to a number. In this case, `!!` might be mentally useful. Though, again, **these are cases where you&#39;re comparing a non-boolean to a hard-typed boolean, which is, imo, a serious mistake.** `if (-1)` is still the way to go here.\n\n    ╔═══════════════════════════════════════╦═══════════════════╦═══════════╗\n    ║               Original                ║    Equivalent     ║  Result   ║\n    ╠═══════════════════════════════════════╬═══════════════════╬═══════════╣\n    ║ if (-1 == true) console.log(&quot;spam&quot;)   ║ if (-1 == 1)      ║ undefined ║\n    ║ if (-1 == false) console.log(&quot;spam&quot;)  ║ if (-1 == 0)      ║ undefined ║\n    ║   Order doesn&#39;t matter...             ║                   ║           ║\n    ║ if (true == -1) console.log(&quot;spam&quot;)   ║ if (1 == -1)      ║ undefined ║\n    ╠═══════════════════════════════════════╬═══════════════════╬═══════════╣\n    ║ if (!!-1 == true) console.log(&quot;spam&quot;) ║ if (true == true) ║ spam      ║ better\n    ╠═══════════════════════════════════════╬═══════════════════╬═══════════╣\n    ║ if (-1) console.log(&quot;spam&quot;)           ║ if (truthy)       ║ spam      ║ still best\n    ╚═══════════════════════════════════════╩═══════════════════╩═══════════╝\n\nAnd things get even crazier depending on your engine. WScript, for instance, wins the prize.\n\n    function test()\n    {\n        return (1 === 1);\n    }\n    WScript.echo(test());\n\nBecause of [some historical Windows jive](https://stackoverflow.com/a/14462348/1028230), that&#39;ll output -1 in a message box! Try it in a cmd.exe prompt and see! But `WScript.echo(-1 == test())` still gives you 0, or WScript&#39;s `false`. [Look away. It&#39;s hideous.](https://www.google.com/search?q=look+away+I%27m+hideous)\n\n### Comparing truthiness :)\n\nBut what if I have two values I need to check for equal truthi/falsi-ness?\n\nPretend we have `myVar1 = 0;` and `myVar2 = undefined;`.\n\n* `myVar1 === myVar2` is `0 === undefined` and is obviously false.\n* `!!myVar1 === !!myVar2` is `!!0 === !!undefined` and is true! Same truthiness! (In this case, both &quot;have a truthiness of falsy&quot;.)\n\nSo the only place you&#39;d really need to use &quot;boolean-cast variables&quot; would be if you had a situation where you&#39;re checking if both variables have the *same* truthiness, right? That is, &lt;b&gt;use `!!` if you need to see if two vars are *both truthy or both falsy* (or not), that is, *of equal* (or not) *truthiness*.&lt;/b&gt;\n\nI can&#39;t think of a great, non-contrived use case for that offhand. Maybe you have &quot;linked&quot; fields in a form? \n\n    if (!!customerInput.spouseName !== !!customerInput.spouseAge ) {\n        errorObjects.spouse = &quot;Please either enter a valid name AND age &quot; \n            + &quot;for your spouse or leave all spouse fields blank.&quot;;\n    }\n\nSo now if you have a truthy for both *or* a falsy for both spouse name and age, you can continue. Otherwise you&#39;ve only got one field with a value (or a very early arranged marriage) and need to create an extra error on your `errorObjects` collection.\n\n---\n\n**EDIT 24 Oct 2017, 6 Feb 19:** \n\n### 3rd party libraries that expect explicit Boolean values\n\nHere&#39;s an interesting case... `!!` might be useful when 3rd party libs expect explicit Boolean values.\n\nFor instance, [False in JSX (React) has a special meaning](https://react-cn.github.io/react/tips/false-in-jsx.html) that&#39;s not triggered on simple falsiness. If you tried returning something like the following in your JSX, expecting an int in `messageCount`...\n\n`{messageCount &amp;&amp; &lt;div&gt;You have messages!&lt;/div&gt;}`\n\n... you might be surprised to see React render a `0` when you have zero messages. You have to explicitly return false for JSX not to render. The above statement returns `0`, which JSX happily renders, as it should. It can&#39;t tell you didn&#39;t have `Count: {messageCount &amp;&amp; &lt;div&gt;Get your count to zero!&lt;/div&gt;}` (or something less contrived).\n\n* One fix involves the bangbang, which coerces `0` into `!!0`, which is `false`:  \n`{!!messageCount &amp;&amp; &lt;div&gt;You have messages!&lt;/div&gt;}`\n\n* JSX&#39; docs suggest you be more explicit, write self-commenting code, and use a comparison to force to a Boolean.  \n`{messageCount &gt; 0 &amp;&amp; &lt;div&gt;You have messages!&lt;/div&gt;}`\n\n* I&#39;m more comfortable handling falsiness myself with a ternary --  \n`{messageCount ? &lt;div&gt;You have messages!&lt;/div&gt; : false}`\n\nSame deal in Typescript: If you have a function that returns a boolean (or you&#39;re assigning a value to a boolean variable), you [usually] can&#39;t return/assign a boolean-y value; it has to be a strongly typed boolean. This means, **iff `myObject` is strongly typed**, `return !myObject;` works for a function returning a boolean, but `return myObject;` doesn&#39;t. You have to `return !!myObject` to match Typescript&#39;s expectations.\n\n&gt; The exception for Typescript? If `myObject` was an `any`, you&#39;re back in JavaScript&#39;s Wild West and can return it without `!!`, even if your return type is a boolean.\n\nKeep in mind that **these *are JSX &amp; Typescript conventions*, not ones inherent to JavaScript**.\n\nBut if you see strange `0`s in your rendered JSX, think loose falsy management."},{"score":3,"body_markdown":"Some operators in JavaScript perform implicit type conversions, and are sometimes\r\nused for type conversion.\r\n\r\nThe unary `!` operator converts its operand to a boolean and negates it.\r\n\r\nThis fact lead to the following idiom that you can see in your source code:\r\n\r\n    !!x // Same as Boolean(x). Note double exclamation mark"},{"score":9,"body_markdown":"`!!x` is shorthand for `Boolean(x)`\r\n\r\nThe first bang forces the js engine to run `Boolean(x)` but also has the side effect of inverting the value.  So the second bang undoes the side effect."},{"score":10,"body_markdown":"The `if` and `while` statements and the `?` operator use truth values to determine which branch of code to run. For example, zero and NaN numbers and the empty string are false, but other numbers and strings are true. Objects are true, but the undefined value and `null` are both false.\r\n\r\nThe double negation operator `!!` calculates the truth value of a value. It&#39;s actually two operators, where `!!x` means `!(!x)`, and behaves as follows:\r\n\r\n* If `x` is a false value, `!x` is `true`, and `!!x` is `false`.\r\n* If `x` is a true value, `!x` is `false`, and `!!x` is `true`.\r\n\r\nWhen used at the top level of a Boolean context (`if`, `while`, or `?`), the `!!` operator is behaviorally a no-op. For example, `if (x)` and `if (!!x)` mean the same thing.\r\n\r\n## Practical uses\r\n\r\nHowever it has several practical uses.\r\n\r\nOne use is to lossily compress an object to its truth value, so that your code isn&#39;t holding a reference to a big object and keeping it alive. Assigning `!!some_big_object` to a variable instead of `some_big_object` lets go of it for the garbage collector. This is useful for cases that produce either an object or a false value such as `null` or the undefined value, such as browser feature detection.\r\n\r\nAnother use, which I mentioned in an [answer about C&#39;s corresponding `!!` operator](https://stackoverflow.com/a/35525827/2738262), is with &quot;lint&quot; tools that look for common typos and print diagnostics. For example, in both C and JavaScript, a few common typos for Boolean operations produce other behaviors whose output isn&#39;t quite as Boolean:\r\n\r\n* `if (a = b)` is assignment followed by use of the truth value of `b`; `if (a == b)` is an equality comparison.\r\n* `if (a &amp; b)` is a bitwise AND; `if (a &amp;&amp; b)` is a logical AND. `2 &amp; 5` is `0` (a false value); `2 &amp;&amp; 5` is true.\r\n\r\nThe `!!` operator reassures the lint tool that what you wrote is what you meant: do this operation, then take the truth value of the result.\r\n\r\nA third use is to produce logical XOR and logical XNOR. In both C and JavaScript, `a &amp;&amp; b` performs a logical AND (true if both sides are true), and `a &amp; b` performs a bitwise AND. `a || b` performs a logical OR (true if at least one are true), and `a | b` performs a bitwise OR. There&#39;s a bitwise XOR (exclusive OR) as `a ^ b`, but there&#39;s no built-in operator for logical XOR (true if exactly one side is true). You might, for example, want to allow the user to enter text in exactly one of two fields. What you can do is convert each to a truth value and compare them: `!!x !== !!y`."},{"score":19,"body_markdown":"I think worth mentioning is, that a condition combined with logical AND/OR will not return a boolean value but last success or first fail in case of &amp;&amp; and \r\nfirst success or last fail in case of || of condition chain.\r\n\r\n    res = (1 &amp;&amp; 2); // res is 2\r\n    res = (true &amp;&amp; alert) // res is function alert()\r\n    res = (&#39;foo&#39; || alert) // res is &#39;foo&#39;\r\n\r\nIn order to cast the condition to a true boolean literal we can use the double negation:\r\n\r\n    res = !!(1 &amp;&amp; 2); // res is true\r\n    res = !!(true &amp;&amp; alert) // res is true\r\n    res = !!(&#39;foo&#39; || alert) // res is true"},{"score":3,"body_markdown":"Use logical not operator two times  \r\n**it means !true= false  \r\n and  !!true = true**"},{"score":8,"body_markdown":"I just wanted to add that\r\n\r\n    if(variableThing){\r\n      // do something\r\n    }\r\n\r\nis the same as\r\n\r\n    if(!!variableThing){\r\n      // do something\r\n    }\r\n\r\nBut this can be an issue when something is undefined.\r\n\r\n    // a === undefined, b is an empty object (eg. b.asdf === undefined)\r\n    var a, b = {};\r\n\r\n    // Both of these give error a.foo is not defined etc.\r\n    // you&#39;d see the same behavior for !!a.foo and !!b.foo.bar\r\n\r\n    a.foo \r\n    b.foo.bar\r\n\r\n    // This works -- these return undefined\r\n\r\n    a &amp;&amp; a.foo\r\n    b.foo &amp;&amp; b.foo.bar\r\n    b &amp;&amp; b.foo &amp;&amp; b.foo.bar\r\n\r\nThe trick here is the chain of `&amp;&amp;`s will return **the first falsey value** it finds -- and this can be fed to an if statement etc.  So if b.foo is undefined, it will return undefined and skip the `b.foo.bar` statement, and we get no error.\r\n\r\nThe above return undefined but if you have an empty string, false, null, 0, undefined those values will return and soon as we encounter them in the chain -- `[]` and `{}` are both &quot;truthy&quot; and we will continue down the so-called &quot;&amp;&amp; chain&quot; to the next value to the right.\r\n\r\n**P.S.** Another way of doing the same thing is `(b || {}).foo`, because if b is undefined then `b || {}` will be `{}`, and you&#39;ll be accessing a value in an empty object (no error) instead of trying to access a value within &quot;undefined&quot; (causes an error).  So, `(b || {}).foo` is the same as `b &amp;&amp; b.foo` and `((b || {}).foo || {}).bar` is the same as `b &amp;&amp; b.foo &amp;&amp; b.foo.bar`."},{"score":5,"body_markdown":"After seeing all these great answers, I would like to add another reason for using  `!!`. Currenty I&#39;m working in Angular 2-4 (TypeScript) and I want to return a boolean as `false` when my user is not authenticated. If he isn&#39;t authenticated, the token-string would be `null` or `&quot;&quot;`. I can do this by using the next block of code:\r\n\r\n    public isAuthenticated(): boolean {\r\n       return !!this.getToken();\r\n    }\r\n\r\n\r\n"},{"score":2,"body_markdown":"`!!` is similar to using the [*Boolean constructor*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean), or arguably more like the [*Boolean function.*](https://www.w3schools.com/js/js_booleans.asp)\r\n\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    console.log(Boolean(null)); // Preffered over the Boolean object\r\n\r\n    console.log(new Boolean(null).valueOf()); // Not recommended for coverting non-boolean values\r\n\r\n    console.log(!!null); // A hacky way to omit calling the Boolean function, but essentially does the same thing. \r\n\r\n\r\n    // The context you saw earlier (your example)\r\n    var vertical;\r\n\r\n    function Example(vertical)\r\n    {\r\n            this.vertical = vertical !== undefined ? !!vertical : \r\n            this.vertical; \r\n            // Let&#39;s break it down: If vertical is strictly not undefined, return the boolean value of vertical and set it to this.vertical. If not, don&#39;t set a value for this.vertical (just ignore it and set it back to what it was before; in this case, nothing).   \r\n\r\n            return this.vertical;\r\n    }\r\n\r\n    console.log( &quot;\\n---------------------&quot; )\r\n\r\n    // vertical is currently undefined\r\n\r\n    console.log(new Example(vertical).vertical); // The falsey or truthy value of this.vertical\r\n    console.log(!!new Example(vertical).vertical); // Coerced value of this.vertical\r\n\r\n    vertical = 12.5; // set vertical to 12.5, a truthy value.\r\n    console.log(new Example(vertical).vertical); // The falsey or truthy value of this.vertical which happens to be true anyway\r\n    console.log(!!new Example(vertical).vertical); // Coerced value of this.vertical\r\n\r\n    vertical = -0; // set vertical to -0, a falsey value.\r\n    console.log(new Example(vertical).vertical); // The falsey or truthy value of this.vertical which happens to be false either way\r\n    console.log(!!new Example(vertical).vertical); // Coerced value of this.vertical\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n*Falsey values* in javascript **coerce** to *false*, and *truthy values* **coerce** to *true.* Falsey and truthy values can also be used in `if` statements and will essentially &quot;map&quot; to their corresponding boolean value. However, you will probably not find yourself having to use proper boolean values often, as they mostly differ in output (return values). \r\n\r\n&gt;Although this may seem similar to casting, realistically this is likely a *mere* coincidence and is not &#39;built&#39; or purposely made for and like a boolean cast. So let&#39;s not call it that.\r\n\r\n&lt;hr /&gt;\r\n&lt;h3&gt;Why and how it works&lt;/h3&gt;\r\nTo be concise, it looks something like this: `! ( !null )`. Whereas, `null` is **falsey**, so `!null` would be **true**. Then `!true` would be **false** and it would essentially *invert back* to what it was before, \r\nexcept this time as a *proper boolean value* (or even *vice versa* with *truthy values*  like `{}` or `1`).   \r\n\r\n&lt;br /&gt;\r\n\r\n&lt;h3&gt;Going back to your example&lt;/h3&gt;\r\nOverall, the context that you saw simply adjusts `this.vertical` depending on whether or not `vertical` is defined, and if so; it will be set to the resulting boolean value of vertical, otherwise it will not change. In other words, if `vertical` is defined; `this.vertical` will be set to the boolean value of it, otherwise, it will stay the same. I guess that in itself is an example of how you would use `!!`, and what it does.\r\n\r\n&lt;br /&gt;\r\n&lt;h3&gt;Vertical I/O Example&lt;/h3&gt;\r\n&lt;small&gt;Run this example and fiddle around with the vertical value in the input. See what the result coerces to so that you can fully understand your context&#39;s code. In the input, enter any valid javascript value.\r\n&lt;strong&gt;Remember to include the quotations if you are testing out a string.&lt;/strong&gt; Don&#39;t mind the CSS and HTML code too much, simply run this snippet and play around with it. However, you might want to take a look at the non-DOM-related javascript code though (the use of the Example constructor and the vertical variable).&lt;/small&gt;\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var vertical = document.getElementById(&quot;vertical&quot;);\r\n    var p = document.getElementById(&quot;result&quot;);\r\n\r\n    function Example(vertical)\r\n    {\r\n            this.vertical = vertical !== undefined ? !!vertical : \r\n            this.vertical;   \r\n\r\n            return this.vertical;\r\n    }\r\n\r\n    document.getElementById(&quot;run&quot;).onclick = function()\r\n    {\r\n\r\n      p.innerHTML = !!( new Example(eval(vertical.value)).vertical );\r\n      \r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    input\r\n    {\r\n      text-align: center;\r\n      width: 5em;\r\n    } \r\n\r\n    button \r\n    {\r\n      margin: 15.5px;\r\n      width: 14em;\r\n      height: 3.4em;\r\n      color: blue;\r\n    }\r\n\r\n    var \r\n    {\r\n      color: purple;\r\n    }\r\n\r\n    p {\r\n      margin: 15px;\r\n    }\r\n\r\n    span.comment {\r\n      color: brown;\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;!--Vertical I/O Example--&gt;\r\n    &lt;h4&gt;Vertical Example&lt;/h4&gt;\r\n    &lt;code id=&quot;code&quot;&gt;&lt;var class=&quot;var&quot;&gt;var&lt;/var&gt; vertical = &lt;input type=&quot;text&quot; id=&quot;vertical&quot; maxlength=&quot;9&quot; /&gt;; &lt;span class=&quot;comment&quot;&gt;// enter any valid javascript value&lt;/span&gt;&lt;/code&gt;\r\n    &lt;br /&gt;\r\n    &lt;button id=&quot;run&quot;&gt;Run&lt;/button&gt;\r\n    &lt;p id=&quot;result&quot;&gt;...&lt;/p&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n\r\n\r\n"},{"score":19,"body_markdown":"`!!` it&#39;s using `NOT` operation twice together, `!` convert the value to a `boolean` and reverse it, here is a simple example to see how `!!` works:\r\n\r\nAt first, the place you have:\r\n\r\n    var zero = 0;\r\n\r\nThen you do `!0`, it will be converted to boolean and be evaluated to `true`, because 0 is `falsy`, so you get the reversed value and converted to boolean, so it gets evaluated to `true`.\r\n\r\n    !zero; //true\r\n\r\nbut we don&#39;t want the reversed **boolean version** of the value, so we can reverse it again to get our result! That&#39;s why we use another `!`.\r\n\r\nBasically, `!!` make us sure, the value we get is boolean, not falsy, truthy or string etc...\r\n\r\nSo  it&#39;s like using `Boolean` function in javascript, but easy and shorter way to convert a value to boolean:\r\n\r\n    var zero = 0;\r\n    !!zero; //false\r\n\r\n"},{"score":3,"body_markdown":"Returns boolean value of a variable.\r\n\r\nInstead, `Boolean` class can be used.\r\n\r\n(please read code descriptions)\r\n\r\n\r\n    var X = &quot;test&quot;; // X value is &quot;test&quot; as a String value\r\n    var booleanX = !!X // booleanX is `true` as a Boolean value beacuse non-empty strings evaluates as `true` in boolean\r\n    var whatIsXValueInBoolean = Boolean(X) // whatIsXValueInBoolean is `true` again\r\n    console.log(Boolean(X) === !!X) // writes `true`\r\n\r\nNamely, `Boolean(X) = !!X` in use.\r\n\r\nPlease check code snippet out below **↓**\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let a = 0\r\n    console.log(&quot;a: &quot;, a) // writes a value in its kind\r\n    console.log(&quot;!a: &quot;, !a) // writes &#39;0 is NOT true in boolean&#39; value as boolean - So that&#39;s true.In boolean 0 means false and 1 means true.\r\n    console.log(&quot;!!a: &quot;, !!a) // writes 0 value in boolean. 0 means false.\r\n    console.log(&quot;Boolean(a): &quot;, Boolean(a)) // equals to `!!a`\r\n    console.log(&quot;\\n&quot;) // newline\r\n\r\n    a = 1\r\n    console.log(&quot;a: &quot;, a)\r\n    console.log(&quot;!a: &quot;, !a)\r\n    console.log(&quot;!!a: &quot;, !!a) // writes 1 value in boolean\r\n    console.log(&quot;\\n&quot;) // newline\r\n\r\n    a = &quot;&quot;\r\n    console.log(&quot;a: &quot;, a)\r\n    console.log(&quot;!a: &quot;, !a) // writes &#39;&quot;&quot; is NOT true in boolean&#39; value as boolean - So that&#39;s true.In boolean empty strings, null and undefined values mean false and if there is a string it means true.\r\n    console.log(&quot;!!a: &quot;, !!a) // writes &quot;&quot; value in boolean\r\n    console.log(&quot;\\n&quot;) // newline\r\n\r\n    a = &quot;test&quot;\r\n    console.log(&quot;a: &quot;, a) // writes a value in its kind\r\n    console.log(&quot;!a: &quot;, !a)\r\n    console.log(&quot;!!a: &quot;, !!a) // writes &quot;test&quot; value in boolean\r\n\r\n    console.log(&quot;Boolean(a) === !!a: &quot;, Boolean(a) === !!a) // writes true\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":9,"body_markdown":"It forces all things to boolean. \r\n\r\nFor example:\r\n\r\n    console.log(undefined); // -&gt; undefined\r\n    console.log(!undefined); // -&gt; true\r\n    console.log(!!undefined); // -&gt; false\r\n    \r\n    console.log(&#39;abc&#39;); // -&gt; abc\r\n    console.log(!&#39;abc&#39;); // -&gt; false\r\n    console.log(!!&#39;abc&#39;); // -&gt; true\r\n\r\n    console.log(0 === false); // -&gt; undefined\r\n    console.log(!0 === false); // -&gt; false\r\n    console.log(!!0 === false); // -&gt; true"},{"score":0,"body_markdown":"Sometimes it is necessary to check whether we have a value in the function or not, and the amount itself is not important to us, but whether or not it matters.\r\nfor example we want to check ,if user has major or not and we have a function just like:\r\n\r\n    hasMajor(){return this.major}//it return &quot;(users major is)Science&quot; \r\n\r\nbut the answer is not important to us we just want to check it has a major or not and we need a boolean value(true or false) how we get it:\r\n\r\njust like this:\r\n\r\n    hasMajor(){ return !(!this.major)}\r\n\r\nor as the same \r\n\r\n    hasMajor(){return !!this.major)}\r\n\r\n if this.major has a value then `!this.major` return false but because the value has exits and we need to return true we use ! twice to return the correct answer `!(!this.major)`\r\n"},{"score":9,"body_markdown":"This question has been answered quite thoroughly, but I&#39;d like to add an answer that I hope is as simplified as possible, making the meaning of !! as simple to grasp as can be.\r\n\r\nBecause javascript has what are called &quot;truthy&quot; and &quot;falsey&quot; values, there are expressions that when evaluated in other expressions will result in a true or false condition, even though the value or expression being examined is not actually `true` or `false`.\r\n\r\nFor instance: \r\n\r\n    if (document.getElementById(&#39;myElement&#39;)) {\r\n        // code block\r\n    }\r\n\r\nIf that element does in fact exist, the expression will evaluate as true, and the code block will be executed.\r\n\r\nHowever:\r\n\r\n    if (document.getElementById(&#39;myElement&#39;) == true) {\r\n        // code block\r\n    }\r\n\r\n...will NOT result in a true condition, and the code block will not be executed, even if the element does exist.  \r\n\r\nWhy?  Because `document.getElementById()` is a &quot;truthy&quot; expression that will evaluate as true in this `if()` statement, but it is not an actual boolean value of `true`.\r\n\r\nThe double &quot;not&quot; in this case is quite simple.  It is simply two `not`s back to back. \r\n\r\nThe first one simply &quot;inverts&quot; the truthy or falsey value, resulting in an actual boolean type, and then the second one &quot;inverts&quot; it back again to it&#39;s original state, but now in an actual boolean value.  That way you have consistency:\r\n\r\n    if (!!document.getElementById(&#39;myElement&#39;)) {}\r\n\r\nand \r\n\r\n    if (!!document.getElementById(&#39;myElement&#39;) == true) {}\r\n\r\nwill BOTH return true, as expected.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"score":2,"body_markdown":"To cast your JavaScript variables to boolean,\r\n\r\n    var firstname = &quot;test&quot;;\r\n    //type of firstname is string\r\n    var firstNameNotEmpty = !!firstname;\r\n    //type of firstNameNotEmpty is boolean\r\n    \r\njavascript **false** for &quot;&quot;,0,undefined and null\r\n\r\njavascript is **true** for number other then zero,not empty strings,{},[] and new Date()\r\nso,\r\n\r\n    !!(&quot;test&quot;) /*is true*/\r\n    !!(&quot;&quot;) /*is false*/\r\n\r\n \r\n\r\n"},{"score":0,"body_markdown":"\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const foo = &#39;bar&#39;;\r\n    console.log(!!foo); // Boolean: true\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n! negates (inverts) a value AND always returns/ produces a boolean. So !&#39;bar&#39; would yield false (because &#39;bar&#39; is truthy =&gt; negated + boolean = false). With the additional ! operator, the value is negated again, so false becomes true."}],"score":3290}