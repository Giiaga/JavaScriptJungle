{"body":"Is there something in JavaScript similar to `@import` in CSS that allows you to include a JavaScript file inside another JavaScript file?\r\n","title":"How do I include a JavaScript file in another JavaScript file?","answers":[{"score":104,"body_markdown":"It is possible to dynamically generate a JavaScript tag and append it to HTML document from inside other JavaScript code. This will load targeted JavaScript file.\r\n\r\n    function includeJs(jsFilePath) {\r\n        var js = document.createElement(&quot;script&quot;);\r\n        \r\n        js.type = &quot;text/javascript&quot;;\r\n        js.src = jsFilePath;\r\n        \r\n        document.body.appendChild(js);\r\n    }\r\n    \r\n    includeJs(&quot;/path/to/some/file.js&quot;);\r\n"},{"score":64,"body_markdown":"Maybe you can use this function that I found on this page *[How do I include a JavaScript file in a JavaScript file?][1]*:\r\n\r\n    function include(filename)\r\n    {\r\n    \tvar head = document.getElementsByTagName(&#39;head&#39;)[0];\r\n    \t\r\n    \tvar script = document.createElement(&#39;script&#39;);\r\n    \tscript.src = filename;\r\n    \tscript.type = &#39;text/javascript&#39;;\r\n    \t\r\n    \thead.appendChild(script)\r\n    }\r\n\r\n  [1]: http://forums.digitalpoint.com/showthread.php?t=146094\r\n"},{"score":4660,"body_markdown":"The old versions of JavaScript had no import, include, or require, so many different approaches to this problem have been developed.\r\n\r\nBut since 2015 (ES6), JavaScript has had the [ES6 modules](http://exploringjs.com/es6/ch_modules.html) standard to import modules in Node.js, which is also supported by [most modern browsers](https://caniuse.com/#feat=es6-module).\r\n\r\nFor compatibility with older browsers, build tools like [Webpack](https://webpack.github.io/) and [Rollup](https://rollupjs.org/) and/or transpilation tools like [Babel](https://babeljs.io/) can be used.\r\n\r\n# ES6 Modules\r\n\r\nECMAScript (ES6) modules have been [supported in Node.js][1] since v8.5, with the `--experimental-modules` flag, and since at least Node.js v13.8.0 without the flag. To enable &quot;ESM&quot; (vs. Node.js&#39;s previous CommonJS-style module system [&quot;CJS&quot;]) you either use `&quot;type&quot;: &quot;module&quot;` in `package.json` or give the files the extension `.mjs`. (Similarly, modules written with Node.js&#39;s previous CJS module can be named `.cjs` if your default is ESM.)\r\n\r\nUsing `package.json`:\r\n\r\n&lt;!-- language: lang-json --&gt;\r\n\r\n    {\r\n        &quot;type&quot;: &quot;module&quot;\r\n    }\r\n\r\nThen `module.js`:\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    export function hello() {\r\n      return &quot;Hello&quot;;\r\n    }\r\n\r\nThen `main.js`:\r\n\r\n    import { hello } from &#39;./module.js&#39;;\r\n    let val = hello();  // val is &quot;Hello&quot;;\r\n\r\nUsing `.mjs`, you&#39;d have `module.mjs`:\r\n\r\n    export function hello() {\r\n      return &quot;Hello&quot;;\r\n    }\r\n\r\nThen `main.mjs`:\r\n\r\n    import { hello } from &#39;./module.mjs&#39;;\r\n    let val = hello();  // val is &quot;Hello&quot;;\r\n\r\n## ECMAScript modules in browsers\r\n\r\nBrowsers have had support for loading ECMAScript modules directly (no tools like Webpack required) [since](https://jakearchibald.com/2017/es-modules-in-browsers/) Safari 10.1, Chrome 61, Firefox 60, and Edge 16. Check the current support at [caniuse](https://caniuse.com/#feat=es6-module). There is no need to use Node.js&#39; `.mjs` extension; browsers completely ignore file extensions on modules/scripts.\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    &lt;script type=&quot;module&quot;&gt;\r\n      import { hello } from &#39;./hello.mjs&#39;; // Or it could be simply `hello.js`\r\n      hello(&#39;world&#39;);\r\n    &lt;/script&gt;\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    // hello.mjs -- or it could be simply `hello.js`\r\n    export function hello(text) {\r\n      const div = document.createElement(&#39;div&#39;);\r\n      div.textContent = `Hello ${text}`;\r\n      document.body.appendChild(div);\r\n    }\r\n\r\nRead more at https://jakearchibald.com/2017/es-modules-in-browsers/\r\n\r\n### Dynamic imports in browsers\r\n\r\nDynamic imports let the script load other scripts as needed:\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    &lt;script type=&quot;module&quot;&gt;\r\n      import(&#39;hello.mjs&#39;).then(module =&gt; {\r\n          module.hello(&#39;world&#39;);\r\n        });\r\n    &lt;/script&gt;\r\n\r\nRead more at https://developers.google.com/web/updates/2017/11/dynamic-import\r\n\r\n# Node.js require\r\n\r\nThe older CJS module style, still widely used in Node.js, is the [`module.exports`/`require`](https://nodejs.org/api/modules.html) system.\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    // mymodule.js\r\n    module.exports = {\r\n       hello: function() {\r\n          return &quot;Hello&quot;;\r\n       }\r\n    }\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    // server.js\r\n    const myModule = require(&#39;./mymodule&#39;);\r\n    let val = myModule.hello(); // val is &quot;Hello&quot;   \r\n\r\nThere are other ways for JavaScript to include external JavaScript contents in browsers that do not require preprocessing.\r\n\r\n# AJAX Loading\r\n\r\nYou could load an additional script with an AJAX call and then use `eval` to run it. This is the most straightforward way, but it is limited to your domain because of the JavaScript sandbox security model. Using `eval` also opens the door to bugs, hacks and security issues.\r\n\r\n# Fetch Loading\r\n\r\nLike Dynamic Imports you can load one or many scripts with a `fetch` call using promises to control order of execution for script dependencies using the [Fetch Inject](https://git.habd.as/jhabdas/fetch-inject) library:\r\n\r\n    fetchInject([\r\n      &#39;https://cdn.jsdelivr.net/momentjs/2.17.1/moment.min.js&#39;\r\n    ]).then(() =&gt; {\r\n      console.log(`Finish in less than ${moment().endOf(&#39;year&#39;).fromNow(true)}`)\r\n    })\r\n\r\n# jQuery Loading\r\n\r\nThe [jQuery][2] library provides loading functionality [in one line][3]:\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    $.getScript(&quot;my_lovely_script.js&quot;, function() {\r\n       alert(&quot;Script loaded but not necessarily executed.&quot;);\r\n    });\r\n\r\n# Dynamic Script Loading\r\n\r\nYou could add a script tag with the script URL into the HTML. To avoid the overhead of jQuery, this is an ideal solution.\r\n\r\nThe script can even reside on a different server. Furthermore, the browser evaluates the code. The `&lt;script&gt;` tag can be injected into either the web page `&lt;head&gt;`, or inserted just before the closing `&lt;/body&gt;` tag.\r\n\r\nHere is an example of how this could work:\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    function dynamicallyLoadScript(url) {\r\n        var script = document.createElement(&quot;script&quot;);  // create a script DOM node\r\n        script.src = url;  // set its src to the provided URL\r\n       \r\n        document.head.appendChild(script);  // add it to the end of the head section of the page (could change &#39;head&#39; to &#39;body&#39; to add it to the end of the body section instead)\r\n    }\r\n\r\nThis function will add a new `&lt;script&gt;` tag to the end of the head section of the page, where the `src` attribute is set to the URL which is given to the function as the first parameter.\r\n\r\nBoth of these solutions are discussed and illustrated in [JavaScript Madness: Dynamic Script Loading][4].\r\n\r\n# Detecting when the script has been executed\r\n\r\nNow, there is a big issue you must know about. Doing that implies that *you remotely load the code*. Modern web browsers will load the file and keep executing your current script because they load everything asynchronously to improve performance. (This applies to both the jQuery method and the manual dynamic script loading method.)\r\n\r\nIt means that if you use these tricks directly, *you won&#39;t be able to use your newly loaded code the next line after you asked it to be loaded*, because it will be still loading.\r\n\r\nFor example: `my_lovely_script.js` contains `MySuperObject`:\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    var js = document.createElement(&quot;script&quot;);\r\n\r\n    js.type = &quot;text/javascript&quot;;\r\n    js.src = jsFilePath;\r\n\r\n    document.body.appendChild(js);\r\n\r\n    var s = new MySuperObject();\r\n\r\n    Error : MySuperObject is undefined\r\n\r\nThen you reload the page hitting &lt;kbd&gt;F5&lt;/kbd&gt;. And it works! Confusing...\r\n\r\n**So what to do about it ?**\r\n\r\nWell, you can use the hack the author suggests in the link I gave you. In summary, for people in a hurry, he uses an event to run a callback function when the script is loaded. So you can put all the code using the remote library in the callback function. For example:\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    function loadScript(url, callback)\r\n    {\r\n        // Adding the script tag to the head as suggested before\r\n        var head = document.head;\r\n        var script = document.createElement(&#39;script&#39;);\r\n        script.type = &#39;text/javascript&#39;;\r\n        script.src = url;\r\n\r\n        // Then bind the event to the callback function.\r\n        // There are several events for cross browser compatibility.\r\n        script.onreadystatechange = callback;\r\n        script.onload = callback;\r\n\r\n        // Fire the loading\r\n        head.appendChild(script);\r\n    }\r\n\r\nThen you write the code you want to use AFTER the script is loaded in a [lambda function][5]:\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    var myPrettyCode = function() {\r\n       // Here, do whatever you want\r\n    };\r\n\r\nThen you run all that:\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    loadScript(&quot;my_lovely_script.js&quot;, myPrettyCode);\r\n\r\nNote that the script may execute after the DOM has loaded, or before, depending on the browser and whether you included the line `script.async = false;`. There&#39;s a [great article on Javascript loading in general](http://www.html5rocks.com/en/tutorials/speed/script-loading/) which discusses this.\r\n\r\n# Source Code Merge/Preprocessing\r\n\r\nAs mentioned at the top of this answer, many developers use build/transpilation tool(s) like Parcel, Webpack, or Babel in their projects, allowing them to use upcoming JavaScript syntax, provide backward compatibility for older browsers, combine files, minify, perform code splitting etc.\r\n\r\n\r\n  [1]: https://nodejs.org/api/esm.html\r\n  [2]: http://jquery.com/\r\n  [3]: http://api.jquery.com/jQuery.getScript/\r\n  [4]: http://unixpapa.com/js/dyna.html\r\n  [5]: http://en.wikipedia.org/wiki/Anonymous_function\r\n"},{"score":52,"body_markdown":"I just wrote this JavaScript code (using [Prototype][1] for [DOM][2] manipulation):\r\n\r\n    var require = (function() {\r\n        var _required = {};\r\n        return (function(url, callback) {\r\n            if (typeof url == &#39;object&#39;) {\r\n                // We&#39;ve (hopefully) got an array: time to chain!\r\n                if (url.length &gt; 1) {\r\n                    // Load the nth file as soon as everything up to the\r\n                    // n-1th one is done.\r\n                    require(url.slice(0, url.length - 1), function() {\r\n                        require(url[url.length - 1], callback);\r\n                    });\r\n                } else if (url.length == 1) {\r\n                    require(url[0], callback);\r\n                }\r\n                return;\r\n            }\r\n            if (typeof _required[url] == &#39;undefined&#39;) {\r\n                // Haven&#39;t loaded this URL yet; gogogo!\r\n                _required[url] = [];\r\n\r\n                var script = new Element(&#39;script&#39;, {\r\n                    src: url,\r\n                    type: &#39;text/javascript&#39;\r\n                });\r\n                script.observe(&#39;load&#39;, function() {\r\n                    console.log(&quot;script &quot; + url + &quot; loaded.&quot;);\r\n                    _required[url].each(function(cb) {\r\n                        cb.call(); // TODO: does this execute in the right context?\r\n                    });\r\n                    _required[url] = true;\r\n                });\r\n\r\n                $$(&#39;head&#39;)[0].insert(script);\r\n            } else if (typeof _required[url] == &#39;boolean&#39;) {\r\n                // We already loaded the thing, so go ahead.\r\n                if (callback) {\r\n                    callback.call();\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (callback) {\r\n                _required[url].push(callback);\r\n            }\r\n        });\r\n    })();\r\n\r\nUsage:\r\n\r\n    &lt;script src=&quot;prototype.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script src=&quot;require.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script&gt;\r\n        require([&#39;foo.js&#39;,&#39;bar.js&#39;], function () {\r\n            /* Use foo.js and bar.js here */\r\n        });\r\n    &lt;/script&gt;\r\n\r\nGist: http://gist.github.com/284442.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework\r\n  [2]: http://en.wikipedia.org/wiki/Document_Object_Model\r\n  "},{"score":32,"body_markdown":"You can also assemble your scripts using [PHP][1]:\r\n\r\nFile `main.js.php`:\r\n\r\n    &lt;?php\r\n        header(&#39;Content-type:text/javascript; charset=utf-8&#39;);\r\n        include_once(&quot;foo.js.php&quot;);\r\n        include_once(&quot;bar.js.php&quot;);\r\n    ?&gt;\r\n\r\n    // Main JavaScript code goes here\r\n\r\n  [1]: http://en.wikipedia.org/wiki/PHP\r\n"},{"score":210,"body_markdown":"There actually _is_ a way to load a JavaScript file _not_ asynchronously, so you could use the functions included in your newly loaded file right after loading it, and I think it works in all browsers.\r\n\r\nYou need to use `jQuery.append()` on the `&lt;head&gt;` element of your page, that is:\r\n\r\n    $(&quot;head&quot;).append(&#39;&lt;script type=&quot;text/javascript&quot; src=&quot;&#39; + script + &#39;&quot;&gt;&lt;/script&gt;&#39;);\r\n\r\nHowever, this method also has a problem: if an error happens in the imported JavaScript file, [Firebug][1] (and also Firefox Error Console and [Chrome Developer Tools][2] as well) will report its place incorrectly, which is a big problem if you use Firebug to track JavaScript errors down a lot (I do). Firebug simply doesn&#39;t know about the newly loaded file for some reason, so if an error occurs in that file, it reports that it occurred in your main [HTML][3] file, and you will have trouble finding out the real reason for the error.\r\n\r\nBut if that is not a problem for you, then this method should work.\r\n\r\nI have actually written a jQuery plugin called *$.import_js()* which uses this method:\r\n\r\n    (function($)\r\n    {\r\n        /*\r\n         * $.import_js() helper (for JavaScript importing within JavaScript code).\r\n         */\r\n        var import_js_imported = [];\r\n        \r\n        $.extend(true,\r\n        {\r\n            import_js : function(script)\r\n            {\r\n                var found = false;\r\n                for (var i = 0; i &lt; import_js_imported.length; i++)\r\n                    if (import_js_imported[i] == script) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                \r\n                if (found == false) {\r\n                    $(&quot;head&quot;).append(&#39;&lt;script type=&quot;text/javascript&quot; src=&quot;&#39; + script + &#39;&quot;&gt;&lt;/script&gt;&#39;);\r\n                    import_js_imported.push(script);\r\n                }\r\n            }\r\n        });\r\n        \r\n    })(jQuery);\r\n\r\nSo all you would need to do to import JavaScript is:\r\n\r\n    $.import_js(&#39;/path_to_project/scripts/somefunctions.js&#39;);\r\n\r\nI also made a simple test for this at [Example][4].\r\n\r\nIt includes a `main.js` file in the main HTML and then the script in `main.js` uses `$.import_js()` to import an additional file called `included.js`, which defines this function:\r\n\r\n    function hello()\r\n    {\r\n        alert(&quot;Hello world!&quot;);\r\n    }\r\n\r\nAnd right after including `included.js`, the `hello()` function is called, and you get the alert.\r\n\r\n(This answer is in response to e-satis&#39; comment).\r\n\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Firebug_%28software%29\r\n  [2]: https://developers.google.com/chrome-developer-tools/\r\n  [3]: http://en.wikipedia.org/wiki/HTML\r\n  [4]: http://www.kipras.com/dev/import_js_test/"},{"score":165,"body_markdown":"Another way, that in my opinion is much cleaner, is to make a synchronous Ajax request instead of using a `&lt;script&gt;` tag. Which is also how [Node.js][1] handles includes.\r\n\r\nHere&#39;s an example using jQuery:\r\n\r\n    function require(script) {\r\n        $.ajax({\r\n            url: script,\r\n            dataType: &quot;script&quot;,\r\n            async: false,           // &lt;-- This is the key\r\n            success: function () {\r\n                // all good...\r\n            },\r\n            error: function () {\r\n                throw new Error(&quot;Could not load script &quot; + script);\r\n            }\r\n        });\r\n    }\r\n\r\nYou can then use it in your code as you&#39;d usually use an include:\r\n\r\n    require(&quot;/scripts/subscript.js&quot;);\r\n\r\nAnd be able to call a function from the required script in the next line:\r\n\r\n    subscript.doSomethingCool(); \r\n\r\n  [1]: http://en.wikipedia.org/wiki/Node.js\r\n"},{"score":10,"body_markdown":"I came to this question because I was looking for a simple way to maintain a collection of useful JavaScript plugins. After seeing some of the solutions here, I came up with this:\r\n\r\n1. Set up a file called &quot;plugins.js&quot; (or extensions.js or whatever you want). Keep your plugin files together with that one master file.\r\n\r\n2. plugins.js will have an array called `pluginNames[]` that we will iterate over `each()`,\r\nthen append a `&lt;script&gt;` tag to the head for each plugin\r\n\r\n```javascript\r\n//set array to be updated when we add or remove plugin files\r\nvar pluginNames = [&quot;lettering&quot;, &quot;fittext&quot;, &quot;butterjam&quot;, etc.];\r\n\r\n//one script tag for each plugin\r\n$.each(pluginNames, function(){\r\n    $(&#39;head&#39;).append(&#39;&lt;script src=&quot;js/plugins/&#39; + this + &#39;.js&quot;&gt;&lt;/script&gt;&#39;);\r\n});\r\n```\r\n\r\n3. Manually call just the one file in your head:  \r\n`&lt;script src=&quot;js/plugins/plugins.js&quot;&gt;&lt;/script&gt;`\r\n\r\nBUT:\r\n\r\nEven though all of the plugins get dropped into the head tag the way they ought to, they don&#39;t always get run by the browser when you click into the page or refresh.\r\n\r\nI&#39;ve found it&#39;s more reliable to just write the script tags in a PHP include. You only have to write it once and that&#39;s just as much work as calling the plugin using JavaScript."},{"score":9,"body_markdown":"I have created a function that will allow you to use similar verbiage to C#/Java to include a JavaScript file. I&#39;ve tested it a little bit even from inside of *another* JavaScript file and it seems to work. It does require jQuery though for a bit of &quot;magic&quot; at the end.\r\n\r\nI put this code in a file at the root of my script directory (I named it `global.js`, but you can use whatever you want. Unless I&#39;m mistaken this and jQuery should be the only required scripts on a given page. Keep in mind this is largely untested beyond some basic usage, so there may or may not be any issues with the way I&#39;ve done it; use at your own risk yadda yadda I am not responsible if you screw anything up yadda yadda:\r\n\r\n    /**\r\n    * @fileoverview This file stores global functions that are required by other libraries.\r\n    */\r\n\r\n    if (typeof(jQuery) === &#39;undefined&#39;) {\r\n        throw &#39;jQuery is required.&#39;;\r\n    }\r\n\r\n    /** Defines the base script directory that all .js files are assumed to be organized under. */\r\n    var BASE_DIR = &#39;js/&#39;;\r\n\r\n    /**\r\n    * Loads the specified file, outputting it to the &lt;head&gt; HTMLElement.\r\n    *\r\n    * This method mimics the use of using in C# or import in Java, allowing\r\n    * JavaScript files to &quot;load&quot; other JavaScript files that they depend on\r\n    * using a familiar syntax.\r\n    *\r\n    * This method assumes all scripts are under a directory at the root and will\r\n    * append the .js file extension automatically.\r\n    *\r\n    * @param {string} file A file path to load using C#/Java &quot;dot&quot; syntax.\r\n    *\r\n    * Example Usage:\r\n    * imports(&#39;core.utils.extensions&#39;);\r\n    * This will output: &lt;script type=&quot;text/javascript&quot; src=&quot;/js/core/utils/extensions.js&quot;&gt;&lt;/script&gt;\r\n    */\r\n    function imports(file) {\r\n        var fileName = file.substr(file.lastIndexOf(&#39;.&#39;) + 1, file.length);\r\n\r\n        // Convert PascalCase name to underscore_separated_name\r\n        var regex = new RegExp(/([A-Z])/g);\r\n        if (regex.test(fileName)) {\r\n            var separated = fileName.replace(regex, &quot;,$1&quot;).replace(&#39;,&#39;, &#39;&#39;);\r\n            fileName = separated.replace(/[,]/g, &#39;_&#39;);\r\n        }\r\n\r\n        // Remove the original JavaScript file name to replace with underscore version\r\n        file = file.substr(0, file.lastIndexOf(&#39;.&#39;));\r\n\r\n        // Convert the dot syntax to directory syntax to actually load the file\r\n        if (file.indexOf(&#39;.&#39;) &gt; 0) {\r\n            file = file.replace(/[.]/g, &#39;/&#39;);\r\n        }\r\n\r\n        var src = BASE_DIR + file + &#39;/&#39; + fileName.toLowerCase() + &#39;.js&#39;;\r\n        var script = document.createElement(&#39;script&#39;);\r\n        script.type = &#39;text/javascript&#39;;\r\n        script.src = src;\r\n\r\n        $(&#39;head&#39;).find(&#39;script:last&#39;).append(script);\r\n    }\r\n"},{"score":6,"body_markdown":"In a past project I had quite a bit of success using [ajile][1] to do imports of reusable JavaScript files. I always wished there was a feature for this built into JavaScript itself.\r\n\r\n\r\n  [1]: http://ajile.net/"},{"score":23,"body_markdown":"Or rather than including at run time, use a script to concatenate prior to upload.\r\n\r\nI use [Sprockets][1] (I don&#39;t know if there are others). You build your JavaScript code in separate files and include comments that are processed by the Sprockets engine as includes. For development you can include files sequentially, then for production to merge them...\r\n\r\nSee also:\r\n\r\n * *[Introducing Sprockets: JavaScript dependency management and concatenation][2]*\r\n\r\n  [1]: https://github.com/sstephenson/sprockets\r\n  [2]: http://37signals.com/svn/posts/1587-introducing-sprockets-javascript-dependency-management-and-concatenation\r\n"},{"score":589,"body_markdown":"If anyone is looking for something more advanced, try out [RequireJS][1]. You&#39;ll get added benefits such as dependency management, better concurrency, and avoid duplication (that is, retrieving a script more than once).\r\n\r\nYou can write your JavaScript files in &quot;modules&quot; and then reference them as dependencies in other scripts. Or you can use RequireJS as a simple &quot;go get this script&quot; solution.\r\n\r\nExample:\r\n\r\nDefine dependencies as modules:\r\n\r\n**some-dependency.js**\r\n\r\n    define([&#39;lib/dependency1&#39;, &#39;lib/dependency2&#39;], function (d1, d2) {\r\n      \r\n         //Your actual script goes here.   \r\n         //The dependent scripts will be fetched if necessary.\r\n\r\n         return libraryObject;  //For example, jQuery object\r\n    });\r\n\r\n**implementation.js** is your &quot;main&quot; JavaScript file that depends on **some-dependency.js**\r\n\r\n    require([&#39;some-dependency&#39;], function(dependency) {\r\n\r\n        //Your script goes here\r\n        //some-dependency.js is fetched.   \r\n        //Then your script is executed\r\n    });\r\n\r\nExcerpt from the [GitHub][2] README:\r\n\r\n&gt; RequireJS loads plain JavaScript files as well as more defined\r\n&gt; modules. It is optimized for in-browser use, including in a Web\r\n&gt; Worker, but it can be used in other JavaScript environments, like\r\n&gt; Rhino and Node. It implements the Asynchronous Module API.\r\n&gt; \r\n&gt; RequireJS uses plain script tags to load modules/files, so it should\r\n&gt; allow for easy debugging. It can be used simply to load existing\r\n&gt; JavaScript files, so **you can add it to your existing project without\r\n&gt; having to re-write your JavaScript files.**\r\n&gt; \r\n&gt; ... \r\n\r\n  [1]: http://requirejs.org/\r\n  [2]: https://github.com/jrburke/requirejs\r\n"},{"score":109,"body_markdown":"There is a good news for you. Very soon you will be able to load JavaScript code easily. It will become a standard way of importing modules of JavaScript code and will be part of core JavaScript itself. \r\n\r\nYou simply have to write `import cond from &#39;cond.js&#39;;` to load a macro named `cond` from a file `cond.js`.\r\n\r\nSo you don&#39;t have to rely upon any JavaScript framework nor do you have to explicitly make [Ajax][1] calls.\r\n\r\nRefer to:\r\n\r\n * *[Static module resolution][2]*\r\n\r\n * *[Module loaders][3]*\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Ajax_%28programming%29\r\n  [2]: http://calculist.org/blog/2012/06/29/static-module-resolution/\r\n  [3]: http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders\r\n"},{"score":14,"body_markdown":"    var js = document.createElement(&quot;script&quot;);\r\n    \r\n    js.type = &quot;text/javascript&quot;;\r\n    js.src = jsFilePath;\r\n    \r\n    document.body.appendChild(js);"},{"score":7,"body_markdown":"Better use the [jQuery][1] way. To delay the ready event, first call `$.holdReady(true)`.\r\nExample ([source][2]):\r\n\r\n    $.holdReady(true);\r\n    $.getScript(&quot;myplugin.js&quot;, function() {\r\n        $.holdReady(false);\r\n    });\r\n\r\n  [1]: http://en.wikipedia.org/wiki/JQuery\r\n  [2]: http://jqapi.com/#p=jQuery.holdReady\r\n"},{"score":5,"body_markdown":"Don&#39;t forget to check out [LAB.js][1]!\r\n\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n\t       $LAB\r\n\t       .script(&quot;jquery-1.8.3.js&quot;).wait()\r\n\t       .script(&quot;scripts/clientscript.js&quot;);      \r\n    &lt;/script&gt;\r\n\r\n\r\n  [1]: http://labjs.com"},{"score":5,"body_markdown":"Now, I may be totally misguided, but here&#39;s what I&#39;ve recently started doing... \r\nStart and end your JavaScript files with a carriage return, place in the PHP script, followed by one more carriage return.\r\nThe JavaScript comment &quot;//&quot; is ignored by PHP so the inclusion happens anyway. The purpose for the carriage returns is so that the first line of your included JavaScript isn&#39;t commented out.\r\n\r\nTechnically, you don&#39;t need the comment, but it posts errors in [Dreamweaver][1] that annoy me. If you&#39;re scripting in an IDE that doesn&#39;t post errors, you shouldn&#39;t need the comment or the carriage returns.\r\n\r\n    \\n\r\n    //&lt;?php require_once(&quot;path/to/javascript/dependency.js&quot;); ?&gt;\r\n    \r\n    function myFunction(){\r\n        // stuff\r\n    }\r\n    \\n\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Adobe_Dreamweaver\r\n"},{"score":5,"body_markdown":"\r\n\r\n\r\n\t\r\n\r\n    var s=[&quot;Hscript.js&quot;,&quot;checkRobert.js&quot;,&quot;Hscript.js&quot;];\r\n    for(i=0;i&lt;s.length;i++){\r\n      var script=document.createElement(&quot;script&quot;);\r\n      script.type=&quot;text/javascript&quot;;\r\n      script.src=s[i];\r\n      document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script)\r\n    };"},{"score":23,"body_markdown":"This should do:\r\n\r\n    xhr = new XMLHttpRequest();\r\n    xhr.open(&quot;GET&quot;, &quot;/soap/ajax/11.0/connection.js&quot;, false);\r\n    xhr.send();\r\n    eval(xhr.responseText);\r\n"},{"score":12,"body_markdown":"I wrote a simple module that automates the job of importing/including module scripts in JavaScript. For detailed explanation of the code, refer to the blog post *[JavaScript require / import / include modules][1]*.\r\n\r\n    // ----- USAGE -----\r\n\r\n    require(&#39;ivar.util.string&#39;);\r\n    require(&#39;ivar.net.*&#39;);\r\n    require(&#39;ivar/util/array.js&#39;);\r\n    require(&#39;http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js&#39;);\r\n\r\n    ready(function(){\r\n        //Do something when required scripts are loaded\r\n    });\r\n\r\n        //--------------------\r\n\r\n    var _rmod = _rmod || {}; //Require module namespace\r\n    _rmod.LOADED = false;\r\n    _rmod.on_ready_fn_stack = [];\r\n    _rmod.libpath = &#39;&#39;;\r\n    _rmod.imported = {};\r\n    _rmod.loading = {\r\n        scripts: {},\r\n        length: 0\r\n    };\r\n\r\n    _rmod.findScriptPath = function(script_name) {\r\n        var script_elems = document.getElementsByTagName(&#39;script&#39;);\r\n        for (var i = 0; i &lt; script_elems.length; i++) {\r\n            if (script_elems[i].src.endsWith(script_name)) {\r\n                var href = window.location.href;\r\n                href = href.substring(0, href.lastIndexOf(&#39;/&#39;));\r\n                var url = script_elems[i].src.substring(0, script_elems[i].length - script_name.length);\r\n                return url.substring(href.length+1, url.length);\r\n            }\r\n        }\r\n        return &#39;&#39;;\r\n    };\r\n\r\n    _rmod.libpath = _rmod.findScriptPath(&#39;script.js&#39;); //Path of your main script used to mark\r\n                                                       //the root directory of your library, any library.\r\n\r\n\r\n    _rmod.injectScript = function(script_name, uri, callback, prepare) {\r\n\r\n        if(!prepare)\r\n            prepare(script_name, uri);\r\n\r\n        var script_elem = document.createElement(&#39;script&#39;);\r\n        script_elem.type = &#39;text/javascript&#39;;\r\n        script_elem.title = script_name;\r\n        script_elem.src = uri;\r\n        script_elem.async = true;\r\n        script_elem.defer = false;\r\n\r\n        if(!callback)\r\n            script_elem.onload = function() {\r\n                callback(script_name, uri);\r\n            };\r\n        document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script_elem);\r\n    };\r\n\r\n    _rmod.requirePrepare = function(script_name, uri) {\r\n        _rmod.loading.scripts[script_name] = uri;\r\n        _rmod.loading.length++;\r\n    };\r\n\r\n    _rmod.requireCallback = function(script_name, uri) {\r\n        _rmod.loading.length--;\r\n        delete _rmod.loading.scripts[script_name];\r\n        _rmod.imported[script_name] = uri;\r\n\r\n        if(_rmod.loading.length == 0)\r\n            _rmod.onReady();\r\n    };\r\n\r\n    _rmod.onReady = function() {\r\n        if (!_rmod.LOADED) {\r\n            for (var i = 0; i &lt; _rmod.on_ready_fn_stack.length; i++){\r\n                _rmod.on_ready_fn_stack[i]();\r\n            });\r\n            _rmod.LOADED = true;\r\n        }\r\n    };\r\n\r\n    _.rmod = namespaceToUri = function(script_name, url) {\r\n        var np = script_name.split(&#39;.&#39;);\r\n        if (np.getLast() === &#39;*&#39;) {\r\n            np.pop();\r\n            np.push(&#39;_all&#39;);\r\n        }\r\n\r\n        if(!url)\r\n            url = &#39;&#39;;\r\n\r\n        script_name = np.join(&#39;.&#39;);\r\n        return  url + np.join(&#39;/&#39;)+&#39;.js&#39;;\r\n    };\r\n\r\n    //You can rename based on your liking. I chose require, but it\r\n    //can be called include or anything else that is easy for you\r\n    //to remember or write, except &quot;import&quot;, because it is reserved\r\n    //for future use.\r\n    var require = function(script_name) {\r\n        var uri = &#39;&#39;;\r\n        if (script_name.indexOf(&#39;/&#39;) &gt; -1) {\r\n            uri = script_name;\r\n            var lastSlash = uri.lastIndexOf(&#39;/&#39;);\r\n            script_name = uri.substring(lastSlash+1, uri.length);\r\n        } \r\n        else {\r\n            uri = _rmod.namespaceToUri(script_name, ivar._private.libpath);\r\n        }\r\n\r\n        if (!_rmod.loading.scripts.hasOwnProperty(script_name)\r\n         &amp;&amp; !_rmod.imported.hasOwnProperty(script_name)) {\r\n            _rmod.injectScript(script_name, uri,\r\n                _rmod.requireCallback,\r\n                    _rmod.requirePrepare);\r\n        }\r\n    };\r\n\r\n    var ready = function(fn) {\r\n        _rmod.on_ready_fn_stack.push(fn);\r\n    };\r\n\r\n  [1]: http://stamat.wordpress.com/2013/04/12/javascript-require-import-include-modules/\r\n"},{"score":13,"body_markdown":"My usual method is:\r\n\r\n    var require = function (src, cb) {\r\n        cb = cb || function () {};\r\n\r\n        var newScriptTag = document.createElement(&#39;script&#39;),\r\n            firstScriptTag = document.getElementsByTagName(&#39;script&#39;)[0];\r\n        newScriptTag.src = src;\r\n        newScriptTag.async = true;\r\n        newScriptTag.onload = newScriptTag.onreadystatechange = function () {\r\n            (!this.readyState || this.readyState === &#39;loaded&#39; || this.readyState === &#39;complete&#39;) &amp;&amp; (cb());\r\n        };\r\n        firstScriptTag.parentNode.insertBefore(newScriptTag, firstScriptTag);\r\n    }\r\n\r\nIt works great and uses no page-reloads for me. I&#39;ve tried the AJAX method (one of the other answers) but it doesn&#39;t seem to work as nicely for me.\r\n\r\nHere&#39;s an explanation of how the code works for those that are curious: essentially, it creates a new script tag (after the first one) of the URL. It sets it to asynchronous mode so it doesn&#39;t block the rest of the code, but calls a callback when the readyState (the state of the content to be loaded) changes to &#39;loaded&#39;."},{"score":30,"body_markdown":"Most of solutions shown here imply dynamical loading. I was searching instead for a compiler which assemble all the depended files into a single output file. The same as [Less][1]/[Sass][2] preprocessors deal with the CSS `@import` at-rule. Since I didn&#39;t find anything decent of this sort, I wrote a simple tool solving the issue.\r\n\r\nSo here is the compiler, https://github.com/dsheiko/jsic, which replaces `$import(&quot;file-path&quot;)` with the requested file content securely. Here is the corresponding [Grunt][3] plugin: https://github.com/dsheiko/grunt-jsic.\r\n\r\nOn the jQuery master branch, they simply concatenate atomic source files into a single one starting with `intro.js` and ending with `outtro.js`. That doesn&#39;t suits me as it provides no flexibility on the source code design. Check out how it works with jsic:\r\n\r\n*src/main.js*\r\n\r\n    var foo = $import(&quot;./Form/Input/Tel&quot;);\r\n\r\n*src/Form/Input/Tel.js*\r\n\r\n    function() {\r\n        return {\r\n              prop: &quot;&quot;,\r\n              method: function(){}\r\n        }\r\n    }\r\n\r\nNow we can run the compiler:\r\n\r\n    node jsic.js src/main.js build/mail.js\r\n\r\nAnd get the combined file\r\n\r\n*build/main.js*\r\n\r\n    var foo = function() {\r\n        return {\r\n              prop: &quot;&quot;,\r\n              method: function(){}\r\n        }\r\n    };\r\n\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Less_%28stylesheet_language%29\r\n  [2]: http://en.wikipedia.org/wiki/Sass_%28stylesheet_language%29\r\n  [3]: http://gruntjs.com/"},{"score":10,"body_markdown":"This script will add a JavaScript file to the top of any other `&lt;script&gt;` tag:\r\n\r\n    (function () {\r\n        var li = document.createElement(&#39;script&#39;); \r\n        li.type = &#39;text/javascript&#39;; \r\n        li.src = &quot;http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js&quot;; \r\n        li.async = true; \r\n        var s = document.getElementsByTagName(&#39;script&#39;)[0]; \r\n        s.parentNode.insertBefore(li, s);\r\n    })();\r\n"},{"score":7,"body_markdown":"Here is a [Grunt][1] plugin allowing you to use `@import &quot;path/to/file.js&quot;;` syntax in any file including JavaScript files. It can be paired with uglify or watch or any other plugin.\r\n\r\nIt can be installed with npm install: https://npmjs.org/package/grunt-import\r\n\r\n  [1]: http://gruntjs.com/\r\n"},{"score":44,"body_markdown":"If you want it in pure JavaScript, you can use `document.write`.\r\n\r\n    document.write(&#39;&lt;script src=&quot;myscript.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&#39;);\r\n\r\nIf you use the jQuery library, you can use the `$.getScript` method.\r\n\r\n    $.getScript(&quot;another_script.js&quot;);\r\n"},{"score":10,"body_markdown":"There is also [Head.js][1]. It is very easy to deal with:\r\n\r\n    head.load(&quot;js/jquery.min.js&quot;,\r\n              &quot;js/jquery.someplugin.js&quot;,\r\n              &quot;js/jquery.someplugin.css&quot;, function() {\r\n      alert(&quot;Everything is ok!&quot;);\r\n    });\r\n\r\nAs you see, it&#39;s easier than Require.js and as convenient as jQuery&#39;s `$.getScript` method. It also has some advanced features, like conditional loading, feature detection and [much more][2].\r\n\r\n  [1]: http://headjs.com/\r\n  [2]: http://headjs.com/site/api/v1.00.html\r\n"},{"score":56,"body_markdown":"Here is a **synchronous** version **without jQuery**:\r\n\r\n\tfunction myRequire( url ) {\r\n\t\tvar ajax = new XMLHttpRequest();\r\n\t\tajax.open( &#39;GET&#39;, url, false ); // &lt;-- the &#39;false&#39; makes it synchronous\r\n\t\tajax.onreadystatechange = function () {\r\n\t\t\tvar script = ajax.response || ajax.responseText;\r\n\t\t\tif (ajax.readyState === 4) {\r\n\t\t\t\tswitch( ajax.status) {\r\n\t\t\t\t\tcase 200:\r\n\t\t\t\t\t\teval.apply( window, [script] );\r\n\t\t\t\t\t\tconsole.log(&quot;script loaded: &quot;, url);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.log(&quot;ERROR: script not loaded: &quot;, url);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tajax.send(null);\r\n\t}\r\n\r\nNote that to get this working cross-domain, the server will need to set `allow-origin` header in its response."},{"score":16,"body_markdown":"The `@import` syntax for achieving CSS-like JavaScript importing is possible using a tool such as [Mixture]() via their special `.mix` file type (see [here][1]). I assume the application does this via one of above-mentioned methods. \r\n\r\nFrom the Mixture documentation on `.mix` files: \r\n\r\n&gt; Mix files are simply .js or .css files with .mix. in the file name. A\r\n&gt; mix file simply     extends the functionality of a normal style or\r\n&gt; script file and allows you to import and combine.\r\n\r\nHere&#39;s an example `.mix` file that combines multiple `.js` files into one:\r\n \r\n    // scripts-global.mix.js\r\n    // Plugins - Global\r\n\r\n    @import &quot;global-plugins/headroom.js&quot;;\r\n    @import &quot;global-plugins/retina-1.1.0.js&quot;;\r\n    @import &quot;global-plugins/isotope.js&quot;;\r\n    @import &quot;global-plugins/jquery.fitvids.js&quot;;\r\n\r\nMixture outputs this as `scripts-global.js` and also as a minified version (`scripts-global.min.js`).\r\n\r\nNote: I&#39;m not in any way affiliated with Mixture, other than using it as a front-end development tool. I came across this question upon seeing a `.mix` JavaScript file in action (in one of the Mixture boilerplates) and being a bit confused by it (&quot;you can do this?&quot; I thought to myself). Then I realized that it was an application-specific file type (somewhat disappointing, agreed). Nevertheless, figured the knowledge might be helpful for others.\r\n\r\n**Note:** Mixture was discontinued on 2016/07/26 (after being open sourced on 2015/04/12).\r\n\r\n  [1]: http://docs.mixture.io/preprocessors#mix\r\n"},{"score":17,"body_markdown":"In case you are using [Web Workers][1] and want to include additional scripts in the scope of the worker, the other answers provided about adding scripts to the `head` tag, etc. will not work for you.\r\n\r\nFortunately, [Web Workers have their own `importScripts` function][2] which is a global function in the scope of the Web Worker, native to the browser itself as it [is part of the specification][3].\r\n\r\nAlternatively, [as the second highest voted answer to your question highlights][4], [RequireJS][5] can also handle including scripts inside a Web Worker (likely calling `importScripts` itself, but with a few other useful features).\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage#Importing_scripts_and_libraries\r\n  [3]: https://html.spec.whatwg.org/multipage/workers.html#importing-scripts-and-libraries\r\n  [4]: https://stackoverflow.com/a/10939737/1676444\r\n  [5]: http://www.requirejs.org/\r\n"},{"score":10,"body_markdown":"There are a lot of potential answers for this question. My answer is obviously based on a number of them. This is what I ended up with after reading through all the answers.\n\nThe problem with `$.getScript` and really any other solution that requires a callback when loading is complete is that if you have multiple files that use it and depend on each other you no longer have a way to know when all scripts have been loaded (once they are nested in multiple files).\n\n### Example:\n\nfile3.js\n\n    var f3obj = &quot;file3&quot;;\n\n    // Define other stuff\n\nfile2.js:\n\n    var f2obj = &quot;file2&quot;;\n    $.getScript(&quot;file3.js&quot;, function(){\n\n        alert(f3obj);\n\n        // Use anything defined in file3.\n    });\n\nfile1.js:\n\n    $.getScript(&quot;file2.js&quot;, function(){\n        alert(f3obj); //This will probably fail because file3 is only guaranteed to have loaded inside the callback in file2.\n        alert(f2obj);\n\n        // Use anything defined in the loaded script...\n    });\n\nYou are right when you say that you could specify Ajax to run synchronously or use [XMLHttpRequest][1], but the current trend appears to be to deprecate synchronous requests, so you may not get full browser support now or in the future.\n\nYou could try to use `$.when` to check an array of deferred objects, but now you are doing this in every file and file2 will be considered loaded as soon as the `$.when` is executed not when the callback is executed, so file1 still continues execution before file3 is loaded. This really still has the same problem.\n\nI decided to go backwards instead of forwards. Thank you `document.writeln`. I know it&#39;s taboo, but as long as it is used correctly this works well. You end up with code that can be debugged easily, shows in the DOM correctly and can ensure the order the dependencies are loaded correctly.\n\nYou can of course use $ (&quot;body&quot;).append(), but then you can no longer debug correctly any more.\n\nNOTE: You must use this only while the page is loading, otherwise you get a blank screen. In other words, **always place this before / outside of document.ready**. I have not tested using this after the page is loaded in a click event or anything like that, but I am pretty sure it&#39;ll fail.\n\nI liked the idea of extending jQuery, but obviously you don&#39;t need to.\n\nBefore calling `document.writeln`, it checks to make sure the script has not already been loading by evaluating all the script elements.\n\nI assume that a script is not fully executed until its `document.ready` event has been executed. (I know using `document.ready` is not required, but many people use it, and handling this is a safeguard.)\n\nWhen the additional files are loaded the `document.ready` callbacks will get executed in the wrong order. To address this when a script is actually loaded, the script that imported it is re-imported itself and execution halted. This causes the originating file to now have its `document.ready` callback executed after any from any scripts that it imports.\n\nInstead of this approach you could attempt to modify the jQuery `readyList`, but this seemed like a worse solution.\n\nSolution:\n\n    $.extend(true,\n    {\n        import_js : function(scriptpath, reAddLast)\n        {\n            if (typeof reAddLast === &quot;undefined&quot; || reAddLast === null)\n            {\n                reAddLast = true; // Default this value to true. It is not used by the end user, only to facilitate recursion correctly.\n            }\n\n            var found = false;\n            if (reAddLast == true) // If we are re-adding the originating script we do not care if it has already been added.\n            {\n                found = $(&#39;script&#39;).filter(function () {\n                    return ($(this).attr(&#39;src&#39;) == scriptpath);\n                }).length != 0; // jQuery to check if the script already exists. (replace it with straight JavaScript if you don&#39;t like jQuery.\n            }\n\n            if (found == false) {\n\n                var callingScriptPath = $(&#39;script&#39;).last().attr(&quot;src&quot;); // Get the script that is currently loading. Again this creates a limitation where this should not be used in a button, and only before document.ready.\n\n                document.writeln(&quot;&lt;script type=&#39;text/javascript&#39; src=&#39;&quot; + scriptpath + &quot;&#39;&gt;&lt;/script&gt;&quot;); // Add the script to the document using writeln\n\n                if (reAddLast)\n                {\n                    $.import_js(callingScriptPath, false); // Call itself with the originating script to fix the order.\n                    throw &#39;Readding script to correct order: &#39; + scriptpath + &#39; &lt; &#39; + callingScriptPath; // This halts execution of the originating script since it is getting reloaded. If you put a try / catch around the call to $.import_js you results will vary.\n                }\n                return true;\n            }\n            return false;\n        }\n    });\n\nUsage:\n\nFile3:\n\n    var f3obj = &quot;file3&quot;;\n\n    // Define other stuff\n    $(function(){\n        f3obj = &quot;file3docready&quot;;\n    });\n\nFile2:\n\n    $.import_js(&#39;js/file3.js&#39;);\n    var f2obj = &quot;file2&quot;;\n    $(function(){\n        f2obj = &quot;file2docready&quot;;\n    });\n\nFile1:\n\n    $.import_js(&#39;js/file2.js&#39;);\n\n    // Use objects from file2 or file3\n    alert(f3obj); // &quot;file3&quot;\n    alert(f2obj); // &quot;file2&quot;\n\n    $(function(){\n        // Use objects from file2 or file3 some more.\n        alert(f3obj); //&quot;file3docready&quot;\n        alert(f2obj); //&quot;file2docready&quot;\n    });\n\n  [1]: http://en.wikipedia.org/wiki/XMLHttpRequest\n"},{"score":9,"body_markdown":"Keep it nice, short, simple, and maintainable! :]\r\n\r\n    // Third-party plugins / script (don&#39;t forget the full path is necessary)\r\n    var FULL_PATH = &#39;&#39;, s =\r\n    [\r\n        FULL_PATH + &#39;plugins/script.js&#39;      // Script example\r\n        FULL_PATH + &#39;plugins/jquery.1.2.js&#39;, // jQuery Library\r\n        FULL_PATH + &#39;plugins/crypto-js/hmac-sha1.js&#39;,      // CryptoJS\r\n        FULL_PATH + &#39;plugins/crypto-js/enc-base64-min.js&#39;  // CryptoJS\r\n    ];\r\n\r\n    function load(url)\r\n    {\r\n        var ajax = new XMLHttpRequest();\r\n        ajax.open(&#39;GET&#39;, url, false);\r\n        ajax.onreadystatechange = function ()\r\n        {\r\n            var script = ajax.response || ajax.responseText;\r\n            if (ajax.readyState === 4)\r\n            {\r\n                switch(ajax.status)\r\n                {\r\n                    case 200:\r\n                        eval.apply( window, [script] );\r\n                        console.log(&quot;library loaded: &quot;, url);\r\n                        break;\r\n                    default:\r\n                        console.log(&quot;ERROR: library not loaded: &quot;, url);\r\n                }\r\n            }\r\n        };\r\n        ajax.send(null);\r\n    }\r\n\r\n    // Initialize a single load\r\n    load(&#39;plugins/script.js&#39;);\r\n\r\n    // Initialize a full load of scripts\r\n    if (s.length &gt; 0)\r\n    {\r\n        for (i = 0; i &lt; s.length; i++)\r\n        {\r\n            load(s[i]);\r\n        }\r\n    }\r\n\r\nThis code is simply a short functional example that *could* require additional feature functionality for full support on any (or given) platform.\r\n\r\n\r\n\r\n\r\n"},{"score":78,"body_markdown":"Statement [`import`][1] is in ECMAScript 6.\r\n\r\nSyntax\r\n\r\n    import name from &quot;module-name&quot;;\r\n    import { member } from &quot;module-name&quot;;\r\n    import { member as alias } from &quot;module-name&quot;;\r\n    import { member1 , member2 } from &quot;module-name&quot;;\r\n    import { member1 , member2 as alias2 , [...] } from &quot;module-name&quot;;\r\n    import name , { member [ , [...] ] } from &quot;module-name&quot;;\r\n    import &quot;module-name&quot; as name;\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import\r\n"},{"score":46,"body_markdown":"Here&#39;s the generalized version of how Facebook does it for their ubiquitous Like button:\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script&gt;\r\n      var firstScript = document.getElementsByTagName(&#39;script&#39;)[0],\r\n          js = document.createElement(&#39;script&#39;);\r\n      js.src = &#39;https://cdnjs.cloudflare.com/ajax/libs/Snowstorm/20131208/snowstorm-min.js&#39;;\r\n      js.onload = function () {\r\n        // do stuff with your dynamically loaded script\r\n        snowStorm.snowColor = &#39;#99ccff&#39;;\r\n      };\r\n      firstScript.parentNode.insertBefore(js, firstScript);\r\n    &lt;/script&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf it works for Facebook, it will work for you.\r\n\r\nThe reason why we look for the first `script` element instead of `head` or `body` is because some browsers don&#39;t create one if missing, but we&#39;re guaranteed to have a `script` element - this one. Read more at http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/.\r\n\r\n"},{"score":20,"body_markdown":"I had a simple issue, but I was baffled by responses to this question.\r\n\r\nI had to use a variable (myVar1) defined in one JavaScript file (myvariables.js) in another JavaScript file (main.js).\r\n\r\nFor this I did as below:\r\n\r\nLoaded the JavaScript code in the HTML file, in the correct order, myvariables.js first, then main.js:\r\n\r\n    &lt;html&gt;\r\n        &lt;body onload=&quot;bodyReady();&quot; &gt;\r\n\r\n            &lt;script src=&quot;myvariables.js&quot; &gt; &lt;/script&gt;\r\n            &lt;script src=&quot;main.js&quot; &gt; &lt;/script&gt;\r\n\r\n            &lt;!-- Some other code --&gt;\r\n        &lt;/body&gt;\r\n    &lt;/html&gt;\r\n\r\nFile: myvariables.js\r\n\r\n    var myVar1 = &quot;I am variable from myvariables.js&quot;;\r\n\r\nFile: main.js\r\n\r\n    // ...\r\n    function bodyReady() {\r\n        // ...\r\n        alert (myVar1);    // This shows &quot;I am variable from myvariables.js&quot;, which I needed\r\n        // ...\r\n    }\r\n    // ...\r\n\r\nAs you saw, I had use a variable in one JavaScript file in another JavaScript file, but I didn&#39;t need to include one in another. I just needed to ensure that the first JavaScript file loaded before the second JavaScript file, and, the first JavaScript file&#39;s variables are accessible in the second JavaScript file, automatically.\r\n\r\nThis saved my day. I hope this helps.\r\n"},{"score":28,"body_markdown":"If your intention to load the JavaScript file is **using the functions from the imported/included file**, you can also define a global object and set the functions as object items. For instance:\r\n\r\n###global.js\r\n\r\n    A = {};\r\n\r\n###file1.js\r\n\r\n    A.func1 = function() {\r\n      console.log(&quot;func1&quot;);\r\n    }\r\n\r\n###file2.js\r\n\r\n    A.func2 = function() {\r\n      console.log(&quot;func2&quot;);\r\n    }\r\n\r\n###main.js\r\n\r\n    A.func1();\r\n    A.func2();\r\n\r\nYou just need to be careful when you are including scripts in an HTML file. The order should be as in below:\r\n\r\n    &lt;head&gt;\r\n      &lt;script type=&quot;text/javascript&quot; src=&quot;global.js&quot;&gt;&lt;/script&gt;\r\n      &lt;script type=&quot;text/javascript&quot; src=&quot;file1.js&quot;&gt;&lt;/script&gt;\r\n      &lt;script type=&quot;text/javascript&quot; src=&quot;file2.js&quot;&gt;&lt;/script&gt;\r\n      &lt;script type=&quot;text/javascript&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;\r\n    &lt;/head&gt;\r\n"},{"score":8,"body_markdown":"I basically do it like the following, creating a new element and attach that to head:\r\n\r\n    var x = document.createElement(&#39;script&#39;);\r\n    x.src = &#39;http://example.com/test.js&#39;;\r\n    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(x);\r\n\r\nIn [jQuery][1]:\r\n\r\n    // jQuery\r\n    $.getScript(&#39;/path/to/imported/script.js&#39;, function()\r\n    {\r\n        // Script is now loaded and executed.\r\n        // Put your dependent JavaScript code here.\r\n    });\r\n\r\n  [1]: http://en.wikipedia.org/wiki/JQuery\r\n"},{"score":6,"body_markdown":"I have the requirement to asynchronously load an array of JavaScript files and at the final make a callback. Basically my best approach is the following:\r\n\r\n    // Load a JavaScript file from other JavaScript file\r\n    function loadScript(urlPack, callback) {\r\n        var url = urlPack.shift();\r\n        var subCallback;\r\n    \r\n        if (urlPack.length == 0) subCallback = callback;\r\n        else subCallback = function () {\r\n            console.log(&quot;Log script: &quot; + new Date().getTime());\r\n            loadScript(urlPack, callback);\r\n        }\r\n    \r\n        // Adding the script tag to the head as suggested before\r\n        var head = document.getElementsByTagName(&#39;head&#39;)[0];\r\n        var script = document.createElement(&#39;script&#39;);\r\n        script.type = &#39;text/javascript&#39;;\r\n        script.src = url;\r\n    \r\n        // Then bind the event to the callback function.\r\n        // There are several events for cross browser compatibility.\r\n        script.onreadystatechange = subCallback;\r\n        script.onload = subCallback;\r\n    \r\n        // Fire the loading\r\n        head.appendChild(script);\r\n    }\r\n\r\nExample:\r\n\r\n    loadScript(\r\n    [\r\n        &quot;js/DataTable/jquery.dataTables.js&quot;,\r\n        &quot;js/DataTable/dataTables.bootstrap.js&quot;,\r\n        &quot;js/DataTable/dataTables.buttons.min.js&quot;,\r\n        &quot;js/DataTable/dataTables.colReorder.min.js&quot;,\r\n        &quot;js/DataTable/dataTables.fixedHeader.min.js&quot;,\r\n        &quot;js/DataTable/buttons.bootstrap.min.js&quot;,\r\n        &quot;js/DataTable/buttons.colVis.min.js&quot;,\r\n        &quot;js/DataTable/buttons.html5.min.js&quot;\r\n    ], function() { gpLoad(params); });\r\n\r\nThe second script will not load until the first is completely loaded, and so...\r\n\r\nResults:\r\n\r\n[![Result][1]][1]\r\n\r\n  [1]: http://i.stack.imgur.com/6Y3vU.png\r\n"},{"score":3,"body_markdown":"You can&#39;t import, but you can reference.\r\n\r\n[PhpShtorm][1] IDE. To reference, in one `.js` file to another `.js`, just add this to the top of the file:\r\n\r\n    &lt;reference path=&quot;../js/file.js&quot; /&gt;\r\n\r\nOf course, you should use your own PATH to the JavaScript file.\r\n\r\nI don&#39;t know if it will work in other IDEs. Probably yes, just try. It should work in Visual Studio too.\r\n\r\n  [1]: https://en.wikipedia.org/wiki/PhpStorm\r\n"},{"score":6,"body_markdown":"# Here is maybe another way!\r\n\r\nIn Node.js you can do that just like the following code shows!\r\n\r\n\r\n**sub.js**\r\n\r\n```js\r\n    module.exports = {\r\n\t  log: function(string) {\r\n\t\tif(console) console.log(string);\r\n\t  }\r\n      mylog: function(){\r\n        console.log(&#39;just for log test!&#39;);\r\n      }\r\n    }\r\n```\r\n\r\n**main.js**\r\n\r\n```js\r\n    const mylog = require(&#39;./sub&#39;);\r\n\r\n    mylog.log(&#39;Hurray, it works! :)&#39;);\r\n    mylog.mylog();\r\n\r\n```\r\n\r\n## refs\r\n\r\nhttp://requirejs.org/docs/node.html\r\n"},{"score":1,"body_markdown":"    var xxx = require(&quot;../lib/your-library.js&quot;)\r\nor\r\n\r\n    import xxx from &quot;../lib/your-library.js&quot; //get default export\r\n    import {specificPart} from &#39;../lib/your-library.js&#39; //get named export\r\n    import * as _name from &#39;../lib/your-library.js&#39;  //get full export to alias _name\r\n\r\n\r\n\r\n\r\n\r\n"},{"score":3,"body_markdown":"Another approach is to use HTML imports. These can contain script references as well as stylesheet references.\r\n\r\nYou can just link an HTML file like\r\n\r\n    &lt;link rel=&quot;import&quot; href=&quot;vendorScripts.html&quot;/&gt;\r\n\r\nWithin the `vendorScripts.html` file you can include your script references like:\r\n\r\n    &lt;script src=&quot;scripts/vendors/jquery.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script src=&quot;scripts/vendors/bootstrap.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script src=&quot;scripts/vendors/angular.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script src=&quot;scripts/vendors/angular-route.js&quot;&gt;&lt;/script&gt;\r\n\r\nLook at [HTML Imports][1] for more details.\r\n\r\nUnfortunately this only works in Chrome.\r\n\r\n\r\n  [1]: https://www.html5rocks.com/en/tutorials/webcomponents/imports/"},{"score":6,"body_markdown":"If you use Angular, then a plugin module [$ocLazyLoad](https://oclazyload.readme.io/docs/getting-started) can help you to do that. \r\n\r\nHere are some quotes from its documentation:\r\n\r\n&gt; Load one or more modules &amp; components with multiple files:\r\n\r\n&gt;     $ocLazyLoad.load([&#39;testModule.js&#39;, &#39;testModuleCtrl.js&#39;, &#39;testModuleService.js&#39;]);\r\n\r\n&gt; Load one or more modules with multiple files and specify a type where necessary:\r\n&gt; Note: When using the requireJS style formatting (with js! at the beginning for example), do not specify a file extension. Use one or the other.\r\n\r\n&gt;     $ocLazyLoad.load([\r\n&gt;       &#39;testModule.js&#39;,\r\n&gt;        {type: &#39;css&#39;, path: &#39;testModuleCtrl&#39;},\r\n&gt;        {type: &#39;html&#39;, path: &#39;testModuleCtrl.html&#39;},\r\n&gt;        {type: &#39;js&#39;, path: &#39;testModuleCtrl&#39;},\r\n&gt;        &#39;js!testModuleService&#39;,\r\n&gt;        &#39;less!testModuleLessFile&#39;\r\n&gt;     ]);\r\n\r\n&gt; You can load external libs (not angular):\r\n\r\n&gt;     $ocLazyLoad.load([&#39;testModule.js&#39;, \r\n&gt;        &#39;bower_components/bootstrap/dist/js/bootstrap.js&#39;, &#39;anotherModule.js&#39;]);\r\n\r\n\r\n&gt; You can also load css and template files:\r\n\r\n\r\n&gt;      $ocLazyLoad.load([\r\n&gt;          &#39;bower_components/bootstrap/dist/js/bootstrap.js&#39;,\r\n&gt;          &#39;bower_components/bootstrap/dist/css/bootstrap.css&#39;,\r\n&gt;          &#39;partials/template1.html&#39;\r\n&gt;      ]);\r\n"},{"score":9,"body_markdown":"Here&#39;s a workaround **for browsers** (not Node.js) using HTML imports.\r\n\r\nFirst, all JavaScript classes and scripts are not in `.js` files, but in `.js.html` files (the **.js**.`html` is just to recognize between HTML pages and complete JavaScript script/classes), inside `&lt;script&gt;` tags, like this:\r\n\r\n`MyClass.js.html`:\r\n\r\n    &lt;script&gt;\r\n       class MyClass {\r\n         \r\n          // Your code here..\r\n\r\n       }\r\n\r\n    &lt;/script&gt;\r\n\r\nThen if you wish to import your class, you just need to use HTML imports:\r\n\r\n    &lt;link rel=&quot;import&quot; href=&quot;relative/path/to/MyClass.js.html&quot;/&gt;\r\n\r\n    &lt;script&gt;\r\n       var myClass = new MyClass();\r\n       // Your code here..\r\n    &lt;/script&gt;\r\n\r\n# EDIT : HTML imports will be dropped\r\n\r\nHTML imports are dropped, in favor of ES6 modules. \r\n**You should use ES6 modules.**\r\n\r\n\r\n  [1]: https://caniuse.com/#search=import"},{"score":5,"body_markdown":"It&#39;s very simple. Suppose you want to import file A.js in file B.js.\r\n\r\n**Now it&#39;s sure you have linked B.js in an HTML file, then just link A.js before B.js in that HTML file. Then the public variables of A.js will be available inside the B.js**\r\n\r\nThis does not require a complicated answer.\r\n"},{"score":18,"body_markdown":"In a modern language with the check if script has already been loaded, it would be:\r\n\r\n    function loadJs( url ){\r\n      return new Promise(( resolve, reject ) =&gt; {\r\n        if (document.querySelector( `head &gt; script[ src = &quot;${url}&quot; ]`) !== null ){\r\n            console.warn( `script already loaded: ${url}` );\r\n            resolve();\r\n        }\r\n        const script = document.createElement( &quot;script&quot; );\r\n        script.src = url;\r\n        script.onload = resolve;\r\n        script.onerror = function( reason ){\r\n            // This can be useful for your error-handling code\r\n            reason.message = `error trying to load script ${url}`;\r\n            reject( reason );\r\n        };\r\n        document.head.appendChild( script );\r\n      });\r\n    }\r\n\r\nUsage (async/await):\r\n\r\n```\r\ntry { await loadJs(&quot;https://.../script.js&quot;); }\r\ncatch(error) { console.log(error); }\r\n```\r\n\r\nor\r\n\r\n```\r\nawait loadJs( &quot;https://.../script.js&quot; ).catch( err =&gt; {} );\r\n```\r\n\r\nUsage (Promise):\r\n\r\n```\r\nloadJs( &quot;https://.../script.js&quot; ).then( res =&gt; {} ).catch( err =&gt; {} );\r\n```\r\n\r\n\r\n"},{"score":15,"body_markdown":"Although these answers are great, there is a simple &quot;solution&quot; that has been around since script loading existed, and it will cover 99.999% of most people&#39;s use cases. Just include the script you need before the script that requires it. For most projects it does not take long to determine which scripts are needed and in what order.\r\n\r\n    &lt;!DOCTYPE HTML&gt;\r\n    &lt;html&gt;\r\n        &lt;head&gt;\r\n            &lt;script src=&quot;script1.js&quot;&gt;&lt;/script&gt;\r\n            &lt;script src=&quot;script2.js&quot;&gt;&lt;/script&gt;\r\n        &lt;/head&gt;\r\n        &lt;body&gt;&lt;/body&gt;\r\n    &lt;/html&gt;\r\n\r\nIf script2 requires script1, this really is the absolute easiest way to do something like this. I&#39;m very surprised no-one has brought this up, as it&#39;s the most obvious and simplest answer that will apply in nearly every single case."},{"score":1,"body_markdown":"Please note that we usually use **static scripts**. So we want to be taken from the **cache** as much as possible.\r\n\r\nThis saves network traffic and speeds up landing.\r\n\r\n *Usage*\r\n\r\n    $.cachedScript( &quot;ajax/test.js&quot; ).done(function( script, textStatus ) {\r\n      console.log( textStatus );\r\n    });\r\n\r\nThe **cache: true** option has been added to the Ajax method.\r\n"},{"score":1,"body_markdown":"If you find there are two or more scripts occupying the same function when they are called, and we cannot be include them at the same time, we need to do it **dynamically** by user selection.\r\n\r\nIncluding another file in jQuery using `$.getScript` works since the script *[will not be cached by default][1]*. So we are safe to call other scripts. The calls can be arranged like this:\r\n\r\n***HTML***\r\n\r\n    &lt;select class=&quot;choice&quot;&gt;\r\n      &lt;option value=&quot;script1&quot; selected&gt;Script-1&lt;/option&gt;\r\n      &lt;option value=&quot;script2&quot;&gt;Script-2&lt;/option&gt;\r\n    &lt;/select&gt;\r\n\r\n***JavaScript***\r\n\r\n      $(&quot;.choice&quot;).change(on_change);\r\n\r\n        var url = &quot;https://example.com&quot;;\r\n        $.url1 = url + &quot;/script1.js&quot;;\r\n        $.url2 = url + &quot;/script2.js&quot;;\r\n\r\n      function on_change() {\r\n        if ($(&quot;.choice&quot;).val()==&quot;script1&quot;) {\r\n            script1();\r\n        } else {\r\n             script2();\r\n        }\r\n\r\n        // script1\r\n        function script1() {\r\n          $.getScript($.url1, function( data, textStatus, jqxhr ) {\r\n              // Execute here\r\n          });\r\n        }\r\n\r\n        // script2\r\n        function script2() {\r\n           $.getScript($.url2, function( data, textStatus, jqxhr ) {\r\n              // Execute here\r\n          });\r\n        }\r\n\r\n  [1]: https://api.jquery.com/jquery.getscript/#caching-requests\r\n"},{"score":8,"body_markdown":"**Yes,** there is...\r\n\r\nKeep reading. In **ES6**, we can `export` and `import` part or whole JavaScript file into another one...\r\n\r\nBut wait, **ES6** is not supported in all the browsers, so you need to transpile it using `babel.js` for example...\r\n\r\nSo you create a class like below:\r\n\r\n    class Person {\r\n      constructor(name) {\r\n        this.name = name;\r\n      }\r\n\r\n      build() {\r\n        return new Person(this);\r\n      }\r\n    }\r\n\r\n    module.exports = Person;\r\n\r\nIn *another* JavaScript file, do the import like:\r\n\r\n    import { Person } from &#39;Person&#39;;\r\n\r\nYou also can require the file like:\r\n\r\n    const Person = require(&#39;./Person&#39;);\r\n\r\nIf you are using an older JavaScript version you can use **requirejs**:\r\n\r\n    requirejs([&quot;helper/util&quot;], function(util) {\r\n        // This function is called when scripts/helper/util.js is loaded.\r\n        // If util.js calls define(), then this function is not fired until\r\n        // util&#39;s dependencies have loaded, and the util argument will hold\r\n        // the module value for &quot;helper/util&quot;.\r\n    });\r\n\r\nIf you want to stick to older version of stuff, like **jQuery**, you can also use something like **getScript**:\r\n\r\n    jQuery.getScript(&#39;./another-script.js&#39;, function() {\r\n        // Call back after another-script loaded\r\n    });\r\n\r\nLast, but not the least, don&#39;t forget you can do the traditional way of putting a script together using the `&lt;script&gt;` tag...\r\n\r\n    &lt;script src=&quot;./first-script.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script src=&quot;./second-script.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script src=&quot;./third-script.js&quot;&gt;&lt;/script&gt;\r\n\r\nThere are also the **async** and **defer** attributes which I should mention here...\r\n\r\n&gt; **Note:** There are several ways an external script can be executed:\r\n&gt;\r\n&gt; &lt;ul&gt; &lt;li&gt;If async is present: The script is executed asynchronously\r\n&gt; with the rest of the page (the script will be executed while the page\r\n&gt; continues the parsing)&lt;/li&gt;   &lt;li&gt;If async is not present and defer is\r\n&gt; present: The script is executed when the page has finished\r\n&gt; parsing&lt;/li&gt;   &lt;li&gt;If neither async or defer is present: The script is\r\n&gt; fetched and executed immediately, before the browser  continues\r\n&gt; parsing the page&lt;/li&gt; &lt;/ul&gt;\r\n\r\n"},{"score":9,"body_markdown":"**For Node.js only, this worked for me the best!**\r\n\r\nI&#39;ve tried most solutions here, but none helped me about just being able to load another file without changing scope. Finally I used this. Which preserves the scope and everything. It is as good as your code is in that point.\r\n\r\n    const fs = require(&#39;fs&#39;);\r\n    eval(fs.readFileSync(&#39;file.js&#39;) + &#39;&#39;);\r\n\r\n"},{"score":6,"body_markdown":"# Import and export modules using ES6 that work with Node.js\r\nName files with `.mjs` extension instead of `.js`\r\n\r\n### Create files\r\n    touch main.mjs lib.mjs\r\n\r\n### main.js \r\n    import { add } from &#39;./lib.mjs&#39;;\r\n    console.log(add(40, 2));\r\n\r\n### lib.mjs \r\n    export let add = (x,y) =&gt; {\r\n      return x + y\r\n    }\r\n\r\n### Run\r\n    node --experimental-modules main.js\r\n"},{"score":10,"body_markdown":"There are several ways to implement modules in JavaScript. Here are the two most popular ones:\r\n\r\n**ES6 Modules**\r\n----------------------------------\r\n\r\nBrowsers do not support this moduling system yet, so in order for you to use this syntax you must use a bundler like [Webpack][1]. Using a bundler is better anyway because this can combine all of your different files into a single (or a couple of related) files. This will serve the files from the server to the client faster because each HTTP request has some associated overhead accompanied with it. Thus by reducing the overall HTTP request we improve the performance. Here is an example of ES6 modules:\r\n\r\n    // main.js file\r\n\r\n    export function add (a, b) {\r\n      return a + b;\r\n    }\r\n\r\n    export default function multiply (a, b) {\r\n      return a * b;\r\n    }\r\n\r\n\r\n    // test.js file\r\n\r\n    import {add}, multiply from &#39;./main&#39;;   // For named exports between curly braces {export1, export2}\r\n                                            // For default exports without {}\r\n\r\n    console.log(multiply(2, 2));  // logs 4\r\n\r\n    console.log(add(1, 2));  // logs 3\r\n\r\n\r\n**CommonJS** (used in Node.js)\r\n----------------------------------\r\n\r\nThis moduling system is used in Node.js. You basically add your exports to an object which is called `module.exports`. You then can access this object via a `require(&#39;modulePath&#39;)`. Important here is to realize that these modules are being cached, so if you `require()` a certain module twice it will return the already created module.\r\n\r\n    // main.js file\r\n\r\n    function add (a, b) {\r\n      return a + b;\r\n    }\r\n\r\n    module.exports = add;  // Here we add our &#39;add&#39; function to the exports object\r\n\r\n\r\n    // test.js file\r\n\r\n    const add = require(&#39;./main&#39;);\r\n\r\n    console.log(add(1,2));  // logs 3\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Webpack\r\n\r\n\r\n\r\n"},{"score":5,"body_markdown":"I tried this problem with another approach,\r\n\r\nOrdering of script importing, has no effect in here.\r\n\r\n**index.html**\r\n\r\n    &lt;!doctype html&gt;\r\n    &lt;html lang=&quot;en&quot;&gt;\r\n    &lt;head&gt;\r\n        &lt;meta charset=&quot;utf-8&quot;&gt;\r\n        &lt;title&gt;Trials&lt;/title&gt;\r\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\r\n        &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;\r\n        &lt;script src=&quot;scriptA.js&quot;&gt;&lt;/script&gt;\r\n    &lt;/head&gt;\r\n    \r\n    &lt;body&gt;\r\n    &lt;h3&gt;testing js in js (check console logs)&lt;/h3&gt;\r\n    &lt;button onclick=&quot;fnClick()&quot;&gt;TEST&lt;/button&gt;\r\n    &lt;/body&gt;\r\n    \r\n    &lt;/html&gt;\r\n\r\n**main.js**\r\n\r\n    function fnClick() {\r\n      console.log(&#39;From\\tAAAAA&#39;);\r\n      var pro = myExpo.hello();\r\n      console.log(pro);\r\n    }\r\n**scriptA.js**\r\n\r\n    myExpo = {\r\n        hello: function () {\r\n            console.log(&#39;From\\tBBBBB&#39;);\r\n            return &quot;Hello&quot;;\r\n        }\r\n    }\r\n\r\nand the **result** is\r\n\r\n    From\tAAAAA\r\n    From\tBBBBB\r\n    Hello\r\n\r\n"},{"score":3,"body_markdown":"# Dynamically Loading Multiple Scripts In Order\r\n\r\nThe above function works fine if you are loading only one script or you don&#39;t care about the loading order of multiple scripts. If you have some scripts that depends on others, you need to use [Promise](https://javascript.info/promise-basics) to specify the order of loading. The reason behind this is Javascript loads resources like scripts and images asynchronously. The loading sequence does not depends on the sequence of asynchronous calls, meaning script1 will not be guaranteed to load before script2 even if you call `dynamicallyLoadScript(&quot;scrip1&quot;)` before calling `dynamicallyLoadScript(&quot;scrip2&quot;)`\r\n\r\nSo here&#39;s another version of dynamicallyLoadScript that guarantees loading order:\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    // Based on: https://javascript.info/promise-basics#example-loadscript\r\n    function dynamicallyLoadScript(url) {\r\n            return new Promise(function(resolve, reject) {\r\n            var script = document.createElement(&quot;script&quot;);\r\n            script.src = url;\r\n            script.onload = resolve;\r\n            script.onerror = () =&gt; reject(new Error(`Error when loading ${url}!`));\r\n            document.body.appendChild(script);\r\n        });\r\n\r\nFor more on Promises, see [this excellent page](https://javascript.info/promise-basics).\r\n\r\nThe usage of this new dynamicallyLoadScript is very simple:\r\n\r\n&lt;!-- language: lang-javascript--&gt;\r\n\r\n    dynamicallyLoadScript(&quot;script1.js&quot;)\r\n    .then(() =&gt; dynamicallyLoadScript(&quot;script2.js&quot;))\r\n    .then(() =&gt; dynamicallyLoadScript(&quot;script3.js&quot;))\r\n    .then(() =&gt; dynamicallyLoadScript(&quot;script4.js&quot;))\r\n    .then(() =&gt; dynamicallyLoadScript(&quot;script5.js&quot;))\r\n    //...\r\n  \r\nNow the scripts are loaded in the order of script1.js, script2.js, script3.js, etc. \r\n\r\n### Run dependent code after script loads\r\n\r\nIn addition, you can immediately run code that uses the scripts after they are loaded. Just add another `.then` after the loading the script:\r\n\r\n&lt;!-- language: lang-javascript--&gt;\r\n\r\n    dynamicallyLoadScript(&quot;script1.js&quot;)\r\n    .then(() =&gt; dynamicallyLoadScript(&quot;script2.js&quot;))\r\n    .then(() =&gt; foo()) // foo can be a function defined in either script1, script2\r\n    .then(() =&gt; dynamicallyLoadScript(&quot;script3.js&quot;))\r\n    .then(() =&gt; {\r\n         if (var1){ // var1 can be a global variable defined in either script1, script2, or script3\r\n              bar(var1); // bar can be a function defined in either script1, script2, or script3\r\n         } else {\r\n              foo(var1);\r\n         }\r\n    })\r\n    //more .then chains...\r\n\r\n---\r\n### Handle loading errors\r\nTo display unhandled promise rejections (errors loading scripts, etc), put this `unhandledrejection` event listener at the top of your code:\r\n\r\n&lt;!-- language: lang-javascript--&gt;\r\n    \r\n    // Based on: https://javascript.info/promise-error-handling#unhandled-rejections\r\n    window.addEventListener(&#39;unhandledrejection&#39;, function(event) {\r\n         // the event object has two special properties:\r\n         console.error(event.promise);// the promise that generated the error\r\n         console.error(event.reason); // the unhandled error object\r\n    });\r\n\r\nNow you will be notified of any script loading errors.\r\n\r\n---\r\n### Shortcut Function\r\nIf you are loading a lot of scripts without executing code immediately after loading, this shorthand function may come in handy:\r\n\r\n&lt;!-- language: lang-javascript--&gt;\r\n\r\n    function dynamicallyLoadScripts(urls){\r\n            if (urls.length === 0){\r\n                return;\r\n            }\r\n            let promise = dynamicallyLoadScript(urls[0]);\r\n            urls.slice(1).forEach(url =&gt; {\r\n                promise = promise.then(() =&gt; dynamicallyLoadScript(url));\r\n            });\r\n        }\r\nTo use it, just pass in an array of script urls like this:\r\n\r\n&lt;!-- language: lang-javascript--&gt;\r\n\r\n    const scriptURLs = [&quot;dist/script1.js&quot;, &quot;dist/script2.js&quot;, &quot;dist/script3.js&quot;];\r\n    dynamicallyLoadScripts(scriptURLs);\r\n\r\nThe scripts will be loaded in the order they appear in the array.\r\n"},{"score":1,"body_markdown":"You can use my [loadScript ES module][1] for loading of the JavaScript files.\r\n\r\n## Usage:\r\n\r\nIn your head tag, include the following code:\r\n\r\n    &lt;script src=&quot;https://raw.githack.com/anhr/loadScriptNodeJS/master/build/loadScript.js&quot;&gt;&lt;/script&gt;\r\n\r\nor\r\n\r\n    &lt;script src=&quot;https://raw.githack.com/anhr/loadScriptNodeJS/master/build/loadScript.min.js&quot;&gt;&lt;/script&gt;\r\n\r\nNow you can use window.loadScript for loading of your JavaScript files.\r\n\r\n### loadScript.async( src, [options] )\r\n\r\nAsynchronous load JavaScript file.\r\n\r\n`src`: URL of an external script file or array of the script file names.\r\n\r\n`options`: the following options are available\r\n\r\n    onload: function () The onload event occurs when a script has been loaded. Default is undefined.\r\n\r\n    onerror: function ( str, e ) The onerror event occurs when an error has been occurred. The default is undefined.\r\n\r\n        str: error details\r\n\r\n        e: event\r\n\r\n    appendTo: The node to which the new script will be append. The default is the head node.\r\n\r\nFor example\r\n\r\n    loadScript.async( &quot;JavaScript.js&quot;,\r\n            {\r\n                onload: function () {\r\n\r\n                    var str = &#39;file has been loaded successfully&#39;;\r\n                    console.log( str );\r\n                },\r\n                onerror: function ( str, e ) {\r\n\r\n                    console.error( str );\r\n                },\r\n            } );\r\n\r\n[Example of usage][2]\r\n\r\n  [1]: https://github.com/anhr/loadScriptNodeJS\r\n  [2]: https://raw.githack.com/anhr/loadScriptNodeJS/master/index.html\r\n"},{"score":2,"body_markdown":"A little extension to the library from [Dan Dascalescu&#39;s answer ][1] taken from the Facebook idea.\r\n\r\n    (function() {\r\n    var __ = {};\r\n    this._ = function(name, callback) {\r\n        if(__[name]==undefined) {\r\n            __[name] = true;\r\n            var firstScript = document.getElementsByTagName(&#39;script&#39;)[0],\r\n              js = document.createElement(&#39;script&#39;);\r\n              js.src =  name;\r\n              js.onload = callback;\r\n              firstScript.parentNode.insertBefore(js, firstScript);\r\n        }\r\n    }\r\n    })();\r\n\r\n    (new _(&#39;https://cdnjs.cloudflare.com/ajax/libs/Snowstorm/20131208/snowstorm-min.js&#39;, function() {\r\n     snowStorm.snowColor = &#39;#99ccff&#39;;\r\n    }));\r\n\r\n  [1]: https://stackoverflow.com/questions/950087/how-do-i-include-a-javascript-file-in-another-javascript-file/31282622#31282622\r\n"},{"score":11,"body_markdown":"# ES6 Modules\r\n\r\n*Yes*, use type=&quot;module&quot; in a script tag ([support][1]):\r\n\r\n    &lt;script type=&quot;module&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;\r\n\r\nAnd in a `script.js` file include another file like this:\r\n\r\n    import { hello } from &#39;./module.js&#39;;\r\n    ...\r\n    // alert(hello());\r\n\r\nIn &#39;module.js&#39; you must [export the function/class][2] that you will import:\r\n\r\n    export function hello() {\r\n        return &quot;Hello World&quot;;\r\n    }\r\n\r\nA working [example is here][3].\r\n\r\n  [1]: https://caniuse.com/#search=type%3D%22module%22\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export\r\n  [3]: http://plnkr.co/edit/ln6J7wfdsJPUNzaEi3u6\r\n\r\n\r\n\r\n\r\n"},{"score":1,"body_markdown":"So this is a edge case. But if you need to load the JavaScript from a remote source, most modern browsers might block your cross-site requests due to CORS or something similar. So normal\r\n\r\n    &lt;script src=&quot;https://another-domain.com/example.js&quot;&gt;&lt;/script&gt;\r\n\r\nWon&#39;t work. And doing the `document.createElement(&#39;script&#39;).src = &#39;...&#39;` won&#39;t cut it either. Instead, what you could do is load the java-script as a resource via standard `GET` request, and do this:\r\n\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var script = document.createElement(&#39;script&#39;);\r\n        script.type = &#39;text/javascript&#39;;\r\n    \r\n        let xhr = new XMLHttpRequest();\r\n        xhr.open(&quot;GET&quot;, &#39;https://raw.githubusercontent.com/Torxed/slimWebSocket/master/slimWebSocket.js&#39;, true);\r\n        xhr.onreadystatechange = function() {\r\n            if (this.readyState === XMLHttpRequest.DONE &amp;&amp; this.status === 200) {\r\n                script.innerHTML = this.responseText; // &lt;-- This one\r\n                document.head.appendChild(script);\r\n            }\r\n        }\r\n        xhr.send();\r\n    &lt;/script&gt;\r\n\r\nBy grabbing the content yourself, the browser won&#39;t notice malicious intents and allow you go do the request. Then you add it in `&lt;script&gt;`&#39;s `innerHTML` instead. This still causes the browser *(at least tested in Chrome)* to parse/execute the script.\r\n\r\nAgain, this is a edge case use case. And you&#39;ll have no backwards compatibility or browser compliance probably. But fun/useful thing to know about."},{"score":0,"body_markdown":"I did not see an answer whereby you create an object of all functions and variables in a file and then make that object an argument to refer to it in another file.\r\n\r\nE.g., you have files called &#39;jsMod.js&#39;, &#39;jsView&#39; and &#39;jsContr.js&#39;:\r\n\r\n```js\r\n\r\n    //jsMod.js file\r\n    JSMODOBJ = {};\r\n    JSMODOBJ.valueAddition = function(/* element value 1 */ val1,\r\n                                          /* element value 2 */ val2) {\r\n        return val1 + val2;\r\n    }\r\n\r\n```\r\n```js\r\n\r\n    //jsView.js file\r\n    JSVIEWOBJ = {};\r\n    JSVIEWOBJ.elementColour = function(/* element id to change colour */ id,\r\n                                          /* css colour classname */ col) {\r\n        document.getElementById(id).className = col;\r\n    }\r\n\r\n```\r\n```javascript\r\n\r\n    //jsContr.js file\r\n    JSCONTROBJ = {};\r\n    var jsMod = JSMODOBJ;\r\n    var jsView = JSVIEWOBJ;\r\n\r\n    JSCONTROBJ.changeColourByValue = function (val1, val2, id, clss) {\r\n        if (jsMod.valueAddition(val1,val2) !== 0) {\r\n            jsView.elementColour(id, clss);\r\n        }\r\n    }\r\n\r\n```\r\n\r\nThen you can set the .js files dynamically by echoeing the `scripts` into your .html or .php file:\r\n\r\n```php\r\n&lt;?php\r\n    echo &quot;&lt;script src = &#39;./js/dleafView.js&#39;&gt;&lt;/script&gt;\r\n        &lt;script src = &#39;./js/dleafModule.js&#39;&gt;&lt;/script&gt;\r\n        &lt;script src = &#39;./js/dleafContr.js&#39;&gt;&lt;/script&gt;&quot;;\r\n?&gt;\r\n```\r\n\r\nThen just call the control function within a `&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;` tag.  Of course this will take a lot of time in the beginning to set up, but it saves you time in the long run.\r\n\r\nI use this in a slightly different way, but this way also work.\r\n"},{"score":0,"body_markdown":"You can also use `gulp`, `gulp-concat`, `gulp-typescript` with `/// &lt;reference path=` includes:\r\n\r\n**packages.json**\r\n```lang-js\r\n{\r\n  &quot;scripts&quot;: {\r\n    &quot;gulp&quot;: &quot;gulp main&quot;\r\n  },\r\n  &quot;dependencies&quot;: {\r\n    &quot;@types/gulp&quot;: &quot;^4.0.6&quot;,\r\n    &quot;@types/gulp-concat&quot;,\r\n    &quot;@types/gulp-typescript&quot;,\r\n    &quot;gulp&quot;: &quot;^4.0.2&quot;,\r\n    &quot;gulp-concat&quot;: &quot;^2.6.1&quot;,\r\n    &quot;gulp-resolve-dependencies&quot;: &quot;^3.0.1&quot;,\r\n    &quot;gulp-typescript&quot;: &quot;^6.0.0-alpha.1&quot;,\r\n    &quot;typescript&quot;: &quot;^3.7.3&quot;\r\n  }\r\n}\r\n```\r\n\r\n**src/someimport.ts**\r\n```lang-js\r\nclass SomeClass {\r\n    delay: number;\r\n}\r\n```\r\n\r\n**src/main.ts**\r\n```lang-js\r\n/// &lt;reference path=&quot;./someimport.ts&quot; /&gt;\r\n\r\nsomeclass = new SomeClass();\r\nsomeclass.delay = 1;\r\n```\r\n\r\nThis `main` gulp task (on `gulpfile.js`) targets only the `src/main.js` file, resolving all its `/// &lt;reference path=...` include references. These includes are know as `Triple-Slash Directives` and they are used only for transpilers tools to combine files. In our case, they are used explicitly by `.pipe(resolveDependencies({` and by typescript itself when checking the file for missing types, variables, etc.\r\n\r\n1. https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html\r\n1. https://stackoverflow.com/questions/22684802/when-do-i-need-a-triple-slash-reference\r\n\r\nRefer to https://github.com/ivogabe/gulp-typescript#api-overview if you would like to customize the `var tsProject = ts.createProject` call and not use a `tsconfig.json` file or override its parameters.\r\n\r\n**gulpfile.js**\r\n```lang-js\r\nvar gulp = require(&quot;gulp&quot;);\r\nvar concat = require(&#39;gulp-concat&#39;);\r\nvar resolveDependencies = require(&#39;gulp-resolve-dependencies&#39;);\r\n\r\nvar ts = require(&quot;gulp-typescript&quot;);\r\nvar tsProject = ts.createProject(&quot;tsconfig.json&quot;);\r\n\r\ngulp.task(&quot;main&quot;, function() {\r\n  return gulp\r\n    .src([&quot;src/main.ts&quot;])\r\n    .pipe(resolveDependencies({\r\n      pattern: /^\\s*\\/\\/\\/\\s*&lt;\\s*reference\\s*path\\s*=\\s*(?:&quot;|&#39;)([^&#39;&quot;\\n]+)/gm\r\n    }))\r\n    .on(&#39;error&#39;, function(err) {\r\n        console.log(err.message);\r\n    })\r\n    .pipe(tsProject())\r\n    .pipe(concat(&#39;main.js&#39;))\r\n    .pipe(gulp.dest(&quot;build/&quot;));\r\n});\r\n```\r\n\r\nIf you wold like to target all your type script project files instead of only `src/main.ts`, you can replace this:\r\n```lang-js\r\n  return gulp\r\n    .src([&quot;src/main.ts&quot;])\r\n    .pipe(resolveDependencies({\r\n    ...\r\n// --&gt;\r\n  return tsProject\r\n    .src()\r\n    .pipe(resolveDependencies({\r\n    ...\r\n```\r\n\r\nIf you do not want to use `typescript`, you can use this simplified `gulpfile.js` and remove all `typescript` includes from `package.json`:\r\n\r\n**gulpfile.js**\r\n```lang-js\r\nvar gulp = require(&quot;gulp&quot;);\r\nvar concat = require(&#39;gulp-concat&#39;);\r\nvar resolveDependencies = require(&#39;gulp-resolve-dependencies&#39;);\r\n\r\ngulp.task(&quot;main&quot;, function() {\r\n  return gulp\r\n    .src([&quot;src/main.js&quot;])\r\n    .pipe(resolveDependencies({\r\n      pattern: /^\\s*\\/\\/\\/\\s*&lt;\\s*reference\\s*path\\s*=\\s*(?:&quot;|&#39;)([^&#39;&quot;\\n]+)/gm\r\n    }))\r\n    .on(&#39;error&#39;, function(err) {\r\n        console.log(err.message);\r\n    })\r\n    .pipe(concat(&#39;main.js&#39;))\r\n    .pipe(gulp.dest(&quot;build/&quot;));\r\n});\r\n```\r\n\r\n**packages.json**\r\n```lang-js\r\n{\r\n  &quot;scripts&quot;: {\r\n    &quot;gulp&quot;: &quot;gulp main&quot;\r\n  },\r\n  &quot;dependencies&quot;: {\r\n    &quot;gulp&quot;: &quot;^4.0.2&quot;,\r\n    &quot;gulp-concat&quot;: &quot;^2.6.1&quot;,\r\n    &quot;gulp-resolve-dependencies&quot;: &quot;^3.0.1&quot;\r\n  }\r\n}\r\n```\r\n\r\nThen, after running the command `npm run gulp`, the file `build/main.js` is created with the following as its contents:\r\n\r\n**build/main.js**\r\n```lang-js\r\nclass SomeClass {\r\n}\r\n/// &lt;reference path=&quot;./someimport.ts&quot; /&gt;\r\nsomeclass = new SomeClass();\r\nsomeclass.delay = 1;\r\n```\r\n\r\nWhich allows me to include it in the browser with the `script` tag, after serving the `build` directory files:\r\n```lang-html\r\n&lt;html&gt;\r\n    &lt;head&gt;\r\n        &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n        &lt;script type=&quot;text/javascript&quot;&gt;\r\n            console.log(someclass.delay);\r\n        &lt;/script&gt;\r\n    &lt;/body&gt;\r\n&lt;/html&gt;\r\n```\r\n\r\nRelated questions:\r\n\r\n1. https://www.typescriptlang.org/docs/handbook/gulp.html\r\n1. https://stackoverflow.com/questions/36710768/can-i-use-the-typescript-without-requirejs\r\n1. https://stackoverflow.com/questions/52338233/gulp-simple-concatenation-of-main-file-that-requires-another-js-file\r\n1. https://stackoverflow.com/questions/19059580/client-on-node-uncaught-referenceerror-require-is-not-defined\r\n1. https://stackoverflow.com/questions/47318837/how-can-typescript-browser-node-modules-be-compiled-with-gulp\r\n1. https://stackoverflow.com/questions/38381621/concatenate-files-using-babel\r\n1. https://stackoverflow.com/questions/7576001/how-to-require-commonjs-modules-in-the-browser\r\n1. https://stackoverflow.com/questions/34438378/is-there-an-alternative-to-browserify\r\n"},{"score":-3,"body_markdown":"You shall use this:\r\n```\r\n&lt;script src=&quot;your_file.js&quot;&gt;&lt;/script&gt;\r\n```\r\nEasy!"},{"score":1,"body_markdown":"    Step 1: Declare the function in another class.\r\n    \r\n        export const myreport = (value) =&gt; {\r\n        color = value.color;\r\n        name = value.name;\r\n        \r\n        var mytext = name + &quot; | &quot; + color;\r\n        return mytext;\r\n        }\r\n    \r\n    Step 2:- Import that function which is needed to be used.\r\n    \r\n        import {myreport} from &#39;../../Test&#39;\r\n    \r\n    Step 3:- Use that function.\r\n    \r\n    let val = { color: &quot;red&quot;, name: &quot;error&quot; }\r\n    var resultText = myreport(val)\r\n    console.log(&quot;resultText :- &quot;, resultText)"}],"score":5425}