{"body":"I would like a JavaScript function to have optional arguments which I set a default on, which get used if the value isn&#39;t defined (and ignored if the value is passed). In Ruby you can do it like this:\r\n\r\n    def read_file(file, delete_after = false)\r\n      # code\r\n    end\r\n\r\nDoes this work in JavaScript?\r\n\r\n    function read_file(file, delete_after = false) {\r\n      // Code\r\n    }\r\n","title":"Set a default parameter value for a JavaScript function","answers":[{"score":611,"body_markdown":"    function read_file(file, delete_after) {\r\n        delete_after = delete_after || &quot;my default here&quot;;\r\n        //rest of code\r\n    }\r\n\r\nThis assigns to `delete_after` the value of `delete_after` if it is not a *falsey* value otherwise it assigns the string `&quot;my default here&quot;`. For more detail, check out [Doug Crockford&#39;s survey of the language and check out the section on Operators][1].\r\n\r\nThis approach does not work if you want to pass in a *falsey* value i.e. `false`, `null`, `undefined`, `0` or `&quot;&quot;`. If you require *falsey* values to be passed in you would need to use the method in [Tom Ritter&#39;s answer][2].\r\n\r\nWhen dealing with a number of parameters to a function, it is often useful to allow the consumer to pass the parameter arguments in an object and then *merge* these values with an object that contains the default values for the function\r\n\r\n    function read_file(values) {\r\n        values = merge({ \r\n            delete_after : &quot;my default here&quot;\r\n        }, values || {});\r\n\r\n        // rest of code\r\n    }\r\n\r\n    // simple implementation based on $.extend() from jQuery\r\n    function merge() {\r\n        var obj, name, copy,\r\n            target = arguments[0] || {},\r\n            i = 1,\r\n            length = arguments.length;\r\n\r\n        for (; i &lt; length; i++) {\r\n            if ((obj = arguments[i]) != null) {\r\n                for (name in obj) {\r\n                    copy = obj[name];\r\n\r\n                    if (target === copy) {\r\n                        continue;\r\n                    }\r\n                    else if (copy !== undefined) {\r\n                        target[name] = copy;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return target;\r\n    };\r\n\r\nto use\r\n\r\n    // will use the default delete_after value\r\n    read_file({ file: &quot;my file&quot; }); \r\n\r\n    // will override default delete_after value\r\n    read_file({ file: &quot;my file&quot;, delete_after: &quot;my value&quot; }); \r\n\r\n\r\n  [1]: http://crockford.com/javascript/survey.html\r\n  [2]: https://stackoverflow.com/questions/894860/how-do-i-make-a-default-value-for-a-parameter-to-a-javascript-function/894877#894877"},{"score":3366,"body_markdown":"From [ES6/ES2015][1], default parameters are in the language specification.\r\n\r\n    function read_file(file, delete_after = false) {\r\n      // Code\r\n    }\r\n\r\njust works.\r\n\r\nReference: [Default Parameters - MDN](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters)\r\n\r\n&gt; Default function parameters allow formal parameters to be initialized with default values if **no value** or **undefined** is passed.\r\n\r\nYou can also [simulate default *named* parameters via destructuring](http://exploringjs.com/es6/ch_parameter-handling.html#sec_named-parameters):\r\n\r\n    // the `= {}` below lets you call the function without any parameters\r\n    function myFor({ start = 5, end = 1, step = -1 } = {}) { // (A)\r\n        // Use the variables `start`, `end` and `step` here\r\n        &#183;&#183;&#183;\r\n    }\r\n\r\n\r\n**Pre ES2015**,\r\n\r\nThere are a lot of ways, but this is my preferred method — it lets you pass in anything you want, including false or null. (`typeof null == &quot;object&quot;`)\r\n\r\n    function foo(a, b) {\r\n      a = typeof a !== &#39;undefined&#39; ? a : 42;\r\n      b = typeof b !== &#39;undefined&#39; ? b : &#39;default_b&#39;;\r\n      ...\r\n    }\r\n\r\n\r\n  [1]: https://www.ecma-international.org/ecma-262/6.0/"},{"score":151,"body_markdown":"I find something simple like this to be much more concise and readable personally.\r\n\r\n    function pick(arg, def) {\r\n       return (typeof arg == &#39;undefined&#39; ? def : arg);\r\n    }\r\n    \r\n    function myFunc(x) {\r\n      x = pick(x, &#39;my default&#39;);\r\n    } "},{"score":65,"body_markdown":"In ECMAScript 6 you will actually be able to write exactly what you have:\r\n\r\n    function read_file(file, delete_after = false) {\r\n      // Code\r\n    }\r\n\r\nThis will set `delete_after` to `false` if it s not present or `undefined`. You can use ES6 features like this one today with transpilers such as [Babel][1].\r\n\r\n[See the MDN article for more information][2]. \r\n\r\n\r\n  [1]: http://babeljs.io/\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters"},{"score":10,"body_markdown":"As an update...with ECMAScript 6 you can **FINALLY** set default values in function parameter declarations like so:\r\n\r\n    function f (x, y = 7, z = 42) {\r\n      return x + y + z\r\n    }\r\n\r\n    f(1) === 50\r\n\r\nAs referenced by - [http://es6-features.org/#DefaultParameterValues][1]\r\n\r\n\r\n  [1]: http://es6-features.org/#DefaultParameterValues"},{"score":11,"body_markdown":"Just use an explicit comparison with undefined.\r\n\r\n    function read_file(file, delete_after)\r\n    {\r\n        if(delete_after === undefined) { delete_after = false; }\r\n    }"},{"score":15,"body_markdown":"that solution is work for me in js:\r\n\r\n    function read_file(file, delete_after) {\r\n        delete_after = delete_after || false;\r\n        // Code\r\n    }"},{"score":9,"body_markdown":"being a long time C++ developer (Rookie to web development :)), when I first came across this situation, I did the parameter assignment in the function definition, like it is mentioned in the question, as follows. \r\n\r\n    function myfunc(a,b=10)\r\n\r\nBut beware that it doesn&#39;t work consistently across browsers. For me it worked on chrome on my desktop, but did not work on chrome on android.\r\nSafer option, as many have mentioned above is -\r\n\r\n        function myfunc(a,b)\r\n        {\r\n        if (typeof(b)===&#39;undefined&#39;) b = 10;\r\n    ......\r\n        }\r\nIntention for this answer is not to repeat the same solutions, what others have already mentioned, but to inform that parameter assignment in the function definition may work on some browsers, but don&#39;t rely on it."},{"score":-3,"body_markdown":"Yes, This will work in Javascript. You can also do that:\r\n\r\n    function func(a=10,b=20)\r\n    {\r\n        alert (a+&#39; and &#39;+b);\r\n    }\r\n\r\n    func(); // Result: 10 and 20\r\n\r\n    func(12); // Result: 12 and 20\r\n\r\n    func(22,25); // Result: 22 and 25"},{"score":8,"body_markdown":"To anyone interested in having there code work in Microsoft Edge, do not use defaults in function parameters. \r\n\r\n    function read_file(file, delete_after = false) {\r\n        #code\r\n    }\r\nIn that example Edge will throw an error &quot;Expecting &#39;)&#39;&quot;    \r\n\r\nTo get around this use\r\n\r\n    function read_file(file, delete_after) {\r\n      if(delete_after == undefined)\r\n      {\r\n        delete_after = false;\r\n      }\r\n      #code\r\n    }\r\n\r\nAs of Aug 08 2016 this is still an issue"},{"score":30,"body_markdown":"**Default Parameter Values**\r\n\r\nWith ES6, you can do perhaps one of the most common idioms in `JavaScript` relates to setting a default  value for a function parameter. The way we’ve done this for years should look quite  familiar:\r\n\r\n    function foo(x,y) {\r\n     x = x || 11;\r\n     y = y || 31;\r\n     console.log( x + y );\r\n    }\r\n    foo(); // 42\r\n    foo( 5, 6 ); // 11\r\n    foo( 5 ); // 36\r\n    foo( null, 6 ); // 17\r\n\r\nThis pattern is most used, but is dangerous when we pass values like \r\n\r\n    foo(0, 42)\r\n    foo( 0, 42 ); // 53 &lt;-- Oops, not 42\r\n\r\nWhy? Because the `0 is falsy`, and so the `x || 11 results in 11`, not the directly passed  in 0. To fix this gotcha, some people will instead write the check more verbosely like this:\r\n\r\n    function foo(x,y) {\r\n     x = (x !== undefined) ? x : 11;\r\n     y = (y !== undefined) ? y : 31;\r\n     console.log( x + y );\r\n    }\r\n    foo( 0, 42 ); // 42\r\n    foo( undefined, 6 ); // 17\r\n\r\nwe can now examine a nice helpful syntax added as of `ES6` to  streamline the assignment of default values to missing arguments:\r\n\r\n    function foo(x = 11, y = 31) {\r\n     console.log( x + y );\r\n    }\r\n    \r\n    foo(); // 42\r\n    foo( 5, 6 ); // 11\r\n    foo( 0, 42 ); // 42\r\n    foo( 5 ); // 36\r\n    foo( 5, undefined ); // 36 &lt;-- `undefined` is missing\r\n    foo( 5, null ); // 5 &lt;-- null coerces to `0`\r\n    foo( undefined, 6 ); // 17 &lt;-- `undefined` is missing\r\n    foo( null, 6 ); // 6 &lt;-- null coerces to `0`\r\n\r\n`x = 11` in a function declaration is more like `x !== undefined ? x : 11` than the  much more common idiom `x || 11`\r\n\r\n**Default Value Expressions**\r\n\r\n`Function` default values can be more than just simple values like 31; they can be any  valid expression, even a `function call`:\r\n\r\n    function bar(val) {\r\n     console.log( &quot;bar called!&quot; );\r\n     return y + val;\r\n    }\r\n    function foo(x = y + 3, z = bar( x )) {\r\n     console.log( x, z );\r\n    }\r\n    var y = 5;\r\n    foo(); // &quot;bar called&quot;\r\n     // 8 13\r\n    foo( 10 ); // &quot;bar called&quot;\r\n     // 10 15\r\n    y = 6;\r\n    foo( undefined, 10 ); // 9 10\r\n\r\nAs you can see, the default value expressions are lazily evaluated, meaning they’re  only run if and when they’re needed — that is, when a parameter’s argument is omitted or is undefined.\r\n\r\nA default value expression can  even be an inline function expression call — commonly referred to as an Immediately  Invoked Function Expression `(IIFE)`:\r\n\r\n    function foo( x =\r\n     (function(v){ return v + 11; })( 31 )\r\n    ) {\r\n     console.log( x );\r\n    }\r\n    foo(); // 42"},{"score":5,"body_markdown":"As per the syntax \r\n\r\n    function [name]([param1[ = defaultValue1 ][, ..., paramN[ = defaultValueN ]]]) {\r\n       statements\r\n    }\r\nyou can define the default value of formal parameters.\r\nand also check undefined value by using **typeof** function.\r\n"},{"score":11,"body_markdown":"I would highly recommend extreme caution when using default parameter values in javascript.  It often creates bugs when used in conjunction with higher order functions like `forEach`, `map`, and `reduce`.  For example, consider this line of code:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt); // [1, NaN, NaN]\r\n\r\nparseInt has an optional second parameter `function parseInt(s, [`**radix**`=10])` but map calls `parseInt` with three arguments: (_element_, _index_, and _array_).\r\n\r\nI suggest you separate your required parameters form your optional/default valued arguments.  If your function takes 1,2, or 3 required parameters for which no default value makes sense, make them positional parameters to the function, any optional parameters should follow as named attributes of a single object. If your function takes 4 or more, perhaps it makes more sense to supply all arguments via attributes of a single object parameter.\r\n\r\nIn your case I would suggest you write your deleteFile function like this: (*edited per* `instead`&#39;s *comments*)...\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // unsafe\r\n    function read_file(fileName, deleteAfter=false) {\r\n        if (deleteAfter) {\r\n            console.log(`Reading and then deleting ${fileName}`);\r\n        } else {\r\n            console.log(`Just reading ${fileName}`);\r\n        }\r\n    }\r\n\r\n    // better\r\n    function readFile(fileName, options) {\r\n      const deleteAfter = !!(options &amp;&amp; options.deleteAfter === true);\r\n      read_file(fileName, deleteAfter);\r\n    }\r\n\r\n    console.log(&#39;unsafe...&#39;);\r\n    [&#39;log1.txt&#39;, &#39;log2.txt&#39;, &#39;log3.txt&#39;].map(read_file);\r\n\r\n    console.log(&#39;better...&#39;);\r\n    [&#39;log1.txt&#39;, &#39;log2.txt&#39;, &#39;log3.txt&#39;].map(readFile);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nRunning the above snippet illustrates the dangers lurking behind default argument values for unused parameters.\r\n"},{"score":5,"body_markdown":"    function helloWorld(name, symbol = &#39;!!!&#39;) {\r\n    \tname = name || &#39;worlds&#39;;\r\n    \tconsole.log(&#39;hello &#39; + name + symbol);\r\n    }\r\n\r\n    helloWorld(); // hello worlds!!!\r\n\r\n    helloWorld(&#39;john&#39;); // hello john!!!\r\n\r\n    helloWorld(&#39;john&#39;, &#39;(&gt;.&lt;)&#39;); // hello john(&gt;.&lt;)\r\n\r\n    helloWorld(&#39;john&#39;, undefined); // hello john!!!\r\n\r\n    helloWorld(undefined, undefined); // hello worlds!!!"},{"score":4,"body_markdown":"\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function throwIfNoValue() {\r\n    throw new Error(&#39;Missing argument&#39;);\r\n    }\r\n    function foo(argValue = throwIfNoValue()) {\r\n    return argValue ;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nHere foo() is a function which has a parameter named argValue. If we don’t pass anything in the function call here, then the function throwIfNoValue() will be called and the returned result will be assigned to the only argument argValue. This is how a function call can be used as a default parameter. Which makes the code more simplified and readable.\r\n\r\n[This example has been taken from here][1]\r\n\r\n\r\n  [1]: http://anjandutta.com/javascript-es6-default-parameter/"},{"score":5,"body_markdown":"Use this if you want to use latest **`ECMA6`** syntax:                      \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function myFunction(someValue = &quot;This is DEFAULT!&quot;) {\r\n      console.log(&quot;someValue --&gt; &quot;, someValue);\r\n    }\r\n\r\n    myFunction(&quot;Not A default value&quot;) // calling the function without default value\r\n    myFunction()  // calling the function with default value\r\n\r\n&lt;!-- end snippet --&gt;                                    \r\n\r\n\r\nIt is called [`default function parameters`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters). It allows formal parameters to be initialized with default values if no value or undefined is passed.\r\n**NOTE**: It wont work with Internet Explorer or older browsers.               \r\n\r\nFor maximum possible **compatibility** use this:                       \r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function myFunction(someValue) {\r\n      someValue = (someValue === undefined) ? &quot;This is DEFAULT!&quot; : someValue;\r\n      console.log(&quot;someValue --&gt; &quot;, someValue);\r\n    }\r\n\r\n    myFunction(&quot;Not A default value&quot;) // calling the function without default value\r\n    myFunction()  // calling the function with default value\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nBoth functions have exact same behavior as each of these example rely on the fact that the parameter variable will be `undefined` if no parameter value was passed when calling that function."},{"score":5,"body_markdown":"If you are using `ES6+` you can set default parameters in the following manner:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function test (foo = 1, bar = 2) {\r\n      console.log(foo, bar);\r\n    }\r\n\r\n    test(5); // foo gets overwritten, bar remains default parameter\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf you need `ES5` syntax you can do it in the following manner:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function test(foo, bar) {\r\n      foo = foo || 2;\r\n      bar = bar || 0;\r\n      \r\n      console.log(foo, bar);\r\n    }\r\n\r\n    test(5); // foo gets overwritten, bar remains default parameter\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIn the above syntax the `OR` operator is used. The `OR` operator always returns the first value if this can be converted to `true` if not it returns the righthandside value. When the function is called with no corresponding argument the parameter variable (`bar` in  our example) is set to `undefined` by the JS engine. `undefined` Is then converted to false and thus does the `OR` operator return the value 0."},{"score":5,"body_markdown":"**ES6:** As already mentioned in most answers, in ES6, you can simply initialise a parameter along with a value.\r\n\r\n___\r\n\r\n**ES5:** Most of the given answers aren&#39;t good enough for me because there are occasions where I may have to pass falsey values such as `0`, `null` and `undefined` to a function. To determine if a parameter is undefined because that&#39;s the value I passed instead of undefined due to not have been defined at all I do this:\r\n\r\n    function foo (param1, param2) {\r\n       param1 = arguments.length &gt;= 1 ? param1 : &quot;default1&quot;;\r\n       param2 = arguments.length &gt;= 2 ? param2 : &quot;default2&quot;;\r\n    }"},{"score":0,"body_markdown":"    def read_file(file, delete_after = false)\r\n      # code\r\n    end\r\n\r\nFollowing code may work in this situation including ECMAScript 6 (ES6) as well as earlier versions.    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function read_file(file, delete_after) {\r\n        if(delete_after == undefined)\r\n            delete_after = false;//default value\r\n\r\n        console.log(&#39;delete_after =&#39;,delete_after);\r\n    }\r\n    read_file(&#39;text1.txt&#39;,true);\r\n    read_file(&#39;text2.txt&#39;);\r\n&lt;!-- end snippet --&gt;\r\n\r\nas default value in languages works when the function&#39;s parameter value is skipped when calling, in JavaScript it is assigned to **undefined**. This approach doesn&#39;t look attractive programmatically but have **backward compatibility**."},{"score":0,"body_markdown":"Yeah this is referred to as a default parameter\r\n\r\nDefault function parameters allow formal parameters to be initialized with default values if no value or undefined is passed.\r\n\r\nSyntax:\r\n\r\n    function [name]([param1[ = defaultValue1 ][, ..., paramN[ = defaultValueN ]]]) {\r\n       statements\r\n    }\r\n\r\n**Description:**\r\n\r\nParameters of functions default to undefined However, in situations it might be useful to set a different default value.  This is where default parameters can help. \r\n\r\nIn the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are undefined.  If no value is provided in the call, its value would be undefined.  You would have to set a conditional check to make sure the parameter is not undefined\r\n\r\nWith default parameters in ES2015, the check in the function body is no longer necessary.  Now you can simply put a default value in the function head.\r\n\r\nExample of the differences:\r\n\r\n    // OLD METHOD\r\n    function multiply(a, b) {\r\n      b = (typeof b !== &#39;undefined&#39;) ?  b : 1;\r\n      return a * b;\r\n    }\r\n \r\n    multiply(5, 2); // 10\r\n    multiply(5, 1); // 5\r\n    multiply(5);    // 5\r\n \r\n \r\n    // NEW METHOD\r\n    function multiply(a, b = 1) {\r\n      return a * b;\r\n    }\r\n \r\n    multiply(5, 2); // 10\r\n    multiply(5, 1); // 5\r\n    multiply(5);    // 5\r\n\r\n**Different Syntax Examples:**\r\n\r\nPadding undefined vs other falsy values:\r\n\r\n\r\nEven if the value is set explicitly when calling, the value of the num argument is the default one.\r\n\r\n    function test(num = 1) {\r\n      console.log(typeof num);\r\n    }\r\n \r\n    test();          // &#39;number&#39; (num is set to 1)\r\n    test(undefined); // &#39;number&#39; (num is set to 1 too)\r\n \r\n    // test with other falsy values:\r\n    test(&#39;&#39;);        // &#39;string&#39; (num is set to &#39;&#39;)\r\n    test(null);      // &#39;object&#39; (num is set to null)\r\n\r\nEvaluated at call time:\r\n\r\nThe default argument gets evaluated at call time, so unlike some other languages, a new object is created each time the function is called.\r\n\r\n    function append(value, array = []) {\r\n      array.push(value);\r\n      return array;\r\n    }\r\n \r\n    append(1); //[1]\r\n    append(2); //[2], not [1, 2]\r\n \r\n \r\n    // This even applies to functions and variables\r\n    function callSomething(thing = something()) {\r\n     return thing;\r\n    }\r\n \r\n    function something() {\r\n      return &#39;sth&#39;;\r\n    }\r\n \r\n    callSomething();  //sth\r\n\r\nDefault parameters are available to later default parameters:\r\n\r\nParams already encountered are available to later default parameters\r\n\r\n    function singularAutoPlural(singular, plural = singular + &#39;s&#39;,\r\n                            rallyingCry = plural + &#39; ATTACK!!!&#39;) {\r\n      return [singular, plural, rallyingCry];\r\n    }\r\n \r\n    //[&quot;Gecko&quot;,&quot;Geckos&quot;, &quot;Geckos ATTACK!!!&quot;]\r\n    singularAutoPlural(&#39;Gecko&#39;);\r\n \r\n    //[&quot;Fox&quot;,&quot;Foxes&quot;, &quot;Foxes ATTACK!!!&quot;]\r\n    singularAutoPlural(&#39;Fox&#39;, &#39;Foxes&#39;);\r\n \r\n    //[&quot;Deer&quot;, &quot;Deer&quot;, &quot;Deer ... change.&quot;]\r\n    singularAutoPlural(&#39;Deer&#39;, &#39;Deer&#39;, &#39;Deer peaceably and respectfully \\ petition the government for positive change.&#39;)\r\n\r\nFunctions defined inside function body:\r\n\r\nIntroduced in Gecko 33 (Firefox 33 / Thunderbird 33 / SeaMonkey 2.30). Functions declared in the function body cannot be referred inside default parameters and throw a ReferenceError (currently a TypeError in SpiderMonkey, see bug 1022967). Default parameters are always executed first, function declarations inside the function body evaluate afterwards.\r\n\r\n    // Doesn&#39;t work! Throws ReferenceError.\r\n    function f(a = go()) {\r\n      function go() { return &#39;:P&#39;; }\r\n    }\r\n\r\nParameters without defaults after default parameters:\r\n\r\nPrior to Gecko 26 (Firefox 26 / Thunderbird 26 / SeaMonkey 2.23 / Firefox OS 1.2), the following code resulted in a SyntaxError. This has been fixed in bug 777060 and works as expected in later versions. Parameters are still set left-to-right, overwriting default parameters even if there are later parameters without defaults.\r\n\r\n    function f(x = 1, y) {\r\n      return [x, y];\r\n    }\r\n \r\n    f(); // [1, undefined]\r\n    f(2); // [2, undefined]\r\n\r\nDestructured paramet with default value assignment:\r\n\r\nYou can use default value assignment with the destructuring assignment notation\r\n\r\n    function f([x, y] = [1, 2], {z: z} = {z: 3}) {\r\n      return x + y + z;\r\n    }\r\n \r\n    f(); // 6"},{"score":3,"body_markdown":"If for some reason you are **not** on ES6 and **are** using [`lodash`][1] here is a concise way to default function parameters via [`_.defaultTo`][2] method:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var fn = function(a, b) {\r\n      a = _.defaultTo(a, &#39;Hi&#39;)\r\n      b = _.defaultTo(b, &#39;Mom!&#39;)\r\n\r\n      console.log(a, b)\r\n    }\r\n\r\n    fn()                 // Hi Mom!\r\n    fn(undefined, null)  // Hi Mom!\r\n    fn(NaN, NaN)         // Hi Mom!\r\n    fn(1)                // 1 &quot;Mom!&quot;\r\n    fn(null, 2)          // Hi 2\r\n    fn(false, false)     // false false\r\n    fn(0, 2)             // 0 2\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js&quot;&gt;&lt;/script&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nWhich will set the default if the current value is **NaN**, **null**, or **undefined**\r\n\r\n\r\n  [1]: https://lodash.com/\r\n  [2]: https://lodash.com/docs/4.17.10#defaultTo"},{"score":4,"body_markdown":"Yes, using default parameters is fully supported in **ES6**:\r\n\r\n    function read_file(file, delete_after = false) {\r\n      // Code\r\n    }\r\n\r\nor \r\n\r\n  \r\n\r\n    const read_file = (file, delete_after = false) =&gt; {\r\n        // Code\r\n    }\r\n\r\nbut prior in **ES5** you could easily do this:\r\n\r\n    function read_file(file, delete_after) {\r\n      var df = delete_after || false;\r\n      // Code\r\n    }\r\n\r\nWhich means if the value is there, use the value, otherwise, use the second value after `||` operation which does the same thing...\r\n\r\n**Note:** also there is a big difference between those if you pass a value to **ES6** one even the value be falsy, that will be replaced with new value, something like `null` or `&quot;&quot;`... but **ES5** one only will be replaced if only the passed value is truthy, that&#39;s because the way `||` working...\r\n\r\n"},{"score":0,"body_markdown":"Just a different approach to set default params is to use object map of arguments, instead of arguments directly.\r\nFor example, \r\n\r\n    const defaultConfig = {\r\n     category: &#39;Animals&#39;,\r\n     legs: 4\r\n    };\r\n    \r\n    function checkOrganism(props) {\r\n     const category = props.category || defaultConfig.category;\r\n     const legs = props.legs || defaultConfig.legs;\r\n    }\r\n\r\nThis way, it&#39;s easy to extend the arguments and not worry about argument length mismatch.\r\n\r\n"},{"score":-1,"body_markdown":"The answer is yes. In fact, there are many languages who support default parameters. Python is one of them: \r\n\r\n    def(a, enter=&quot;Hello&quot;):\r\n       print(a+enter)\r\n\r\nEven though this is Python 3 code due to the parentheses, default parameters in functions also work in JS.\r\n\r\nFor example, and in your case: \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function read_file(file, deleteAfter=false){\r\n      console.log(deleteAfter);\r\n    }\r\n\r\n    read_file(&quot;test.txt&quot;);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nBut sometimes you don&#39;t really need default parameters.\r\n\r\nYou can just define the variable right after the start of the function, like this:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function read_file(file){\r\n      var deleteAfter = false;\r\n      console.log(deleteAfter);\r\n    }\r\n\r\n    read_file(&quot;test.txt&quot;);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIn both of my examples, it returns the same thing. But sometimes they actually could be useful, like in very advanced projects.\r\n\r\nSo, in conclusion, default parameter values can be used in JS. But it is almost the same thing as defining a variable right after the start of the function. However, sometimes they are still very useful. As you have may noticed, default parameter values take 1 less line of code than the standard way which is defining the parameter right after the start of the function. \r\n\r\n***EDIT:*** And this is super important! This will *not* work in IE. See [documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters#Browser_compatibility). So with IE you have to use the &quot;define variable at top of function&quot; method. Default parameters won&#39;t work in IE.\r\n\r\n\r\n\r\n "},{"score":2,"body_markdown":"## Sounds of Future\n\nIn future, you will be able to &quot;spread&quot; one object to another (currently as of 2019 [NOT supported by Edge][1]!) - demonstration how to use that for nice default options regardless of order:\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    function test(options) {\n        var options = {\n           // defaults\n           url: &#39;defaultURL&#39;,\n           some: &#39;somethingDefault&#39;,\n           // override with input options\n           ...options\n        };\n        \n        var body = document.getElementsByTagName(&#39;body&#39;)[0];\n        body.innerHTML += &#39;&lt;br&gt;&#39; + options.url + &#39; : &#39; + options.some;\n    }\n    test();\n    test({});\n    test({url:&#39;myURL&#39;});\n    test({some:&#39;somethingOfMine&#39;});\n    test({url:&#39;overrideURL&#39;, some:&#39;andSomething&#39;});\n    test({url:&#39;overrideURL&#39;, some:&#39;andSomething&#39;, extra:&#39;noProblem&#39;});\n\n\n&lt;!-- end snippet --&gt;\n\n\n\nMDN reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\n\n...meanwhile what [Edge DOES support is Object.assign()][2] (IE does not, but I really hope we can leave IE behind :) )\n\nSimilarly you could do\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n        function test(options) {\n            var options = Object.assign({\n               // defaults\n               url: &#39;defaultURL&#39;,\n               some: &#39;somethingDefault&#39;,\n            }, options); // override with input options\n            \n            var body = document.getElementsByTagName(&#39;body&#39;)[0];\n            body.innerHTML += &#39;&lt;br&gt;&#39; + options.url + &#39; : &#39; + options.some;\n        }\n        test();\n        test({});\n        test({url:&#39;myURL&#39;});\n        test({some:&#39;somethingOfMine&#39;});\n        test({url:&#39;overrideURL&#39;, some:&#39;andSomething&#39;});\n        test({url:&#39;overrideURL&#39;, some:&#39;andSomething&#39;, extra:&#39;noProblem&#39;});\n\n&lt;!-- end snippet --&gt;\n\n\n**EDIT:** Due to comments regarding `const` options - the problem with using constant options in the rest of the function is actually **not** that you can&#39;t do that, is just that you can&#39;t use the constant variable in its own declaration - you would have to adjust the input naming to something like \n\n    function test(input_options){\n       const options = {\n         // defaults\n         someKey:    &#39;someDefaultValue&#39;,\n         anotherKey: &#39;anotherDefaultValue&#39;,\n\n         // merge-in input options\n         ...input_options\n       };\n\n       // from now on use options with no problem\n    }\n\n\n\n\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility"},{"score":1,"body_markdown":"Just to showcase my skills too (lol), above function can written even without having named arguments as below:\r\n\r\n**ES5 and above**\r\n\r\n    function foo() {\r\n        a = typeof arguments[0] !== &#39;undefined&#39; ? a : 42;\r\n        b = typeof arguments[1] !== &#39;undefined&#39; ? b : &#39;default_b&#39;;\r\n        ...\r\n    }\r\n\r\n**ES6 and above**\r\n\r\n    function foo(...rest) {\r\n        a = typeof rest[0] !== &#39;undefined&#39; ? a : 42;\r\n        b = typeof rest[1] !== &#39;undefined&#39; ? b : &#39;default_b&#39;;\r\n        ...\r\n    }"},{"score":0,"body_markdown":"# Yes - proof:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function read_file(file, delete_after = false) {\r\n      // Code\r\n      console.log({file,delete_after});\r\n    }\r\n\r\n\r\n\r\n    // TEST\r\n    read_file(&quot;A&quot;);\r\n    read_file(&quot;B&quot;,true);\r\n    read_file(&quot;C&quot;,false);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"}],"score":2434}