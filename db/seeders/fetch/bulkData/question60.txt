{"body":"How do you safely encode a URL using JavaScript such that it can be put into a GET string?\r\n\r\n    var myUrl = &quot;http://example.com/index.html?param=1&amp;anotherParam=2&quot;;\r\n    var myOtherUrl = &quot;http://example.com/index.html?url=&quot; + myUrl;\r\n\r\nI assume that you need to encode the `myUrl` variable on that second line?\r\n","title":"Encode URL in JavaScript?","answers":[{"score":2867,"body_markdown":"Check out the built-in function [encodeURIComponent(str)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) and [encodeURI(str)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI).  \r\nIn your case, this should work:\r\n\r\n    var myOtherUrl = \r\n           &quot;http://example.com/index.html?url=&quot; + encodeURIComponent(myUrl);\r\n"},{"score":1555,"body_markdown":"You have three options:\r\n\r\n  -  `escape()` will not encode: `@*/+`\r\n\r\n  -  `encodeURI()` will not encode: `~!@#$&amp;*()=:/,;?+&#39;`\r\n\r\n  -  `encodeURIComponent()` will not encode: `~!*()&#39;`\r\n\r\nBut in your case, if you want to pass a [URL][1] into a `GET` parameter of other page, you should use `escape` or `encodeURIComponent`, but not `encodeURI`.\r\n\r\nSee Stack Overflow question *[Best practice: escape, or encodeURI / encodeURIComponent][2]* for further discussion.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Uniform_Resource_Locator\r\n  [2]: https://stackoverflow.com/questions/75980/best-practice-escape-or-encodeuri-encodeuricomponent\r\n"},{"score":187,"body_markdown":"Stick with [`encodeURIComponent()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent). The function [`encodeURI()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) does not bother to encode many characters that have semantic importance in URLs (e.g. &quot;#&quot;, &quot;?&quot;, and &quot;&amp;&quot;). [`escape()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape) is deprecated, and does not bother to encode &quot;+&quot; characters, which will be interpreted as encoded spaces on the server (and, as pointed out by others here, does not properly URL-encode non-ASCII characters).\r\n\r\nThere is a nice [explanation of the difference between `encodeURI()` and `encodeURIComponent()`][1] elsewhere. If you want to encode something so that it can safely be included as a component of a URI (e.g. as a query string parameter), you want to use `encodeURIComponent()`.\r\n\r\n  [1]: https://stackoverflow.com/questions/75980/best-practice-escape-or-encodeuri-encodeuricomponent"},{"score":3,"body_markdown":"Nothing worked for me. All I was seeing was the HTML of the login page, coming back to the client side with code 200. (302 at first but the same Ajax request loading login page inside another Ajax request, which was supposed to be a redirect rather than loading plain text of the login page).\r\n\r\nIn the login controller, I added this line:\r\n\r\n    Response.Headers[&quot;land&quot;] = &quot;login&quot;;\r\n\r\nAnd in the global Ajax handler, I did this:\r\n\r\n    $(function () {\r\n        var $document = $(document);\r\n        $document.ajaxSuccess(function (e, response, request) {\r\n            var land = response.getResponseHeader(&#39;land&#39;);\r\n            var redrUrl = &#39;/login?ReturnUrl=&#39; + encodeURIComponent(window.location);\r\n            if(land) {\r\n                if (land.toString() === &#39;login&#39;) {\r\n                    window.location = redrUrl;\r\n                }\r\n            }\r\n        });\r\n    });\r\n\r\nNow I don&#39;t have any issue, and it works like a charm.\r\n"},{"score":85,"body_markdown":"The best answer is to use `encodeURIComponent` on *values* in the query string (and nowhere else).\r\n\r\nHowever, I find that many APIs want to replace &quot; &quot; with &quot;+&quot; so I&#39;ve had to use the following:\r\n\r\n```javascript\r\nconst value = encodeURIComponent(value).replace(&#39;%20&#39;,&#39;+&#39;);\r\nconst url = &#39;http://example.com?lang=en&amp;key=&#39; + value\r\n```\r\n\r\n`escape` is implemented differently in different browsers and `encodeURI` doesn&#39;t encode many characters (like # and even /) -- it&#39;s made to be used on a full URI/URL without breaking it â€“ which isn&#39;t super helpful or secure.\r\n\r\nAnd as @Jochem points out below, you may want to use `encodeURIComponent()` on a (each) folder name, but for whatever reason these APIs don&#39;t seem to want `+` in folder names so plain old `encodeURIComponent` works great.\r\n\r\nExample:\r\n\r\n```javascript\r\nconst escapedValue = encodeURIComponent(value).replace(&#39;%20&#39;,&#39;+&#39;);\r\nconst escapedFolder = encodeURIComponent(&#39;My Folder&#39;); // no replace\r\nconst url = `http://example.com/${escapedFolder}/?myKey=${escapedValue}`;\r\n```"},{"score":41,"body_markdown":"I would suggest to use [qs npm package][1]\r\n\r\n    qs.stringify({a:&quot;1=2&quot;, b:&quot;Test 1&quot;}); // gets a=1%3D2&amp;b=Test+1\r\n\r\nit is easier to use with JS object and it gives you proper URL encoding for all parameters\r\n\r\n\r\nIf you are using jQuery I would go for [`$.param`](http://api.jquery.com/jquery.param/) method. It URL encodes an object mapping fields to values, which is easier to read than calling an escape method on each value.\r\n\r\n    $.param({a:&quot;1=2&quot;, b:&quot;Test 1&quot;}) // gets a=1%3D2&amp;b=Test+1\r\n\r\n\r\n  [1]: https://www.npmjs.com/package/qs"},{"score":6,"body_markdown":"Similar kind of thing I tried with normal javascript\r\n    \r\n    function fixedEncodeURIComponent(str){\r\n    \t return encodeURIComponent(str).replace(/[!&#39;()]/g, escape).replace(/\\*/g, &quot;%2A&quot;);\r\n    }"},{"score":2,"body_markdown":" **Encode URL String**\r\n    &lt;pre&gt;\r\n    var url = $(location).attr(&#39;href&#39;); //get current url\r\n    //OR\r\n    var url = &#39;folder/index.html?param=#23dd&amp;noob=yes&#39;; //or specify one\r\n    \r\n    var encodedUrl = encodeURIComponent(url);\r\n    console.log(encodedUrl);\r\n    //outputs folder%2Findex.html%3Fparam%3D%2323dd%26noob%3Dyes\r\n\r\n    \r\n    for more info go http://www.sitepoint.com/jquery-decode-url-string\r\n   \r\n    \r\n"},{"score":13,"body_markdown":"encodeURIComponent() is the way to go.\r\n\r\n    var myOtherUrl = &quot;http://example.com/index.html?url=&quot; + encodeURIComponent(myUrl);\r\n\r\nBUT you should keep in mind that there are small differences from php version `urlencode()` and as @CMS mentioned, it will not encode every char. Guys at http://phpjs.org/functions/urlencode/ made js equivalent to `phpencode()`:\r\n\r\n    function urlencode(str) {\r\n      str = (str + &#39;&#39;).toString();\r\n    \r\n      // Tilde should be allowed unescaped in future versions of PHP (as reflected below), but if you want to reflect current\r\n      // PHP behavior, you would need to add &quot;.replace(/~/g, &#39;%7E&#39;);&quot; to the following.\r\n      return encodeURIComponent(str)\r\n        .replace(&#39;!&#39;, &#39;%21&#39;)\r\n        .replace(&#39;\\&#39;&#39;, &#39;%27&#39;)\r\n        .replace(&#39;(&#39;, &#39;%28&#39;)\r\n        .replace(&#39;)&#39;, &#39;%29&#39;)\r\n        .replace(&#39;*&#39;, &#39;%2A&#39;)\r\n        .replace(&#39;%20&#39;, &#39;+&#39;);\r\n    }"},{"score":1,"body_markdown":"You can use esapi library and encode your url using the below function. The function ensures that &#39;/&#39; are not lost to encoding while the remainder of the text contents are encoded:\r\n\r\n    function encodeUrl(url)\r\n    {\r\n    \tString arr[] = url.split(&quot;/&quot;);\r\n    \tString encodedUrl = &quot;&quot;;\r\n    \tfor(int i = 0; i&lt;arr.length; i++)\r\n    \t{\r\n    \t\tencodedUrl = encodedUrl + ESAPI.encoder().encodeForHTML(ESAPI.encoder().encodeForURL(arr[i]));\r\n    \t\tif(i&lt;arr.length-1) encodedUrl = encodedUrl + &quot;/&quot;;\r\n    \t}\r\n    \treturn url;\r\n    }\r\n\r\n[https://www.owasp.org/index.php/ESAPI_JavaScript_Readme][1]\r\n\r\n\r\n  [1]: https://www.owasp.org/index.php/ESAPI_JavaScript_Readme"},{"score":4,"body_markdown":"To prevent double encoding it&#39;s a good idea to decode the url before encoding (if you are dealing with user entered urls for example, which might be already encoded).\r\n\r\nLets say we have `abc%20xyz 123` as input (one space is already encoded):\r\n\r\n\tencodeURI(&quot;abc%20xyz 123&quot;)            //   wrong: &quot;abc%2520xyz%20123&quot;\r\n\tencodeURI(decodeURI(&quot;abc%20xyz 123&quot;)) // correct: &quot;abc%20xyz%20123&quot;"},{"score":11,"body_markdown":"To encode a URL, as has been said before, you have two functions:\r\n\r\n    encodeURI()\r\n\r\nand \r\n\r\n    encodeURIComponent()\r\n\r\nThe reason both exist is that the first preserves the URL with the risk of leaving too many things unescaped, while the second encodes everything needed.\r\n\r\nWith the first, you could copy the newly escaped URL into address bar (for example) and it would work.  However your unescaped &#39;&amp;&#39;s would interfere with field delimiters, the &#39;=&#39;s would interfere with field names and values, and the &#39;+&#39;s would look like spaces.  But for simple data when you want to preserve the URL nature of what you are escaping, this works.\r\n\r\nThe second is everything you need to do to make sure nothing in your string interfers with a URL.  It leaves various unimportant characters unescaped so that the URL remains as human readable as possible without interference.  A URL encoded this way will no longer work as a URL without unescaping it.\r\n\r\nSo if you can take the time, you always want to use encodeURIComponent() -- before adding on name/value pairs encode both the name and the value using this function before adding it to the query string.\r\n\r\nI&#39;m having a tough time coming up with reasons to use the encodeURI() -- I&#39;ll leave that to the smarter people."},{"score":5,"body_markdown":"What is URL encoding:\r\n---------------------\r\n\r\nA URL should be encoded when there are special characters located inside the URL. For example:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    console.log(encodeURIComponent(&#39;?notEncoded=&amp;+&#39;));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nWe can observe in this example that all characters except the string `notEncoded` are encoded with % signs. URL encoding is also known as **percentage encoding** because it escapes all special characters with a %. Then after this % sign every special character has a unique code\r\n\r\nWhy do we need URL encoding:\r\n----------------------------\r\n\r\nCertain characters have a special value in a URL string. For example, the ? character denotes the beginning of a query string. In order to succesfully locate a resource on the web, it is necesarry to distinguish between when a character is meant as a part of string or part of the url structure.\r\n\r\nHow can we achieve URL encoding in JS:\r\n--------------------------------\r\n\r\nJS offers a bunch of build in utility function which we can use to easily encode URL&#39;s. These are two convenient options:\r\n\r\n 1. `encodeURIComponent()`: Takes a component of a URI as an argument and returns the encoded URI string.\r\n 2. `encodeURI()`:  Takes a  URI as an argument and returns the encoded URI string.\r\n\r\nExample and caveats:\r\n--------------------\r\n\r\nBe aware of not passing in the whole URL (including scheme, e.g https://) into `encodeURIComponent()`. This can actually transform it into a not functional URL. For example:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // for a whole URI don&#39;t use encodeURIComponent it will transform\r\n    // the / characters and the URL won&#39;t fucntion properly\r\n    console.log(encodeURIComponent(&quot;http://www.random.com/specials&amp;char.html&quot;));\r\n\r\n    // instead use encodeURI for whole URL&#39;s\r\n    console.log(encodeURI(&quot;http://www.random.com/specials&amp;char.html&quot;));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nWe can observe f we put the whole URL in `encodeURIComponent` that the foward slashes (/) are also converted to special characters. This will cause the URL to not function properly anymore. \r\n\r\nTherefore (as the name implies) use:\r\n\r\n 1. `encodeURIComponent` on a certain part of a URL which you want to encode.\r\n 2. `encodeURI` on a whole URL which you want to encode.\r\n\r\n"},{"score":2,"body_markdown":"Here is a [LIVE DEMO][1] of `encodeURIComponent()` and `decodeURIComponent()` JS built in functions:\r\n\r\n\r\n    &lt;!DOCTYPE html&gt;\r\n    &lt;html&gt;\r\n      &lt;head&gt;\r\n        &lt;style&gt;\r\n          textarea{\r\n            width:30%;\r\n            height:100px;\r\n          }\r\n        &lt;/style&gt;\r\n        &lt;script&gt;\r\n          // encode string to base64\r\n          function encode()\r\n          {\r\n            var txt = document.getElementById(&quot;txt1&quot;).value;\r\n            var result = btoa(txt);\r\n            document.getElementById(&quot;txt2&quot;).value = result;\r\n          }\r\n          // decode base64 back to original string\r\n          function decode()\r\n          {\r\n            var txt = document.getElementById(&quot;txt3&quot;).value;\r\n            var result = atob(txt);\r\n            document.getElementById(&quot;txt4&quot;).value = result;\r\n          }\r\n        &lt;/script&gt;\r\n      &lt;/head&gt;\r\n      &lt;body&gt;\r\n        &lt;div&gt;\r\n          &lt;textarea id=&quot;txt1&quot;&gt;Some text to decode\r\n          &lt;/textarea&gt;\r\n        &lt;/div&gt;\r\n        &lt;div&gt;\r\n          &lt;input type=&quot;button&quot; id=&quot;btnencode&quot; value=&quot;Encode&quot; onClick=&quot;encode()&quot;/&gt;\r\n        &lt;/div&gt;\r\n        &lt;div&gt;\r\n          &lt;textarea id=&quot;txt2&quot;&gt;\r\n          &lt;/textarea&gt;\r\n        &lt;/div&gt;\r\n        &lt;br/&gt;\r\n        &lt;div&gt;\r\n          &lt;textarea id=&quot;txt3&quot;&gt;U29tZSB0ZXh0IHRvIGRlY29kZQ==\r\n          &lt;/textarea&gt;\r\n        &lt;/div&gt;\r\n        &lt;div&gt;\r\n          &lt;input type=&quot;button&quot; id=&quot;btndecode&quot; value=&quot;Decode&quot; onClick=&quot;decode()&quot;/&gt;\r\n        &lt;/div&gt;\r\n        &lt;div&gt;\r\n          &lt;textarea id=&quot;txt4&quot;&gt;\r\n          &lt;/textarea&gt;\r\n        &lt;/div&gt;\r\n      &lt;/body&gt;\r\n    &lt;/html&gt;\r\n\r\n  [1]: https://codverter.com/src/webeditor?query=64199300-c557-4048-b924-c2561dcfbf17\r\n"},{"score":1,"body_markdown":"Use `fixedEncodeURIComponent` function to strictly comply with [RFC 3986][1]:\r\n\r\n    function fixedEncodeURIComponent(str) {\r\n      return encodeURIComponent(str).replace(/[!&#39;()*]/g, function(c) {\r\n        return &#39;%&#39; + c.charCodeAt(0).toString(16);\r\n      });\r\n    }\r\n\r\n\r\n  [1]: https://tools.ietf.org/html/rfc3986"},{"score":7,"body_markdown":"# Elegant way\r\nIn my humble opinion the most elegant way to encode query params is to create an object with params like \r\n```javascript\r\nconst queryParams = { param1: &#39;value1&#39;, param2: &#39;value2&#39; }\r\n```\r\nand then encode it using: \r\n```javascript\r\nconst queryString = new URLSearchParams(queryParams).toString()\r\n``` \r\nas mentioned in this answer: \r\nhttps://stackoverflow.com/a/53171438/7284582"},{"score":2,"body_markdown":"*You should not use `encodeURIComponent()` directly.*\r\n\r\n[Take a look at RFC3986: Uniform Resource Identifier (URI): Generic Syntax][1]\r\n\r\n&gt;sub-delims  = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;&#39;&quot; / &quot;(&quot; / &quot;)&quot;\r\n&gt;                  / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;\r\n&gt;\r\n&gt;   The purpose of reserved characters is to provide a set of delimiting characters that are distinguishable from other data within a URI.\r\n\r\n***These reserved characters from the URI definition in RFC3986 ARE NOT escaped by `encodeURIComponent()`.***\r\n\r\n[MDN Web Docs: encodeURIComponent()][2]\r\n\r\n&gt;To be more stringent in adhering to RFC 3986 (which reserves !, &#39;, (, ), and *), even though these characters have no formalized URI delimiting uses, the following can be safely used:\r\n\r\nUse the MDN Web Docs function...\r\n\r\n    function fixedEncodeURIComponent(str) {\r\n      return encodeURIComponent(str).replace(/[!&#39;()*]/g, function(c) {\r\n        return &#39;%&#39; + c.charCodeAt(0).toString(16);\r\n      });\r\n    }\r\n\r\n\r\n  [1]: https://tools.ietf.org/html/rfc3986\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent"},{"score":0,"body_markdown":"Performance\r\n-\r\n\r\nToday (2020.06.12) I perform speed test for chosen solutions on MacOs HighSierra 10.13.6 on browsers Chrome 83.0, Safari 13.1, Firefox 77.0. This results can be useful for massive urls encoding.\r\n\r\nConclusions\r\n-\r\n* `encodeURI` (B) seems to be fastest but it is not [recommended for url-s](https://stackoverflow.com/a/332897/860099)  \r\n* `escape` (A) is fast cross-browser solution\r\n* solution F recommended by [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) is medium fast\r\n* solution D is slowest\r\n\r\n[![enter image description here][1]][1]\r\n\r\n\r\nDetails\r\n-\r\n\r\nFor solutions \r\n[A](https://stackoverflow.com/a/332897/860099)\r\n[B](https://stackoverflow.com/a/332897/860099)\r\n[C](https://stackoverflow.com/a/332888/860099)\r\n[D](https://stackoverflow.com/a/58879100/860099)\r\n[E](https://stackoverflow.com/a/16536783/860099)\r\n[F](https://stackoverflow.com/a/61843371/860099)\r\nI perform two tests\r\n\r\n* for short url - 50 char - you can run it [HERE](https://jsbench.me/9hkbbw4580/1)\r\n* for long url - 1M char - you can run it [HERE](https://jsbench.me/ffkbbw662s/1)\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function A(url) {\r\n    \treturn escape(url);\r\n    }\r\n\r\n    function B(url) {\r\n    \treturn encodeURI(url);\r\n    }\r\n\r\n    function C(url) {\r\n    \treturn encodeURIComponent(url);\r\n    }\r\n\r\n    function D(url) {\r\n    \treturn new URLSearchParams({url}).toString();\r\n    }\r\n\r\n    function E(url){\r\n         return encodeURIComponent(url).replace(/[!&#39;()]/g, escape).replace(/\\*/g, &quot;%2A&quot;);\r\n    }\r\n\r\n    function F(url) {\r\n      return encodeURIComponent(url).replace(/[!&#39;()*]/g, function(c) {\r\n        return &#39;%&#39; + c.charCodeAt(0).toString(16);\r\n      });\r\n    }\r\n\r\n\r\n\r\n    // ----------\r\n    // TEST\r\n    // ----------\r\n\r\n    var myUrl = &quot;http://example.com/index.html?param=1&amp;anotherParam=2&quot;;\r\n\r\n    [A,B,C,D,E,F]\r\n      .forEach(f=&gt; console.log(`${f.name} ?url=${f(myUrl).replace(/^url=/,&#39;&#39;)}`));\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    This snippet only presents code of choosen solutions\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nExample results for Chrome\r\n\r\n[![enter image description here][2]][2]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/Z9Xjl.png\r\n  [2]: https://i.stack.imgur.com/HBWv9.png"},{"score":0,"body_markdown":"    var myOtherUrl = \r\n       &quot;http://example.com/index.html?url=&quot; + encodeURIComponent(myUrl).replace(/%20/g,&#39;+&#39;);\r\n\r\nDon&#39;t forget the /g flag to replace all encoded &#39; &#39;"}],"score":2544}