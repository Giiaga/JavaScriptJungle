{"body":"I would like to upload a file asynchronously with jQuery. \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $(document).ready(function () {\r\n        $(&quot;#uploadbutton&quot;).click(function () {\r\n            var filename = $(&quot;#file&quot;).val();\r\n\r\n            $.ajax({\r\n                type: &quot;POST&quot;,\r\n                url: &quot;addFile.do&quot;,\r\n                enctype: &#39;multipart/form-data&#39;,\r\n                data: {\r\n                    file: filename\r\n                },\r\n                success: function () {\r\n                    alert(&quot;Data Uploaded: &quot;);\r\n                }\r\n            });\r\n        });\r\n    });\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.0/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;span&gt;File&lt;/span&gt;\r\n    &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; size=&quot;10&quot;/&gt;\r\n    &lt;input id=&quot;uploadbutton&quot; type=&quot;button&quot; value=&quot;Upload&quot;/&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n    \r\n\r\nInstead of the file being uploaded, I am only getting the filename. What can I do to fix this problem?\r\n","title":"How can I upload files asynchronously?","answers":[{"score":104,"body_markdown":" Note: This answer is outdated, it is now possible to upload files using XHR.\r\n\r\n---\r\n\r\nYou cannot upload files using [XMLHttpRequest][1] (Ajax). You can simulate the effect using an iframe or Flash. The excellent [jQuery Form Plugin][2] that posts your files through an iframe to get the effect.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/XMLHttpRequest\r\n  [2]: http://malsup.com/jquery/form/\r\n\r\n"},{"score":290,"body_markdown":"## 2019 Update: It *still* depends on the browsers *your* demographic uses.\r\n\r\nAn important thing to understand with the &quot;new&quot; HTML5 `file` API is that it [wasn&#39;t supported until IE&#160;10][1]. If the specific market you&#39;re aiming at has a higher-than-average propensity toward older versions of Windows, you might not have access to it.\r\n\r\nAs of 2017, about 5% of browsers are one of IE 6, 7, 8 or 9. If you head into a big corporation (e.g., this is a B2B tool, or something you&#39;re delivering for training) that number can skyrocket. In 2016, I dealt with a company using IE8 on over 60% of their machines.\r\n\r\nIt&#39;s 2019 as of this edit, almost 11 years after my initial answer. IE9 and lower are *globally* around the 1% mark but there are still clusters  of higher usage.\r\n\r\nThe important take-away from this —whatever the feature— is, **check what browser *your* users use**. If you don&#39;t, you&#39;ll learn a quick and painful lesson in why &quot;works for me&quot; isn&#39;t good enough in a deliverable to a client. [caniuse][2] is a useful tool but note where they get their demographics from. They may not align with yours. This is never truer than enterprise environments.\r\n\r\nMy answer from 2008 follows.\r\n\r\n---\r\n\r\nHowever, there are viable non-JS methods of file uploads. You can create an iframe on the page (that you hide with CSS) and then target your form to post to that iframe. The main page doesn&#39;t need to move.\r\n\r\nIt&#39;s a &quot;real&quot; post so it&#39;s not wholly interactive. If you need status you need something server-side to process that. This varies massively depending on your server. [ASP.NET][3] has nicer mechanisms. PHP plain fails, but you can use [Perl][4] or Apache modifications to get around it.\r\n\r\nIf you need multiple file-uploads, it&#39;s best to do each file one at a time (to overcome maximum file upload limits). Post the first form to the iframe, monitor its progress using the above and when it has finished, post the second form to the iframe, and so on.\r\n\r\nOr use a Java/Flash solution. They&#39;re a lot more flexible in what they can do with their posts...\r\n\r\n\r\n  [1]: http://caniuse.com/fileapi\r\n  [2]: https://caniuse.com/\r\n  [3]: http://en.wikipedia.org/wiki/ASP.NET\r\n  [4]: http://en.wikipedia.org/wiki/Perl"},{"score":33,"body_markdown":"A solution I found was to have the `&lt;form&gt;` target a hidden iFrame. The iFrame can then run JS to display to the user that it&#39;s complete (on page load)."},{"score":115,"body_markdown":"I recommend using the [Fine Uploader][1] plugin for this purpose. Your `JavaScript` code would be:\r\n\r\n    $(document).ready(function() {\r\n      $(&quot;#uploadbutton&quot;).jsupload({\r\n        action: &quot;addFile.do&quot;,\r\n        onComplete: function(response){\r\n          alert( &quot;server response: &quot; + response);\r\n        }\r\n      });\r\n    });\r\n\r\n  [1]: http://fineuploader.com/demos.html\r\n"},{"score":33,"body_markdown":"[I&#39;ve written this up in a Rails environment][1].  It&#39;s only about five lines of JavaScript, if you use the lightweight jQuery-form plugin.\r\n\r\nThe challenge is in getting AJAX upload working as the standard `remote_form_for` doesn&#39;t understand multi-part form submission. It&#39;s not going to send the file data Rails seeks back with the AJAX request.   \r\n\r\nThat&#39;s where the jQuery-form plugin comes into play.  \r\n\r\nHere’s the Rails code for it:\r\n\r\n    &lt;% remote_form_for(:image_form, \r\n                       :url =&gt; { :controller =&gt; &quot;blogs&quot;, :action =&gt; :create_asset }, \r\n                       :html =&gt; { :method =&gt; :post, \r\n                                  :id =&gt; &#39;uploadForm&#39;, :multipart =&gt; true }) \r\n                                                                            do |f| %&gt;\r\n     Upload a file: &lt;%= f.file_field :uploaded_data %&gt;\r\n    &lt;% end %&gt;\r\n\r\nHere’s the associated JavaScript:\r\n\r\n    $(&#39;#uploadForm input&#39;).change(function(){\r\n     $(this).parent().ajaxSubmit({\r\n      beforeSubmit: function(a,f,o) {\r\n       o.dataType = &#39;json&#39;;\r\n      },\r\n      complete: function(XMLHttpRequest, textStatus) {\r\n       // XMLHttpRequest.responseText will contain the URL of the uploaded image.\r\n       // Put it in an image element you create, or do with it what you will.\r\n       // For example, if you have an image elemtn with id &quot;my_image&quot;, then\r\n       //  $(&#39;#my_image&#39;).attr(&#39;src&#39;, XMLHttpRequest.responseText);\r\n       // Will set that image tag to display the uploaded image.\r\n      },\r\n     });\r\n    });\r\n\r\nAnd here’s the Rails controller action, pretty vanilla:\r\n\r\n     @image = Image.new(params[:image_form])\r\n     @image.save\r\n     render :text =&gt; @image.public_filename\r\n\r\nI’ve been using this for the past few weeks with Bloggity, and it’s worked like a champ.\r\n\r\n\r\n  [1]: http://www.williambharding.com/blog/rails/rails-ajax-image-uploading-made-simple-with-jquery/\r\n"},{"score":86,"body_markdown":"This [AJAX file upload jQuery plugin][1] uploads the file somehwere, and passes the\r\nresponse to a callback, nothing else. \r\n\r\n- It does not depend on specific HTML, just give it a `&lt;input type=&quot;file&quot;&gt;`\r\n- It does not require your server to respond in any particular way\r\n- It does not matter how many files you use, or where they are on the page\r\n\r\n-- Use as little as --\r\n\r\n    $(&#39;#one-specific-file&#39;).ajaxfileupload({\r\n      &#39;action&#39;: &#39;/upload.php&#39;\r\n    });\r\n\r\n-- or as much as --\r\n\r\n    $(&#39;input[type=&quot;file&quot;]&#39;).ajaxfileupload({\r\n      &#39;action&#39;: &#39;/upload.php&#39;,\r\n      &#39;params&#39;: {\r\n        &#39;extra&#39;: &#39;info&#39;\r\n      },\r\n      &#39;onComplete&#39;: function(response) {\r\n        console.log(&#39;custom handler for file:&#39;);\r\n        alert(JSON.stringify(response));\r\n      },\r\n      &#39;onStart&#39;: function() {\r\n        if(weWantedTo) return false; // cancels upload\r\n      },\r\n      &#39;onCancel&#39;: function() {\r\n        console.log(&#39;no file selected&#39;);\r\n      }\r\n    });\r\n\r\n\r\n  [1]: https://github.com/jfeldstein/jQuery.AjaxFileUpload.js"},{"score":2552,"body_markdown":"With [HTML5][1] you can make file uploads with Ajax and jQuery. Not only that, you can do file validations (name, size, and MIME type) or handle the progress event with the HTML5 progress tag (or a div). Recently I had to make a file uploader, but I didn&#39;t want to use [Flash][2] nor Iframes or plugins and after some research I came up with the solution.\r\n\r\nThe HTML:\r\n\r\n    &lt;form enctype=&quot;multipart/form-data&quot;&gt;\r\n        &lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;\r\n        &lt;input type=&quot;button&quot; value=&quot;Upload&quot; /&gt;\r\n    &lt;/form&gt;\r\n    &lt;progress&gt;&lt;/progress&gt;\r\n\r\nFirst, you can do some validation if you want. For example, in the `.on(&#39;change&#39;)` event of the file:\r\n\r\n    $(&#39;:file&#39;).on(&#39;change&#39;, function () {\r\n      var file = this.files[0];\r\n\r\n      if (file.size &gt; 1024) {\r\n        alert(&#39;max upload size is 1k&#39;);\r\n      }\r\n    \r\n      // Also see .name, .type\r\n    });\r\n\r\nNow the `$.ajax()` submit with the button&#39;s click:\r\n\r\n    $(&#39;:button&#39;).on(&#39;click&#39;, function () {\r\n      $.ajax({\r\n        // Your server script to process the upload\r\n        url: &#39;upload.php&#39;,\r\n        type: &#39;POST&#39;,\r\n    \r\n        // Form data\r\n        data: new FormData($(&#39;form&#39;)[0]),\r\n    \r\n        // Tell jQuery not to process data or worry about content-type\r\n        // You *must* include these options!\r\n        cache: false,\r\n        contentType: false,\r\n        processData: false,\r\n    \r\n        // Custom XMLHttpRequest\r\n        xhr: function () {\r\n          var myXhr = $.ajaxSettings.xhr();\r\n          if (myXhr.upload) {\r\n            // For handling the progress of the upload\r\n            myXhr.upload.addEventListener(&#39;progress&#39;, function (e) {\r\n              if (e.lengthComputable) {\r\n                $(&#39;progress&#39;).attr({\r\n                  value: e.loaded,\r\n                  max: e.total,\r\n                });\r\n              }\r\n            }, false);\r\n          }\r\n          return myXhr;\r\n        }\r\n      });\r\n    });\r\n\r\n\r\nAs you can see, with HTML5 (and some research) file uploading not only becomes possible but super easy. Try it with [Google Chrome][3] as some of the HTML5 components of the examples aren&#39;t available in every browser.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/HTML5\r\n  [2]: http://en.wikipedia.org/wiki/Adobe_Flash\r\n  [3]: http://en.wikipedia.org/wiki/Google_Chrome\r\n"},{"score":63,"body_markdown":"I have been using the below script to upload images which happens to work fine.\r\n\r\n#HTML\r\n    &lt;input id=&quot;file&quot; type=&quot;file&quot; name=&quot;file&quot;/&gt;\r\n    &lt;div id=&quot;response&quot;&gt;&lt;/div&gt;\r\n\r\n#JavaScript\r\n\r\n    jQuery(&#39;document&#39;).ready(function(){\r\n        var input = document.getElementById(&quot;file&quot;);\r\n        var formdata = false;\r\n        if (window.FormData) {\r\n            formdata = new FormData();\r\n        }\r\n        input.addEventListener(&quot;change&quot;, function (evt) {\r\n            var i = 0, len = this.files.length, img, reader, file;\r\n\r\n            for ( ; i &lt; len; i++ ) {\r\n                file = this.files[i];\r\n\r\n                if (!!file.type.match(/image.*/)) {\r\n                    if ( window.FileReader ) {\r\n                        reader = new FileReader();\r\n                        reader.onloadend = function (e) {\r\n                            //showUploadedItem(e.target.result, file.fileName);\r\n                        };\r\n                        reader.readAsDataURL(file);\r\n                    }\r\n\r\n                    if (formdata) {\r\n                        formdata.append(&quot;image&quot;, file);\r\n                        formdata.append(&quot;extra&quot;,&#39;extra-data&#39;);\r\n                    }\r\n\r\n                    if (formdata) {\r\n                        jQuery(&#39;div#response&#39;).html(&#39;&lt;br /&gt;&lt;img src=&quot;ajax-loader.gif&quot;/&gt;&#39;);\r\n\r\n                        jQuery.ajax({\r\n                            url: &quot;upload.php&quot;,\r\n                            type: &quot;POST&quot;,\r\n                            data: formdata,\r\n                            processData: false,\r\n                            contentType: false,\r\n                            success: function (res) {\r\n                             jQuery(&#39;div#response&#39;).html(&quot;Successfully uploaded&quot;);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    alert(&#39;Not a vaild image!&#39;);\r\n                }\r\n            }\r\n\r\n        }, false);\r\n    });\r\n\r\n#Explanation\r\n\r\nI use response `div` to show the uploading animation and response after upload is done.\r\n\r\nBest part is you can send extra data such as ids &amp; etc with the file when you use this script. I have mention it `extra-data` as in the script.\r\n\r\nAt the PHP level this will work as normal file upload. extra-data can be retrieved as `$_POST` data.\r\n\r\nHere you are not using a plugin and stuff. You can change the code as you want. You are not blindly coding here. This is the core functionality of any jQuery file upload. Actually Javascript.\r\n"},{"score":53,"body_markdown":"You can do it in vanilla JavaScript pretty easily. Here&#39;s a snippet from my current project:\r\n\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.upload.onprogress = function(e) {\r\n        var percent = (e.position/ e.totalSize);\r\n        // Render a pretty progress bar\r\n    };\r\n    xhr.onreadystatechange = function(e) {\r\n        if(this.readyState === 4) {\r\n            // Handle file upload complete\r\n        }\r\n    };\r\n    xhr.open(&#39;POST&#39;, &#39;/upload&#39;, true);\r\n    xhr.setRequestHeader(&#39;X-FileName&#39;,file.name); // Pass the filename along\r\n    xhr.send(file);\r\n"},{"score":26,"body_markdown":"jQuery [Uploadify][1] is another good plugin which I have used before to upload files. The JavaScript code is as simple as the following: code. However, the new version does not work in Internet&amp;nbsp;Explorer.\r\n\r\n    $(&#39;#file_upload&#39;).uploadify({\r\n        &#39;swf&#39;: &#39;/public/js/uploadify.swf&#39;,\r\n        &#39;uploader&#39;: &#39;/Upload.ashx?formGuid=&#39; + $(&#39;#formGuid&#39;).val(),\r\n        &#39;cancelImg&#39;: &#39;/public/images/uploadify-cancel.png&#39;,\r\n        &#39;multi&#39;: true,\r\n        &#39;onQueueComplete&#39;: function (queueData) {\r\n            // ...\r\n        },\r\n        &#39;onUploadStart&#39;: function (file) {\r\n            // ...\r\n        }\r\n    });\r\n\r\n\r\nI have done a lot of searching and I have come to another solution for uploading files without any plugin and only with ajax. The solution is as below:\r\n\r\n    $(document).ready(function () {\r\n        $(&#39;#btn_Upload&#39;).live(&#39;click&#39;, AjaxFileUpload);\r\n    });\r\n\r\n    function AjaxFileUpload() {\r\n        var fileInput = document.getElementById(&quot;#Uploader&quot;);\r\n        var file = fileInput.files[0];\r\n        var fd = new FormData();\r\n        fd.append(&quot;files&quot;, file);\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open(&quot;POST&quot;, &#39;Uploader.ashx&#39;);\r\n        xhr.onreadystatechange = function () {\r\n            if (xhr.readyState == 4) {\r\n                 alert(&#39;success&#39;);\r\n            }\r\n            else if (uploadResult == &#39;success&#39;)\r\n                alert(&#39;error&#39;);\r\n        };\r\n        xhr.send(fd);\r\n    }\r\n\r\n  [1]: http://www.uploadify.com/download/\r\n"},{"score":32,"body_markdown":"Simple Ajax Uploader is another option:\r\n\r\nhttps://github.com/LPology/Simple-Ajax-Uploader\r\n\r\n- Cross-browser -- works in IE7+, Firefox, Chrome, Safari, Opera\r\n- Supports multiple, concurrent uploads -- even in non-HTML5 browsers\r\n- No flash or external CSS -- just one 5Kb Javascript file\r\n- Optional, built-in support for fully cross-browser progress bars (using PHP&#39;s APC extension)\r\n- Flexible and highly customizable -- use any element as upload button, style your own progress indicators\r\n- No forms required, just provide an element that will serve as upload button\r\n- MIT license -- free to use in commercial project\r\n\r\nExample usage:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var uploader = new ss.SimpleUpload({\r\n        button: $(&#39;#uploadBtn&#39;), // upload button\r\n        url: &#39;/uploadhandler&#39;, // URL of server-side upload handler\r\n        name: &#39;userfile&#39;, // parameter name of the uploaded file\r\n        onSubmit: function() {\r\n            this.setProgressBar( $(&#39;#progressBar&#39;) ); // designate elem as our progress bar\r\n        },\r\n        onComplete: function(file, response) {\r\n            // do whatever after upload is finished\r\n        }\r\n    });"},{"score":10,"body_markdown":"You can use\r\n\r\n    $(function() {\r\n        $(&quot;#file_upload_1&quot;).uploadify({\r\n            height        : 30,\r\n            swf           : &#39;/uploadify/uploadify.swf&#39;,\r\n            uploader      : &#39;/uploadify/uploadify.php&#39;,\r\n            width         : 120\r\n        });\r\n    });\r\n\r\n[Demo][1]\r\n\r\n\r\n  [1]: http://www.uploadify.com/demos/"},{"score":15,"body_markdown":"To upload file asynchronously with Jquery use below steps:\n\n**step 1** In your project open Nuget manager and add package (jquery fileupload(only you need to write it in search box it will come up and install it.))\nURL: https://github.com/blueimp/jQuery-File-Upload\n\n**step 2** Add below scripts in the HTML files, which are already added to the project by running above package:\n\n   &gt;jquery.ui.widget.js\n   &gt;\n   &gt;jquery.iframe-transport.js\n   &gt;\n   &gt;jquery.fileupload.js\n\n**step 3**  Write file upload control as per below code:\n\n    &lt;input id=&quot;upload&quot; name=&quot;upload&quot; type=&quot;file&quot; /&gt;\n\n**step 4**  write a js method as uploadFile as below: \n\n     function uploadFile(element) {\n        \n                $(element).fileupload({\n        \n                    dataType: &#39;json&#39;,\n                    url: &#39;../DocumentUpload/upload&#39;,\n                    autoUpload: true,\n                    add: function (e, data) {           \n                      // write code for implementing, while selecting a file. \n                      // data represents the file data. \n                      //below code triggers the action in mvc controller\n                      data.formData =\n                                        {\n                                         files: data.files[0]\n                                        };\n                      data.submit();\n                    },\n                    done: function (e, data) {          \n                       // after file uploaded\n                    },\n                    progress: function (e, data) {\n                        \n                       // progress\n                    },\n                    fail: function (e, data) {\n                        \n                       //fail operation\n                    },\n                    stop: function () {\n                        \n                      code for cancel operation\n                    }\n                });\n            \n            };\n\n**step 5** In ready function call element file upload to initiate the process as per below:\n\n    $(document).ready(function()\n    {\n        uploadFile($(&#39;#upload&#39;));\n    \n    });\n\n\n**step 6** Write MVC controller and Action as per below:\n\n    public class DocumentUploadController : Controller\n        {       \n            \n            [System.Web.Mvc.HttpPost]\n            public JsonResult upload(ICollection&lt;HttpPostedFileBase&gt; files)\n            {\n                bool result = false;\n    \n                if (files != null || files.Count &gt; 0)\n                {\n                    try\n                    {\n                        foreach (HttpPostedFileBase file in files)\n                        {\n                            if (file.ContentLength == 0)\n                                throw new Exception(&quot;Zero length file!&quot;);                       \n                            else \n                                //code for saving a file\n    \n                        }\n                    }\n                    catch (Exception)\n                    {\n                        result = false;\n                    }\n                }\n    \n    \n                return new JsonResult()\n                    {\n                        Data=result\n                    };\n    \n    \n            }\n    \n        }\n"},{"score":9,"body_markdown":"Convert file to base64 using |HTML5&#39;s [readAsDataURL()][1] or [some base64 encoder][2]. \r\n[Fiddle here][3]\r\n\r\n    var reader = new FileReader();\r\n    \r\n            reader.onload = function(readerEvt) {\r\n                var binaryString = readerEvt.target.result;\r\n                document.getElementById(&quot;base64textarea&quot;).value = btoa(binaryString);\r\n            };\r\n    \r\n            reader.readAsBinaryString(file);\r\nThen to retrieve:\r\n\r\n    window.open(&quot;data:application/octet-stream;base64,&quot; + base64);\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/API/FileReader#readAsDataURL%28%29\r\n  [2]: http://scotch.io/quick-tips/js/how-to-encode-and-decode-strings-with-base64-in-javascript\r\n  [3]: http://jsfiddle.net/eliseosoto/JHQnk/"},{"score":45,"body_markdown":"The simplest and most robust way I have done this in the past, is to simply target a hidden iFrame tag with your form - then it will submit within the iframe without reloading the page.\r\n\r\nThat is if you don&#39;t want to use a plugin, JavaScript or any other forms of &quot;magic&quot; other than HTML.  Of course you can combine this with JavaScript or what have you...\r\n\r\n    &lt;form target=&quot;iframe&quot; action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;\r\n        &lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;\r\n        &lt;input type=&quot;button&quot; value=&quot;Upload&quot; /&gt;\r\n    &lt;/form&gt;\r\n    \r\n    &lt;iframe name=&quot;iframe&quot; id=&quot;iframe&quot; style=&quot;display:none&quot; &gt;&lt;/iframe&gt;\r\n\r\nYou can also read the contents of the iframe `onLoad` for server errors or success responses and then output that to user.\r\n\r\n**Chrome, iFrames, and onLoad** \r\n\r\n*-note- you only need to keep reading if you are interested in how to setup a UI blocker when doing uploading/downloading*\r\n\r\nCurrently Chrome doesn&#39;t trigger the onLoad event for the iframe when it&#39;s used to transfer files.  Firefox, IE, and Edge all fire the onload event for file transfers.\r\n\r\nThe only solution that I found works for Chrome was to use a cookie.  \r\n\r\nTo do that basically when the upload/download is started:\r\n\r\n - [Client Side] Start an interval to look for the existence of a cookie\r\n - [Server Side] Do whatever you need to with the file data\r\n - [Server Side] Set cookie for client side interval\r\n - [Client Side] Interval sees the cookie and uses it like the onLoad event.  For example you can start a UI blocker and then onLoad ( or when cookie is made )  you remove the UI blocker.\r\n\r\nUsing a cookie for this is ugly but it works.  \r\n\r\nI made a jQuery plugin to handle this issue for Chrome when downloading, you can find here\r\n\r\nhttps://github.com/ArtisticPhoenix/jQuery-Plugins/blob/master/iDownloader.js\r\n\r\nThe same basic principal applies to uploading, as well.\r\n\r\nTo use the downloader  ( include the JS, obviously )\r\n\r\n     $(&#39;body&#39;).iDownloader({\r\n         &quot;onComplete&quot; : function(){\r\n              $(&#39;#uiBlocker&#39;).css(&#39;display&#39;, &#39;none&#39;); //hide ui blocker on complete\r\n         }\r\n     });\r\n\r\n     $(&#39;somebuttion&#39;).click( function(){\r\n          $(&#39;#uiBlocker&#39;).css(&#39;display&#39;, &#39;block&#39;); //block the UI\r\n          $(&#39;body&#39;).iDownloader(&#39;download&#39;, &#39;htttp://example.com/location/of/download&#39;);\r\n     });\r\n\r\nAnd on the server side, just before transferring the file data, create the cookie\r\n\r\n     setcookie(&#39;iDownloader&#39;, true, time() + 30, &quot;/&quot;);\r\n\r\nThe plugin will see the cookie, and then trigger the `onComplete` callback.\r\n     "},{"score":48,"body_markdown":"You can upload simply with jQuery `.ajax()`.\r\n\r\nHTML:\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n\t&lt;form id=&quot;upload-form&quot;&gt;\r\n        &lt;div&gt;\r\n            &lt;label for=&quot;file&quot;&gt;File:&lt;/label&gt;\r\n            &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt;\r\n            &lt;progress class=&quot;progress&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;\r\n        &lt;/div&gt;\r\n        &lt;hr /&gt;\r\n        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;\r\n    &lt;/form&gt;\r\n\r\nCSS\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .progress { display: none; }\r\n\r\nJavascript:\r\n\r\n&lt;!-- language: lang-javascript --&gt;\r\n\r\n    $(document).ready(function(ev) {\r\n        $(&quot;#upload-form&quot;).on(&#39;submit&#39;, (function(ev) {\r\n            ev.preventDefault();\r\n            $.ajax({\r\n                xhr: function() {\r\n                    var progress = $(&#39;.progress&#39;),\r\n                        xhr = $.ajaxSettings.xhr();\r\n\r\n                    progress.show();\r\n\r\n                    xhr.upload.onprogress = function(ev) {\r\n                        if (ev.lengthComputable) {\r\n                            var percentComplete = parseInt((ev.loaded / ev.total) * 100);\r\n                            progress.val(percentComplete);\r\n                            if (percentComplete === 100) {\r\n                                progress.hide().val(0);\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    return xhr;\r\n                },\r\n                url: &#39;upload.php&#39;,\r\n                type: &#39;POST&#39;,\r\n                data: new FormData(this),\r\n                contentType: false,\r\n                cache: false,\r\n                processData: false,\r\n                success: function(data, status, xhr) {\r\n                    // ...\r\n                },\r\n                error: function(xhr, status, error) {\r\n                    // ...\r\n                }\r\n           });\r\n        }));\r\n    });"},{"score":99,"body_markdown":"Wrapping up for future readers.\r\n\r\n# Asynchronous File Upload\r\n\r\n## With HTML5\r\n\r\nYou can upload files **with jQuery** using the `$.ajax()` method if [FormData](https://developer.mozilla.org/en-US/docs/Web/Guide/Using_FormData_Objects) and the [File API](https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications) are supported (both HTML5 features). \r\n\r\nYou can also send files [without FormData](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files) but either way the File API must be present to process files in such a way that they can be sent with *XMLHttpRequest* (Ajax).\r\n\r\n    $.ajax({\r\n      url: &#39;file/destination.html&#39;, \r\n      type: &#39;POST&#39;,\r\n      data: new FormData($(&#39;#formWithFiles&#39;)[0]), // The form with the file inputs.\r\n      processData: false,\r\n      contentType: false                    // Using FormData, no need to process data.\r\n    }).done(function(){\r\n      console.log(&quot;Success: Files sent!&quot;);\r\n    }).fail(function(){\r\n      console.log(&quot;An error occurred, the files couldn&#39;t be sent!&quot;);\r\n    });\r\n\r\nFor a quick, pure JavaScript (**no jQuery**) example see &quot;[Sending files using a FormData object](https://developer.mozilla.org/en-US/docs/Web/Guide/Using_FormData_Objects#Sending_files_using_a_FormData_object)&quot;.\r\n\r\n\r\n\r\n## Fallback\r\n\r\nWhen HTML5 isn&#39;t supported (no *File API*) the only other pure JavaScript solution (no *Flash* or any other browser plugin) is the **hidden iframe** technique, which allows to emulate an asynchronous request without using the *XMLHttpRequest* object.\r\n\r\nIt consists of setting an iframe as the target of the form with the file inputs. When the user submits a request is made and the files are uploaded but the response is displayed inside the iframe instead of re-rendering the main page. Hiding the iframe makes the whole process transparent to the user and emulates an asynchronous request.\r\n\r\nIf done properly it should work virtually on any browser, but it has some caveats as how to obtain the response from the iframe. \r\n\r\nIn this case you may prefer to use a wrapper plugin like [Bifr&#246;st](//github.com/matiasgagliano/bifrost) which uses the *iframe technique* but also provides a [jQuery Ajax transport](//api.jquery.com/jQuery.ajaxTransport) allowing to **send files** with just the `$.ajax()` method like this:\r\n\r\n    $.ajax({\r\n      url: &#39;file/destination.html&#39;, \r\n      type: &#39;POST&#39;,\r\n      // Set the transport to use (iframe means to use Bifr&#246;st)\r\n      // and the expected data type (json in this case).\r\n      dataType: &#39;iframe json&#39;,                                \r\n      fileInputs: $(&#39;input[type=&quot;file&quot;]&#39;),  // The file inputs containing the files to send.\r\n      data: { msg: &#39;Some extra data you might need.&#39;}\r\n    }).done(function(){\r\n      console.log(&quot;Success: Files sent!&quot;);\r\n    }).fail(function(){\r\n      console.log(&quot;An error occurred, the files couldn&#39;t be sent!&quot;);\r\n    });\r\n \r\n## Plugins\r\n\r\n[Bifr&#246;st](//github.com/matiasgagliano/bifrost) is just a small wrapper that adds fallback support to jQuery&#39;s ajax method, but many of the aforementioned plugins like [jQuery Form Plugin](//malsup.com/jquery/form/) or [jQuery File Upload](//github.com/blueimp/jQuery-File-Upload) include the whole stack from HTML5 to different fallbacks and some useful features to ease out the process. Depending on your needs and requirements you might want to consider a bare implementation or either of this plugins."},{"score":8,"body_markdown":"Look for *Handling the upload process for a file, asynchronously* in here:\r\nhttps://developer.mozilla.org/en-US/docs/Using_files_from_web_applications\r\n\r\nSample from the link\r\n\r\n\r\n    &lt;?php\r\n    if (isset($_FILES[&#39;myFile&#39;])) {\r\n        // Example:\r\n        move_uploaded_file($_FILES[&#39;myFile&#39;][&#39;tmp_name&#39;], &quot;uploads/&quot; . $_FILES[&#39;myFile&#39;][&#39;name&#39;]);\r\n        exit;\r\n    }\r\n    ?&gt;&lt;!DOCTYPE html&gt;\r\n    &lt;html&gt;\r\n    &lt;head&gt;\r\n        &lt;title&gt;dnd binary upload&lt;/title&gt;\r\n        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\r\n        &lt;script type=&quot;text/javascript&quot;&gt;\r\n            function sendFile(file) {\r\n                var uri = &quot;/index.php&quot;;\r\n                var xhr = new XMLHttpRequest();\r\n                var fd = new FormData();\r\n                \r\n                xhr.open(&quot;POST&quot;, uri, true);\r\n                xhr.onreadystatechange = function() {\r\n                    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {\r\n                        // Handle response.\r\n                        alert(xhr.responseText); // handle response.\r\n                    }\r\n                };\r\n                fd.append(&#39;myFile&#39;, file);\r\n                // Initiate a multipart/form-data upload\r\n                xhr.send(fd);\r\n            }\r\n\r\n            window.onload = function() {\r\n                var dropzone = document.getElementById(&quot;dropzone&quot;);\r\n                dropzone.ondragover = dropzone.ondragenter = function(event) {\r\n                    event.stopPropagation();\r\n                    event.preventDefault();\r\n                }\r\n        \r\n                dropzone.ondrop = function(event) {\r\n                    event.stopPropagation();\r\n                    event.preventDefault();\r\n\r\n                    var filesArray = event.dataTransfer.files;\r\n                    for (var i=0; i&lt;filesArray.length; i++) {\r\n                        sendFile(filesArray[i]);\r\n                    }\r\n                }\r\n            }\r\n        &lt;/script&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n        &lt;div&gt;\r\n            &lt;div id=&quot;dropzone&quot; style=&quot;margin:30px; width:500px; height:300px; border:1px dotted grey;&quot;&gt;Drag &amp; drop your file here...&lt;/div&gt;\r\n        &lt;/div&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;\r\n\r\n\r\n\r\n"},{"score":19,"body_markdown":"    var formData=new FormData();\r\n    formData.append(&quot;fieldname&quot;,&quot;value&quot;);\r\n    formData.append(&quot;image&quot;,$(&#39;[name=&quot;filename&quot;]&#39;)[0].files[0]);\r\n\r\n    $.ajax({\r\n        url:&quot;page.php&quot;,\r\n        data:formData,\r\n        type: &#39;POST&#39;,\r\n        dataType:&quot;JSON&quot;,\r\n        cache: false,\r\n        contentType: false,\r\n        processData: false,\r\n    \tsuccess:function(data){ }\r\n    });\r\n\r\nYou can use form data to post all your values including images."},{"score":7,"body_markdown":"This is my solution.\r\n\r\n    &lt;form enctype=&quot;multipart/form-data&quot;&gt;    \r\n    \r\n        &lt;div class=&quot;form-group&quot;&gt;\r\n            &lt;label class=&quot;control-label col-md-2&quot; for=&quot;apta_Description&quot;&gt;Description&lt;/label&gt;\r\n            &lt;div class=&quot;col-md-10&quot;&gt;\r\n                &lt;input class=&quot;form-control text-box single-line&quot; id=&quot;apta_Description&quot; name=&quot;apta_Description&quot; type=&quot;text&quot; value=&quot;&quot;&gt;\r\n            &lt;/div&gt;\r\n        &lt;/div&gt;\r\n\r\n        &lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;\r\n        &lt;input type=&quot;button&quot; value=&quot;Upload&quot; /&gt;\r\n    &lt;/form&gt;\r\n\r\n\r\nand the js\r\n\r\n\r\n    &lt;script&gt;\r\n    \r\n        $(&#39;:button&#39;).click(function () {\r\n            var formData = new FormData($(&#39;form&#39;)[0]);\r\n            $.ajax({\r\n                url: &#39;@Url.Action(&quot;Save&quot;, &quot;Home&quot;)&#39;,  \r\n                type: &#39;POST&#39;,                \r\n                success: completeHandler,\r\n                data: formData,\r\n                cache: false,\r\n                contentType: false,\r\n                processData: false\r\n            });\r\n        });    \r\n    \r\n        function completeHandler() {\r\n            alert(&quot;:)&quot;);\r\n        }    \r\n    &lt;/script&gt;\r\n\r\nController\r\n\r\n    [HttpPost]\r\n    public ActionResult Save(string apta_Description, HttpPostedFileBase file)\r\n    {\r\n        [...]\r\n    }\r\n\r\n"},{"score":25,"body_markdown":"Here&#39;s just another solution of how to upload file (**without any plugin**) \r\n\r\nUsing simple **Javascripts** and **AJAX** (with progress-bar)\r\n\r\n**HTML part**\r\n\r\n    &lt;form id=&quot;upload_form&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;\r\n        &lt;input type=&quot;file&quot; name=&quot;file1&quot; id=&quot;file1&quot;&gt;&lt;br&gt;\r\n        &lt;input type=&quot;button&quot; value=&quot;Upload File&quot; onclick=&quot;uploadFile()&quot;&gt;\r\n        &lt;progress id=&quot;progressBar&quot; value=&quot;0&quot; max=&quot;100&quot; style=&quot;width:300px;&quot;&gt;&lt;/progress&gt;\r\n        &lt;h3 id=&quot;status&quot;&gt;&lt;/h3&gt;\r\n        &lt;p id=&quot;loaded_n_total&quot;&gt;&lt;/p&gt;\r\n    &lt;/form&gt;\r\n\r\n**JS part**\r\n\r\n    function _(el){\r\n    \treturn document.getElementById(el);\r\n    }\r\n    function uploadFile(){\r\n    \tvar file = _(&quot;file1&quot;).files[0];\r\n    \t// alert(file.name+&quot; | &quot;+file.size+&quot; | &quot;+file.type);\r\n    \tvar formdata = new FormData();\r\n    \tformdata.append(&quot;file1&quot;, file);\r\n    \tvar ajax = new XMLHttpRequest();\r\n    \tajax.upload.addEventListener(&quot;progress&quot;, progressHandler, false);\r\n    \tajax.addEventListener(&quot;load&quot;, completeHandler, false);\r\n    \tajax.addEventListener(&quot;error&quot;, errorHandler, false);\r\n    \tajax.addEventListener(&quot;abort&quot;, abortHandler, false);\r\n    \tajax.open(&quot;POST&quot;, &quot;file_upload_parser.php&quot;);\r\n    \tajax.send(formdata);\r\n    }\r\n    function progressHandler(event){\r\n    \t_(&quot;loaded_n_total&quot;).innerHTML = &quot;Uploaded &quot;+event.loaded+&quot; bytes of &quot;+event.total;\r\n    \tvar percent = (event.loaded / event.total) * 100;\r\n    \t_(&quot;progressBar&quot;).value = Math.round(percent);\r\n    \t_(&quot;status&quot;).innerHTML = Math.round(percent)+&quot;% uploaded... please wait&quot;;\r\n    }\r\n    function completeHandler(event){\r\n    \t_(&quot;status&quot;).innerHTML = event.target.responseText;\r\n    \t_(&quot;progressBar&quot;).value = 0;\r\n    }\r\n    function errorHandler(event){\r\n    \t_(&quot;status&quot;).innerHTML = &quot;Upload Failed&quot;;\r\n    }\r\n    function abortHandler(event){\r\n    \t_(&quot;status&quot;).innerHTML = &quot;Upload Aborted&quot;;\r\n    }\r\n\r\n**PHP part**\r\n\r\n    &lt;?php\r\n    $fileName = $_FILES[&quot;file1&quot;][&quot;name&quot;]; // The file name\r\n    $fileTmpLoc = $_FILES[&quot;file1&quot;][&quot;tmp_name&quot;]; // File in the PHP tmp folder\r\n    $fileType = $_FILES[&quot;file1&quot;][&quot;type&quot;]; // The type of file it is\r\n    $fileSize = $_FILES[&quot;file1&quot;][&quot;size&quot;]; // File size in bytes\r\n    $fileErrorMsg = $_FILES[&quot;file1&quot;][&quot;error&quot;]; // 0 for false... and 1 for true\r\n    if (!$fileTmpLoc) { // if file not chosen\r\n        echo &quot;ERROR: Please browse for a file before clicking the upload button.&quot;;\r\n        exit();\r\n    }\r\n    if(move_uploaded_file($fileTmpLoc, &quot;test_uploads/$fileName&quot;)){ // assuming the directory name &#39;test_uploads&#39;\r\n        echo &quot;$fileName upload is complete&quot;;\r\n    } else {\r\n        echo &quot;move_uploaded_file function failed&quot;;\r\n    }\r\n    ?&gt;\r\n\r\n\r\n[**Here&#39;s the EXAMPLE application**][1]\r\n\r\n\r\n  [1]: https://github.com/SiddharthaChowdhury/Async-File-Upload-using-PHP-Javascript-AJAX"},{"score":11,"body_markdown":"You can see a solved solution with a working demo [**here**][1] that allows you to preview and submit form files to the server. For your case, you need to use [Ajax][2] to facilitate the file upload to the server:\r\n\r\n    &lt;from action=&quot;&quot; id=&quot;formContent&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;\r\n        &lt;span&gt;File&lt;/span&gt;\r\n        &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; size=&quot;10&quot;/&gt;\r\n        &lt;input id=&quot;uploadbutton&quot; type=&quot;button&quot; value=&quot;Upload&quot;/&gt;\r\n    &lt;/form&gt;\r\n\r\nThe data being submitted is a formdata. On your jQuery, use a form submit function instead of a button click to submit the form file as shown below.\r\n\r\n    $(document).ready(function () {\r\n       $(&quot;#formContent&quot;).submit(function(e){\r\n\r\n         e.preventDefault();\r\n         var formdata = new FormData(this);\r\n\r\n     $.ajax({\r\n         url: &quot;ajax_upload_image.php&quot;,\r\n         type: &quot;POST&quot;,\r\n         data: formdata,\r\n         mimeTypes:&quot;multipart/form-data&quot;,\r\n         contentType: false,\r\n         cache: false,\r\n         processData: false,\r\n         success: function(){\r\n\r\n         alert(&quot;successfully submitted&quot;);\r\n\r\n         });\r\n       });\r\n    });\r\n\r\n[View more details][1]\r\n\r\n  [1]: http://whats-online.info/science-and-tutorials/30/select-preview-rename-and-upload-image-using-jquery-Ajax/\r\n  [2]: http://en.wikipedia.org/wiki/Ajax_%28programming%29\r\n"},{"score":11,"body_markdown":"Sample: If you use jQuery, you can do easy to an upload file. This is a small and strong jQuery plugin, [http://jquery.malsup.com/form/][1].\n\n### Example\n\n    var $bar   = $(&#39;.ProgressBar&#39;);\n    $(&#39;.Form&#39;).ajaxForm({\n      dataType: &#39;json&#39;,\n\n      beforeSend: function(xhr) {\n        var percentVal = &#39;0%&#39;;\n        $bar.width(percentVal);\n      },\n\n      uploadProgress: function(event, position, total, percentComplete) {\n        var percentVal = percentComplete + &#39;%&#39;;\n        $bar.width(percentVal)\n      },\n\n      success: function(response) {\n        // Response\n      }\n    });\n\n**I hope it would be helpful**\n\n  [1]: http://jquery.malsup.com/form/\n"},{"score":3,"body_markdown":"It is an old question, but still has no answer correct answer, so:\r\n\r\nHave you tried [jQuery-File-Upload][1]?\r\n\r\n\r\n  [1]: https://github.com/blueimp/jQuery-File-Upload/wiki/Submit-files-asynchronously\r\n\r\n\r\nHere is an example from the link above that might solve your problem:\r\n\r\n    $(&#39;#fileupload&#39;).fileupload({\r\n        add: function (e, data) {\r\n            var that = this;\r\n            $.getJSON(&#39;/example/url&#39;, function (result) {\r\n                data.formData = result; // e.g. {id: 123}\r\n                $.blueimp.fileupload.prototype\r\n                    .options.add.call(that, e, data);\r\n            });\r\n        } \r\n    });"},{"score":6,"body_markdown":"Using **HTML5** and **JavaScript**, uploading async is quite easy, I create the uploading logic along with your html, this is not fully working as it needs the api, but demonstrate how it works, if you have the endpoint called `/upload` from root of your website, this code should work for you:\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    const asyncFileUpload = () =&gt; {\n      const fileInput = document.getElementById(&quot;file&quot;);\n      const file = fileInput.files[0];\n      const uri = &quot;/upload&quot;;\n      const xhr = new XMLHttpRequest();\n      xhr.upload.onprogress = e =&gt; {\n        const percentage = e.loaded / e.total;\n        console.log(percentage);\n      };\n      xhr.onreadystatechange = e =&gt; {\n        if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {\n          console.log(&quot;file uploaded&quot;);\n        }\n      };\n      xhr.open(&quot;POST&quot;, uri, true);\n      xhr.setRequestHeader(&quot;X-FileName&quot;, file.name);\n      xhr.send(file);\n    }\n\n&lt;!-- language: lang-html --&gt;\n\n    &lt;form&gt;\n      &lt;span&gt;File&lt;/span&gt;\n      &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; size=&quot;10&quot; /&gt;\n      &lt;input onclick=&quot;asyncFileUpload()&quot; id=&quot;upload&quot; type=&quot;button&quot; value=&quot;Upload&quot; /&gt;\n    &lt;/form&gt;\n\n&lt;!-- end snippet --&gt;\n\nAlso some further information about XMLHttpReques:\n\n&gt; **The XMLHttpRequest Object** \n&gt;\n&gt; All modern browsers support the XMLHttpRequest object.\n&gt; The XMLHttpRequest object can be used to exchange data with a web\n&gt; server behind the scenes. This means that it is possible to update\n&gt; parts of a web page, without reloading the whole page.\n\n&lt;br&gt;\n\n&gt; **Create an XMLHttpRequest Object**\n&gt;\n&gt; All modern browsers (Chrome, Firefox,\n&gt; IE7+, Edge, Safari, Opera) have a built-in XMLHttpRequest object.\n&gt; \n&gt; Syntax for creating an XMLHttpRequest object:\n&gt; \n&gt; variable = new XMLHttpRequest();\n\n&lt;br&gt; \n\n&gt; **Access Across Domains**\n&gt;\n&gt; For security reasons, modern browsers do not\n&gt; allow access across domains.\n&gt; \n&gt; This means that both the web page and the XML file it tries to load,\n&gt; must be located on the same server.\n&gt; \n&gt; The examples on W3Schools all open XML files located on the W3Schools\n&gt; domain.\n&gt; \n&gt; If you want to use the example above on one of your own web pages, the\n&gt; XML files you load must be located on your own server.\n\nFor more details, you can continue reading [here][1]...\n\n\n  [1]: https://www.w3schools.com/js/js_ajax_http.asp"},{"score":6,"body_markdown":"You can use **newer** [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) by JavaScript. Like this:                             \r\n\r\n\r\n    function uploadButtonCLicked(){\r\n        var input = document.querySelector(&#39;input[type=&quot;file&quot;]&#39;)\r\n        \r\n        fetch(&#39;/url&#39;, {\r\n          method: &#39;POST&#39;,\r\n          body: input.files[0]\r\n        }).then(res =&gt; res.json())   // you can do something with response\r\n          .catch(error =&gt; console.error(&#39;Error:&#39;, error))\r\n          .then(response =&gt; console.log(&#39;Success:&#39;, response));\r\n    }                               \r\n\r\n**Advantage:** Fetch API is **natively supported** by all modern browsers, so you don&#39;t have to import anything. Also, note that fetch() returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) which is then handled by using `.then(..code to handle response..)` asynchronously. "},{"score":14,"body_markdown":"A modern approach **without Jquery** is to use the [FileList][1] object you get back from `&lt;input type=&quot;file&quot;&gt;` when user selects a file(s) and then use [Fetch][2] to post the FileList wrapped around a [FormData][3] object.\r\n\r\n    // The input DOM element // &lt;input type=&quot;file&quot;&gt;\r\n    const inputElement = document.querySelector(&#39;input[type=file]&#39;);\r\n    \r\n    // Listen for a file submit from user\r\n    inputElement.addEventListener(&#39;change&#39;, () =&gt; {\r\n        const data = new FormData();\r\n        data.append(&#39;file&#39;, inputElement.files[0]);\r\n        data.append(&#39;imageName&#39;, &#39;flower&#39;);\r\n\r\n        // You can then post it to your server.\r\n        // Fetch can accept an object of type FormData on its  body\r\n        fetch(&#39;/uploadImage&#39;, {\r\n            method: &#39;POST&#39;,\r\n            body: data\r\n        });\r\n    });\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/API/FileList\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/API/FormData"},{"score":4,"body_markdown":"You can do the Asynchronous Multiple File uploads using JavaScript or jQuery and that to without using any plugin. You can also show the real time progress of file upload in the progress control. I have come across 2 nice links -\r\n\r\n1. [ASP.NET Web Forms based Mulitple File Upload Feature with Progress Bar][1]\r\n2. [ASP.NET MVC based Multiple File Upload made in jQuery][2]\r\n\r\nThe server side language is C# but you can do some modification for making it work with other language like PHP.\r\n\r\n**File Upload ASP.NET Core MVC:**\r\n\r\nIn the View create file upload control in html:\r\n\r\n    &lt;form method=&quot;post&quot; asp-action=&quot;Add&quot; enctype=&quot;multipart/form-data&quot;&gt;\r\n        &lt;input type=&quot;file&quot; multiple name=&quot;mediaUpload&quot; /&gt;\r\n        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;\r\n    &lt;/form&gt;\r\n\r\nNow create action method in your controller:\r\n\r\n    [HttpPost]\r\n    public async Task&lt;IActionResult&gt; Add(IFormFile[] mediaUpload)\r\n    {\r\n        //looping through all the files\r\n        foreach (IFormFile file in mediaUpload)\r\n        {\r\n            //saving the files\r\n            string path = Path.Combine(hostingEnvironment.WebRootPath, &quot;some-folder-path&quot;); \r\n            using (var stream = new FileStream(path, FileMode.Create))\r\n            {\r\n                await file.CopyToAsync(stream);\r\n            }\r\n        }\r\n    }\r\n\r\nhostingEnvironment variable is of type IHostingEnvironment which can be injected to the controller using dependency injection, like:\r\n\r\n    private IHostingEnvironment hostingEnvironment;\r\n    public MediaController(IHostingEnvironment environment)\r\n    {\r\n        hostingEnvironment = environment;\r\n    }\r\n\r\n\r\n  [1]: http://www.yogihosting.com/multi-file-upload-with-progress-bar-in-asp-net/\r\n  [2]: http://www.yogihosting.com/jquery-file-upload/"},{"score":4,"body_markdown":"For PHP, look for https://developer.hyvor.com/php/image-upload-ajax-php-mysql\r\n\r\n**HTML**\r\n\r\n    &lt;html&gt;\r\n    &lt;head&gt;\r\n        &lt;title&gt;Image Upload with AJAX, PHP and MYSQL&lt;/title&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n    &lt;form onsubmit=&quot;submitForm(event);&quot;&gt;\r\n        &lt;input type=&quot;file&quot; name=&quot;image&quot; id=&quot;image-selecter&quot; accept=&quot;image/*&quot;&gt;\r\n        &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Upload Image&quot;&gt;\r\n    &lt;/form&gt;\r\n    &lt;div id=&quot;uploading-text&quot; style=&quot;display:none;&quot;&gt;Uploading...&lt;/div&gt;\r\n    &lt;img id=&quot;preview&quot;&gt;\r\n    &lt;/body&gt;\r\n    &lt;/html&gt;\r\n\r\n**JAVASCRIPT**\r\n\r\n    var previewImage = document.getElementById(&quot;preview&quot;),\t\r\n    \tuploadingText = document.getElementById(&quot;uploading-text&quot;);\r\n    \r\n    function submitForm(event) {\r\n    \t// prevent default form submission\r\n    \tevent.preventDefault();\r\n    \tuploadImage();\r\n    }\r\n    \r\n    function uploadImage() {\r\n    \tvar imageSelecter = document.getElementById(&quot;image-selecter&quot;),\r\n    \t\tfile = imageSelecter.files[0];\r\n    \tif (!file) \r\n    \t\treturn alert(&quot;Please select a file&quot;);\r\n    \t// clear the previous image\r\n    \tpreviewImage.removeAttribute(&quot;src&quot;);\r\n    \t// show uploading text\r\n    \tuploadingText.style.display = &quot;block&quot;;\r\n    \t// create form data and append the file\r\n    \tvar formData = new FormData();\r\n    \tformData.append(&quot;image&quot;, file);\r\n    \t// do the ajax part\r\n    \tvar ajax = new XMLHttpRequest();\r\n    \tajax.onreadystatechange = function() {\r\n    \t\tif (this.readyState === 4 &amp;&amp; this.status === 200) {\r\n    \t\t\tvar json = JSON.parse(this.responseText);\r\n    \t\t\tif (!json || json.status !== true) \r\n    \t\t\t\treturn uploadError(json.error);\r\n    \r\n    \t\t\tshowImage(json.url);\r\n    \t\t}\r\n    \t}\r\n    \tajax.open(&quot;POST&quot;, &quot;upload.php&quot;, true);\r\n    \tajax.send(formData); // send the form data\r\n    }\r\n    \r\n    \r\n**PHP**\r\n    \r\n    &lt;?php\r\n    $host = &#39;localhost&#39;;\r\n    $user = &#39;user&#39;;\r\n    $password = &#39;password&#39;;\r\n    $database = &#39;database&#39;;\r\n    $mysqli = new mysqli($host, $user, $password, $database);\r\n       \r\n\r\n     try {\r\n        if (empty($_FILES[&#39;image&#39;])) {\r\n            throw new Exception(&#39;Image file is missing&#39;);\r\n        }\r\n        $image = $_FILES[&#39;image&#39;];\r\n        // check INI error\r\n        if ($image[&#39;error&#39;] !== 0) {\r\n            if ($image[&#39;error&#39;] === 1) \r\n                throw new Exception(&#39;Max upload size exceeded&#39;);\r\n                \r\n            throw new Exception(&#39;Image uploading error: INI Error&#39;);\r\n        }\r\n        // check if the file exists\r\n        if (!file_exists($image[&#39;tmp_name&#39;]))\r\n            throw new Exception(&#39;Image file is missing in the server&#39;);\r\n        $maxFileSize = 2 * 10e6; // in bytes\r\n        if ($image[&#39;size&#39;] &gt; $maxFileSize)\r\n            throw new Exception(&#39;Max size limit exceeded&#39;); \r\n        // check if uploaded file is an image\r\n        $imageData = getimagesize($image[&#39;tmp_name&#39;]);\r\n        if (!$imageData) \r\n            throw new Exception(&#39;Invalid image&#39;);\r\n        $mimeType = $imageData[&#39;mime&#39;];\r\n        // validate mime type\r\n        $allowedMimeTypes = [&#39;image/jpeg&#39;, &#39;image/png&#39;, &#39;image/gif&#39;];\r\n        if (!in_array($mimeType, $allowedMimeTypes)) \r\n            throw new Exception(&#39;Only JPEG, PNG and GIFs are allowed&#39;);\r\n        \r\n        // nice! it&#39;s a valid image\r\n        // get file extension (ex: jpg, png) not (.jpg)\r\n        $fileExtention = strtolower(pathinfo($image[&#39;name&#39;] ,PATHINFO_EXTENSION));\r\n        // create random name for your image\r\n        $fileName = round(microtime(true)) . mt_rand() . &#39;.&#39; . $fileExtention; // anyfilename.jpg\r\n        // Create the path starting from DOCUMENT ROOT of your website\r\n        $path = &#39;/examples/image-upload/images/&#39; . $fileName;\r\n        // file path in the computer - where to save it \r\n        $destination = $_SERVER[&#39;DOCUMENT_ROOT&#39;] . $path;\r\n    \r\n        if (!move_uploaded_file($image[&#39;tmp_name&#39;], $destination))\r\n            throw new Exception(&#39;Error in moving the uploaded file&#39;);\r\n    \r\n        // create the url\r\n        $protocol = stripos($_SERVER[&#39;SERVER_PROTOCOL&#39;],&#39;https&#39;) === true ? &#39;https://&#39; : &#39;http://&#39;;\r\n        $domain = $protocol . $_SERVER[&#39;SERVER_NAME&#39;];\r\n        $url = $domain . $path;\r\n        $stmt = $mysqli -&gt; prepare(&#39;INSERT INTO image_uploads (url) VALUES (?)&#39;);\r\n        if (\r\n            $stmt &amp;&amp;\r\n            $stmt -&gt; bind_param(&#39;s&#39;, $url) &amp;&amp;\r\n            $stmt -&gt; execute()\r\n        ) {\r\n            exit(\r\n                json_encode(\r\n                    array(\r\n                        &#39;status&#39; =&gt; true,\r\n                        &#39;url&#39; =&gt; $url\r\n                    )\r\n                )\r\n            );\r\n        } else \r\n            throw new Exception(&#39;Error in saving into the database&#39;);\r\n    \r\n    } catch (Exception $e) {\r\n        exit(json_encode(\r\n            array (\r\n                &#39;status&#39; =&gt; false,\r\n                &#39;error&#39; =&gt; $e -&gt; getMessage()\r\n            )\r\n        ));\r\n    }"},{"score":9,"body_markdown":"You can pass additional parameters along with file name on making asynchronous upload using XMLHttpRequest (without flash and iframe dependency). Append the additional parameter value with FormData and send the upload request.\r\n\r\n-------\r\n\r\n    var formData = new FormData();\r\n    formData.append(&#39;parameter1&#39;, &#39;value1&#39;);\r\n    formData.append(&#39;parameter2&#39;, &#39;value2&#39;); \r\n    formData.append(&#39;file&#39;, $(&#39;input[type=file]&#39;)[0].files[0]);\r\n    \r\n    $.ajax({\r\n        url: &#39;post back url&#39;,\r\n        data: formData,\r\n    // other attributes of AJAX\r\n    });\r\n\r\n----\r\nAlso, Syncfusion JavaScript UI file upload provides solution for this scenario simply using event argument. you can find documentation [here][1] and further details about this control here enter link description [here][2]\r\n\r\n\r\n  [1]: https://ej2.syncfusion.com/documentation/uploader/how-to/#add-additional-data-on-upload\r\n  [2]: https://www.syncfusion.com/javascript-ui-controls/file-upload\r\n"},{"score":4,"body_markdown":"You could also consider using something like https://uppy.io.\r\n\r\nIt does file uploading without navigating away from the page and offers a few bonuses like drag &amp; drop, resuming uploads in case of browser crashes/flaky networks, and importing from e.g. Instagram.\r\nIt&#39;s open source and does not rely on jQuery/React/Angular/Vue, but can be used with it. Disclaimer: as its creator I&#39;m biased ;)"},{"score":3,"body_markdown":"You can use the following code.\r\n\r\n    async: false(true)"},{"score":4,"body_markdown":"Try\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    async function saveFile() \r\n    {\r\n        let formData = new FormData();           \r\n        formData.append(&quot;file&quot;, file.files[0]);\r\n        await fetch(&#39;addFile.do&#39;, {method: &quot;POST&quot;, body: formData});    \r\n        alert(&quot;Data Uploaded: &quot;);\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;span&gt;File&lt;/span&gt;\r\n    &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; size=&quot;10&quot;/&gt;\r\n    &lt;input type=&quot;button&quot; value=&quot;Upload&quot; onclick=&quot;saveFile()&quot;/&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe `content-type=&#39;multipart/form-data&#39;` is set by browser automatically, the file name is added automatically too to `filename` FormData parameter (and can be easy read by server). Here is more developed example with err handling and json adding\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    async function saveFile(inp) \r\n    {\r\n        let user = { name:&#39;john&#39;, age:34 };\r\n        let formData = new FormData();\r\n        let photo = inp.files[0];      \r\n             \r\n        formData.append(&quot;photo&quot;, photo);\r\n        formData.append(&quot;user&quot;, JSON.stringify(user));  \r\n        \r\n        try {\r\n           let r = await fetch(&#39;/upload/image&#39;, {method: &quot;POST&quot;, body: formData}); \r\n           console.log(&#39;HTTP response code:&#39;,r.status); \r\n           alert(&#39;success&#39;);\r\n        } catch(e) {\r\n           console.log(&#39;Huston we have problem...:&#39;, e);\r\n        }\r\n        \r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;input type=&quot;file&quot; onchange=&quot;saveFile(this)&quot; &gt;\r\n    &lt;br&gt;&lt;br&gt;\r\n    Before selecting the file Open chrome console &gt; network tab to see the request details.\r\n    &lt;br&gt;&lt;br&gt;\r\n    &lt;small&gt;Because in this example we send request to https://stacksnippets.net/upload/image the response code will be 404 ofcourse...&lt;/small&gt;\r\n\r\n&lt;!-- end snippet --&gt;"},{"score":2,"body_markdown":"What if using promises which ajax and checking if the file is valid and well saved in your backend, so you can use some animation in front while user is navigating thought your page.\r\n\r\nYou can even make it paralel upload or stacking with recursive approach"}],"score":2979}