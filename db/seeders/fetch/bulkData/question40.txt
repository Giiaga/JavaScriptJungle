{"body":"I have an array of JavaScript objects:\r\n\r\n    var objs = [ \r\n        { first_nom: &#39;Lazslo&#39;, last_nom: &#39;Jamf&#39;     },\r\n        { first_nom: &#39;Pig&#39;,    last_nom: &#39;Bodine&#39;   },\r\n        { first_nom: &#39;Pirate&#39;, last_nom: &#39;Prentice&#39; }\r\n    ];\r\n\r\nHow can I sort them by the value of `last_nom` in JavaScript?\r\n\r\nI know about `sort(a,b)`, but that only seems to work on strings and numbers. Do I need to add a `toString()` method to my objects?\r\n","title":"Sort array of objects by string property value","answers":[{"score":4238,"body_markdown":"It&#39;s easy enough to write your own comparison function:\r\n\r\n    function compare( a, b ) {\r\n      if ( a.last_nom &lt; b.last_nom ){\r\n        return -1;\r\n      }\r\n      if ( a.last_nom &gt; b.last_nom ){\r\n        return 1;\r\n      }\r\n      return 0;\r\n    }\r\n    \r\n    objs.sort( compare );\r\n\r\nOr inline (c/o Marco Demaio): \r\n\r\n    objs.sort((a,b) =&gt; (a.last_nom &gt; b.last_nom) ? 1 : ((b.last_nom &gt; a.last_nom) ? -1 : 0)); "},{"score":66,"body_markdown":"If you have duplicate last names you might sort those by first name-\r\n\r\n    obj.sort(function(a,b){\r\n      if(a.last_nom&lt; b.last_nom) return -1;\r\n      if(a.last_nom &gt;b.last_nom) return 1;\r\n      if(a.first_nom&lt; b.first_nom) return -1;\r\n      if(a.first_nom &gt;b.first_nom) return 1;\r\n      return 0;\r\n    });"},{"score":32,"body_markdown":"Instead of using a custom comparison function, you could also create an object type with custom `toString()` method (which is invoked by the default comparison function):\r\n\r\n    function Person(firstName, lastName) {\r\n        this.firtName = firstName;\r\n        this.lastName = lastName;\r\n    }\r\n\r\n    Person.prototype.toString = function() {\r\n        return this.lastName + &#39;, &#39; + this.firstName;\r\n    }\r\n\r\n    var persons = [ new Person(&#39;Lazslo&#39;, &#39;Jamf&#39;), ...]\r\n    persons.sort();"},{"score":875,"body_markdown":"You can also create a dynamic sort function that sorts objects by their value that you pass:\r\n\r\n    function dynamicSort(property) {\r\n        var sortOrder = 1;\r\n        if(property[0] === &quot;-&quot;) {\r\n            sortOrder = -1;\r\n            property = property.substr(1);\r\n        }\r\n        return function (a,b) {\r\n\t\t\t/* next line works with strings and numbers, \r\n\t\t\t * and you may want to customize it to your needs\r\n\t\t\t */\r\n            var result = (a[property] &lt; b[property]) ? -1 : (a[property] &gt; b[property]) ? 1 : 0;\r\n            return result * sortOrder;\r\n        }\r\n    }\r\n\r\nSo you can have an array of objects like this:\r\n\r\n    var People = [\r\n        {Name: &quot;Name&quot;, Surname: &quot;Surname&quot;},\r\n        {Name:&quot;AAA&quot;, Surname:&quot;ZZZ&quot;},\r\n        {Name: &quot;Name&quot;, Surname: &quot;AAA&quot;}\r\n    ];\r\n\r\n...and it will work when you do:\r\n\r\n    People.sort(dynamicSort(&quot;Name&quot;));\r\n    People.sort(dynamicSort(&quot;Surname&quot;));\r\n    People.sort(dynamicSort(&quot;-Surname&quot;));\r\n\r\nActually this already answers the question. Below part is written because many people contacted me, complaining that [it doesn&#39;t work with multiple parameters][1].\r\n\r\n## Multiple Parameters\r\n\r\nYou can use the function below to generate sort functions with multiple sort parameters.\r\n\r\n\tfunction dynamicSortMultiple() {\r\n\t\t/*\r\n\t\t * save the arguments object as it will be overwritten\r\n\t\t * note that arguments object is an array-like object\r\n\t\t * consisting of the names of the properties to sort by\r\n\t\t */\r\n\t\tvar props = arguments;\r\n\t\treturn function (obj1, obj2) {\r\n\t\t\tvar i = 0, result = 0, numberOfProperties = props.length;\r\n\t\t\t/* try getting a different result from 0 (equal)\r\n\t\t\t * as long as we have extra properties to compare\r\n\t\t\t */\r\n\t\t\twhile(result === 0 &amp;&amp; i &lt; numberOfProperties) {\r\n\t\t\t\tresult = dynamicSort(props[i])(obj1, obj2);\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\r\n\r\nWhich would enable you to do something like this:\r\n\r\n    People.sort(dynamicSortMultiple(&quot;Name&quot;, &quot;-Surname&quot;));\r\n\r\n### Subclassing Array\r\n\r\nFor the lucky among us who can use ES6, which allows extending the native objects:\r\n\r\n    class MyArray extends Array {\r\n    \tsortBy(...args) {\r\n            return this.sort(dynamicSortMultiple.apply(null, args));\r\n        }\r\n    }\r\n\r\nThat would enable this:\r\n\r\n    MyArray.from(People).sortBy(&quot;Name&quot;, &quot;-Surname&quot;);\r\n\r\n  [1]: https://stackoverflow.com/questions/11379361\r\n  [2]: https://stackoverflow.com/users/2312161/mike-r\r\n  [3]: https://stackoverflow.com/a/16174180/300011\r\n  [4]: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty\r\n  [5]: http://jsfiddle.net/M2ESb/\r\n  [6]: http://jsfiddle.net/K7Lt8/\r\n  [7]: https://github.com/zenparsing/es-function-bind &quot;bind operator proposal&quot;\r\n  [8]: https://stackoverflow.com/questions/14034180/why-is-extending-native-objects-a-bad-practice"},{"score":193,"body_markdown":"[underscore.js][1]\r\n\r\nuse underscore, its small and awesome...\r\n\r\n&gt; sortBy_.sortBy(list, iterator, [context])  Returns a sorted copy of\r\n&gt; list, ranked in ascending order by the results of running each value\r\n&gt; through iterator. Iterator may also be the string name of the property\r\n&gt; to sort by (eg. length).\r\n\r\n\r\n    var objs = [ \r\n      { first_nom: &#39;Lazslo&#39;,last_nom: &#39;Jamf&#39; },\r\n      { first_nom: &#39;Pig&#39;, last_nom: &#39;Bodine&#39;  },\r\n      { first_nom: &#39;Pirate&#39;, last_nom: &#39;Prentice&#39; }\r\n    ];\r\n\r\n    var sortedObjs = _.sortBy( objs, &#39;first_nom&#39; );\r\n\r\n\r\n  [1]: http://underscorejs.org/#sortBy"},{"score":51,"body_markdown":"Simple and quick solution to this problem using prototype inheritance:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    Array.prototype.sortBy = function(p) {\r\n      return this.slice(0).sort(function(a,b) {\r\n        return (a[p] &gt; b[p]) ? 1 : (a[p] &lt; b[p]) ? -1 : 0;\r\n      });\r\n    }\r\n\r\n\r\n**Example / Usage**\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    objs = [{age:44,name:&#39;vinay&#39;},{age:24,name:&#39;deepak&#39;},{age:74,name:&#39;suresh&#39;}];\r\n\r\n    objs.sortBy(&#39;age&#39;);\r\n    // Returns\r\n    // [{&quot;age&quot;:24,&quot;name&quot;:&quot;deepak&quot;},{&quot;age&quot;:44,&quot;name&quot;:&quot;vinay&quot;},{&quot;age&quot;:74,&quot;name&quot;:&quot;suresh&quot;}]\r\n\r\n    objs.sortBy(&#39;name&#39;);\r\n    // Returns\r\n    // [{&quot;age&quot;:24,&quot;name&quot;:&quot;deepak&quot;},{&quot;age&quot;:74,&quot;name&quot;:&quot;suresh&quot;},{&quot;age&quot;:44,&quot;name&quot;:&quot;vinay&quot;}]\r\n\r\n**Update:** No longer modifies original array."},{"score":10,"body_markdown":"additional desc params for **Ege &#214;zcan** code\r\n\r\n    function dynamicSort(property, desc) {\r\n        if (desc) {\r\n            return function (a, b) {\r\n                return (a[property] &gt; b[property]) ? -1 : (a[property] &lt; b[property]) ? 1 : 0;\r\n            }   \r\n        }\r\n        return function (a, b) {\r\n            return (a[property] &lt; b[property]) ? -1 : (a[property] &gt; b[property]) ? 1 : 0;\r\n        }\r\n    }"},{"score":10,"body_markdown":"Combining Ege&#39;s dynamic solution with Vinay&#39;s idea, you get a nice robust solution:\r\n\r\n    Array.prototype.sortBy = function() {\r\n        function _sortByAttr(attr) {\r\n            var sortOrder = 1;\r\n            if (attr[0] == &quot;-&quot;) {\r\n                sortOrder = -1;\r\n                attr = attr.substr(1);\r\n            }\r\n            return function(a, b) {\r\n                var result = (a[attr] &lt; b[attr]) ? -1 : (a[attr] &gt; b[attr]) ? 1 : 0;\r\n                return result * sortOrder;\r\n            }\r\n        }\r\n        function _getSortFunc() {\r\n            if (arguments.length == 0) {\r\n                throw &quot;Zero length arguments not allowed for Array.sortBy()&quot;;\r\n            }\r\n            var args = arguments;\r\n            return function(a, b) {\r\n                for (var result = 0, i = 0; result == 0 &amp;&amp; i &lt; args.length; i++) {\r\n                    result = _sortByAttr(args[i])(a, b);\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        return this.sort(_getSortFunc.apply(null, arguments));\r\n    }\r\n\r\nUsage:\r\n\r\n    // Utility for printing objects\r\n    Array.prototype.print = function(title) {\r\n        console.log(&quot;************************************************************************&quot;);\r\n        console.log(&quot;**** &quot;+title);\r\n        console.log(&quot;************************************************************************&quot;);\r\n        for (var i = 0; i &lt; this.length; i++) {\r\n            console.log(&quot;Name: &quot;+this[i].FirstName, this[i].LastName, &quot;Age: &quot;+this[i].Age);\r\n        }\r\n    }\r\n    \r\n    // Setup sample data\r\n    var arrObj = [\r\n        {FirstName: &quot;Zach&quot;, LastName: &quot;Emergency&quot;, Age: 35},\r\n        {FirstName: &quot;Nancy&quot;, LastName: &quot;Nurse&quot;, Age: 27},\r\n        {FirstName: &quot;Ethel&quot;, LastName: &quot;Emergency&quot;, Age: 42},\r\n        {FirstName: &quot;Nina&quot;, LastName: &quot;Nurse&quot;, Age: 48},\r\n        {FirstName: &quot;Anthony&quot;, LastName: &quot;Emergency&quot;, Age: 44},\r\n        {FirstName: &quot;Nina&quot;, LastName: &quot;Nurse&quot;, Age: 32},\r\n        {FirstName: &quot;Ed&quot;, LastName: &quot;Emergency&quot;, Age: 28},\r\n        {FirstName: &quot;Peter&quot;, LastName: &quot;Physician&quot;, Age: 58},\r\n        {FirstName: &quot;Al&quot;, LastName: &quot;Emergency&quot;, Age: 51},\r\n        {FirstName: &quot;Ruth&quot;, LastName: &quot;Registration&quot;, Age: 62},\r\n        {FirstName: &quot;Ed&quot;, LastName: &quot;Emergency&quot;, Age: 38},\r\n        {FirstName: &quot;Tammy&quot;, LastName: &quot;Triage&quot;, Age: 29},\r\n        {FirstName: &quot;Alan&quot;, LastName: &quot;Emergency&quot;, Age: 60},\r\n        {FirstName: &quot;Nina&quot;, LastName: &quot;Nurse&quot;, Age: 54}\r\n    ];\r\n    \r\n    //Unit Tests\r\n    arrObj.sortBy(&quot;LastName&quot;).print(&quot;LastName Ascending&quot;);\r\n    arrObj.sortBy(&quot;-LastName&quot;).print(&quot;LastName Descending&quot;);\r\n    arrObj.sortBy(&quot;LastName&quot;, &quot;FirstName&quot;, &quot;-Age&quot;).print(&quot;LastName Ascending, FirstName Ascending, Age Descending&quot;);\r\n    arrObj.sortBy(&quot;-FirstName&quot;, &quot;Age&quot;).print(&quot;FirstName Descending, Age Ascending&quot;);\r\n    arrObj.sortBy(&quot;-Age&quot;).print(&quot;Age Descending&quot;);"},{"score":7,"body_markdown":"You may need to convert them to the lower case in order to prevent from confusion.\r\n\r\n    objs.sort(function (a,b) {\r\n\r\n    var nameA=a.last_nom.toLowerCase(), nameB=b.last_nom.toLowerCase()\r\n\r\n    if (nameA &lt; nameB)\r\n      return -1;\r\n    if (nameA &gt; nameB)\r\n      return 1;\r\n    return 0;  //no sorting\r\n\r\n    })"},{"score":197,"body_markdown":"Don&#39;t get why people make it so complicated:\r\n\r\n    objs.sort(function(a, b){\r\n      return a.last_nom &gt; b.last_nom;\r\n    });\r\n\r\nFor stricter engines:\r\n\r\n    objs.sort(function(a, b){\r\n      return a.last_nom == b.last_nom ? 0 : +(a.last_nom &gt; b.last_nom) || -1;\r\n    });\r\nSwap the operator to have it sorted by reverse alphabetical order."},{"score":24,"body_markdown":"Example Usage:\r\n\r\n    objs.sort(sortBy(&#39;last_nom&#39;));\r\n\r\nScript: \r\n\r\n    /**\r\n     * @description\r\n     * Returns a function which will sort an\r\n     * array of objects by the given key.\r\n     *\r\n     * @param  {String}  key\r\n     * @param  {Boolean} reverse\r\n     * @return {Function}\r\n     */\r\n    const sortBy = (key, reverse) =&gt; {\r\n      \r\n      // Move smaller items towards the front\r\n      // or back of the array depending on if\r\n      // we want to sort the array in reverse\r\n      // order or not.\r\n      const moveSmaller = reverse ? 1 : -1;\r\n      \r\n      // Move larger items towards the front\r\n      // or back of the array depending on if\r\n      // we want to sort the array in reverse\r\n      // order or not.\r\n      const moveLarger = reverse ? -1 : 1;\r\n      \r\n      /**\r\n       * @param  {*} a\r\n       * @param  {*} b\r\n       * @return {Number}\r\n       */\r\n      return (a, b) =&gt; {\r\n        if (a[key] &lt; b[key]) {\r\n          return moveSmaller;\r\n        }\r\n        if (a[key] &gt; b[key]) {\r\n          return moveLarger;\r\n        }\r\n        return 0;\r\n      };\r\n    };\r\n"},{"score":8,"body_markdown":"Acording your example, you need to sort by two fields (last name, first name), rather then one. You can use [Alasql][1] library to make this sort in one line:\r\n\r\n    var res = alasql(&#39;SELECT * FROM ? ORDER BY last_nom, first_nom&#39;,[objs]);\r\n\r\nTry this example [at jsFiddle][2].\r\n\r\n\r\n  [1]: http://github.com/agershun/alasql\r\n  [2]: http://jsfiddle.net/agershun/4f4Lr9ss/1/"},{"score":4,"body_markdown":"Using **xPrototype**: https://github.com/reduardo7/xPrototype/blob/master/README.md#sortbycol1-col2-coln\r\n\r\n\r\n\tvar o = [ \r\n\t  { Name: &#39;Lazslo&#39;, LastName: &#39;Jamf&#39;     },\r\n\t  { Name: &#39;Pig&#39;,    LastName: &#39;Bodine&#39;   },\r\n\t  { Name: &#39;Pirate&#39;, LastName: &#39;Prentice&#39; },\r\n\t  { Name: &#39;Pag&#39;,    LastName: &#39;Bodine&#39;   }\r\n\t];\r\n\r\n\r\n\t// Original\r\n\to.each(function (a, b) { console.log(a, b); });\r\n\t/*\r\n\t 0 Object {Name: &quot;Lazslo&quot;, LastName: &quot;Jamf&quot;}\r\n\t 1 Object {Name: &quot;Pig&quot;, LastName: &quot;Bodine&quot;}\r\n\t 2 Object {Name: &quot;Pirate&quot;, LastName: &quot;Prentice&quot;}\r\n\t 3 Object {Name: &quot;Pag&quot;, LastName: &quot;Bodine&quot;}\r\n\t*/\r\n\r\n\r\n\t// Sort By LastName ASC, Name ASC\r\n\to.sortBy(&#39;LastName&#39;, &#39;Name&#39;).each(function(a, b) { console.log(a, b); });\r\n\t/*\r\n\t 0 Object {Name: &quot;Pag&quot;, LastName: &quot;Bodine&quot;}\r\n\t 1 Object {Name: &quot;Pig&quot;, LastName: &quot;Bodine&quot;}\r\n\t 2 Object {Name: &quot;Lazslo&quot;, LastName: &quot;Jamf&quot;}\r\n\t 3 Object {Name: &quot;Pirate&quot;, LastName: &quot;Prentice&quot;}\r\n\t*/\r\n\r\n\r\n\t// Sort by LastName ASC and Name ASC\r\n\to.sortBy(&#39;LastName&#39;.asc, &#39;Name&#39;.asc).each(function(a, b) { console.log(a, b); });\r\n\t/*\r\n\t 0 Object {Name: &quot;Pag&quot;, LastName: &quot;Bodine&quot;}\r\n\t 1 Object {Name: &quot;Pig&quot;, LastName: &quot;Bodine&quot;}\r\n\t 2 Object {Name: &quot;Lazslo&quot;, LastName: &quot;Jamf&quot;}\r\n\t 3 Object {Name: &quot;Pirate&quot;, LastName: &quot;Prentice&quot;}\r\n\t*/\r\n\r\n\r\n\t// Sort by LastName DESC and Name DESC\r\n\to.sortBy(&#39;LastName&#39;.desc, &#39;Name&#39;.desc).each(function(a, b) { console.log(a, b); });\r\n\t/*\r\n\t 0 Object {Name: &quot;Pirate&quot;, LastName: &quot;Prentice&quot;}\r\n\t 1 Object {Name: &quot;Lazslo&quot;, LastName: &quot;Jamf&quot;}\r\n\t 2 Object {Name: &quot;Pig&quot;, LastName: &quot;Bodine&quot;}\r\n\t 3 Object {Name: &quot;Pag&quot;, LastName: &quot;Bodine&quot;}\r\n\t*/\r\n\r\n\r\n\t// Sort by LastName DESC and Name ASC\r\n\to.sortBy(&#39;LastName&#39;.desc, &#39;Name&#39;.asc).each(function(a, b) { console.log(a, b); });\r\n\t/*\r\n\t 0 Object {Name: &quot;Pirate&quot;, LastName: &quot;Prentice&quot;}\r\n\t 1 Object {Name: &quot;Lazslo&quot;, LastName: &quot;Jamf&quot;}\r\n\t 2 Object {Name: &quot;Pag&quot;, LastName: &quot;Bodine&quot;}\r\n\t 3 Object {Name: &quot;Pig&quot;, LastName: &quot;Bodine&quot;}\r\n\t*/"},{"score":5,"body_markdown":"I Just enhanced [Ege &#214;zcan](https://stackoverflow.com/users/300011)&#39;s dynamic sort to dive deep inside objects. \r\nIf Data looks like this: \r\n\r\n\tobj = [\r\n        {\r\n\t\t\ta: { a: 1, b: 2, c: 3 },\r\n\t\t\tb: { a: 4, b: 5, c: 6 }\r\n\t\t},\r\n\t\t{ \r\n\t\t\ta: { a: 3, b: 2, c: 1 },\r\n\t\t\tb: { a: 6, b: 5, c: 4 }\r\n    }];\r\n\r\nand if you want to sort it over **a.a** property I think my enhancement helps very well. I add new functionality to objects like this:\r\n\r\n    Object.defineProperty(Object.prototype, &#39;deepVal&#39;, {\r\n\t\tenumerable: false,\r\n\t\twritable: true,\r\n\t\tvalue: function (propertyChain) {\r\n\t\t\tvar levels = propertyChain.split(&#39;.&#39;);\r\n\t\t\tparent = this;\r\n\t\t\tfor (var i = 0; i &lt; levels.length; i++) {\r\n\t\t\t\tif (!parent[levels[i]])\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\tparent = parent[levels[i]];\r\n\t\t\t}\r\n\t\t\treturn parent;\r\n\t\t}\r\n\t});\r\n\r\nand changed **_dynamicSort**&#39;s *return* function:\r\n\r\n    return function (a,b) {\r\n\t\t\tvar result = ((a.deepVal(property) &gt; b.deepVal(property)) - (a.deepVal(property) &lt; b.deepVal(property)));\r\n\t\t\treturn result * sortOrder;\r\n\t\t}\r\nAnd now you can sort by **a.a.** this way:\r\n\r\n    obj.sortBy(&#39;a.a&#39;);\r\n\r\nSee Commplete script in [JSFiddle](http://jsfiddle.net/Gigapedia/ofd0a1nd/1/)"},{"score":15,"body_markdown":"# Sorting (more) Complex Arrays of Objects\r\nSince you probably encounter more complex data structures like this array, I would expand the solution. \r\n\r\n## TL;DR\r\n&gt; Are more pluggable version based on **[@ege-&#214;zcan](https://stackoverflow.com/users/300011/ege-%C3%96zcan)**&#39;s very lovely [answer](https://stackoverflow.com/a/4760279/3580261).\r\n\r\n## Problem \r\nI encountered the below and couldn&#39;t change it. I also did not want to flatten the object temporarily. Nor did I want to use underscore / lodash, mainly for performance reasons and the fun to implement it myself.\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n       \r\n    var People = [\r\n       {Name: {name: &quot;Name&quot;, surname: &quot;Surname&quot;}, Middlename: &quot;JJ&quot;},\r\n       {Name: {name: &quot;AAA&quot;, surname: &quot;ZZZ&quot;}, Middlename:&quot;Abrams&quot;},\r\n       {Name: {name: &quot;Name&quot;, surname: &quot;AAA&quot;}, Middlename: &quot;Wars&quot;}\r\n    ];\r\n### Goal \r\nThe goal is to sort it primarily by `People.Name.name` and secondarily by `People.Name.surname`\r\n\r\n### Obstacles\r\nNow, in the base solution uses bracket notation to compute the properties to sort for dynamically. Here, though, we would have to construct the bracket notation dynamically also, since you would expect some like `People[&#39;Name.name&#39;]` would work - which doesn&#39;t. \r\n\r\nSimply doing `People[&#39;Name&#39;][&#39;name&#39;]`, on the other hand, is static and only allows you to go down the *n*-th level.\r\n\r\n## Solution\r\nThe main addition here will be to walk down the object tree and determine the value of the last leaf, you have to specify, as well as any intermediary leaf.\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var People = [\r\n       {Name: {name: &quot;Name&quot;, surname: &quot;Surname&quot;}, Middlename: &quot;JJ&quot;},\r\n       {Name: {name: &quot;AAA&quot;, surname: &quot;ZZZ&quot;}, Middlename:&quot;Abrams&quot;},\r\n       {Name: {name: &quot;Name&quot;, surname: &quot;AAA&quot;}, Middlename: &quot;Wars&quot;}\r\n    ];\r\n\r\n    People.sort(dynamicMultiSort([&#39;Name&#39;,&#39;name&#39;], [&#39;Name&#39;, &#39;-surname&#39;]));\r\n    // Results in...\r\n    // [ { Name: { name: &#39;AAA&#39;, surname: &#39;ZZZ&#39; }, Middlename: &#39;Abrams&#39; },\r\n    //   { Name: { name: &#39;Name&#39;, surname: &#39;Surname&#39; }, Middlename: &#39;JJ&#39; },\r\n    //   { Name: { name: &#39;Name&#39;, surname: &#39;AAA&#39; }, Middlename: &#39;Wars&#39; } ]\r\n\r\n    // same logic as above, but strong deviation for dynamic properties \r\n    function dynamicSort(properties) {\r\n      var sortOrder = 1;\r\n      // determine sort order by checking sign of last element of array\r\n      if(properties[properties.length - 1][0] === &quot;-&quot;) {\r\n        sortOrder = -1;\r\n        // Chop off sign\r\n        properties[properties.length - 1] = properties[properties.length - 1].substr(1);\r\n      }\r\n      return function (a,b) {\r\n        propertyOfA = recurseObjProp(a, properties)\r\n        propertyOfB = recurseObjProp(b, properties)\r\n        var result = (propertyOfA &lt; propertyOfB) ? -1 : (propertyOfA &gt; propertyOfB) ? 1 : 0;\r\n        return result * sortOrder;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Takes an object and recurses down the tree to a target leaf and returns it value\r\n     * @param  {Object} root - Object to be traversed.\r\n     * @param  {Array} leafs - Array of downwards traversal. To access the value: {parent:{ child: &#39;value&#39;}} -&gt; [&#39;parent&#39;,&#39;child&#39;]\r\n     * @param  {Number} index - Must not be set, since it is implicit.\r\n     * @return {String|Number}       The property, which is to be compared by sort.\r\n     */\r\n    function recurseObjProp(root, leafs, index) {\r\n      index ? index : index = 0\r\n      var upper = root\r\n      // walk down one level\r\n      lower = upper[leafs[index]]\r\n      // Check if last leaf has been hit by having gone one step too far.\r\n      // If so, return result from last step.\r\n      if (!lower) {\r\n        return upper\r\n      }\r\n      // Else: recurse!\r\n      index++\r\n      // HINT: Bug was here, for not explicitly returning function\r\n      // https://stackoverflow.com/a/17528613/3580261\r\n      return recurseObjProp(lower, leafs, index)\r\n    }\r\n\r\n    /**\r\n     * Multi-sort your array by a set of properties\r\n     * @param {...Array} Arrays to access values in the form of: {parent:{ child: &#39;value&#39;}} -&gt; [&#39;parent&#39;,&#39;child&#39;]\r\n     * @return {Number} Number - number for sort algorithm\r\n     */\r\n    function dynamicMultiSort() {\r\n      var args = Array.prototype.slice.call(arguments); // slight deviation to base\r\n    \r\n      return function (a, b) {\r\n        var i = 0, result = 0, numberOfProperties = args.length;\r\n        // REVIEW: slightly verbose; maybe no way around because of `.sort`-&#39;s nature\r\n        // Consider: `.forEach()`\r\n        while(result === 0 &amp;&amp; i &lt; numberOfProperties) {\r\n          result = dynamicSort(args[i])(a, b);\r\n          i++;\r\n        }\r\n        return result;\r\n      }\r\n    }\r\n\r\n## Example\r\n\r\nWorking example [on JSBin](http://jsbin.com/lotifa/2/edit?js,console)"},{"score":7,"body_markdown":"    function compare(propName) {\r\n        return function(a,b) {\r\n            if (a[propName] &lt; b[propName])\r\n                return -1;\r\n            if (a[propName] &gt; b[propName])\r\n                return 1;\r\n            return 0;\r\n        };\r\n    }\r\n    \r\n    objs.sort(compare(&quot;last_nom&quot;));"},{"score":7,"body_markdown":"This is a simple problem, don&#39;t know why people have such complex solution.&lt;br&gt;\r\nA simple sort function (based on **quick-sort** algorithm):\r\n\r\n    function sortObjectsArray(objectsArray, sortKey)\r\n            {\r\n                // Quick Sort:\r\n                var retVal;\r\n\r\n                if (1 &lt; objectsArray.length)\r\n                {\r\n                    var pivotIndex = Math.floor((objectsArray.length - 1) / 2);  // middle index\r\n                    var pivotItem = objectsArray[pivotIndex];                    // value in the middle index\r\n                    var less = [], more = [];\r\n\r\n                    objectsArray.splice(pivotIndex, 1);                          // remove the item in the pivot position\r\n                    objectsArray.forEach(function(value, index, array)\r\n                    {\r\n                        value[sortKey] &lt;= pivotItem[sortKey] ?                   // compare the &#39;sortKey&#39; proiperty\r\n                            less.push(value) :\r\n                            more.push(value) ;\r\n                    });\r\n\r\n                    retVal = sortObjectsArray(less, sortKey).concat([pivotItem], sortObjectsArray(more, sortKey));\r\n                }\r\n                else\r\n                {\r\n                    retVal = objectsArray;\r\n                }\r\n\r\n                return retVal;\r\n            }\r\n\r\nUse example:\r\n\r\n    var myArr = \r\n            [\r\n                { val: &#39;x&#39;, idx: 3 },\r\n                { val: &#39;y&#39;, idx: 2 },\r\n                { val: &#39;z&#39;, idx: 5 },\r\n            ];\r\n    myArr = sortObjectsArray(myArr, &#39;idx&#39;);"},{"score":11,"body_markdown":"A simple way:\r\n\r\n    objs.sort(function(a,b) {\r\n      return b.last_nom.toLowerCase() &lt; a.last_nom.toLowerCase();\r\n    });\r\n    \r\nSee that `&#39;.toLowerCase()&#39;` is necessary to prevent erros \r\nin comparing strings."},{"score":504,"body_markdown":"In ES6/ES2015 or later you can do this way:\r\n\r\n    objs.sort((a, b) =&gt; a.last_nom.localeCompare(b.last_nom));\r\n\r\n\r\nPrior to ES6/ES2015\r\n\r\n    objs.sort(function(a, b) {\r\n    \treturn a.last_nom.localeCompare(b.last_nom)\r\n    });"},{"score":9,"body_markdown":"    objs.sort(function(a,b){return b.last_nom&gt;a.last_nom})"},{"score":2,"body_markdown":"I came into problem of sorting array of objects, with changing priority of values, basically I want to sort array of peoples by their Age, and then by surname - or just by surname, name. \r\nI think that this is most simple solution compared to another answers.\r\n\r\nit&#39; is used by calling sortPeoples([&#39;array&#39;, &#39;of&#39;, &#39;properties&#39;], reverse=false)\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    ///////////////////////example array of peoples ///////////////////////\r\n\r\n    var peoples = [\r\n        {name: &quot;Zach&quot;, surname: &quot;Emergency&quot;, age: 1},\r\n        {name: &quot;Nancy&quot;, surname: &quot;Nurse&quot;, age: 1},\r\n        {name: &quot;Ethel&quot;, surname: &quot;Emergency&quot;, age: 1},\r\n        {name: &quot;Nina&quot;, surname: &quot;Nurse&quot;, age: 42},\r\n        {name: &quot;Anthony&quot;, surname: &quot;Emergency&quot;, age: 42},\r\n        {name: &quot;Nina&quot;, surname: &quot;Nurse&quot;, age: 32},\r\n        {name: &quot;Ed&quot;, surname: &quot;Emergency&quot;, age: 28},\r\n        {name: &quot;Peter&quot;, surname: &quot;Physician&quot;, age: 58},\r\n        {name: &quot;Al&quot;, surname: &quot;Emergency&quot;, age: 58},\r\n        {name: &quot;Ruth&quot;, surname: &quot;Registration&quot;, age: 62},\r\n        {name: &quot;Ed&quot;, surname: &quot;Emergency&quot;, age: 38},\r\n        {name: &quot;Tammy&quot;, surname: &quot;Triage&quot;, age: 29},\r\n        {name: &quot;Alan&quot;, surname: &quot;Emergency&quot;, age: 60},\r\n        {name: &quot;Nina&quot;, surname: &quot;Nurse&quot;, age: 58}\r\n    ];\r\n\r\n\r\n\r\n    //////////////////////// Sorting function /////////////////////\r\n    function sortPeoples(propertyArr, reverse) {\r\n            function compare(a,b) {\r\n                var i=0;\r\n                while (propertyArr[i]) {\r\n                    if (a[propertyArr[i]] &lt; b[propertyArr[i]])  return -1;\r\n                    if (a[propertyArr[i]] &gt; b[propertyArr[i]])  return 1;\r\n                    i++;\r\n                }\r\n                return 0;\r\n                }\r\n            peoples.sort(compare);\r\n            if (reverse){\r\n                peoples.reverse();\r\n            }\r\n        };\r\n\r\n    ////////////////end of sorting method///////////////\r\n    function printPeoples(){\r\n      $(&#39;#output&#39;).html(&#39;&#39;);\r\n    peoples.forEach( function(person){\r\n     $(&#39;#output&#39;).append(person.surname+&quot; &quot;+person.name+&quot; &quot;+person.age+&quot;&lt;br&gt;&quot;);\r\n    } )\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;head&gt;\r\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;/head&gt;\r\n      &lt;html&gt;\r\n      &lt;body&gt;\r\n    &lt;button onclick=&quot;sortPeoples([&#39;surname&#39;]); printPeoples()&quot;&gt;sort by ONLY by surname ASC results in mess with same name cases&lt;/button&gt;&lt;br&gt;\r\n    &lt;button onclick=&quot;sortPeoples([&#39;surname&#39;, &#39;name&#39;], true); printPeoples()&quot;&gt;sort by surname then name DESC&lt;/button&gt;&lt;br&gt;\r\n    &lt;button onclick=&quot;sortPeoples([&#39;age&#39;]); printPeoples()&quot;&gt;sort by AGE ASC. Same issue as in first case&lt;/button&gt;&lt;br&gt;\r\n    &lt;button onclick=&quot;sortPeoples([&#39;age&#39;, &#39;surname&#39;]); printPeoples()&quot;&gt;sort by AGE and Surname ASC. Adding second field fixed it.&lt;/button&gt;&lt;br&gt;\r\n            \r\n        &lt;div id=&quot;output&quot;&gt;&lt;/div&gt;\r\n        &lt;/body&gt;\r\n      &lt;/html&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":26,"body_markdown":"There are many good answers here, but I would like to point out that they can be extended very simply to achieve a lot more complex sorting. The only thing you have to do is to use the OR operator to chain comparision functions like this:\r\n\r\n    objs.sort((a,b)=&gt; fn1(a,b) || fn2(a,b) || fn3(a,b) )\r\n\r\nWhere `fn1`, `fn2`, ... are the sort functions which return [-1,0,1]. This results in &quot;sorting by fn1&quot;, &quot;sorting by fn2&quot; which is pretty much equal to ORDER BY in SQL.\r\n\r\nThis solution is based on the behaviour of `||` operator which evaluates to the [first evaluated expression which can be converted to true][1].\r\n\r\n**The simplest form** has only one inlined function like this:\r\n  \r\n    // ORDER BY last_nom\r\n    objs.sort((a,b)=&gt; a.last_nom.localeCompare(b.last_nom) )\r\n\r\nHaving two steps with  `last_nom`,`first_nom` sort order would look like this:\r\n\r\n    // ORDER_BY last_nom, first_nom\r\n    objs.sort((a,b)=&gt; a.last_nom.localeCompare(b.last_nom) || \r\n                      a.first_nom.localeCompare(b.first_nom)&#160; )\r\n\r\n**A generic comparision function** could be something like this:\r\n\r\n    // ORDER BY &lt;n&gt;\r\n    let cmp = (a,b,n)=&gt;a[n].localeCompare(b[n])\r\n\r\nThis function could be extended to support numeric fields, case sensitity, arbitary datatypes etc.\r\n\r\nYou can them use it with chaining them by sort priority:\r\n\r\n    // ORDER_BY last_nom, first_nom\r\n    objs.sort((a,b)=&gt; cmp(a,b, &quot;last_nom&quot;) || cmp(a,b, &quot;first_nom&quot;) )\r\n    // ORDER_BY last_nom, first_nom DESC\r\n    objs.sort((a,b)=&gt; cmp(a,b, &quot;last_nom&quot;) || -cmp(a,b, &quot;first_nom&quot;) )\r\n    // ORDER_BY last_nom DESC, first_nom DESC\r\n    objs.sort((a,b)=&gt; -cmp(a,b, &quot;last_nom&quot;) || -cmp(a,b, &quot;first_nom&quot;) )\r\n\r\nThe point here is that pure JavaScript with functional approach can take you a long way without external libraries or complex code. It is also very effective, since no string parsing have to be done\r\n\r\n\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Logical_operators\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare#Parameters"},{"score":13,"body_markdown":"One more option:\r\n\r\n    var someArray = [...];\r\n\r\n    function generateSortFn(prop, reverse) {\r\n        return function (a, b) {\r\n            if (a[prop] &lt; b[prop]) return reverse ? 1 : -1;\r\n            if (a[prop] &gt; b[prop]) return reverse ? -1 : 1;\r\n            return 0;\r\n        };\r\n    }\r\n\r\n    someArray.sort(generateSortFn(&#39;name&#39;, true));\r\n\r\nsorts ascending by default."},{"score":2,"body_markdown":"    // Sort Array of Objects\r\n\r\n    // Data\r\n    var booksArray = [\r\n        { first_nom: &#39;Lazslo&#39;, last_nom: &#39;Jamf&#39;     },\r\n        { first_nom: &#39;Pig&#39;,    last_nom: &#39;Bodine&#39;   },\r\n        { first_nom: &#39;Pirate&#39;, last_nom: &#39;Prentice&#39; }\r\n    ];\r\n    \r\n    // Property to Sort By\r\n    var args = &quot;last_nom&quot;;\r\n    \r\n    // Function to Sort the Data by given Property\r\n    function sortByProperty(property) {\r\n        return function (a, b) {\r\n            var sortStatus = 0,\r\n                aProp = a[property].toLowerCase(),\r\n                bProp = b[property].toLowerCase();\r\n            if (aProp &lt; bProp) {\r\n                sortStatus = -1;\r\n            } else if (aProp &gt; bProp) {\r\n                sortStatus = 1;\r\n            }\r\n            return sortStatus;\r\n        };\r\n    }\r\n    \r\n    // Implementation\r\n    var sortedArray = booksArray.sort(sortByProperty(args));\r\n    \r\n    console.log(&quot;sortedArray: &quot; + JSON.stringify(sortedArray) );\r\n\r\n\r\nConsole log output:\r\n\r\n    &quot;sortedArray: \r\n    [{&quot;first_nom&quot;:&quot;Pig&quot;,&quot;last_nom&quot;:&quot;Bodine&quot;},\r\n    {&quot;first_nom&quot;:&quot;Lazslo&quot;,&quot;last_nom&quot;:&quot;Jamf&quot;},\r\n    {&quot;first_nom&quot;:&quot;Pirate&quot;,&quot;last_nom&quot;:&quot;Prentice&quot;}]&quot;\r\n\r\n\r\nAdapted based on this source: [http://www.levihackwith.com/code-snippet-how-to-sort-an-array-of-json-objects-by-property/][1]\r\n\r\n\r\n  [1]: http://www.levihackwith.com/code-snippet-how-to-sort-an-array-of-json-objects-by-property/"},{"score":2,"body_markdown":"This will sort a two level nested array by the property passed to it in alpha numeric order.\r\n\r\n\tfunction sortArrayObjectsByPropAlphaNum(property) {\r\n\t\treturn function (a,b) {\r\n\t\t\tvar reA = /[^a-zA-Z]/g;\r\n\t\t\tvar reN = /[^0-9]/g;\r\n\t\t\tvar aA = a[property].replace(reA, &#39;&#39;);\r\n\t\t\tvar bA = b[property].replace(reA, &#39;&#39;);\r\n\r\n\t\t\tif(aA === bA) {\r\n\t\t\t\tvar aN = parseInt(a[property].replace(reN, &#39;&#39;), 10);\r\n\t\t\t\tvar bN = parseInt(b[property].replace(reN, &#39;&#39;), 10);\r\n\t\t\t\treturn aN === bN ? 0 : aN &gt; bN ? 1 : -1;\r\n\t\t\t} else {\r\n\t\t\t\treturn a[property] &gt; b[property] ? 1 : -1;\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\nUsage:\r\n\r\n    objs.sort(utils.sortArrayObjectsByPropAlphaNum(&#39;last_nom&#39;));"},{"score":21,"body_markdown":"I know this question is too old, but I didn&#39;t see any implementation similar to mine.  \r\nThis version is based on the [Schwartzian transform idiom](https://en.wikipedia.org/wiki/Schwartzian_transform). \r\n\r\n    function sortByAttribute(array, ...attrs) {\r\n      // generate an array of predicate-objects contains\r\n      // property getter, and descending indicator\r\n      let predicates = attrs.map(pred =&gt; {\r\n        let descending = pred.charAt(0) === &#39;-&#39; ? -1 : 1;\r\n        pred = pred.replace(/^-/, &#39;&#39;);\r\n        return {\r\n          getter: o =&gt; o[pred],\r\n          descend: descending\r\n        };\r\n      });\r\n      // schwartzian transform idiom implementation. aka: &quot;decorate-sort-undecorate&quot;\r\n      return array.map(item =&gt; {\r\n        return {\r\n          src: item,\r\n          compareValues: predicates.map(predicate =&gt; predicate.getter(item))\r\n        };\r\n      })\r\n      .sort((o1, o2) =&gt; {\r\n        let i = -1, result = 0;\r\n        while (++i &lt; predicates.length) {\r\n          if (o1.compareValues[i] &lt; o2.compareValues[i]) result = -1;\r\n          if (o1.compareValues[i] &gt; o2.compareValues[i]) result = 1;\r\n          if (result *= predicates[i].descend) break;\r\n        }\r\n        return result;\r\n      })\r\n      .map(item =&gt; item.src);\r\n    }\r\n        \r\n\r\nHere&#39;s an example how to use it:\r\n\r\n    let games = [\r\n      { name: &#39;Mashraki&#39;,          rating: 4.21 },\r\n      { name: &#39;Hill Climb Racing&#39;, rating: 3.88 },\r\n      { name: &#39;Angry Birds Space&#39;, rating: 3.88 },\r\n      { name: &#39;Badland&#39;,           rating: 4.33 }\r\n    ];\r\n    \r\n    // sort by one attribute\r\n    console.log(sortByAttribute(games, &#39;name&#39;));\r\n    // sort by mupltiple attributes\r\n    console.log(sortByAttribute(games, &#39;-rating&#39;, &#39;name&#39;));"},{"score":2,"body_markdown":"So here is one sorting algorithm which can sort in any order , throughout array of any kind of objects , without the restriction of datatype comparison ( i.e. Number , String )\r\n\r\n    function smoothSort(items,prop,reverse) {  \r\n        var length = items.length;\r\n        for (var i = (length - 1); i &gt;= 0; i--) {\r\n            //Number of passes\r\n            for (var j = (length - i); j &gt; 0; j--) {\r\n                //Compare the adjacent positions\r\n                if(reverse){\r\n                  if (items[j][prop] &gt; items[j - 1][prop]) {\r\n                    //Swap the numbers\r\n                    var tmp = items[j];\r\n                    items[j] = items[j - 1];\r\n                    items[j - 1] = tmp;\r\n                }\r\n                }\r\n                \r\n                if(!reverse){\r\n                  if (items[j][prop] &lt; items[j - 1][prop]) {\r\n                      //Swap the numbers\r\n                      var tmp = items[j];\r\n                      items[j] = items[j - 1];\r\n                      items[j - 1] = tmp;\r\n                  }\r\n                }\r\n            }\r\n        }\r\n    \r\n        return items;\r\n    }\r\n\r\n - the first argument *items* is the array of objects , \r\n   \r\n \r\n - *prop* is the key of the object on which you want to sort ,\r\n\r\n\r\n   \r\n - *reverse* is a boolean parameter which on being true results in Ascending  order and in false it returns descending order."},{"score":7,"body_markdown":"Using Ramda,\r\n\r\n**npm install ramda**\r\n\r\n    import R from &#39;ramda&#39;\r\n    var objs = [ \r\n        { first_nom: &#39;Lazslo&#39;, last_nom: &#39;Jamf&#39;     },\r\n        { first_nom: &#39;Pig&#39;,    last_nom: &#39;Bodine&#39;   },\r\n        { first_nom: &#39;Pirate&#39;, last_nom: &#39;Prentice&#39; }\r\n    ];\r\n    var ascendingSortedObjs = R.sortBy(R.prop(&#39;last_nom&#39;), objs)\r\n    var descendingSortedObjs = R.reverse(ascendingSortedObjs)\r\n\r\n"},{"score":1,"body_markdown":"I will give you a solution implementing selectionSort algorithm ,it is simple and effective\r\n\r\n    var objs = [ \r\n    { first_nom: &#39;Lazslo&#39;, last_nom: &#39;Jamf&#39;     },\r\n    { first_nom: &#39;Pig&#39;,    last_nom: &#39;Bodine&#39;   },\r\n    { first_nom: &#39;Pirate&#39;, last_nom: &#39;Prentice&#39; }\r\n    ];\r\n\r\n\r\n    function selection_Sort(num) { \r\n     //console.log(num);  \r\n     var temp, index;\r\n     for (var i = 0; i &lt;= num.length - 1; i++) {\r\n    index = i;\r\n    for (var j = i + 1; j &lt;= num.length - 1; j++) {\r\n     // you can use first_nom/last_nom,any way you choose to sort\r\n\r\n      if (num[j]. last_nom &lt; num[index]. last_nom) {\r\n        index = j;\r\n      } \r\n    }\r\n\r\n    //below is the swapping part\r\n    temp = num[i]. last_nom;\r\n    num[i]. last_nom = num[index]. last_nom;\r\n    num[index]. last_nom = temp;\r\n     };\r\n     console.log(num); \r\n     return num; \r\n      }\r\n      selection_Sort(objs);\r\n\r\nGreat to see such great answers"},{"score":37,"body_markdown":"[Lodash.js][1] (superset of [Underscore.js][2])\r\n\r\nIt&#39;s good not to add a framework for every simple piece of logic, but relying on well tested utility frameworks can speed up development and reduce the amount of bugs.\r\n\r\nLodash produces very clean code and promotes a more *functional programming* style. In one glimpse it becomes clear what the intent of the code is.\r\n\r\nOP&#39;s issue can simply be solved as:\r\n\r\n    const sortedObjs = _.sortBy(objs, &#39;last_nom&#39;);\r\n\r\nMore info? E.g. we have following nested object:\r\n\r\n    const&#160;users&#160;=&#160;[\r\n    &#160;&#160;{&#160;&#39;user&#39;:&#160;{&#39;name&#39;:&#39;fred&#39;, &#39;age&#39;:&#160;48}},\r\n    &#160;&#160;{&#160;&#39;user&#39;:&#160;{&#39;name&#39;:&#39;barney&#39;,&#160;&#39;age&#39;:&#160;36&#160;}},\r\n    &#160;&#160;{&#160;&#39;user&#39;:&#160;{&#39;name&#39;:&#39;wilma&#39;}},\r\n    &#160;&#160;{&#160;&#39;user&#39;:&#160;{&#39;name&#39;:&#39;betty&#39;, &#39;age&#39;:&#160;32}}\r\n    ];\r\n\r\nWe now can use the [_.property][3] shorthand `user.age` to specify the path to the property that should be matched. We will sort the user objects by the nested age property. Yes, it allows for nested property matching!\r\n\r\n    const sortedObjs = _.sortBy(users,&#160;[&#39;user.age&#39;]);\r\n\r\nWant it reversed? No problem. Use [_.reverse][4].\r\n\r\n    const sortedObjs = _.reverse(_.sortBy(users,&#160;[&#39;user.age&#39;]));\r\n\r\nWant to combine both using [chain][5]?\r\n\r\n    const { chain } = require(&#39;lodash&#39;);\r\n    const sortedObjs = chain(users).sortBy(&#39;user.age&#39;).reverse().value();\r\n\r\nOr when do you prefer [flow][6] over chain\r\n\r\n    const { flow, reverse, sortBy } = require(&#39;lodash/fp&#39;);\r\n    const sortedObjs = flow([sortBy(&#39;user.age&#39;), reverse])(users); \r\n\r\n  [1]: https://lodash.com\r\n  [2]: http://underscorejs.org\r\n  [3]: https://lodash.com/docs/4.17.15#property\r\n  [4]: https://lodash.com/docs/4.17.15#reverse\r\n  [5]: https://lodash.com/docs/4.17.15#chain\r\n  [6]: https://lodash.com/docs/4.17.15#flow"},{"score":41,"body_markdown":"Old answer that is not correct:\r\n\r\n    arr.sort((a, b) =&gt; a.name &gt; b.name)\r\n\r\n**UPDATE**\r\n\r\nFrom Beauchamp&#39;s comment:\r\n\r\n    arr.sort((a, b) =&gt; a.name &lt; b.name ? -1 : (a.name &gt; b.name ? 1 : 0))\r\n\r\nMore readable format:\r\n\r\n    arr.sort((a, b) =&gt; {\r\n      if (a.name &lt; b.name) return -1\r\n      return a.name &gt; b.name ? 1 : 0\r\n    })\r\n\r\nWithout nested ternaries:\r\n\r\n    arr.sort((a, b) =&gt; a.name &lt; b.name ? - 1 : Number(a.name &gt; b.name))\r\n\r\nExplanation: `Number()` will cast `true` to `1` and `false` to `0`."},{"score":8,"body_markdown":"Given the original example:\r\n\r\n    var objs = [ \r\n        { first_nom: &#39;Lazslo&#39;, last_nom: &#39;Jamf&#39;     },\r\n        { first_nom: &#39;Pig&#39;,    last_nom: &#39;Bodine&#39;   },\r\n        { first_nom: &#39;Pirate&#39;, last_nom: &#39;Prentice&#39; }\r\n    ];\r\n\r\nSort by multiple fields:\r\n\r\n    objs.sort(function(left, right) {\r\n        var last_nom_order = left.last_nom.localeCompare(right.last_nom);\r\n        var first_nom_order = left.first_nom.localeCompare(right.first_nom);\r\n        return last_nom_order || first_nom_order;\r\n    });\r\n\r\nNotes\r\n\r\n* `a.localeCompare(b)` is [universally supported](https://caniuse.com/#feat=localecompare) and returns -1,0,1 if `a&lt;b`,`a==b`,`a&gt;b` respectively.\r\n* `||` in the last line gives `last_nom` priority over `first_nom`.\r\n* Subtraction works on numeric fields: `var age_order = left.age - right.age;`\r\n* Negate to reverse order, `return -last_nom_order || -first_nom_order || -age_order;`"},{"score":3,"body_markdown":"Using lodash or Underscore, its a piece of cake \r\n\r\n    \r\n\r\n    &gt; const sortedList = _.orderBy(objs, [last_nom], [asc]); // asc or desc\r\n    "},{"score":11,"body_markdown":"A simple function that sort an array of object by a property\r\n\r\n    function sortArray(array, property, direction) {\r\n        direction = direction || 1;\r\n        array.sort(function compare(a, b) {\r\n            let comparison = 0;\r\n            if (a[property] &gt; b[property]) {\r\n                comparison = 1 * direction;\r\n            } else if (a[property] &lt; b[property]) {\r\n                comparison = -1 * direction;\r\n            }\r\n            return comparison;\r\n        });\r\n        return array; // Chainable\r\n    }\r\n\r\nUsage:\r\n\r\n    var objs = [ \r\n        { first_nom: &#39;Lazslo&#39;, last_nom: &#39;Jamf&#39;     },\r\n        { first_nom: &#39;Pig&#39;,    last_nom: &#39;Bodine&#39;   },\r\n        { first_nom: &#39;Pirate&#39;, last_nom: &#39;Prentice&#39; }\r\n    ];\r\n\r\n    sortArray(objs, &quot;last_nom&quot;); // Asc\r\n    sortArray(objs, &quot;last_nom&quot;, -1); // Desc\r\n\r\n"},{"score":6,"body_markdown":"Way 1 :  \r\n\r\nYou can use `Underscore.js`. Import underscore first.    \r\n\r\n     import * as _ from &#39;underscore&#39;;\r\n     let SortedObjs = _.sortBy(objs, &#39;last_nom&#39;);\r\n\r\nWay 2 :  Use compare function.    \r\n\r\n    function compare(first, second) {\r\n         if (first.last_nom &lt; second.last_nom)\r\n             return -1;\r\n         if (first.last_nom &gt; second.last_nom)\r\n           return 1;\r\n        return 0;\r\n     }\r\n\r\n    objs.sort(compare);\r\n\r\n\r\n\r\n"},{"score":43,"body_markdown":"As of 2018 there is a much shorter and elegant solution. Just use. [Array.prototype.sort()][1].\r\n\r\nExample:\r\n\r\n    var items = [\r\n      { name: &#39;Edward&#39;, value: 21 },\r\n      { name: &#39;Sharpe&#39;, value: 37 },\r\n      { name: &#39;And&#39;, value: 45 },\r\n      { name: &#39;The&#39;, value: -12 },\r\n      { name: &#39;Magnetic&#39;, value: 13 },\r\n      { name: &#39;Zeros&#39;, value: 37 }\r\n    ];\r\n    \r\n    // sort by value\r\n    items.sort(function (a, b) {\r\n      return a.value - b.value;\r\n    });\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\r\n"},{"score":4,"body_markdown":"&gt; It works for me. Here It will keep **undefined** to the end.\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n     function sort(items, property, direction) {\r\n\r\n        function compare(a, b) {\r\n          if(!a[property] &amp;&amp; !b[property]) {\r\n            return 0;\r\n          } else if(a[property] &amp;&amp; !b[property]) {\r\n            return -1;\r\n          } else if(!a[property] &amp;&amp; b[property]) {\r\n            return 1;\r\n          } else {\r\n            const value1 = a[property].toString().toUpperCase(); // ignore upper and lowercase\r\n            const value2 = b[property].toString().toUpperCase(); // ignore upper and lowercase\r\n            if (value1 &lt; value2) {\r\n              return direction === 0 ? -1 : 1;\r\n            } else if (value1 &gt; value2) {\r\n              return direction === 0 ? 1 : -1;\r\n            } else {\r\n              return 0;\r\n            }\r\n            \r\n          }\r\n        }\r\n        \r\n        return items.sort(compare);\r\n       } \r\n       \r\n       var items = [\r\n      { name: &#39;Edward&#39;, value: 21 },\r\n      { name: &#39;Sharpe&#39;, value: 37 },\r\n      { name: &#39;And&#39;, value: 45 },\r\n      { name: &#39;The&#39;, value: -12 },\r\n      { name: undefined, value: -12 },\r\n      { name: &#39;Magnetic&#39;, value: 13 },\r\n      { name: &#39;Zeros&#39;, value: 37 }\r\n    ];\r\n       console.log(&#39;Ascending Order:- &#39;);\r\n       console.log(sort(items, &#39;name&#39;, 0));\r\n       console.log(&#39;Decending Order:- &#39;);\r\n       console.log(sort(items, &#39;name&#39;, 1));\r\n        \r\n        \r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":32,"body_markdown":"I haven&#39;t seen this particular approach suggested, so here&#39;s a terse comparison method I like to use that works for both `string` and `number` types:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const objs = [ \r\n      { first_nom: &#39;Lazslo&#39;, last_nom: &#39;Jamf&#39;     },\r\n      { first_nom: &#39;Pig&#39;,    last_nom: &#39;Bodine&#39;   },\r\n      { first_nom: &#39;Pirate&#39;, last_nom: &#39;Prentice&#39; }\r\n    ];\r\n\r\n    const sortBy = fn =&gt; {\r\n      const cmp = (a, b) =&gt; -(a &lt; b) || +(a &gt; b);\r\n      return (a, b) =&gt; cmp(fn(a), fn(b));\r\n    };\r\n\r\n    const getLastName = o =&gt; o.last_nom;\r\n    const sortByLastName = sortBy(getLastName);\r\n\r\n    objs.sort(sortByLastName);\r\n    console.log(objs.map(getLastName));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n### Explanation of `sortBy()`\r\n\r\n`sortBy()` accepts a `fn` that selects a value from an object to use in comparison, and returns a function that can be passed to [`Array.prototype.sort()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort). In this example, we&#39;re comparing `o.last_nom`. Whenever we receive two objects such as\r\n\r\n    a = { first_nom: &#39;Lazslo&#39;, last_nom: &#39;Jamf&#39; }\r\n    b = { first_nom: &#39;Pig&#39;, last_nom: &#39;Bodine&#39; }\r\n\r\nwe compare them with `(a, b) =&gt; cmp(fn(a), fn(b))`. Given that\r\n\r\n    fn = o =&gt; o.last_nom\r\n\r\nwe can expand the comparison function to `(a, b) =&gt; cmp(a.last_nom, b.last_nom)`. Because of the way [logical OR (`||`)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR) works in JavaScript, `cmp(a.last_nom, b.last_nom)` is equivalent to\r\n\r\n    if (a.last_nom &lt; b.last_nom) return -1;\r\n    if (a.last_nom &gt; b.last_nom) return 1;\r\n    return 0;\r\n\r\nIncidentally, this is called the [three-way comparison &quot;spaceship&quot; (`&lt;=&gt;`) operator](https://stackoverflow.com/a/30365399/1541563) in other languages.\r\n\r\nFinally, here&#39;s the ES5-compatible syntax without using arrow functions:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var objs = [ \r\n      { first_nom: &#39;Lazslo&#39;, last_nom: &#39;Jamf&#39;     },\r\n      { first_nom: &#39;Pig&#39;,    last_nom: &#39;Bodine&#39;   },\r\n      { first_nom: &#39;Pirate&#39;, last_nom: &#39;Prentice&#39; }\r\n    ];\r\n\r\n    function sortBy(fn) {\r\n      function cmp(a, b) { return -(a &lt; b) || +(a &gt; b); }\r\n      return function (a, b) { return cmp(fn(a), fn(b)); };\r\n    }\r\n\r\n    function getLastName(o) { return o.last_nom; }\r\n    var sortByLastName = sortBy(getLastName);\r\n\r\n    objs.sort(sortByLastName);\r\n    console.log(objs.map(getLastName));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":30,"body_markdown":"You can use\r\nEasiest Way: *Lodash* \r\n---\r\n(https://lodash.com/docs/4.17.10#orderBy)\r\n\r\nThis method is like _.sortBy except that it allows specifying the sort orders of the iteratees to sort by. If orders is unspecified, all values are sorted in ascending order. Otherwise, specify an order of &quot;desc&quot; for descending or &quot;asc&quot; for ascending sort order of corresponding values.\r\n\r\n\r\n**Arguments**\r\n\r\ncollection (Array|Object): The collection to iterate over.\r\n[iteratees=[_.identity]] (Array[]|Function[]|Object[]|string[]): The iteratees to sort by.\r\n[orders] (string[]): The sort orders of iteratees.\r\n\r\n**Returns**\r\n\r\n(Array): Returns the new sorted array.\r\n\r\n-------------------\r\n\r\n    var _ = require(&#39;lodash&#39;);\r\n    var homes = [\r\n        {&quot;h_id&quot;:&quot;3&quot;,\r\n         &quot;city&quot;:&quot;Dallas&quot;,\r\n         &quot;state&quot;:&quot;TX&quot;,\r\n         &quot;zip&quot;:&quot;75201&quot;,\r\n         &quot;price&quot;:&quot;162500&quot;},\r\n        {&quot;h_id&quot;:&quot;4&quot;,\r\n         &quot;city&quot;:&quot;Bevery Hills&quot;,\r\n         &quot;state&quot;:&quot;CA&quot;,\r\n         &quot;zip&quot;:&quot;90210&quot;,\r\n         &quot;price&quot;:&quot;319250&quot;},\r\n        {&quot;h_id&quot;:&quot;6&quot;,\r\n         &quot;city&quot;:&quot;Dallas&quot;,\r\n         &quot;state&quot;:&quot;TX&quot;,\r\n         &quot;zip&quot;:&quot;75000&quot;,\r\n         &quot;price&quot;:&quot;556699&quot;},\r\n        {&quot;h_id&quot;:&quot;5&quot;,\r\n         &quot;city&quot;:&quot;New York&quot;,\r\n         &quot;state&quot;:&quot;NY&quot;,\r\n         &quot;zip&quot;:&quot;00010&quot;,\r\n         &quot;price&quot;:&quot;962500&quot;}\r\n        ];\r\n        \r\n    _.orderBy(homes, [&#39;city&#39;, &#39;state&#39;, &#39;zip&#39;], [&#39;asc&#39;, &#39;desc&#39;, &#39;asc&#39;]);"},{"score":1,"body_markdown":"In case you have nested objects\r\n\r\n    const objs = [{\r\n            first_nom: &#39;Lazslo&#39;,\r\n            last_nom: &#39;Jamf&#39;,\r\n            moreDetails: {\r\n                age: 20\r\n            }\r\n        }, {\r\n            first_nom: &#39;Pig&#39;,\r\n            last_nom: &#39;Bodine&#39;,\r\n            moreDetails: {\r\n                age: 21\r\n            }\r\n        }, {\r\n            first_nom: &#39;Pirate&#39;,\r\n            last_nom: &#39;Prentice&#39;,\r\n            moreDetails: {\r\n                age: 22\r\n            }\r\n        }];\r\n\r\n    nestedSort = (prop1, prop2 = null, direction = &#39;asc&#39;) =&gt; (e1, e2) =&gt; {\r\n            const a = prop2 ? e1[prop1][prop2] : e1[prop1],\r\n                b = prop2 ? e2[prop1][prop2] : e2[prop1],\r\n                sortOrder = direction === &quot;asc&quot; ? 1 : -1\r\n            return (a &lt; b) ? -sortOrder : (a &gt; b) ? sortOrder : 0;\r\n        }\r\n\r\nand call it like\r\n\r\n    objs.sort(nestedSort(&quot;last_nom&quot;));\r\n    objs.sort(nestedSort(&quot;last_nom&quot;, null, &quot;desc&quot;));\r\n    objs.sort(nestedSort(&quot;moreDetails&quot;, &quot;age&quot;));\r\n    objs.sort(nestedSort(&quot;moreDetails&quot;, &quot;age&quot;, &quot;desc&quot;));"},{"score":3,"body_markdown":"It is also possible to make a dynamic sorting function when programming in *TypeScript*, but the types become more tricky in this case.\r\n\r\n&lt;!-- language typescript --&gt;\r\n\r\n    function sortByKey&lt;O&gt;(key: keyof O, decending: boolean = false): (a: O, b: O) =&gt; number {\r\n    \tconst order = decending ? -1 : 1;\r\n    \treturn (a, b): number =&gt; {\r\n    \t\tconst valA = a[key];\r\n    \t\tconst valB = b[key];\r\n    \t\tif (valA &lt; valB) {\r\n    \t\t\treturn -order;\r\n    \t\t} else if (valA &gt; valB) {\r\n    \t\t\treturn order;\r\n    \t\t} else {\r\n    \t\t\treturn 0;\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\nThis can be used in TypeScript as the following:\r\n\r\n&lt;!-- language typescript --&gt;\r\n\r\n    const test = [\r\n    \t{\r\n    \t\tid: 0,\r\n    \t},\r\n    \t{\r\n    \t\tid: 2,\r\n    \t}\r\n    ]\r\n    \r\n    test.sort(sortByKey(&#39;id&#39;)) // OK\r\n    test.sort(sortByKey(&#39;id1&#39;)) // ERROR\r\n    test.sort(sortByKey(&#39;&#39;)) // ERROR"},{"score":3,"body_markdown":"**this sorting funciton can be use for all object sorting,** \r\n \r\n\r\n - object\r\n\r\n \r\n\r\n - deepObject\r\n - numeric array\r\n\r\nyou can also do assending or desending sort by passing 1,-1 as param\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    Object.defineProperty(Object.prototype, &#39;deepVal&#39;, {\r\n        enumerable: false,\r\n        writable: true,\r\n        value: function (propertyChain) {\r\n            var levels = propertyChain.split(&#39;.&#39;);\r\n            parent = this;\r\n            for (var i = 0; i &lt; levels.length; i++) {\r\n                if (!parent[levels[i]])\r\n                    return undefined;\r\n                parent = parent[levels[i]];\r\n            }\r\n            return parent;\r\n        }\r\n    });\r\n\r\n\r\n    function dynamicSortAll(property,sortOrders=1) {\r\n\r\n/**default sorting will be ascending order if you need descending order\r\nsording you have to pass -1 as param**/\r\n\r\n        var sortOrder = sortOrders;\r\n       \r\n        return function (a,b) {\r\n\r\n    \t\t var result =(property? ((a.deepVal(property) &gt; b.deepVal(property)) ? 1 : (a.deepVal(property) &lt; b.deepVal(property)) ? -1 : 0) :((a &gt; b) ? 1 : (a &lt; b) ? -1 : 0))\r\n    \t\t\r\n            return result * sortOrder;\r\n    \t\t\r\n       \r\n        }\r\n    }\r\n\r\n    deepObj = [\r\n        {\r\n            a: { a: 1, b: 2, c: 3 },\r\n            b: { a: 4, b: 5, c: 6 }\r\n        },\r\n        { \r\n            a: { a: 3, b: 2, c: 1 },\r\n            b: { a: 6, b: 5, c: 4 }\r\n    }];\r\n\r\n    let deepobjResult=deepObj.sort(dynamicSortAll(&#39;a.a&#39;,1))\r\n    console.log(&#39;deepobjResult :&#39;+ JSON.stringify(deepobjResult))\r\n    var obj = [ \r\n        { first_nom: &#39;Lazslo&#39;, last_nom: &#39;Jamf&#39;     },\r\n        { first_nom: &#39;Pig&#39;,    last_nom: &#39;Bodine&#39;   },\r\n        { first_nom: &#39;Pirate&#39;, last_nom: &#39;Prentice&#39; }\r\n    ];\r\n    let objResult=obj.sort(dynamicSortAll(&#39;last_nom&#39;,1))\r\n    console.log(&#39;objResult :&#39;+ JSON.stringify(objResult))\r\n\r\n    var numericObj=[1,2,3,4,5,6]\r\n\r\n    let numResult=numericObj.sort(dynamicSortAll(null,-1))\r\n    console.log(&#39;numResult :&#39;+ JSON.stringify(numResult))\r\n\r\nlet stringSortResult=&#39;helloworld&#39;.split(&#39;&#39;).sort(dynamicSortAll(null,1))\r\n\r\n console.log(&#39;stringSortResult:&#39;+ JSON.stringify(stringSortResult))\r\n\r\nlet uniqueStringOrger=[...new Set(stringSortResult)]; \r\n console.log(&#39;uniqueStringOrger:&#39;+ JSON.stringify(uniqueStringOrger))\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n   "},{"score":2,"body_markdown":"Hers a function you can use to sort the list by multiple objects, where if the first object is equal, the second order will be used as a fallback. empty values should also be ignored to fallback order if possible.\r\n\r\n    function sortObjects(list, orderBy){\r\n    \tlist.sort(function(a, b){\r\n    \t\tlet byIndex = 0;\r\n    \t\tlet order = orderBy[byIndex];\r\n    \t\twhile(!a[order.by] || !b[order.by] || a[order.by] === b[order.by]){\r\n\t\t\t    byIndex++;\r\n\t\t\t    if(byIndex &gt;= orderBy.length){break;}\r\n\t\t\t    order = orderBy[byIndex];\r\n\t\t    }\r\n            if(!a[order.by] || !b[order.by] || a[order.by] === b[order.by]){\r\n\t\t\t    return false;\r\n\t\t    }\r\n    \t\tif(order.desc){\r\n    \t\t\treturn a[order.by] &lt; b[order.by];\r\n    \t\t}\r\n    \t\treturn a[order.by] &gt; b[order.by];\r\n    \t});\r\n    \treturn list;\r\n    }\r\n\r\nusage:\r\n\r\n    var objs = [\r\n\t    {a: 10, b: 20, c: 30},\r\n\t    {a: 30, b: 10, c: 20},\r\n\t    {a: 20, b: 10, c: 30},\r\n    ];\r\n    \r\n    sortObjectList(objs, [{by: &#39;a&#39;}]);\r\n    [\r\n        {a: 10, b: 20, c: 30},\r\n        {a: 20, b: 10, c: 30},\r\n        {a: 30, b: 10, c: 20},\r\n    ]\r\n    \r\n    sortObjectList(objs, [{by: &#39;a&#39;, desc: true}]);\r\n    [\r\n        {a: 30, b: 10, c: 20},\r\n        {a: 20, b: 10, c: 30},\r\n        {a: 10, b: 20, c: 30},\r\n    ]\r\n    \r\n    sortObjectList(objs, [{by: &#39;b&#39;, desc: true}, {by: &#39;c&#39;}]);\r\n    [\r\n        {a: 10, b: 20, c: 30},\r\n        {a: 30, b: 10, c: 20},\r\n        {a: 20, b: 10, c: 30},\r\n    ]\r\n\r\nanother example:\r\n\r\n    var objs = [\r\n    \t{a: 5, b: 5},\r\n    \t{a: 10, b: 15},\r\n    \t{a: 15, b: 25},\r\n    \t{b: 10},\r\n    \t{b: 20},\r\n    \t{a: 10, b: 30},\r\n        {a: 10, b: 12},\r\n    ];\r\n    \r\n    sortObjectList(objs, [{by: &#39;a&#39;}, {by: &#39;b&#39;}]);\r\n    [\r\n        {a: 5, b: 5},\r\n        {b: 10},\r\n        {a: 10, b: 12},\r\n        {a: 10, b: 15},\r\n        {b: 20},\r\n        {a: 10, b: 30},\r\n        {a: 15, b: 25},\r\n    ]\r\n\r\n"},{"score":9,"body_markdown":"This is my take on this:\r\n\r\nThe `order` parameter is optional and defaults to &quot;ASC&quot; for ascending order.\r\n\r\nWorks on **accented chars and it&#39;s case insensitive**.\r\n\r\n**NOTE:** It sorts and returns the **ORIGINAL** array.\r\n\r\n```\r\nfunction sanitizeToSort(str) {\r\n  return str\r\n    .normalize(&#39;NFD&#39;)                   // REMOVE ACCENTED AND DIACRITICS\r\n    .replace(/[\\u0300-\\u036f]/g,&#39;&#39;)     // REMOVE ACCENTED AND DIACRITICS\r\n    .toLowerCase()                      // SORT WILL BE CASE INSENSITIVE\r\n  ;\r\n}\r\n\r\nfunction sortByProperty(arr, property, order=&quot;ASC&quot;) {\r\n  arr.forEach((item) =&gt; item.tempProp = sanitizeToSort(item[property]));\r\n  arr.sort((a,b) =&gt; order === &quot;ASC&quot; ?\r\n      a.tempProp &gt; b.tempProp ?  1 : a.tempProp &lt; b.tempProp ? -1 : 0\r\n    : a.tempProp &gt; b.tempProp ? -1 : a.tempProp &lt; b.tempProp ?  1 : 0\r\n  );\r\n  arr.forEach((item) =&gt; delete item.tempProp);\r\n  return arr;\r\n}\r\n```\r\n\r\n**SNIPPET**\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function sanitizeToSort(str) {\r\n      return str\r\n        .normalize(&#39;NFD&#39;)                   // REMOVE ACCENTED CHARS\r\n        .replace(/[\\u0300-\\u036f]/g,&#39;&#39;)     // REMOVE DIACRITICS\r\n        .toLowerCase()\r\n      ;\r\n    }\r\n\r\n    function sortByProperty(arr, property, order=&quot;ASC&quot;) {\r\n      arr.forEach((item) =&gt; item.tempProp = sanitizeToSort(item[property]));\r\n      arr.sort((a,b) =&gt; order === &quot;ASC&quot; ?\r\n          a.tempProp &gt; b.tempProp ?  1 : a.tempProp &lt; b.tempProp ? -1 : 0\r\n        : a.tempProp &gt; b.tempProp ? -1 : a.tempProp &lt; b.tempProp ?  1 : 0\r\n      );\r\n      arr.forEach((item) =&gt; delete item.tempProp);\r\n      return arr;\r\n    }\r\n\r\n    const rockStars = [\r\n      { name: &quot;Axl&quot;,\r\n        lastname: &quot;Rose&quot; },\r\n      { name: &quot;Elthon&quot;,\r\n        lastname: &quot;John&quot; },\r\n      { name: &quot;Paul&quot;,\r\n        lastname: &quot;McCartney&quot; },\r\n      { name: &quot;Lou&quot;,\r\n        lastname: &quot;Reed&quot; },\r\n      { name: &quot;freddie&quot;,             // WORKS ON LOWER/UPPER CASE\r\n        lastname: &quot;mercury&quot; },\r\n      { name: &quot;&#193;my&quot;,                 // WORKS ON ACCENTED CHARS TOO\r\n        lastname: &quot;winehouse&quot;}\r\n      \r\n    ];\r\n\r\n    sortByProperty(rockStars,&quot;name&quot;);\r\n\r\n    console.log(&quot;Ordered by name A-Z:&quot;);\r\n    rockStars.forEach((item) =&gt; console.log(item.name + &quot; &quot; + item.lastname));\r\n\r\n    sortByProperty(rockStars,&quot;lastname&quot;,&quot;DESC&quot;);\r\n\r\n    console.log(&quot;\\nOrdered by lastname Z-A:&quot;);\r\n    rockStars.forEach((item) =&gt; console.log(item.lastname + &quot;, &quot; + item.name));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":19,"body_markdown":"Try this,\r\n\r\n    UPTO ES5\r\n\r\n    //Ascending Sort\r\n    items.sort(function (a, b) {\r\n       return a.value - b.value;\r\n    });\r\n\r\n\r\n    //Descending Sort\r\n    items.sort(function (a, b) {\r\n       return b.value - a.value;\r\n    });\r\n\r\n\r\n    IN ES6 &amp; above:\r\n\r\n    // Ascending sort\r\n    items.sort((a, b) =&gt; a.value - b.value);\r\n\r\n    // Descending Sort\r\n     items.sort((a, b) =&gt; b.value - a.value);\r\n\r\n\r\n\r\n\r\n"},{"score":6,"body_markdown":"You can use a reusable sort function. \r\n\r\n```js\r\nArray.prototype.order= function(prop, methods = {}) {\r\n  let swipe = 1;\r\n  if (prop?.constructor == Object) methods = prop;\r\n  swipe = methods.reverse ? -1 : 1;\r\n  function key(x) {\r\n    if (typeof prop == &quot;string&quot;)\r\n      return methods.insensitive ? String(x[prop]).toLowerCase() : x[prop];\r\n    if (methods.insensitive) return String(x).toLowerCase();\r\n    return x;\r\n  }\r\n  this.sort((a, b) =&gt; {\r\n    if (key(a) &lt; key(b)) return -1 * swipe;\r\n    if (key(b) &lt; key(a)) return 1 * swipe;\r\n    return 0;\r\n  });\r\n  return this;\r\n};\r\n```\r\nIts can be use to sort both **Array** and **Object** in array&lt;br&gt;.\r\n```js\r\nlet arr = [6, 2, 4, 1, 5, 3];\r\nlet arr2 = [\r\n  { name: &quot;Bar&quot;, age: 12 },\r\n  { name: &quot;Nur&quot;, age: 18 },\r\n  { name: &quot;foo&quot;, age: 30 },\r\n  { name: &quot;bazz&quot;, age: 15 }\r\n];\r\narr.order({ reverse: true }); //  [ 6, 5, 4, 3, 2, 1 ]\r\narr2.order(&quot;name&quot;, { reverse: 1, insensitive: 0});\r\nlet arr3 = [...arr2].order(&quot;age&quot;);  // new sorted array created from arr2 (But does not change original array)\r\n``` \r\n*1nd  (optional)* &gt;  to sort object contain  in array. &lt;br&gt;\r\n*2rd is method*   &gt;   ```{ reverse: Boolean, insensitive: Boolean }```&lt;br&gt; "},{"score":1,"body_markdown":"# Deep\n\nBased on [this](https://javascript.info/string#comparing-strings) excellent tutorial I would like to develop [Vlad Bezden answer](https://stackoverflow.com/a/35092754/860099) and explain why [`localeCompare`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare) is better than standard comarison method like `strA &gt; strB`. Lets run this example\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    console.log( &#39;&#214;sterreich&#39; &gt; &#39;Zealand&#39; );  // We expect false\n    console.log( &#39;a&#39; &gt; &#39;Z&#39; );                 // We expect false\n\n&lt;!-- end snippet --&gt;\n\nThe reason is that in JS all strings are encoded using [UTF-16](https://en.wikipedia.org/wiki/UTF-16) and\n\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    let str = &#39;&#39;;\n\n    // order of characters in JS\n    for (let i = 65; i &lt;= 220; i++) {\n      str += String.fromCodePoint(i); // code to character\n    }\n\n    console.log(str);\n\n&lt;!-- end snippet --&gt;\n\nCapital letters go first (have small codes) and then go small letters and then go character `&#214;` (after `z`). This is reason why we get true in first snippet - becasue operator `&gt;` compare characters codes.\n\nAs you can see compare characters in diffrent languages is non trivial task - but luckily, modern browsers support the internationalization standard [ECMA-402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf). So in JS we have `strA.localeCompare(strB)` which do the job (`-1` means `strA` is less than `strB`; 1 means opposite; 0 means equal)\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    console.log( &#39;&#214;sterreich&#39;.localeCompare(&#39;Zealand&#39;) ); // We expect -1\n    console.log( &#39;a&#39;.localeCompare(&#39;Z&#39;) );                // We expect -1\n\n&lt;!-- end snippet --&gt;\n\nI would like to add that `localeCompare` supports two parameters: language and additional [rules ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator/Collator)\n\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    var objs = [ \n        { first_nom: &#39;Lazslo&#39;, last_nom: &#39;Jamf&#39;     },\n        { first_nom: &#39;Pig&#39;,    last_nom: &#39;Bodine&#39;   },\n        { first_nom: &#39;Pirate&#39;, last_nom: &#39;Prentice&#39; },\n        { first_nom: &#39;Test&#39;,   last_nom: &#39;jamf&#39;     } \n    ];\n\n    objs.sort((a,b)=&gt; a.last_nom.localeCompare(b.last_nom,&#39;en&#39;,{sensitivity:&#39;case&#39;}))\n\n    console.log(objs);\n\n    // in &#39;&gt;&#39; comparison &#39;Jamf&#39; will NOT be next to &#39;jamf&#39;\n\n&lt;!-- end snippet --&gt;\n\n"},{"score":1,"body_markdown":"**Simple answer:**\r\n\r\n```javascript\r\nobjs.sort((a,b)=&gt;a.last_nom.localeCompare(b.last_nom))\r\n```\r\n\r\n**Details:**\r\n\r\nToday it is very simple, You can compare strings with `localeCompare`. As the Mozilla Doc says:\r\n\r\n&gt; The `localeCompare()` method returns a number indicating whether a\r\n&gt; reference string comes `before`, or `after`, or `is the same as the\r\n&gt; given string in sort order`.\r\n\r\n```javascript\r\n    //example1:\r\n    console.log(&quot;aaa&quot;.localeCompare(&quot;aab&quot;)); //-1\r\n    console.log(&quot;aaa&quot;.localeCompare(&quot;aaa&quot;)); //0\r\n    console.log(&quot;aab&quot;.localeCompare(&quot;aaa&quot;)); //1\r\n```\r\n\r\n```javascript\r\n\r\n    //example2:\r\n    const a = &#39;r&#233;serv&#233;&#39;; // with accents, lowercase\r\n    const b = &#39;RESERVE&#39;; // no accents, uppercase\r\n\r\n    console.log(a.localeCompare(b));\r\n    // expected output: 1\r\n    console.log(a.localeCompare(b, &#39;en&#39;, { sensitivity: &#39;base&#39; }));\r\n    // expected output: 0\r\n```\r\n\r\nFor more details see Mozilla doc[`localeCompare`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare):"}],"score":2981}