{"body":"I&#39;m using [JSLint][1] to go through JavaScript, and it&#39;s returning many suggestions to replace `==` (two equals signs) with `===` (three equals signs) when doing things like comparing `idSele_UNVEHtype.value.length == 0` inside of an `if` statement.\r\n\r\nIs there a performance benefit to replacing `==` with `===`? \r\n\r\nAny performance improvement would be welcomed as many comparison operators exist.\r\n\r\nIf no type conversion takes place, would there be a performance gain over `==`?\r\n\r\n  [1]: http://en.wikipedia.org/wiki/JSLint\r\n","title":"Which equals operator (== vs ===) should be used in JavaScript comparisons?","answers":[{"score":6670,"body_markdown":"The strict equality operator (`===`) behaves identically to the abstract equality operator (`==`) except no type conversion is done, and the types must be the same to be considered equal.\r\n\r\nReference: [Javascript Tutorial: Comparison Operators][1]\r\n\r\nThe `==` operator will compare for equality _after doing any necessary type conversions_.  The `===` operator will **not** do the conversion, so if two values are not the same type `===` will simply return `false`. Both are equally quick.\r\n\r\nTo quote Douglas Crockford&#39;s excellent [JavaScript: The Good Parts][2],\r\n\r\n&gt; JavaScript has two sets of equality operators: `===` and `!==`, and their evil twins `==` and `!=`.  The good ones work the way you would expect.  If the two operands are of the same type and have the same value, then `===` produces `true` and `!==` produces `false`.  The evil twins do the right thing when the operands are of the same type, but if they are of different types, they attempt to coerce the values.  the rules by which they do that are complicated and unmemorable.  These are some of the interesting cases:\r\n\r\n&gt;     &#39;&#39; == &#39;0&#39;           // false\r\n&gt;     0 == &#39;&#39;             // true\r\n&gt;     0 == &#39;0&#39;            // true\r\n    \r\n&gt;     false == &#39;false&#39;    // false\r\n&gt;     false == &#39;0&#39;        // true\r\n    \r\n&gt;     false == undefined  // false\r\n&gt;     false == null       // false\r\n&gt;     null == undefined   // true\r\n    \r\n&gt;     &#39; \\t\\r\\n &#39; == 0     // true\r\n\r\n[![Equality Comparison Table ][3]][3]\r\n&gt; The lack of transitivity is alarming.  My advice is to never use the evil twins.  Instead, always use `===` and `!==`.  All of the comparisons just shown produce `false` with the `===` operator.\r\n\r\n---\r\n\r\n###Update:\r\n\r\nA good point was brought up by [@Casebash][4] in the comments and in [@Phillipe Laybaert&#39;s][5] [answer][6] concerning objects.  For objects, `==` and `===` act consistently with one another (except in a special case).\r\n\r\n    var a = [1,2,3];\r\n    var b = [1,2,3];\r\n\r\n    var c = { x: 1, y: 2 };\r\n    var d = { x: 1, y: 2 };\r\n\r\n    var e = &quot;text&quot;;\r\n    var f = &quot;te&quot; + &quot;xt&quot;;\r\n\r\n    a == b            // false\r\n    a === b           // false\r\n    \r\n    c == d            // false\r\n    c === d           // false\r\n    \r\n    e == f            // true\r\n    e === f           // true\r\n\r\n\r\nThe special case is when you compare a primitive with an object that evaluates to the same primitive, due to its `toString` or `valueOf` method. For example, consider the comparison of a string primitive with a string object created using the `String` constructor.\r\n\r\n    &quot;abc&quot; == new String(&quot;abc&quot;)    // true\r\n    &quot;abc&quot; === new String(&quot;abc&quot;)   // false\r\n\r\nHere the `==` operator is checking the values of the two objects and returning `true`, but the `===` is seeing that they&#39;re not the same type and returning `false`.  Which one is correct?  That really depends on what you&#39;re trying to compare.  My advice is to bypass the question entirely and just don&#39;t use the `String` constructor to create string objects from string literals.\r\n\r\n**Reference**  \r\nhttp://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3\r\n\r\n\r\n  [1]: http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm\r\n  [2]: http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742\r\n  [3]: https://i.stack.imgur.com/yISob.png\r\n  [4]: https://stackoverflow.com/users/165495/casebash\r\n  [5]: https://stackoverflow.com/users/113570/philippe-leybaert\r\n  [6]: https://stackoverflow.com/a/957602/1288"},{"score":1170,"body_markdown":"Using the `==` operator (*Equality*)\r\n\r\n    true == 1; //true, because &#39;true&#39; is converted to 1 and then compared\r\n    &quot;2&quot; == 2;  //true, because &quot;2&quot; is converted to 2 and then compared\r\n\r\nUsing the `===` operator (*Identity*)\r\n\r\n    true === 1; //false\r\n    &quot;2&quot; === 2;  //false\r\n\r\nThis is because the **equality operator `==` does type coercion**, meaning that the interpreter implicitly tries to convert the values before comparing.\r\n\r\nOn the other hand, the **identity operator `===` does not do type coercion**, and thus does not convert the values when comparing, and is therefore faster (as according to [This JS benchmark][1] test) as it skips one step.\r\n\r\n\r\n  [1]: http://jsben.ch/JUOm2"},{"score":40,"body_markdown":"There is unlikely to be any performance difference between the two operations in your usage. There is no type-conversion to be done because both parameters are already the same type. Both operations will have a type comparison followed by a value comparison."},{"score":90,"body_markdown":"The **===** operator is called a strict comparison operator, it **does** differ from the **==** operator.\r\n\r\nLets take 2 vars a and b.\r\n\r\nFor **&quot;a == b&quot;** to evaluate to true a and b need to be the **same value**.\r\n\r\nIn the case of **&quot;a === b&quot;** a and b must be the **same value** and also the **same type** for it to evaluate to true.  \r\n\r\nTake the following example\r\n\r\n    var a = 1;\r\n    var b = &quot;1&quot;;\r\n    \r\n    if (a == b) //evaluates to true as a and b are both 1\r\n    {\r\n        alert(&quot;a == b&quot;);\r\n    }\r\n\r\n    if (a === b) //evaluates to false as a is not the same type as b\r\n    {\r\n        alert(&quot;a === b&quot;);\r\n    }\r\n\r\n**In summary**; using the **==** operator might evaluate to true in situations where you do not want it to so using the **===** operator would be safer.  \r\n\r\nIn the 90% usage scenario it won&#39;t matter which one you use, but it is handy to know the difference when you get some unexpected behaviour one day."},{"score":48,"body_markdown":"In a typical script there will be no performance difference. More important may be the fact that thousand &quot;===&quot; is 1&amp;nbsp;KB heavier than thousand &quot;==&quot; :) [JavaScript profilers](https://stackoverflow.com/questions/tagged/javascript+performance) can tell you if there is a performance difference in your case.\r\n\r\nBut personally I would do what JSLint suggests. This recommendation is there not because of performance issues, but because type coercion means `(&#39;\\t\\r\\n&#39; == 0)` is true.\r\n"},{"score":106,"body_markdown":"I tested this in Firefox with [Firebug][1] using code like this:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    console.time(&quot;testEquality&quot;);\r\n    var n = 0;\r\n    while (true) {\r\n      n++;\r\n      if (n == 100000)\r\n        break;\r\n    }\r\n    console.timeEnd(&quot;testEquality&quot;);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nand\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    console.time(&quot;testTypeEquality&quot;);\r\n    var n = 0;\r\n    while (true) {\r\n      n++;\r\n      if (n === 100000)\r\n        break;\r\n    }\r\n    console.timeEnd(&quot;testTypeEquality&quot;);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nMy results (tested five times each and averaged):\r\n\r\n    ==: 115.2\r\n    ===: 114.4\r\n\r\nSo I&#39;d say that the miniscule difference (this is over 100000 iterations, remember) is negligible. Performance ***isn&#39;t*** a reason to do `===`. Type safety (well, as safe as you&#39;re going to get in JavaScript), and code quality is.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Firebug_%28software%29\r\n"},{"score":22,"body_markdown":"The problem is that you might easily get into trouble since JavaScript have a lot of implicit conversions meaning...\r\n\r\n    var x = 0;\r\n    var isTrue = x == null;\r\n    var isFalse = x === null;\r\n\r\nWhich pretty soon becomes a problem. The best sample of why implicit conversion is &quot;evil&quot; can be taken from this code in [MFC][1] / C++ which actually will compile due to an implicit conversion from CString to HANDLE which is a pointer typedef type...\r\n\r\n    CString x;\r\n    delete x;\r\n\r\nWhich obviously during runtime does *very* undefined things...\r\n\r\nGoogle for implicit conversions in C++ and [STL][2] to get some of the arguments against it...\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library\r\n  [2]: http://en.wikipedia.org/wiki/Standard_Template_Library\r\n"},{"score":627,"body_markdown":"In the answers here, I didn&#39;t read anything about what **equal** means. Some will say that `===` means **equal and of the same type**, but that&#39;s not really true. It actually means that **both operands reference the same object**, or in case of **value types, have the same value**.\n\nSo, let&#39;s take the following code:\n\n    var a = [1,2,3];\n    var b = [1,2,3];\n    var c = a;\n    \n    var ab_eq = (a === b); // false (even though a and b are the same type)\n    var ac_eq = (a === c); // true\n\nThe same here:\n\n    var a = { x: 1, y: 2 };\n    var b = { x: 1, y: 2 };\n    var c = a;\n    \n    var ab_eq = (a === b); // false (even though a and b are the same type)\n    var ac_eq = (a === c); // true\n\nOr even:\n\n    var a = { };\n    var b = { };\n    var c = a;\n    \n    var ab_eq = (a === b); // false (even though a and b are the same type)\n    var ac_eq = (a === c); // true\n\nThis behavior is not always obvious. There&#39;s more to the story than being equal and being of the same type.\n\nThe rule is:\n\n***For value types (numbers):***  \n   `a === b` returns true if `a` and `b` have the same value and are of the same type\n \n***For reference types:***  \n   `a === b` returns true if `a` and `b` reference the exact same object\n\n***For strings:***  \n   `a === b` returns true if `a` and `b` are both strings and contain the exact same characters\n\n---\n\n## Strings: the special case... ##\n\nStrings are not value types, but in Javascript they behave like value types, so they will be &quot;equal&quot; when the characters in the string are the same and when they are of the same length (as explained in the third rule)\n\nNow it becomes interesting:\n\n    var a = &quot;12&quot; + &quot;3&quot;;\n    var b = &quot;123&quot;;\n\n    alert(a === b); // returns true, because strings behave like value types\n\nBut how about this?:\n\n    var a = new String(&quot;123&quot;);\n    var b = &quot;123&quot;;\n    \n    alert(a === b); // returns false !! (but they are equal and of the same type)\n\nI thought strings behave like value types? Well, it depends who you ask... In this case a and b are not the same type. `a` is of type `Object`, while `b` is of type `string`. Just remember that creating a string object using the `String` constructor creates something of type `Object` that behaves as a string *most of the time*.\n"},{"score":274,"body_markdown":"Let me add this counsel:\n\n***If in doubt, read the [specification][1]!*** \n\nECMA-262 is the specification for a scripting language of which JavaScript is a dialect. Of course in practice it matters more how the most important browsers behave than an esoteric definition of how something is supposed to be handled. But it is helpful to understand why **new String(&quot;a&quot;) !== &quot;a&quot;**.\n\nPlease let me explain how to read the specification to clarify this question. I see that in this very old topic nobody had an answer for the very strange effect. So, if you can read a specification, this will help you in your profession tremendously. It is an acquired skill. So, let&#39;s continue.\n\nSearching the PDF file for === brings me to page 56 of the specification: **11.9.4. The Strict Equals Operator ( === )**, and after wading through the specificationalese I find:\n\n&gt; **11.9.6 The Strict Equality Comparison Algorithm**&lt;br&gt;\nThe comparison x === y, where x and y are values, produces **true** or **false**. Such a comparison is performed as follows:&lt;br&gt;\n&amp;nbsp;&amp;nbsp;1. If Type(x) is different from Type(y), return **false**.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;2. If Type(x) is Undefined, return **true**.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;3. If Type(x) is Null, return **true**.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;4. If Type(x) is not Number, go to step 11.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;5. If x is **NaN**, return **false**.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;6. If y is **NaN**, return **false**.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;7. If x is the same number value as y, return **true**.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;8. If x is +0 and y is −0, return **true**.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;9. If x is −0 and y is +0, return **true**.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;10. Return **false**.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;11. If Type(x) is String, then return **true** if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return **false**.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;12. If Type(x) is Boolean, return **true** if x and y are both **true** or both **false**; otherwise, return **false**.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;13. Return **true** if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return **false**.\n\nInteresting is step 11. Yes, strings are treated as value types. But this does not explain why **new String(&quot;a&quot;) !== &quot;a&quot;**. Do we have a browser not conforming to ECMA-262?\n\nNot so fast!\n\nLet&#39;s check the types of the operands. Try it out for yourself by wrapping them in **typeof()**. I find that **new String(&quot;a&quot;)** is an object, and step 1 is used: return **false** if the types are different.\n\nIf you wonder why **new String(&quot;a&quot;)** does not return a string, how about some exercise reading a specification? Have fun!\n\n&lt;hr&gt;\n\nAidiakapi wrote this in a comment below:\n\n&gt; From the specification \n&gt;\n&gt; **11.2.2 The new Operator**:\n&gt;\n&gt; If Type(constructor) is not Object, throw a TypeError exception.\n&gt;\n&gt; With other words, if String wouldn&#39;t be of type Object it couldn&#39;t be used with the new operator. \n\n**new** always returns an Object, even for **String** constructors, too. And alas! The value semantics for strings (see step 11) is lost.\n\nAnd this finally means: **new String(&quot;a&quot;) !== &quot;a&quot;**.\n\n  [1]: http://www.ecma-international.org/publications/standards/Ecma-262.htm\n"},{"score":82,"body_markdown":"# `===` checks same sides are equal in *type* as well as *value*.\n\n---\n\n## Example:\n\n    &#39;1&#39; === 1 // will return &quot;false&quot; because `string` is not a `number`\n\n\n## Common example:\n    \n    0 == &#39;&#39;  // will be &quot;true&quot;, but it&#39;s very common to want this check to be &quot;false&quot;\n\n## Another common example:\n\n    null == undefined // returns &quot;true&quot;, but in most cases a distinction is necessary\n\n---\n\nMany times an *untyped* check would be handy because you do not care if the value is either `undefined`, `null`, `0`  or `&quot;&quot;`\n\n"},{"score":98,"body_markdown":"In JavaScript it means of the same value and type.\r\n\r\nFor example,\r\n\r\n    4 == &quot;4&quot; // will return true\r\n    \r\nbut\r\n    \r\n    4 === &quot;4&quot; // will return false \r\n"},{"score":102,"body_markdown":"In PHP and JavaScript, it is a strict equality operator. Which means, it will compare both type and values."},{"score":54,"body_markdown":"It means **equality without type coercion**\r\ntype coercion means JavaScript do not automatically convert any other data types to string data types \r\n\r\n    0==false   // true,although they are different types\r\n\r\n    0===false  // false,as they are different types\r\n\r\n    2==&#39;2&#39;    //true,different types,one is string and another is integer but \r\n                javaScript convert 2 to string by using == operator \r\n  \r\n    2===&#39;2&#39;  //false because by using === operator ,javaScript do not convert \r\n               integer to string \r\n\r\n    2===2   //true because both have same value and same types "},{"score":22,"body_markdown":"From the [core javascript reference][1]\r\n\r\n&gt; `===` Returns `true` if the operands are strictly equal (see above)\r\n&gt; with no type conversion.\r\n\r\n\t\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators"},{"score":33,"body_markdown":"`===` operator  checks the values as well as the types of the variables for equality.\r\n\r\n`==` operator just checks the value of the variables for equality.\r\n"},{"score":32,"body_markdown":"It&#39;s a strict check test.\r\n\r\nIt&#39;s a good thing especially if you&#39;re checking between 0 and false and null. \r\n\r\nFor example, if you have:\r\n\r\n    $a = 0;\r\n\r\nThen:\r\n\r\n    $a==0; \r\n    $a==NULL;\r\n    $a==false;\r\n\r\nAll returns true and you may not want this. Let&#39;s suppose you have a function that can return the 0th index of an array or false on failure. If you check with &quot;==&quot; false, you can get a confusing result.\r\n\r\nSo with the same thing as above, but a strict test:\r\n\r\n    $a = 0;\r\n    \r\n    $a===0; // returns true\r\n    $a===NULL; // returns false\r\n    $a===false; // returns false"},{"score":46,"body_markdown":"***The equal comparison operator == is confusing and should be avoided.*** \r\n\r\nIf you **HAVE TO** live with it, then remember the following 3 things: \r\n\r\n 1. **It is not transitive: *(a == b)* and *(b == c)* does not lead to *(a == c)***\r\n 2. **It&#39;s mutually exclusive to its negation: *(a == b)* and *(a != b)* always hold opposite Boolean values, with all a and b.**\r\n 3. **In case of doubt, learn by heart the following truth table:**\r\n\r\nEQUAL OPERATOR TRUTH TABLE IN JAVASCRIPT\r\n\r\n* Each row in the table is a set of 3 mutually &quot;equal&quot; values, meaning that any 2 values among them are equal using the equal == sign*\r\n\r\n** STRANGE: note that any two values on the first column are not equal in that sense.**\r\n\r\n\r\n    &#39;&#39;       == 0 == false   // Any two values among these 3 ones are equal with the == operator\r\n    &#39;0&#39;      == 0 == false   // Also a set of 3 equal values, note that only 0 and false are repeated\r\n    &#39;\\t&#39;     == 0 == false   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\r\n    &#39;\\r&#39;     == 0 == false   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\r\n    &#39;\\n&#39;     == 0 == false   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\r\n    &#39;\\t\\r\\n&#39; == 0 == false   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\r\n \r\n    null == undefined  // These two &quot;default&quot; values are not-equal to any of the listed values above\r\n    NaN                // NaN is not equal to any thing, even to itself.\r\n"},{"score":31,"body_markdown":"JSLint sometimes gives you unrealistic reasons to modify stuff. `===` has exactly the same performance as `==` if the types are already the same. \r\n\r\nIt is faster only when the types are not the same, in which case it does not try to convert types but directly returns a false.\r\n\r\nSo, *IMHO,* JSLint maybe used to write new code, but useless over-optimizing should be avoided at all costs. \r\n\r\nMeaning, there is no reason to change `==` to `===` in a check like `if (a == &#39;test&#39;)` when you know it for a fact that a can only be a String. \r\n\r\nModifying a lot of code that way wastes developers&#39; and reviewers&#39; time and achieves nothing."},{"score":25,"body_markdown":"As a rule of thumb, I would generally use `===` instead of `==` (and `!==` instead of `!=`).\r\n\r\nReasons are explained in in the answers above and also Douglas Crockford is pretty clear about it ([JavaScript: The Good Parts][1]).\r\n\r\nHowever there is **one single exception**:\r\n`== null` is an efficient way to check for &#39;is null or undefined&#39;:\r\n\r\n    if( value == null ){\r\n        // value is either null or undefined\r\n    }\r\n\r\nFor example jQuery 1.9.1 uses this pattern 43 times, and  the [JSHint syntax checker](http://www.jshint.com/docs/#options) even provides the `eqnull` relaxing option for this reason.\r\n\r\nFrom the [jQuery style guide][2]:\r\n&gt; Strict equality checks (===) should be used in favor of ==. The only\r\n&gt; exception is when checking for undefined and null by way of null.\r\n&gt; \r\n    // Check for both undefined and null values, for some important reason. \r\n    undefOrNull == null;\r\n\r\n\r\n  [1]: http://www.amazon.com/dp/0596517742/\r\n  [2]: http://contribute.jquery.org/style-guide/js/"},{"score":55,"body_markdown":"JavaScript `===` **vs** `==` .\r\n        \r\n\r\n    0==false   // true\r\n    0===false  // false, because they are of a different type\r\n    1==&quot;1&quot;     // true, auto type coercion\r\n    1===&quot;1&quot;    // false, because they are of a different type"},{"score":25,"body_markdown":"The top 2 answers both mentioned == means equality and === means identity. Unfortunately, this statement is incorrect. \r\n\r\nIf both operands of == are objects, then they are compared to see if they are the same object. If both operands point to the same object, then the equal operator returns true. Otherwise,\r\nthe two are not equal. \r\n\r\n    var a = [1, 2, 3];  \r\n    var b = [1, 2, 3];  \r\n    console.log(a == b)  // false  \r\n    console.log(a === b) // false  \r\n\r\nIn the code above, both == and === get false because a and b are not the same objects.\r\n\r\nThat&#39;s to say: if both operands of == are objects, == behaves same as ===, which also means identity. The essential difference of this two operators is about type conversion. == has conversion before it checks equality, but === does not."},{"score":21,"body_markdown":"&lt;b&gt;Equality comparison: &lt;/b&gt;\r\n\r\nOperator `==`\r\n\r\n\r\nReturns true, when both operands are equal. The operands are converted to the same type before being compared.\r\n\r\n    &gt;&gt;&gt; 1 == 1\r\n    true\r\n    &gt;&gt;&gt; 1 == 2\r\n    false\r\n    &gt;&gt;&gt; 1 == &#39;1&#39;\r\n    true\r\n\r\n\r\n&lt;b&gt;Equality and type comparison: &lt;/b&gt;\r\n\r\nOperator `===`\r\n\r\nReturns true if both operands are equal and of the same type. It&#39;s generally \r\nbetter and safer if you compare this way, because there&#39;s no behind-the-scenes type conversions.\r\n\r\n    &gt;&gt;&gt; 1 === &#39;1&#39;\r\n    false\r\n    &gt;&gt;&gt; 1 === 1\r\n    true\r\n"},{"score":18,"body_markdown":"****Operators === vs == **** \r\n\r\n    1 == true    =&gt;    true\r\n    true == true    =&gt;    true\r\n    1 === true    =&gt;    false\r\n    true === true    =&gt;    true"},{"score":20,"body_markdown":"Here is a handy comparison table that shows the conversions that happen and the differences between `==` and `===`.\r\n\r\nAs the conclusion states:\r\n\r\n&gt; &quot;Use three equals unless you fully understand the conversions that take\r\n&gt; place for two-equals.&quot;\r\n\r\nhttp://dorey.github.io/JavaScript-Equality-Table/"},{"score":20,"body_markdown":"null and undefined are nothingness, that is,\r\n\r\n    var a;\r\n    var b = null;\r\n\r\nHere `a` and `b` do not have values. Whereas, 0, false and &#39;&#39; are all values. One thing common beween all these are that they are all falsy values, which means they all **satisfy** falsy conditions.\r\n\r\nSo, the 0, false and &#39;&#39; together form a sub-group. And on other hand, null &amp; undefined form the second sub-group. Check the comparisons in the below image. null and undefined would equal. The other three would equal to each other. But, they all are treated as falsy conditions in JavaScript.\r\n\r\n![Enter image description here][1]\r\n\r\nThis is same as any object (like {}, arrays, etc.), non-empty string &amp; Boolean true are all truthy conditions. But, they are all not equal.\r\n\r\n  [1]: http://i.stack.imgur.com/11I0i.jpg\r\n\r\n\r\n"},{"score":758,"body_markdown":"An interesting pictorial representation of the equality comparison between `==` and `===`.  \r\n\r\n**Source: http://dorey.github.io/JavaScript-Equality-Table/**\r\n\r\n---\r\n\r\n# `var1 === var2`\r\n\r\n&gt; ***When using `===` for JavaScript equality testing, everything is as is. Nothing gets converted before being evaluated.***\r\n\r\n![Equality evaluation of === in JS][1]\r\n\r\n---\r\n\r\n# `var1 == var2`\r\n\r\n&gt; ***When using `==` for JavaScript equality testing, some\r\n&gt; funky conversions take place.***\r\n\r\n![Equality evaluation of == in JS][2]\r\n\r\n\r\n&gt; ***Moral of the story:*** \r\n\r\n&gt; ***Use `===` unless you fully understand the\r\n&gt; conversions that take place with `==`.***\r\n\r\n\r\n  [1]: http://i.stack.imgur.com/62vxI.png\r\n  [2]: http://i.stack.imgur.com/35MpY.png"},{"score":18,"body_markdown":"JavaScript has both strict and type–converting comparisons. A strict comparison (e.g., `===`) is only true if the operands are of the same type. The more commonly used abstract comparison (e.g. `==`) converts the operands to the same Type before making the comparison.\r\n\r\n - The equality (`==`) operator converts the operands if they are not of the same type, then applies strict comparison. If either operand is a number or a boolean, the operands are converted to numbers if possible; else if either operand is a string, the string operand is converted to a number if possible. If both operands are objects, then JavaScript compares internal references which are equal when operands refer to the same object in memory.\r\n\r\n    Syntax:\r\n\r\n    &lt;code&gt;x == y&lt;/code&gt;\r\n\r\n    Examples:\r\n\r\n        3 == 3     // true\r\n        &quot;3&quot; == 3   // true\r\n        3 == &#39;3&#39;   // true\r\n\r\n - The identity/strict equality(`===`) operator returns true if the operands are strictly equal (see above) with no type conversion.\r\n\r\n    Syntax:\r\n\r\n    &lt;code&gt;x === y&lt;/code&gt;\r\n\r\n    Examples:\r\n\r\n    &lt;code&gt;3 === 3   // true&lt;/code&gt;\r\n\r\nFor reference: *[Comparison operators][1]* (Mozilla Developer Network)\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators\r\n"},{"score":38,"body_markdown":"**Yes!** It does matter.\r\n\r\n`===` operator in javascript **checks value as well as type** where as `==` operator just checks **the value (does type conversion if required)**.\r\n\r\n![enter image description here][1]\r\n\r\n\r\nYou can easily test it. Paste following code in an HTML file and open it in browser\r\n\r\n    &lt;script&gt;\r\n    \r\n    function onPageLoad()\r\n    {\r\n    \tvar x = &quot;5&quot;;\r\n    \tvar y = 5;\r\n    \talert(x === 5);\r\n    };\r\n    \r\n    &lt;/script&gt;\r\n    \r\n    &lt;/head&gt;\r\n    \r\n    &lt;body onload=&#39;onPageLoad();&#39;&gt;\r\n\r\nYou will get &#39;**false**&#39; in alert. Now modify the `onPageLoad()` method to `alert(x == 5);` you will get **true**.\r\n\r\n\r\n  [1]: http://i.stack.imgur.com/5ttlR.png"},{"score":16,"body_markdown":"If you are making a web application or a secured page you should always use (only when possible)\r\n\r\n    ===\r\n\r\nbecause it will will check if it is the same content and if it is the same type!\r\n\r\nso when someone enters:\r\n\r\n    var check = 1;\r\n    if(check == &#39;1&#39;) {\r\n        //someone continued with a string instead of number, most of the time useless for your webapp, most of the time entered by a user who does not now what he is doing (this will sometimes let your app crash), or even worse it is a hacker searching for weaknesses in your webapp!\r\n    }\r\n\r\nbut with\r\n\r\n    var check = 1;\r\n    if(check === 1) {\r\n        //some continued with a number (no string) for your script\r\n    } else {\r\n        alert(&#39;please enter a real number&#39;);\r\n    }\r\na hacker will never get deeper in the system to find bugs and hack your app or your users\r\n\r\n\r\nmy point it is that the \r\n\r\n    ===\r\n\r\nwill add more security to your scripts\r\n\r\nof course you can also check if the entered number is valid, is a string, etc.. with other if statements inside the first example, but this is for at least me more easier to understand and use\r\n\r\n\r\nThe reason I posted this is that the word &#39;more secure&#39; or &#39;security&#39; has never been said in this conversation (if you look at iCloud.com it uses 2019 times === and 1308 times ==, this also means that you sometimes have the use == instead of === because it will otherwise block your function, but as said in the begin you should use === as much as possible)"},{"score":30,"body_markdown":"Simply \r\n\r\n   `==` means **comparison** between operands **with** `type conversion`\r\n\r\n&amp;\r\n\r\n   `===` means **comparison** between operands **without** `type conversion`\r\n\r\nType conversion in javaScript means javaScript automatically convert any other data types to string data types.\r\n\r\nFor example:\r\n\r\n    123==&#39;123&#39;   //will return true, because JS convert integer 123 to string &#39;123&#39;\r\n                 //as we used &#39;==&#39; operator \r\n\r\n    123===&#39;123&#39; //will return false, because JS do not convert integer 123 to string \r\n                //&#39;123&#39; as we used &#39;===&#39; operator "},{"score":13,"body_markdown":"`===` cares if the objects are the same. Therefore, `new String(&quot;Hello world&quot;) === &quot;Hello world&quot;` returns false. However, `==` does not care about if the objects are the same; it just simply converts one argument into the other&#39;s type: if conversion is not possible, return false. Then `new String(&quot;Hello world&quot;) == &quot;Hello world&quot;` returns true instead of false."},{"score":26,"body_markdown":"A simple example is \r\n\r\n    2 == &#39;2&#39;  -&gt; true, values are SAME because of type conversion.\r\n    \r\n    2 === &#39;2&#39;  -&gt; false, values are NOT SAME because of no type conversion."},{"score":11,"body_markdown":"The javascript is a **weakly typed language** i.e. without any data-types as there in C,c++ eg. int, boolean, float etc. thus a variable can hold any type of value, that why these special comparison operators are there\r\n\r\nEg\r\n\r\n    var i = 20;var j = &quot;20&quot;;\r\nif we apply comparison operators these variables result will be\r\n\r\n    i==j //result is true\r\nor \r\n\r\n    j != i//result is false\r\n\r\nfor that we need a special comparison operators which checks for the **value as well as for the data type** of the variable\r\n\r\nif we do\r\n\r\n    i===j //result is false\r\n"},{"score":13,"body_markdown":"My reasoning process using emacs org-mode and node.js to run a test.\r\n\r\n    | use ==     | &#39;&#39; | &#39;0&#39; | false | &#39;false&#39; | undefined | null | &#39; \\t\\r\\n &#39; |\r\n    | &#39;&#39;         | x  | f   | t     | f       | f         | f    | f          |\r\n    | &#39;0&#39;        |    | x   | t     | f       | f         | f    | f          |\r\n    | false      |    |     | x     | f       | f         | f    | t          |\r\n    | &#39;false&#39;    |    |     |       | x       | f         | f    | f          |\r\n    | undefined  |    |     |       |         | x         | t    | f          |\r\n    | null       |    |     |       |         |           | x    | f          |\r\n    | &#39; \\t\\r\\n &#39; |    |     |       |         |           |      | x          | \r\n\r\n\r\n\r\n    | use ===    | &#39;&#39; | &#39;0&#39; | false | &#39;false&#39; | undefined | null | &#39; \\t\\r\\n &#39; |\r\n    | &#39;&#39;         | x  | f   | f     | f       | f         | f    | f          |\r\n    | &#39;0&#39;        |    | x   | f     | f       | f         | f    | f          |\r\n    | false      |    |     | x     | f       | f         | f    | f          |\r\n    | &#39;false&#39;    |    |     |       | x       | f         | f    | f          |\r\n    | undefined  |    |     |       |         | x         | f    | f          |\r\n    | null       |    |     |       |         |           | x    | f          |\r\n    | &#39; \\t\\r\\n &#39; |    |     |       |         |           |      | x          |\r\n\r\n\r\nMy test script below: run &gt; node xxx.js\r\n\r\n    var rowItems = [&#39;&#39;, &#39;0&#39;, false, &#39;false&#39;, undefined, null, &#39; \\t\\r\\n &#39;]\r\n    var colItems = rowItems\r\n    \r\n    for(var i = 0; i &lt; rowItems.length; i++) {\r\n    \tfor (var j = 0; j &lt; colItems.length; j++) {\r\n    \t\tvar r = (rowItems[i] === colItems[j]) ? true : false;\r\n    \t\tconsole.log(rowItems[i] + &quot; = &quot; + colItems[j] + &quot; &quot; + r + &quot; [&quot; + i + &quot;] ==&gt; [&quot; + j + &quot;]&quot;)\r\n    \t};\r\n    }"},{"score":73,"body_markdown":"Javascript execution flow diagram for strict equality / Comparison &#39;===&#39;\r\n\r\n[![Javascript strict equality][2]][2]\r\n\r\nJavascript execution flow diagram for non strict equality / comparison &#39;==&#39;\r\n\r\n[![Javascript non equality][1]][1]\r\n\r\n  [1]: http://i.stack.imgur.com/Ccyb8.png\r\n  [2]: http://i.stack.imgur.com/A27Be.png"},{"score":5,"body_markdown":"Yes, there is a big difference between equality `==` and identity `===` operators.  \r\nUsually the identity operator performs faster, because no types conversion is done. But if the values are of the same type, you&#39;ll see no difference.  \r\nCheck my post [The legend of JavaScript equality operator][1], which explains the details, including the types conversion &amp; comparison algorithms, with a lot of examples.\r\n\r\n\r\n  [1]: http://rainsoft.io/the-legend-of-javascript-equality-operator/"},{"score":5,"body_markdown":"*One* unmentioned reason to use `===` - is in the case that you are co-existing with / cross-compiling to/from `coffee-script`. From The [Little Book on CoffeeScript][1]...\n\n&gt; The weak equality comparison in JavaScript has some confusing behavior and is often the source of confusing bugs.  \n&gt;\n&gt; The solution is to instead use the strict equality operator, which consists of three equal signs: ===. It works exactly like the normal equality operator, but without any type coercion. It&#39;s recommended to always use the strict equality operator, and explicitly convert types if needs be.\n\nIf you are regularly converting to and from `coffee-script`, you should just use `===`.  In fact, the `coffee-script` compiler will **force you to**...\n\n&gt; CoffeeScript solves this by simply replacing all weak comparisons with strict ones, in other words converting all == comparators into ===. You can&#39;t do a a weak equality comparison in CoffeeScript, and you should explicitly convert types before comparing them if necessary.\n\n\n  [1]: https://arcturo.github.io/library/coffeescript/07_the_bad_parts.html"},{"score":6,"body_markdown":"**always** use &#39;**===**&#39; and you will avoid thousand of mistakes. nowadays using **triple** equality is more preferable by different style guides, because it compares taking into account type of operands."},{"score":1,"body_markdown":"Javascript is loosely typed just like php is,\n\n    var x = &quot;20&quot;;\n    var y =20;\n\n    if (x===y) // false\nThis will always give you a false because even though the values of the variables are the same, the data types are not\n\nOne is string the the other is int\n\n    If(x==y)//true\n\nThis however just checks if the content is the same, regardless of the data types...\n \nI dont want to say the values are equal because a string value cannot be equal to an int value logically\n\n \n"},{"score":0,"body_markdown":"    var a = new String(&quot;123&quot;);\r\n    var b = &quot;123&quot;;\r\n\r\n    alert(a === b); // returns false !! (but they are equal and of the same type)\r\n\r\nSaw this in one of the answers.\r\n`a` and `b` are not really the same type in this case, if you will check `typeof(a)`\r\n you will get _&#39;object&#39;_ and `typeof(b)` is _&#39;string&#39;_."},{"score":89,"body_markdown":"**Why `==` is so unpredictable?**\r\n\r\nWhat do you get when you compare an empty string `&quot;&quot;` with the number zero `0`?\r\n\r\n`true`\r\n\r\nYep, that&#39;s right according to `==` an empty string and the number zero are the same time.\r\n\r\nAnd it doesn&#39;t end there, here&#39;s another one:\r\n\r\n    &#39;0&#39; == false // true\r\n\r\n**Things get really weird with arrays.**\r\n\r\n    [1] == true // true\r\n    [] == false // true\r\n    [[]] == false // true\r\n    [0] == false // true\r\n\r\n**Then weirder with strings**\r\n\r\n    [1,2,3] == &#39;1,2,3&#39; // true - REALLY?!\r\n    &#39;\\r\\n\\t&#39; == 0 // true - Come on!\r\n\r\nIt get&#39;s worse:\r\n\r\n**When is equal not equal?**\r\n\r\n    let A = &#39;&#39;  // empty string\r\n    let B = 0   // zero\r\n    let C = &#39;0&#39; // zero string\r\n\r\n    A == B // true - ok... \r\n    B == C // true - so far so good...\r\n    A == C // **FALSE** - Plot twist!\r\n\r\nLet me say that again:\r\n\r\n    (A == B) &amp;&amp; (B == C) // true\r\n    (A == C) // **FALSE**\r\n\r\nAnd this is just the crazy stuff you get with primitives.\r\n\r\nIt&#39;s a whole new level of crazy when you use `==` with objects.\r\n\r\nAt this point your probably wondering...\r\n\r\n**Why does this happen?**\r\n\r\nWell it&#39;s because unlike &quot;triple equals&quot; (`===`) which just checks if two values are the same.\r\n\r\n`==` does a ***whole bunch of other stuff***.\r\n\r\nIt has special handling for functions, special handling for nulls, undefined, strings, you name it.\r\n\r\nIt get&#39;s pretty wacky.\r\n\r\nIn fact, if you tried to write a function that does what `==` does it would look something like this:\r\n\r\n    function isEqual(x, y) { // if `==` were a function\r\n        if(typeof y === typeof x) return y === x;\r\n        // treat null and undefined the same\r\n        var xIsNothing = (y === undefined) || (y === null);\r\n        var yIsNothing = (x === undefined) || (x === null);\r\n        \r\n        if(xIsNothing || yIsNothing) return (xIsNothing &amp;&amp; yIsNothing);\r\n\r\n        if(typeof y === &quot;function&quot; || typeof x === &quot;function&quot;) {\r\n            // if either value is a string \r\n            // convert the function into a string and compare\r\n            if(typeof x === &quot;string&quot;) {\r\n                return x === y.toString();\r\n            } else if(typeof y === &quot;string&quot;) {\r\n                return x.toString() === y;\r\n            } \r\n            return false;\r\n        }\r\n        \r\n        if(typeof x === &quot;object&quot;) x = toPrimitive(x);\r\n        if(typeof y === &quot;object&quot;) y = toPrimitive(y);\r\n        if(typeof y === typeof x) return y === x;\r\n\r\n        // convert x and y into numbers if they are not already use the &quot;+&quot; trick\r\n        if(typeof x !== &quot;number&quot;) x = +x;\r\n        if(typeof y !== &quot;number&quot;) y = +y;\r\n        // actually the real `==` is even more complicated than this, especially in ES6\r\n        return x === y;\r\n    }\r\n\r\n    function toPrimitive(obj) {\r\n        var value = obj.valueOf();\r\n        if(obj !== value) return value;\r\n        return obj.toString();\r\n    }\r\n\r\n**So what does this mean?**\r\n\r\nIt means `==` is complicated.\r\n\r\nBecause it&#39;s complicated it&#39;s hard to know what&#39;s going to happen when you use it.\r\n\r\nWhich means you could end up with bugs.\r\n\r\n**So the moral of the story is...**\r\n\r\nMake your life less complicated.\r\n\r\nUse `===` instead of `==`.\r\n\r\nThe End.\r\n"},{"score":-5,"body_markdown":"    1 == &quot;1&quot;    =&gt;    true(define)\r\n    true === &quot;true&quot;    =&gt; false(undefined compare the type of variable)\r\n    Case 1\r\n    if(true === &quot;true&quot;){\r\n      echo &#39;true&#39;\r\n    }else{\r\n     echo &#39;false undefined&#39;\r\n    }\r\n    Ans :- false undefined because case 1 is check data type also with ===  \r\n    Case 2\r\n    if(1 == &quot;1&quot;){\r\n      echo &#39;true define&#39;\r\n    }else{\r\n     echo &#39;false undefined&#39;\r\n    }\r\n    Ans :- true define undefined because case 2 is not check data type with ==\r\n"},{"score":1,"body_markdown":"First, some terminology about Javascript string equals: Double equals is officially known as the abstract equality comparison operator while triple equals is termed the strict equality comparison operator. The difference between them can be summed up as follows: Abstract equality will attempt to resolve the data types via type coercion before making a comparison. Strict equality will return false if the types are different. Consider the following example:\r\n\r\n    console.log(3 == &quot;3&quot;); // true\r\n    console.log(3 === &quot;3&quot;); // false.\r\n    console.log(3 == &quot;3&quot;); // true\r\n    console.log(3 === &quot;3&quot;); // false.\r\nUsing two equal signs returns true because the string “3” is converted to the number 3 before the comparison is made. Three equal signs sees that the types are different and returns false. Here’s another:\r\n\r\n\r\n    console.log(true == &#39;1&#39;); // true\r\n    console.log(true === &#39;1&#39;); // false\r\n    console.log(true == &#39;1&#39;); // true\r\n    console.log(true === &#39;1&#39;); // false\r\nAgain, the abstract equality comparison performs a type conversion. In this case both the boolean true and the string ‘1’ are converted to the number 1 and the result is true. Strict equality returns false.\r\n\r\nIf you understand that you are well on your way to distinguishing between == and ===. However, there’s some scenarios where the behavior of these operators is non intuitive. Let’s take a look at some more examples:\r\n\r\n\r\n    console.log(undefined == null); // true\r\n    console.log(undefined === null); // false. Undefined and null are distinct types and are not interchangeable.\r\n    console.log(undefined == null); // true     \r\n    console.log(undefined === null); // false. Undefined and null are distinct types and are not interchangeable.\r\n\r\n    console.log(true == &#39;true&#39;); // false. A string will not be converted to a boolean and vice versa.\r\n    console.log(true === &#39;true&#39;); // false\r\n    console.log(true == &#39;true&#39;); // false. A string will not be converted to a boolean and vice versa.\r\n    console.log(true === &#39;true&#39;); // false\r\n\r\nThe example below is interesting because it illustrates that string literals are different from string objects.\r\n\r\n\r\n    console.log(&quot;This is a string.&quot; == new String(&quot;This is a string.&quot;)); // true\r\n    console.log(&quot;This is a string.&quot; === new String(&quot;This is a string.&quot;)); // false\r\n    console.log(&quot;This is a string.&quot; == new String(&quot;This is a string.&quot;)); // true\r\n    console.log(&quot;This is a string.&quot; === new String(&quot;This is a string.&quot;)); // false"},{"score":9,"body_markdown":"`==` operator just compares the values not datatype.\r\n\r\n`===` operator compare the values with comparison of its datatype.\r\n\r\neg : \r\n \r\n\r\n    1 == &quot;1&quot; //true\r\n    \r\n    1 === &quot;1&quot; //false\r\n\r\nThis operator (`&quot;===&quot;`) used in languages which performs automatic type cast eg. PHP, Javascript.&lt;br&gt;`&quot;===&quot;` operator helps to prevent unexpected comparison caused by automatic typecast.\r\n \r\n"},{"score":1,"body_markdown":"Use `===` if you want to compare couple of things in JavaScript, it&#39;s called **strict equality**, it means this will return true if **only both type and value are the same**, so there wouldn&#39;t be any unwanted type correction for you, if you using `==`, you basically don&#39;t care about the type and in many cases you could face issues with loose equality comparison. &lt;br&gt;&lt;br&gt;\r\n\r\n**Strict equality using ===**\r\n\r\n&gt; Strict equality compares two values for equality. Neither value is\r\n&gt; implicitly converted to some other value before being compared. If the\r\n&gt; values have different types, the values are considered unequal.\r\n&gt; Otherwise, if the values have the same type and are not numbers,\r\n&gt; they&#39;re considered equal if they have the same value. Finally, if both\r\n&gt; values are numbers, they&#39;re considered equal if they&#39;re both not NaN\r\n&gt; and are the same value, or if one is +0 and one is -0.\r\n\r\n    var num = 0;\r\n    var obj = new String(&#39;0&#39;);\r\n    var str = &#39;0&#39;;\r\n    \r\n    console.log(num === num); // true\r\n    console.log(obj === obj); // true\r\n    console.log(str === str); // true\r\n    \r\n    console.log(num === obj); // false\r\n    console.log(num === str); // false\r\n    console.log(obj === str); // false\r\n    console.log(null === undefined); // false\r\n    console.log(obj === null); // false\r\n    console.log(obj === undefined); // false\r\n\r\n&lt;br&gt;**Loose equality using ==**\r\n\r\n&gt; Loose equality compares two values for equality, after converting both\r\n&gt; values to a common type.  After conversions (one or both sides may\r\n&gt; undergo conversions), the final equality comparison is performed\r\n&gt; exactly as === performs it.  Loose equality is symmetric: A == B\r\n&gt; always has identical semantics to B == A for any values of A and B\r\n&gt; (except for the order of applied conversions).\r\n\r\n    var num = 0;\r\n    var obj = new String(&#39;0&#39;);\r\n    var str = &#39;0&#39;;\r\n    \r\n    console.log(num == num); // true\r\n    console.log(obj == obj); // true\r\n    console.log(str == str); // true\r\n    \r\n    console.log(num == obj); // true\r\n    console.log(num == str); // true\r\n    console.log(obj == str); // true\r\n    console.log(null == undefined); // true\r\n    \r\n    // both false, except in rare cases\r\n    console.log(obj == null);\r\n    console.log(obj == undefined);"},{"score":8,"body_markdown":"&gt; Different&#39;s Between ` = ` , `= =` , `= = = `\r\n\r\n - `=` operator Used to just assign the `value`.\r\n - `= =` operator Used to just compares the `values` not `datatype`\r\n - `= = = ` operator Used to Compare the `values` as well as `datatype`."},{"score":1,"body_markdown":"The reason it suggest to replace `==` with `===` is that the `===` operator is more reliable than `==`. In our context reliable means `===` also goes for type checking. Considering the best programming practices we should always choose more reliable feature over less reliable one. Again whenever we think about exactly equal to operator most of the time, we are by default consider the type should be same. As `===` provides the same, we should go for it."},{"score":3,"body_markdown":"&lt;h1&gt;Strict equality is for the most part better&lt;/h1&gt;\r\n&lt;p&gt;The fact that Javascript is a loosely typed language needs to be in the front of your mind constantly as you work with it. As long as the data structure is the same there really is no reason as to not use strict equality, with regular equality you often have an implicit conversion of values that happens automatically, this can have far-reaching effects on your code. It is very easy to have problems with this conversion seeing as they happen automatically.&lt;/p&gt;\r\n\r\n&lt;p&gt;With strict equality there is no automatic implicit conversion as the values must already be of the correct data structure.&lt;/p&gt;"},{"score":1,"body_markdown":"The dilemma of &quot;Should I use `==` or `===` in JavaScript comparison&quot; is equal or analogous to a question of: &quot;Should I use a &#39;spoon&#39; or a &#39;fork&#39; for eating. \r\n\r\nThe only reasonable answer to this question is that \r\n\r\n 1. You should use **Dynamic Type** comparison e.g.:`==` for ***loose Type*** comparisons. \r\n 2. You should use **Static Type** comparison e.g.:`===` for ***strong Type*** comparisons. \r\n\r\nThat&#39;s because they are not the same. They don&#39;t have the same purpose and are not meant to be used for the same purpose.\r\n\r\nOf course both &#39;forks&#39; and &#39;spoons&#39; are meant for &#39;eating&#39;, but you will chose to use them accordingly to what you&#39;ve been served to eat.\r\n\r\nMeaning: you&#39;ll resolve to using a &#39;spoon&#39; i.e.: `==` for having a &#39;soup&#39;, and / or the &#39;fork&#39; i.e.: `===` for picking. \r\n\r\nAsking if it is better to use a &quot;fork&quot; or a &quot;spoon&quot; for &quot;eating&quot; - is equall to asking if it is better to use a static [===] versus dynamic [==] eq., op. in JS. Both questions are equally wrong and reflect a very narrow or shallow understanding of the subject in question."}],"score":5662}