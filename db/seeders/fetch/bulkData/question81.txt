{"body":"I am new to this kind of stuff, but lately I&#39;ve been hearing a lot about how good [Node.js][1] is. Considering how much I love working with jQuery and JavaScript in general, I can&#39;t help but wonder how to decide when to use Node.js. The web application I have in mind is something like [Bitly][2] - takes some content, archives it. \r\n\r\nFrom all the homework I have been doing in the last few days, I obtained the following information. Node.js \r\n\r\n - is a command-line tool that can be run as a regular web server and lets one run JavaScript programs\r\n - utilizes the great [V8 JavaScript engine][3]\r\n - is very good when you need to do several things at the same time\r\n - is event-based so all the wonderful [Ajax][4]-like stuff can be done on the server side\r\n - lets us share code between the browser and the backend\r\n - lets us talk with MySQL\r\n\r\nSome of the sources that I have come across are:\r\n\r\n  - [Diving into Node.js – Introduction and Installation][5]\r\n  - [Understanding NodeJS][6]\r\n  - [Node by Example][7] ([Archive.is][13])\r\n  - [Let’s Make a Web App: NodePad][8]\r\n\r\nConsidering that Node.js can be run almost out-of-the-box on [Amazon&#39;s EC2][9] instances, I am trying to understand what type of problems require Node.js as opposed to any of the mighty kings out there like [PHP][10], [Python][11] and [Ruby][12]. I understand that it really depends on the expertise one has on a language, but my question falls more into the general category of: When to use a particular framework and what type of problems is it particularly suited for?\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Node.js\r\n  [2]: https://en.wikipedia.org/wiki/Bitly\r\n  [3]: http://en.wikipedia.org/wiki/V8_%28JavaScript_engine%29\r\n  [4]: http://en.wikipedia.org/wiki/Ajax_%28programming%29\r\n  [5]: http://www.stoimen.com/blog/2010/11/16/diving-into-node-js-introduction-and-installation/\r\n  [6]: http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb\r\n  [7]: http://blog.osbutler.com/categories/node-by-example/?page=3\r\n  [8]: http://dailyjs.com/2010/11/01/node-tutorial/\r\n  [9]: http://en.wikipedia.org/wiki/Amazon_Elastic_Compute_Cloud\r\n  [10]: http://en.wikipedia.org/wiki/PHP\r\n  [11]: http://en.wikipedia.org/wiki/Python_%28programming_language%29\r\n  [12]: http://en.wikipedia.org/wiki/Ruby_%28programming_language%29\r\n  [13]: http://archive.is/exhaR\r\n","title":"How to decide when to use Node.js?","answers":[{"score":1355,"body_markdown":"You did a great job of summarizing what&#39;s awesome about Node.js. My feeling is that Node.js is especially suited for applications where you&#39;d like to maintain a persistent connection from the browser back to the server. Using a technique known as [&quot;long-polling&quot;][1], you can write an application that sends updates to the user in real time. Doing long polling on many of the web&#39;s giants, like [Ruby on Rails][2] or [Django][3], would create immense load on the server, because each active client eats up one server process. This situation amounts to a [tarpit][4] attack. When you use something like Node.js, the server has no need of maintaining separate threads for each open connection.  \r\n\r\nThis means you can create a [browser-based chat application][5] in Node.js that takes almost no system resources to serve a great many clients. Any time you want to do this sort of long-polling, Node.js is a great option.  \r\n\r\nIt&#39;s worth mentioning that Ruby and Python both have tools to do this sort of thing ([eventmachine][6] and [twisted][7], respectively), but that Node.js does it exceptionally well, and from the ground up. JavaScript is exceptionally well situated to a callback-based concurrency model, and it excels here. Also, being able to serialize and deserialize with JSON native to both the client and the server is pretty nifty. \r\n\r\nI look forward to reading other answers here, this is a fantastic question. \r\n\r\nIt&#39;s worth pointing out that Node.js is also great for situations in which you&#39;ll be reusing a lot of code across the client/server gap. The [Meteor framework][8] makes this really easy, and a lot of folks are suggesting this might be the future of web development. I can say from experience that it&#39;s a whole lot of fun to write code in Meteor, and a big part of this is spending less time thinking about how you&#39;re going to restructure your data, so the code that runs in the browser can easily manipulate it and pass it back. \r\n\r\nHere&#39;s an article on Pyramid and long-polling, which turns out to be very easy to set up with a little help from gevent: [*TicTacToe and Long Polling with Pyramid*][9].\r\n\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Push_technology#Long_polling\r\n  [2]: http://en.wikipedia.org/wiki/Ruby_on_Rails\r\n  [3]: http://en.wikipedia.org/wiki/Django_%28web_framework%29\r\n  [4]: http://en.wikipedia.org/wiki/Tarpit_(networking)\r\n  [5]: https://github.com/rivalslayer/node_chat\r\n  [6]: http://rubyeventmachine.com/\r\n  [7]: https://twistedmatrix.com/trac/\r\n  [8]: http://meteor.com\r\n  [9]: http://michael.merickel.org/2011/6/21/tictactoe-and-long-polling-with-pyramid/"},{"score":409,"body_markdown":"I believe Node.js is best suited for real-time applications: online games, collaboration tools, chat rooms, or anything where what one user (or robot?  or sensor?) does with the application needs to be seen by other users immediately, without a page refresh.\r\n\r\nI should also mention that Socket.IO in combination with Node.js will reduce your real-time latency even further than what is possible with long polling.  Socket.IO will fall back to long polling as a worst case scenario, and instead use web sockets or even Flash if they are available.\r\n\r\nBut I should also mention that just about any situation where the code might block due to threads can be better addressed with Node.js.  Or any situation where you need the application to be event-driven.\r\n\r\nAlso, Ryan Dahl said in a talk that I once attended that the Node.js benchmarks closely rival Nginx for regular old HTTP requests.  So if we build with Node.js, we can serve our normal resources quite effectively, and when we need the event-driven stuff, it&#39;s ready to handle it.\r\n\r\nPlus it&#39;s all JavaScript all the time.  Lingua Franca on the whole stack."},{"score":206,"body_markdown":"To make it short:\r\n\r\nNode.js is well suited for applications that have a lot of concurrent connections and each request only needs very few CPU cycles, because the event loop (with all the other clients) is blocked during execution of a function.\r\n\r\nA good article about the event loop in Node.js is [*Mixu&#39;s tech blog: Understanding the node.js event loop*][1].\r\n\r\n  [1]: http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/\r\n"},{"score":60,"body_markdown":"There is nothing like Silver Bullet. Everything comes with some cost associated with it. It is like if you eat oily food, you will compromise your health and healthy food does not come with spices like oily food. It is individual choice whether they want health or spices as in their food.\r\nSame way Node.js consider to be used in specific scenario. If your app does not fit into that scenario you should not consider it for your app development. I am just putting my thought on the same:\r\n\r\n**When to use Node.JS**\r\n\r\n 1. If your server side code requires very few cpu cycles. In other world you are doing non blocking operation and does not have heavy algorithm/Job which consumes lots of CPU cycles.\r\n 2. If you are from Javascript back ground and comfortable in writing Single Threaded code just like client side JS.\r\n\r\n\r\n**When NOT to use Node.JS**\r\n\r\n1. Your server request is dependent on heavy CPU consuming algorithm/Job.\r\n\r\n**Scalability Consideration with Node.JS**\r\n\r\n1. Node.JS itself does not utilize all core of underlying system and it is single threaded by default, you have to write logic by your own to utilize multi core processor and make it multi threaded.\r\n\r\n**Node.JS Alternatives**\r\n\r\nThere are other option to use in place of Node.JS however [Vert.x][1] seems to be pretty promising and has lots of additional features like polygot and better scalability considerations.\r\n\r\n\r\n  [1]: http://vertx.io/"},{"score":37,"body_markdown":"My piece: nodejs is great for making real time systems like analytics, chat-apps, apis, ad servers, etc.\r\nHell, I made my first chat app using nodejs and socket.io under 2 hours and that too during exam \r\nweek!\r\n\r\n**Edit**\r\n\r\nIts been several years since I have started using nodejs and I have used it in making many different things including static file servers, simple analytics, chat apps and much more.\r\nThis is my take on when to use nodejs\r\n\r\n**When to use**\r\n\r\nWhen making system which put emphasis on concurrency and speed.\r\n\r\n - Sockets only servers like chat apps, irc apps, etc.\r\n - Social networks which put emphasis on realtime resources like geolocation, video stream, audio        stream, etc.\r\n - Handling small chunks of data really fast like an analytics webapp.\r\n - As exposing a REST only api.\r\n\r\n**When not to use**\r\n\r\nIts a very versatile webserver so you can use it wherever you want but probably not these places.\r\n\r\n - Simple blogs and static sites.\r\n - Just as a static file server.\r\n\r\nKeep in mind that I am just nitpicking. For static file servers, apache is better mainly because it is widely available. The nodejs community has grown larger and more mature over the years and it is safe to say nodejs can be used just about everywhere if you have your own choice of hosting."},{"score":127,"body_markdown":"I have one real-world example where I have used Node.js. The company where I work got one client who wanted to have a simple static HTML website. This website is for selling one item using [PayPal][1] and the client also wanted to have a counter which shows the amount of sold items. Client expected to have huge amount of visitors to this website. I decided to make the counter using Node.js and the [Express.js][2] framework.\r\n\r\nThe Node.js application was simple. Get the sold items amount from a [Redis][3] database, increase the counter when item is sold and serve the counter value to users via the [API][4].\r\n\r\n**Some reasons why I chose to use Node.js in this case**\r\n\r\n 1. It is very lightweight and fast. There has been over 200000 visits on this website in three weeks and minimal server resources has been able to handle it all.\r\n 2. The counter is really easy to make to be real time.\r\n 3. Node.js was easy to configure.\r\n 4. There are lots of modules available for free. For example, I found a Node.js module for PayPal.\r\n\r\nIn this case, Node.js was an awesome choice.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/PayPal\r\n  [2]: http://expressjs.com/\r\n  [3]: http://en.wikipedia.org/wiki/Redis_%28data_store%29\r\n  [4]: http://en.wikipedia.org/wiki/Application_programming_interface\r\n"},{"score":41,"body_markdown":"Another great thing that *I think* no one has mentioned about Node.js is the amazing community, the package management system (npm) and the amount of modules that exist that you can include by simply including them in your package.json file. "},{"score":16,"body_markdown":"My **one more reason** to choose Node.js for a new project is: \r\n\r\n**Be able to do pure cloud based development**\r\n\r\nI have used [Cloud9 IDE][1] for a while and now I can&#39;t imagine without it, it covers all the development lifecycles. All you need is a browser and you can code anytime anywhere on any devices. You don&#39;t need to check in code in one Computer(like at home), then checkout in another computer(like at work place). \r\n\r\nOf course, there maybe cloud based IDE for other languages or platforms (Cloud 9 IDE is adding supports for other languages as well), but using Cloud 9 to do Node.js developement is really a great experience for me.   \r\n\r\n\r\n  [1]: https://c9.io"},{"score":209,"body_markdown":"Reasons to use NodeJS:\r\n\r\n- It runs Javascript, so you can use the **same language** on server and client, and even share some code between them (e.g. for form validation, or to render views at either end.)\r\n\r\n- The [single-threaded](http://www.haneycodes.net/to-node-js-or-not-to-node-js/) event-driven system is [**fast**](https://stackoverflow.com/questions/9290160/node-js-vs-net-performance) even when handling lots of requests at once, and also simple, compared to traditional multi-threaded [Java](http://www.infoworld.com/article/2883328/java/java-vs-nodejs-an-epic-battle-for-developer-mindshare.html) or ROR frameworks.\r\n\r\n- The ever-growing pool of **[packages](http://npmjs.org/) accessible through NPM**, including client and server-side libraries/modules, as well as command-line tools for web development.  Most of these are conveniently hosted on github, where sometimes you can report an issue and find it fixed within hours!  It&#39;s nice to have everything under one roof, with standardized issue reporting and easy forking.\r\n\r\n- It has become the defacto standard environment in which to run **Javascript-related tools** and other **web-related tools**, including task runners, minifiers, beautifiers, linters, preprocessors, bundlers and analytics processors.\r\n\r\n- It seems quite suitable for prototyping, agile development and **rapid product iteration**.\r\n\r\nReasons **not** to use NodeJS:\r\n\r\n- It runs Javascript, which has no compile-time type checking.  For large, complex **safety-critical** systems, or projects including collaboration between different organizations, a language which encourages **contractual interfaces** and provides **static type checking** may save you some debugging time (and *explosions*) in the long run.  (Although the JVM is stuck with `null`, so please use Haskell for your nuclear reactors.)\r\n\r\n- Added to that, many of the packages in NPM are a little **raw**, and still under rapid development.  Some libraries for older frameworks have undergone a decade of testing and bugfixing, and are very **stable** by now. [Npmjs.org has no mechanism to rate packages](https://pinboard.in/u:dandv/t:npm/t:against), which has lead to a proliferation of packages doing more or less the same thing, out of which a large percentage are no longer maintained.\r\n\r\n- Nested callback hell.  (Of course there are [20 different solutions][1] to this...)\r\n\r\n- The ever-growing pool of packages can make one NodeJS project appear **radically different** from the next.  There is a large diversity in implementations due to the huge number of options available (e.g. Express/[Sails.js](http://sailsjs.org/)/[Meteor](https://www.meteor.com/)/[Derby](http://derbyjs.com/)).  This can sometimes make it harder for a new developer to jump in on a Node project.  Contrast that with a **Rails** developer joining an existing project: he should be able to get familiar with the app pretty quickly, because all Rails apps are encouraged to use a **similar structure**.\r\n\r\n- Dealing with files can be a bit of a pain. Things that are trivial in other languages, like reading a line from a text file, are [weird enough to do with Node.js](https://stackoverflow.com/questions/6156501/read-a-file-one-line-at-a-time-in-node-js#comment23691959_6156501) that there&#39;s a StackOverflow question on that with 80+ upvotes. There&#39;s [no simple way to read one record at a time from a CSV file](https://stackoverflow.com/questions/19587936/how-can-i-parse-records-on-demand-with-node-js). Etc.\r\n\r\nI love NodeJS, it is fast and wild and fun, but I am concerned it has little interest in provable-correctness.  Let&#39;s hope we can eventually merge the best of both worlds.  I am eager to see what will replace Node in the future... :)\r\n\r\n\r\n  [1]: https://github.com/nodejs/node/wiki/Modules#async-flow"},{"score":15,"body_markdown":"One more thing node provides is the ability to create multiple v8 instanes of node using node&#39;s child process( [childProcess.fork()][1] each requiring 10mb memory as per docs) on the fly, thus not affecting the main process running the server. So offloading a background job that requires huge server load becomes a child&#39;s play and we can easily kill them as and when needed.\r\n\r\nI&#39;ve been using node a lot and in most of the apps we build, require server connections at the same time thus a heavy network traffic. Frameworks like [Express.js][2] and the new [Koajs][3] (which removed callback hell) have made working on node even more easier.\r\n\r\n\r\n  [1]: http://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options\r\n  [2]: http://expressjs.com\r\n  [3]: http://koajs.com/"},{"score":105,"body_markdown":"The most important reasons to start your next project using Node ...\r\n\r\n  - All the coolest dudes are into it ... so it _must_ be fun.\r\n  - You can hangout at the cooler and have lots of Node adventures to brag about.\r\n  - You&#39;re a penny pincher when it comes to cloud hosting costs.\r\n  - Been there done that with Rails\r\n  - You hate IIS deployments\r\n  - Your old IT job is getting rather dull and you wish you were in a shiny new Start Up.\r\n\r\nWhat to expect ...\r\n\r\n  - You&#39;ll feel safe and secure with Express without all the server bloatware you never needed.\r\n  - Runs like a rocket and scales well.\r\n  - You dream it. You installed it. The node package repo [npmjs.org](http://npmjs.org) is the largest ecosystem of open source libraries in the world.\r\n  - Your brain will get time warped in the land of nested callbacks ...\r\n  - ... until you learn to keep your [Promises](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise).\r\n  - [Sequelize](http://docs.sequelizejs.com/en/latest/) and [Passport](http://passportjs.org/) are your new API friends.\r\n  - Debugging mostly async code will get umm ... *interesting* .\r\n  - Time for all Noders to master [Typescript](http://www.typescriptlang.org/).\r\n\r\nWho uses it?\r\n\r\n  - PayPal, Netflix, Walmart, LinkedIn, Groupon, Uber, GoDaddy, Dow Jones\r\n  - Here&#39;s why they [switched to Node](http://www.algoworks.com/blog/developing-enterprise-applications-using-node-js/). "},{"score":30,"body_markdown":"It can be used where\r\n\r\n- Applications that are highly event driven &amp; are heavily I/O bound\r\n- Applications handling a large number of connections to other systems\r\n- Real-time applications (Node.js was designed from the ground up for real time and to be easy\r\nto use.)\r\n- Applications that juggle scads of information streaming to and from other sources\r\n- High traffic, Scalable applications\r\n- Mobile apps that have to talk to platform API &amp; database, without having to do a lot of data\r\nanalytics\r\n- Build out networked applications\r\n- Applications that need to talk to the back end very often\r\n\r\nOn Mobile front, prime-time companies have relied on Node.js for their mobile solutions. **Check out why?**\r\n\r\n[LinkedIn][1] is a prominent user. Their entire mobile stack is built on Node.js. They went from running 15 servers with 15 instances on each physical machine, to just 4 instances – that can handle double the traffic!\r\n\r\n[eBay][2] launched ql.io, a web query language for HTTP APIs, which uses Node.js as the runtime stack. They were able to tune a regular developer-quality Ubuntu workstation to handle more than 120,000 active connections per node.js process, with each connection consuming about 2kB memory!\r\n\r\n[Walmart][3] re-engineered its mobile app to use Node.js and pushed its JavaScript processing to the server.\r\n\r\nRead more at: http://www.pixelatingbits.com/a-closer-look-at-mobile-app-development-with-node-js/\r\n\r\n\r\n  [1]: http://venturebeat.com/2011/08/16/linkedin-node/\r\n  [2]: http://www.ebaytechblog.com/2011/11/30/announcing-ql-io/\r\n  [3]: http://venturebeat.com/2012/01/24/why-walmart-is-using-node-js/"},{"score":9,"body_markdown":"If your application mainly tethers web apis, or other io channels, give or take a user interface, node.js may be a fair pick for you, especially if you want to squeeze out the most scalability, or, if your main language in life is javascript (or javascript transpilers of sorts). If you build microservices, node.js is also okay. Node.js is also suitable for any project that is small or simple.\r\n\r\nIts main selling point is it allows front-enders take responsibility for back-end stuff rather than the typical divide. Another justifiable selling point is if your workforce is javascript oriented to begin with. \r\n\r\nBeyond a certain point however, you cannot scale your code without terrible hacks for forcing modularity, readability and flow control. Some people like those hacks though, especially coming from an event-driven javascript background, they seem familiar or forgivable. \r\n\r\nIn particular, when your application needs to perform synchronous flows, you start bleeding over half-baked solutions that slow you down considerably in terms of your development process. If you have computation intensive parts in your application, tread with caution picking (only) node.js. Maybe http://koajs.com/ or other novelties alleviate those originally thorny aspects, compared to when I originally used node.js or wrote this.\r\n\r\n"},{"score":-3,"body_markdown":"1. Node is great for quick prototypes but I&#39;d never use it again for anything complex.\r\nI spent 20 years developing a relationship with a compiler and I sure miss it. \r\n\r\n2. Node is especially painful for maintaining code that you haven&#39;t visited for awhile. Type info and compile time error detection are GOOD THINGS. Why throw all that out? For what? And dang, when something does go south the stack traces quite often completely useless.\r\n\r\n"},{"score":20,"body_markdown":" [Node best for concurrent request handling -][1]\r\n\r\nSo, Let’s start with a story. From last 2 years I am working on JavaScript and developing web front end and I am enjoying it. Back end guys provide’s us some API’s written in Java,python (we don’t care) and we simply write a AJAX call, get our data and guess what ! we are done. But in real it is not that easy, If data we are getting is not correct or there is some server error then we stuck and we have to contact our back end guys over the mail or chat(sometimes on whatsApp too :).) This is not cool. What if we wrote our API’s in JavaScript and call those API’s from our front end ? Yes that’s pretty cool because if we face any problem in API we can look into it. Guess what ! you can do this now , How ? – Node is there for you.\r\n\r\nOk agreed that you can write your API in JavaScript but what if I am ok with above problem. Do you have any other reason to use node for rest API ?\r\n\r\nso here is the magic begins. Yes I do have other reasons to use node for our API’s.\r\n\r\nLet’s go back to our traditional rest API system which is based on either blocking operation or threading. Suppose two concurrent request occurs( r1 and r2) , each of them require database operation. So In traditional system what will happens :\r\n\r\n**1. Waiting Way :** Our server starts serving `r1` request and waits for query response. after completion of `r1` , server starts to serve `r2` and does it in same way. So waiting is not a good idea because we don’t have that much time.\r\n\r\n**2. Threading Way :** Our server will creates two threads for both requests `r1` and `r2` and serve their purpose after querying database so cool its fast.But it is memory consuming because you can see we started two threads also problem increases when both request is querying same data then you have to deal with deadlock kind of issues . So its better than waiting way but still issues are there.\r\n\r\nNow here is , how node will do it:\r\n\r\n**3. Nodeway :** When same concurrent request comes in node then it will register an event with its callback and move ahead it will not wait for query response for a particular request.So when `r1` request comes then node’s event loop (yes there is an event loop in node which serves this purpose.) register an event with its callback function and move ahead for serving `r2` request and similarly register its event with its callback. Whenever any query finishes it triggers its corresponding event and execute its callback  to completion without being interrupted.\r\n\r\nSo no waiting, no threading , no memory consumption – yes this is nodeway for serving rest API.\r\n\r\n\r\n  [1]: https://nodeway.wordpress.com/2015/01/16/why-rest-api-in-node/"},{"score":15,"body_markdown":"**Donning asbestos longjohns...**\r\n\r\nYesterday my title with Packt Publications, [Reactive Programming with JavaScript](http://www.amazon.com/Reactive-Programming-JavaScript-Jonathan-Hayward/dp/1783558555/ref=sr_1_1?ie=UTF8&amp;qid=1441220486&amp;sr=8-1&amp;keywords=reactive+programming+with+JavaScript). It isn&#39;t really a Node.js-centric title; early chapters are intended to cover theory, and later code-heavy chapters cover practice. Because I didn&#39;t really think it would be appropriate to fail to give readers a webserver, Node.js seemed ***by far*** the obvious choice. The case was closed before it was even opened.\r\n\r\nI could have given a very rosy view of my experience with Node.js. Instead I was honest about good points and bad points I encountered.\r\n\r\nLet me include a few quotes that are relevant here:\r\n\r\n&gt; **Warning: Node.js and its ecosystem are *hot*--hot enough to burn you badly!**\r\n\r\n&gt;When I was a teacher’s assistant in math, one of the non-obvious suggestions I was told was not to tell a student that something was “easy.” The reason was somewhat obvious in retrospect: if you tell people something is easy, someone who doesn’t see a solution may end up feeling (even more) stupid, because not only do they not get how to solve the problem, but the problem they are too stupid to understand is an easy one!\r\n\r\n&gt; There are gotchas that don’t just annoy people coming from Python / Django, which immediately reloads the source if you change anything. With Node.js, the default behavior is that if you make one change, the old version continues to be active until the end of time or until you manually stop and restart the server. This inappropriate behavior doesn’t just annoy Pythonistas; it also irritates native Node.js users who provide various workarounds. The StackOverflow question “Auto-reload of files in Node.js” has, at the time of this writing, over 200 upvotes and 19 answers; an edit directs the user to a nanny script, node-supervisor, with homepage at http://tinyurl.com/reactjs-node-supervisor. This problem affords new users with great opportunity to feel stupid because they thought they had fixed the problem, but the old, buggy behavior is completely unchanged. And it is easy to forget to bounce the server; I have done so multiple times. And the message I would like to give is, “No, you’re not stupid because this behavior of Node.js bit your back; it’s just that the designers of Node.js saw no reason to provide appropriate behavior here. Do try to cope with it, perhaps taking a little help from node-supervisor or another solution, but please don’t walk away feeling that you’re stupid. You’re not the one with the problem; the problem is in Node.js’s default behavior.”\r\n\r\n&gt; This section, after some debate, was left in, precisely because I don&#39;t want to give an impression of “It’s easy.” I cut my hands repeatedly while getting things to work, and I don’t want to smooth over difficulties and set you up to believe that getting Node.js and its ecosystem to function well is a straightforward matter and if it’s not straightforward for you too, you don’t know what you’re doing. If you don’t run into obnoxious difficulties using Node.js, that’s wonderful. If you do, I would hope that you don’t walk away feeling, “I’m stupid—there must be something wrong with me.” You’re not stupid if you experience nasty surprises dealing with Node.js. It’s not you! It’s Node.js and its ecosystem!\r\n\r\nThe Appendix, which I did not really want after the rising crescendo in the last chapters and the conclusion, talks about what I was able to find in the ecosystem, and provided a workaround for moronic literalism:\r\n\r\n&gt; Another database that seemed like a perfect fit, and may yet be redeemable, is a server-side implementation of the HTML5 key-value store. This approach has the cardinal advantage of an API that most good front-end developers understand well enough. For that matter, it’s also an API that most not-so-good front-end developers understand well enough. But with the node-localstorage package, while dictionary-syntax access is not offered (you want to use localStorage.setItem(key, value) or localStorage.getItem(key), not localStorage[key]), the full localStorage semantics are implemented, including a default 5MB quota—*WHY?* Do server-side JavaScript developers need to be protected from themselves?\r\n\r\n&gt; For client-side database capabilities, a 5MB quota per website is really a generous and useful amount of breathing room to let developers work with it. You could set a much lower quota and still offer developers an immeasurable improvement over limping along with cookie management. A 5MB limit doesn’t lend itself very quickly to Big Data client-side processing, but there is a really quite generous allowance that resourceful developers can use to do a lot. But on the other hand, 5MB is not a particularly large portion of most disks purchased any time recently, meaning that if you and a website disagree about what is reasonable use of disk space, or some site is simply hoggish, it does not really cost you much and you are in no danger of a swamped hard drive unless your hard drive was already too full. Maybe we would be better off if the balance were a little less or a little more, but overall it’s a decent solution to address the intrinsic tension for a client-side context.\r\n\r\n&gt; However, it might gently be pointed out that when you are the one writing code for your server, you don’t need any additional protection from making your database more than a tolerable 5MB in size. Most developers will neither need nor want tools acting as a nanny and protecting them from storing more than 5MB of server-side data. And the 5MB quota that is a golden balancing act on the client-side is rather a bit silly on a Node.js server. (And, for a database for multiple users such as is covered in this Appendix, it might be pointed out, slightly painfully, that that’s not 5MB per user account unless you create a separate database on disk for each user account; that’s 5MB shared between all user accounts together. That could get *painful* if you go viral!) The documentation states that the quota is customizable, but an email a week ago to the developer asking how to change the quota is unanswered, as was the StackOverflow question asking the same. The only answer I have been able to find is in the Github CoffeeScript source, where it is listed as an optional second integer argument to a constructor. So that’s easy enough, and you could specify a quota equal to a disk or partition size. But besides porting a feature that does not make sense, the tool’s author has failed completely to follow a very standard convention of interpreting 0 as meaning “unlimited” for a variable or function where an integer is to specify a maximum limit for some resource use. The best thing to do with this misfeature is probably to specify that the quota is Infinity:\r\n\r\n    if (typeof localStorage === &#39;undefined&#39; || localStorage === null)\r\n      {      \r\n      var LocalStorage = require(&#39;node-localstorage&#39;).LocalStorage;\r\n      localStorage = new LocalStorage(__dirname + &#39;/localStorage&#39;,\r\n        Infinity);\r\n      }\r\n\r\nSwapping two comments in order:\r\n\r\n&gt; People needlessly shot themselves in the foot constantly using JavaScript as a whole, and part of JavaScript being made respectable language was a Douglas Crockford saying in essence, “JavaScript as a language has some really good parts and some really bad parts. Here are the good parts. Just forget that anything else is there.” Perhaps the hot Node.js ecosystem will grow its **own** “Douglas Crockford,” who will say, “The Node.js ecosystem is a coding Wild West, but there are some real gems to be found. Here’s a roadmap. Here are the areas to avoid at almost any cost. Here are the areas with some of the richest paydirt to be found in ANY language or environment.”\r\n\r\n&gt; Perhaps someone else can take those words as a challenge, and follow Crockford’s lead and write up “the good parts” and / or “the better parts” for Node.js and its ecosystem. I’d buy a copy!\r\n\r\n&gt; And given the degree of enthusiasm and sheer work-hours on all projects, it may be warranted in a year, or two, or three, to sharply temper any remarks about an immature ecosystem made at the time of this writing. It really may make sense in five years to say, “The 2015 Node.js ecosystem had several minefields. The 2020 Node.js ecosystem has multiple paradises.”"},{"score":-2,"body_markdown":"I can share few points where&amp;why to use node js.\r\n\r\n 1. For realtime applications like chat,collaborative editing better we go with nodejs as it is event base where fire event and data to clients from server. \r\n 2. Simple and easy to understand as it is javascript base where most of people have idea.\r\n 3. Most of current web applications going towards  angular js&amp;backbone, with node it is easy to interact with client side code as both will use json data. \r\n 4. Lot of plugins available.\r\n\r\nDrawbacks:-\r\n\r\n 1. Node will support most of databases but best is mongodb which won&#39;t support complex joins and others.\r\n 2. Compilation Errors...developer should handle each and every exceptions other wise if any error accord application will stop working  where again we need to go and start it manually or using  any automation tool. \r\n\r\nConclusion:- \r\nNodejs best to use for simple and real time applications..if you have very big business logic and complex functionality better should not use nodejs.\r\nIf you want to build an application along with chat and any collaborative functionality.. node can be used in specific parts and remain should go with your convenience technology."}],"score":2195}