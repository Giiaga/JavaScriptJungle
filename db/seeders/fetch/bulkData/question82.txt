{"body":"What is the preferred syntax for defining enums in JavaScript? Something like:\r\n\r\n    my.namespace.ColorEnum = {\r\n        RED : 0,\r\n        GREEN : 1,\r\n        BLUE : 2\r\n    }\r\n\r\n    // later on\r\n\r\n    if(currentColor == my.namespace.ColorEnum.RED) {\r\n       // whatever\r\n    }\r\n\r\nOr is there a more preferable idiom?","title":"What is the preferred syntax for defining enums in JavaScript?","answers":[{"score":613,"body_markdown":"This isn&#39;t much of an answer, but I&#39;d say that works just fine, personally\r\n\r\nHaving said that, since it doesn&#39;t matter what the values are (you&#39;ve used 0, 1, 2), I&#39;d use a meaningful string in case you ever wanted to output the current value."},{"score":85,"body_markdown":"Bottom line: You can&#39;t. \r\n\r\nYou can fake it, but you won&#39;t get type safety. Typically this is done by creating a simple dictionary of string values mapped to integer values. For example:\r\n\r\n    var DaysEnum = {&quot;monday&quot;:1, &quot;tuesday&quot;:2, &quot;wednesday&quot;:3, ...}\r\n    \r\n    Document.Write(&quot;Enumerant: &quot; + DaysEnum.tuesday);\r\n\r\nThe problem with this approach? You can accidentally redefine your enumerant, or accidentally have duplicate enumerant values. For example:\r\n\r\n    DaysEnum.monday = 4; // whoops, monday is now thursday, too\r\n\r\n**Edit**  \r\n&gt;What about Artur Czajka&#39;s Object.freeze? Wouldn&#39;t that work to prevent you from setting monday to thursday? â€“ Fry Quad \r\n\r\nAbsolutely, [`Object.freeze`][1] would totally fix the problem I complained about. I would like to remind everyone that when I wrote the above, `Object.freeze` didn&#39;t really exist. \r\n\r\nNow.... now it opens up some *very* interesting possibilities. \r\n\r\n**Edit 2**  \r\nHere&#39;s a very good library for creating enums. \r\n\r\nhttp://www.2ality.com/2011/10/enums.html\r\n\r\nWhile it probably doesn&#39;t fit every valid use of enums, it goes a very long way. \r\n\r\n\r\n  [1]: http://msdn.microsoft.com/en-us/library/windows/apps/ff806186%28v=vs.94%29.aspx"},{"score":510,"body_markdown":"## UPDATE\r\nThanks for all the upvotes everyone, but I don&#39;t think my answer below is the best way to write enums in JavaScript anymore. See my blog post for more details: [Enums in JavaScript][1].\r\n\r\n---\r\n\r\nAlerting the name is already possible:\r\n\r\n    if (currentColor == my.namespace.ColorEnum.RED) {\r\n       // alert name of currentColor (RED: 0)\r\n       var col = my.namespace.ColorEnum;\r\n       for (var name in col) {\r\n         if (col[name] == col.RED)\r\n           alert(name);\r\n       }\r\n    }\r\n\r\nAlternatively, you could make the values objects, so you can have the cake and eat it too:\r\n\r\n    var SIZE = {\r\n      SMALL : {value: 0, name: &quot;Small&quot;, code: &quot;S&quot;}, \r\n      MEDIUM: {value: 1, name: &quot;Medium&quot;, code: &quot;M&quot;}, \r\n      LARGE : {value: 2, name: &quot;Large&quot;, code: &quot;L&quot;}\r\n    };\r\n    \r\n    var currentSize = SIZE.MEDIUM;\r\n    if (currentSize == SIZE.MEDIUM) {\r\n      // this alerts: &quot;1: Medium&quot;\r\n      alert(currentSize.value + &quot;: &quot; + currentSize.name);\r\n    }\r\n\r\nIn JavaScript, as it is a dynamic language, it is even possible to add enum values to the set later:\r\n\r\n    // Add EXTRALARGE size\r\n    SIZE.EXTRALARGE = {value: 3, name: &quot;Extra Large&quot;, code: &quot;XL&quot;};\r\n\r\nRemember, the fields of the enum (value, name and code in this example) are not needed for the identity check and are only there for convenience. Also the name of the size property itself does not need to be hard coded, but can also be set dynamically. So supposing you only know the name for your new enum value, you can still add it without problems:\r\n\r\n    // Add &#39;Extra Large&#39; size, only knowing it&#39;s name\r\n    var name = &quot;Extra Large&quot;;\r\n    SIZE[name] = {value: -1, name: name, code: &quot;?&quot;};\r\n\r\nOf course this means that some assumptions can no longer be made (that value represents the correct order for the size for example). \r\n\r\nRemember, in JavaScript an object is just like a *map* or *hash table*. A set of name-value pairs. You can loop through them or otherwise manipulate them without knowing much about them in advance.\r\n\r\n## Example\r\n\r\n    for (var sz in SIZE) {\r\n      // sz will be the names of the objects in SIZE, so\r\n      // &#39;SMALL&#39;, &#39;MEDIUM&#39;, &#39;LARGE&#39;, &#39;EXTRALARGE&#39;\r\n      var size = SIZE[sz]; // Get the object mapped to the name in sz\r\n      for (var prop in size) {\r\n        // Get all the properties of the size object, iterates over\r\n        // &#39;value&#39;, &#39;name&#39; and &#39;code&#39;. You can inspect everything this way.        \r\n      }\r\n    } \r\n\r\nAnd by the way, if you are interested in namespaces, you may want to have a look at my solution for simple but powerful namespace and dependency management for JavaScript: [Packages JS][2]\r\n\r\n  [1]: https://stijndewitt.com/2014/01/26/enums-in-javascript/\r\n  [2]: http://packagesinjavascript.wordpress.com/"},{"score":985,"body_markdown":"Since 1.8.5 it&#39;s possible to [seal and freeze the object](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/freeze), so define the above as:\r\n\r\n    const DaysEnum = Object.freeze({&quot;monday&quot;:1, &quot;tuesday&quot;:2, &quot;wednesday&quot;:3, ...})\r\n\r\nor\r\n\r\n    const DaysEnum = {&quot;monday&quot;:1, &quot;tuesday&quot;:2, &quot;wednesday&quot;:3, ...}\r\n    Object.freeze(DaysEnum)\r\n\r\nand voila! JS enums.\r\n\r\nHowever, this doesn&#39;t prevent you from assigning an undesired value to a variable, which is often the main goal of enums:\r\n\r\n    let day = DaysEnum.tuesday\r\n    day = 298832342 // goes through without any errors\r\n\r\nOne way to ensure a stronger degree of type safety (with enums or otherwise) is to use a tool like [TypeScript][1] or [Flow][2].\r\n\r\nQuotes aren&#39;t needed but I kept them for consistency.\r\n\r\n\r\n  [1]: https://www.typescriptlang.org/\r\n  [2]: https://flow.org/"},{"score":58,"body_markdown":"Here&#39;s what we all want:\r\n\r\n    function Enum(constantsList) {\r\n    \tfor (var i in constantsList) {\r\n    \t\tthis[constantsList[i]] = i;\r\n    \t}\r\n    }\r\n\r\nNow you can create your enums:\r\n\r\n    var YesNo = new Enum([&#39;NO&#39;, &#39;YES&#39;]);\r\n    var Color = new Enum([&#39;RED&#39;, &#39;GREEN&#39;, &#39;BLUE&#39;]);\r\n\r\nBy doing this, constants can be acessed in the usual way (YesNo.YES, Color.GREEN) and they get a sequential int value (NO = 0, YES = 1; RED = 0, GREEN = 1, BLUE = 2).\r\n\r\nYou can also add methods, by using Enum.prototype:\r\n\r\n    Enum.prototype.values = function() {\r\n        return this.allValues;\r\n        /* for the above to work, you&#39;d need to do\r\n                this.allValues = constantsList at the constructor */\r\n    };\r\n\r\n\r\n&lt;br&gt;\r\nEdit - small improvement - now with varargs: (unfortunately it doesn&#39;t work properly on IE :S... should stick with previous version then)\r\n\r\n    function Enum() {\r\n        for (var i in arguments) {\r\n            this[arguments[i]] = i;\r\n        }\r\n    }\r\n    \r\n    var YesNo = new Enum(&#39;NO&#39;, &#39;YES&#39;);\r\n    var Color = new Enum(&#39;RED&#39;, &#39;GREEN&#39;, &#39;BLUE&#39;);"},{"score":11,"body_markdown":"If you&#39;re using [Backbone][1], you can get full-blown enum functionality (find by id, name, custom members) for free using [Backbone.Collection][2].\r\n\r\n    // enum instance members, optional\r\n    var Color = Backbone.Model.extend({\r\n        print : function() {\r\n            console.log(&quot;I am &quot; + this.get(&quot;name&quot;))\r\n        }\r\n    });\r\n\r\n    // enum creation\r\n    var Colors = new Backbone.Collection([\r\n        { id : 1, name : &quot;Red&quot;, rgb : 0xFF0000},\r\n        { id : 2, name : &quot;Green&quot; , rgb : 0x00FF00},\r\n        { id : 3, name : &quot;Blue&quot; , rgb : 0x0000FF}\r\n    ], {\r\n        model : Color\r\n    });\r\n\r\n    // Expose members through public fields.\r\n    Colors.each(function(color) {\r\n        Colors[color.get(&quot;name&quot;)] = color;\r\n    });\r\n    \r\n    // using\r\n    Colors.Red.print()\r\n\r\n  [1]: http://documentcloud.github.com/backbone/\r\n  [2]: http://documentcloud.github.com/backbone/#Collection"},{"score":15,"body_markdown":"This is the solution that I use.\r\n\r\n    function Enum() {\r\n    \tthis._enums = [];\r\n    \tthis._lookups = {};\r\n    }\r\n    \r\n    Enum.prototype.getEnums = function() {\r\n    \treturn _enums;\r\n    }\r\n\r\n    Enum.prototype.forEach = function(callback){\r\n    \tvar length = this._enums.length;\r\n    \tfor (var i = 0; i &lt; length; ++i){\r\n    \t\tcallback(this._enums[i]);\r\n    \t}\r\n    }\r\n    \r\n    Enum.prototype.addEnum = function(e) {\r\n    \tthis._enums.push(e);\r\n    }\r\n    \r\n    Enum.prototype.getByName = function(name) {\r\n    \treturn this[name];\r\n    }\r\n    \r\n    Enum.prototype.getByValue = function(field, value) {\r\n    \tvar lookup = this._lookups[field];\r\n    \tif(lookup) {\r\n    \t\treturn lookup[value];\r\n    \t} else {\r\n    \t\tthis._lookups[field] = ( lookup = {});\r\n    \t\tvar k = this._enums.length - 1;\r\n    \t\tfor(; k &gt;= 0; --k) {\r\n    \t\t\tvar m = this._enums[k];\r\n    \t\t\tvar j = m[field];\r\n    \t\t\tlookup[j] = m;\r\n    \t\t\tif(j == value) {\r\n    \t\t\t\treturn m;\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \treturn null;\r\n    }\r\n\r\n    function defineEnum(definition) {\r\n    \tvar k;\r\n    \tvar e = new Enum();\r\n    \tfor(k in definition) {\r\n    \t\tvar j = definition[k];\r\n    \t\te[k] = j;\r\n    \t\te.addEnum(j)\r\n    \t}\r\n    \treturn e;\r\n    }\r\n\r\nAnd you define your enums like this:\r\n\r\n    var COLORS = defineEnum({\r\n    \tRED : {\r\n    \t\tvalue : 1,\r\n    \t\tstring : &#39;red&#39;\r\n    \t},\r\n    \tGREEN : {\r\n    \t\tvalue : 2,\r\n    \t\tstring : &#39;green&#39;\r\n    \t},\r\n    \tBLUE : {\r\n    \t\tvalue : 3,\r\n    \t\tstring : &#39;blue&#39;\r\n    \t}\r\n    });\r\n    \r\nAnd this is how you access your enums:\r\n\r\n    COLORS.BLUE.string\r\n    COLORS.BLUE.value\r\n    COLORS.getByName(&#39;BLUE&#39;).string\r\n    COLORS.getByValue(&#39;value&#39;, 1).string\r\n\r\n    COLORS.forEach(function(e){\r\n    \t// do what you want with e\r\n    });\r\n\r\nI usually use the last 2 methods for mapping enums from message objects.\r\n\r\nSome advantages to this approach:\r\n\r\n - Easy to declare enums\r\n - Easy to access your enums\r\n - Your enums can be complex types\r\n - The Enum class has some associative caching if you are using getByValue a lot\r\n\r\nSome disadvantages:\r\n\r\n - Some messy memory management going on in there, as I keep the references to the enums\r\n - Still no type safety\r\n\r\n\r\n\r\n"},{"score":7,"body_markdown":"I&#39;ve modified the solution of Andre &#39;Fi&#39;:\r\n\r\n\r\n      function Enum() {\r\n        var that = this;\r\n        for (var i in arguments) {\r\n            that[arguments[i]] = i;\r\n        }\r\n        this.name = function(value) {\r\n            for (var key in that) {\r\n                if (that[key] == value) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        this.exist = function(value) {\r\n            return (typeof that.name(value) !== &quot;undefined&quot;);\r\n        };\r\n        if (Object.freeze) {\r\n            Object.freeze(that);\r\n        }\r\n      }\r\n\r\nTest:\r\n\r\n    var Color = new Enum(&#39;RED&#39;, &#39;GREEN&#39;, &#39;BLUE&#39;);\r\n    undefined\r\n    Color.name(Color.REDs)\r\n    undefined\r\n    Color.name(Color.RED)\r\n    &quot;RED&quot;\r\n    Color.exist(Color.REDs)\r\n    false\r\n    Color.exist(Color.RED)\r\n    true"},{"score":17,"body_markdown":"This is an old one I know, but the way it has since been implemented via the TypeScript interface is:\r\n\r\n    var MyEnum;\r\n    (function (MyEnum) {\r\n        MyEnum[MyEnum[&quot;Foo&quot;] = 0] = &quot;Foo&quot;;\r\n        MyEnum[MyEnum[&quot;FooBar&quot;] = 2] = &quot;FooBar&quot;;\r\n        MyEnum[MyEnum[&quot;Bar&quot;] = 1] = &quot;Bar&quot;;\r\n    })(MyEnum|| (MyEnum= {}));\r\n\r\nThis enables you to look up on both `MyEnum.Bar` which returns 1, and `MyEnum[1]` which returns &quot;Bar&quot; regardless of the order of declaration."},{"score":23,"body_markdown":"I&#39;ve been playing around with this, as I love my enums. =)\r\n\r\nUsing &lt;code&gt;Object.defineProperty&lt;/code&gt; I think I came up with a somewhat viable solution.\r\n\r\nHere&#39;s a jsfiddle: http://jsfiddle.net/ZV4A6/\r\n\r\nUsing this method.. you should (in theory) be able to call and define enum values for any object, without affecting other attributes of that object.\r\n\r\n    Object.defineProperty(Object.prototype,&#39;Enum&#39;, {\r\n    \tvalue: function() {\r\n    \t\tfor(i in arguments) {\r\n    \t\t\tObject.defineProperty(this,arguments[i], {\r\n    \t\t\t\tvalue:parseInt(i),\r\n    \t\t\t\twritable:false,\r\n    \t\t\t\tenumerable:true,\r\n    \t\t\t\tconfigurable:true\r\n    \t\t\t});\r\n    \t\t}\r\n    \t\treturn this;\r\n    \t},\r\n    \twritable:false,\r\n    \tenumerable:false,\r\n    \tconfigurable:false\r\n    }); \r\n\r\nBecause of the attribute &lt;code&gt;writable:false&lt;/code&gt; this &lt;i&gt;should&lt;/i&gt; make it type safe.\r\n\r\nSo you should be able to create a custom object, then call &lt;code&gt;Enum()&lt;/code&gt; on it. The values assigned start at 0 and increment per item.\r\n\r\n    var EnumColors={};\r\n    EnumColors.Enum(&#39;RED&#39;,&#39;BLUE&#39;,&#39;GREEN&#39;,&#39;YELLOW&#39;);\r\n    EnumColors.RED;    // == 0\r\n    EnumColors.BLUE;   // == 1\r\n    EnumColors.GREEN;  // == 2\r\n    EnumColors.YELLOW; // == 3"},{"score":2,"body_markdown":"I had done it a while ago using a mixture of `__defineGetter__` and `__defineSetter__` or `defineProperty` depending on the JS version.\r\n\r\nHere&#39;s the enum generating function I made: https://gist.github.com/gfarrell/6716853\r\n\r\nYou&#39;d use it like this:\r\n\r\n    var Colours = Enum(&#39;RED&#39;, &#39;GREEN&#39;, &#39;BLUE&#39;);\r\n\r\nAnd it would create an immutable string:int dictionary (an enum)."},{"score":4,"body_markdown":"A quick and simple way would be :\r\n\r\n    var Colors = function(){\r\n\treturn {\r\n\t\t&#39;WHITE&#39;:0,\r\n\t\t&#39;BLACK&#39;:1,\r\n\t\t&#39;RED&#39;:2,\r\n\t\t&#39;GREEN&#39;:3\r\n        }\r\n    }();\r\n\r\n    console.log(Colors.WHITE)  //this prints out &quot;0&quot;\r\n"},{"score":-3,"body_markdown":"You could also try to define a new function and therebefore a new namespace, and add variables to it, like this.\r\n\r\n\r\n    function Color () {};  \r\n    Color.RED = 1;\r\n    Color.YELLOW = 2;\r\n\r\nAs long anybody uses the namespace granted by the function Color, everything will go fine.\r\nIf you know Java, this is kind of old enums : where we use a class or interface only to hold static attributes. If a function, in javascript, is a kind of class, this is pretty much the same approach.\r\n\r\nI thing is a very simple way to define enums.\r\n\r\nHope it helps!\r\n\r\nGreetings.\r\n\r\nVictor.\r\n"},{"score":3,"body_markdown":"As of writing, **October 2014** - so here is a contemporary solution. Am writing the solution as a Node Module, and have included a test using Mocha and Chai, as well as underscoreJS. You can easily ignore these, and just take the Enum code if preferred.\r\n\r\nSeen a lot of posts with overly convoluted libraries etc. The solution to getting enum support in Javascript is so simple it really isn&#39;t needed. Here is the code:\r\n\r\nFile: enums.js\r\n\r\n    _ = require(&#39;underscore&#39;);\r\n    \r\n    var _Enum = function () {\r\n\r\n       var keys = _.map(arguments, function (value) {\r\n          return value;\r\n       });\r\n       var self = {\r\n          keys: keys\r\n       };\r\n       for (var i = 0; i &lt; arguments.length; i++) {\r\n          self[keys[i]] = i;\r\n       }\r\n       return self;\r\n    };\r\n    \r\n    var fileFormatEnum = Object.freeze(_Enum(&#39;CSV&#39;, &#39;TSV&#39;));\r\n    var encodingEnum = Object.freeze(_Enum(&#39;UTF8&#39;, &#39;SHIFT_JIS&#39;));\r\n    \r\n    exports.fileFormatEnum = fileFormatEnum;\r\n    exports.encodingEnum = encodingEnum;\r\n\r\n\r\nAnd a test to illustrate what it gives you:\r\n\r\nfile: enumsSpec.js\r\n\r\n    var chai = require(&quot;chai&quot;),\r\n        assert = chai.assert,\r\n        expect = chai.expect,\r\n        should = chai.should(),\r\n        enums = require(&#39;./enums&#39;),\r\n        _ = require(&#39;underscore&#39;);\r\n    \r\n    \r\n    describe(&#39;enums&#39;, function () {\r\n    \r\n        describe(&#39;fileFormatEnum&#39;, function () {\r\n            it(&#39;should return expected fileFormat enum declarations&#39;, function () {\r\n                var fileFormatEnum = enums.fileFormatEnum;\r\n                should.exist(fileFormatEnum);\r\n                assert(&#39;{&quot;keys&quot;:[&quot;CSV&quot;,&quot;TSV&quot;],&quot;CSV&quot;:0,&quot;TSV&quot;:1}&#39; === JSON.stringify(fileFormatEnum), &#39;Unexpected format&#39;);\r\n                assert(&#39;[&quot;CSV&quot;,&quot;TSV&quot;]&#39; === JSON.stringify(fileFormatEnum.keys), &#39;Unexpected keys format&#39;);\r\n            });\r\n        });\r\n    \r\n        describe(&#39;encodingEnum&#39;, function () {\r\n            it(&#39;should return expected encoding enum declarations&#39;, function () {\r\n                var encodingEnum = enums.encodingEnum;\r\n                should.exist(encodingEnum);\r\n                assert(&#39;{&quot;keys&quot;:[&quot;UTF8&quot;,&quot;SHIFT_JIS&quot;],&quot;UTF8&quot;:0,&quot;SHIFT_JIS&quot;:1}&#39; === JSON.stringify(encodingEnum), &#39;Unexpected format&#39;);\r\n                assert(&#39;[&quot;UTF8&quot;,&quot;SHIFT_JIS&quot;]&#39; === JSON.stringify(encodingEnum.keys), &#39;Unexpected keys format&#39;);\r\n            });\r\n        });\r\n    \r\n    });\r\n\r\n\r\nAs you can see, you get an Enum factory, you can get all the keys simply by calling enum.keys, and you can match the keys themselves to integer constants. And you can reuse the factory with different values, and export those generated Enums using Node&#39;s modular approach. \r\n\r\nOnce again, if you are just a casual user, or in the browser etc, just take the factory part of the code, potentially removing underscore library too if you don&#39;t wish to use it in your code."},{"score":8,"body_markdown":"your answers are far too complicated\r\n\r\n    var buildSet = function(array) {\r\n      var set = {};\r\n      for (var i in array) {\r\n        var item = array[i];\r\n        set[item] = item;\r\n      }\r\n      return set;\r\n    }\r\n\r\n    var myEnum = buildSet([&#39;RED&#39;,&#39;GREEN&#39;,&#39;BLUE&#39;]);\r\n    // myEnum.RED == &#39;RED&#39; ...etc"},{"score":1,"body_markdown":"Really like what @Duncan did above, but I don&#39;t like mucking up global Object function space with Enum, so I wrote the following:\r\n\r\n    function mkenum_1()\r\n    {\r\n      var o = new Object();\r\n      var c = -1;\r\n      var f = function(e, v) { Object.defineProperty(o, e, { value:v, writable:false, enumerable:true, configurable:true })};\r\n\r\n      for (i in arguments) {\r\n        var e = arguments[i];\r\n        if ((!!e) &amp; (e.constructor == Object))\r\n          for (j in e)\r\n            f(j, (c=e[j]));\r\n        else\r\n          f(e, ++c);\r\n        }\r\n\r\n      return Object.freeze ? Object.freeze(o) : o;\r\n    }\r\n    \r\n    var Sizes = mkenum_1(&#39;SMALL&#39;,&#39;MEDIUM&#39;,{LARGE: 100},&#39;XLARGE&#39;);\r\n    \r\n    console.log(&quot;MED := &quot; + Sizes.MEDIUM);\r\n    console.log(&quot;LRG := &quot; + Sizes.LARGE);\r\n    \r\n    // Output is:\r\n    // MED := 1\r\n    // LRG := 100\r\n\r\n@Stijin also has a neat solution (referring to his blog) which includes properties on these objects. I wrote some code for that, too, which I&#39;m including next.\r\n\r\n    function mkenum_2(seed)\r\n    {\r\n        var p = {};\r\n    \r\n        console.log(&quot;Seed := &quot; + seed);\r\n    \r\n        for (k in seed) {\r\n            var v = seed[k];\r\n    \r\n            if (v instanceof Array)\r\n                p[(seed[k]=v[0])] = { value: v[0], name: v[1], code: v[2] };\r\n            else\r\n                p[v] = { value: v, name: k.toLowerCase(), code: k.substring(0,1) };\r\n        }\r\n        seed.properties = p;\r\n    \r\n        return Object.freeze ? Object.freeze(seed) : seed;\r\n    }\r\nThis version produces an additional property list allowing friendly name conversion and short codes.  I like this version because one need not duplicate data entry in properties as the code does it for you.\r\n\r\n    var SizeEnum2 = mkenum_2({ SMALL: 1, MEDIUM: 2, LARGE: 3});\r\n    var SizeEnum3 = mkenum_2({ SMALL: [1, &quot;small&quot;, &quot;S&quot;], MEDIUM: [2, &quot;medium&quot;, &quot;M&quot;], LARGE: [3, &quot;large&quot;, &quot;L&quot;] });\r\n\r\nThese two can be combined into a single processing unit, mkenum, (consume enums, assign values, create and add property list).  However, as I&#39;ve spent far too much time on this today already, I will leave the combination as an exercise for the dear reader."},{"score":5,"body_markdown":"    var ColorEnum = {\r\n        red: {},\r\n        green: {},\r\n        blue: {}\r\n    }\r\n\r\nYou don&#39;t need to make sure you don&#39;t assign duplicate numbers to different enum values this way. A new object gets instantiated and assigned to all enum values."},{"score":1,"body_markdown":"You can use [Object.prototype.hasOwnProperty()][1] \r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var findInEnum,\r\n        colorEnum = {\r\n        red : 0,\r\n        green : 1,\r\n        blue : 2\r\n    };\r\n\r\n    // later on\r\n\r\n    findInEnum = function (enumKey) {\r\n      if (colorEnum.hasOwnProperty(enumKey)) {\r\n        return enumKey+&#39; Value: &#39; + colorEnum[enumKey]\r\n      }\r\n    }\r\n\r\n    alert(findInEnum(&quot;blue&quot;))\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"},{"score":4,"body_markdown":"Here&#39;s a couple different ways to implement [TypeScript enums][1].\r\n\r\nThe easiest way is to just iterate over an object, adding inverted key-value pairs to the object. The only drawback is that you must manually set the value for each member.\r\n\r\n    function _enum(list) {       \r\n      for (var key in list) {\r\n        list[list[key] = list[key]] = key;\r\n      }\r\n      return Object.freeze(list);\r\n    }\r\n\r\n    var Color = _enum({\r\n      Red: 0,\r\n      Green: 5,\r\n      Blue: 2\r\n    });\r\n    \r\n    // Color â†’ {0: &quot;Red&quot;, 2: &quot;Blue&quot;, 5: &quot;Green&quot;, &quot;Red&quot;: 0, &quot;Green&quot;: 5, &quot;Blue&quot;: 2}\r\n    // Color.Red â†’ 0\r\n    // Color.Green â†’ 5\r\n    // Color.Blue â†’ 2\r\n    // Color[5] â†’ Green\r\n    // Color.Blue &gt; Color.Green â†’ false\r\n\r\n\r\n&lt;br&gt;\r\nAnd here&#39;s a [lodash mixin][2] to create an enum using a string. While this version is a little bit more involved, it does the numbering automatically for you. All the lodash methods used in this example have a regular JavaScript equivalent, so you can easily switch them out if you want.\r\n\r\n\r\n    function enum() {\r\n        var key, val = -1, list = {};\r\n        _.reduce(_.toArray(arguments), function(result, kvp) {    \r\n            kvp = kvp.split(&quot;=&quot;);\r\n            key = _.trim(kvp[0]);\r\n            val = _.parseInt(kvp[1]) || ++val;            \r\n            result[result[val] = key] = val;\r\n            return result;\r\n        }, list);\r\n        return Object.freeze(list);\r\n    }    \r\n\r\n    // Add enum to lodash \r\n    _.mixin({ &quot;enum&quot;: enum });\r\n\r\n    var Color = _.enum(\r\n        &quot;Red&quot;,\r\n        &quot;Green&quot;,\r\n        &quot;Blue = 5&quot;,\r\n        &quot;Yellow&quot;,\r\n        &quot;Purple = 20&quot;,\r\n        &quot;Gray&quot;\r\n    );\r\n\r\n    // Color.Red â†’ 0\r\n    // Color.Green â†’ 1\r\n    // Color.Blue â†’ 5\r\n    // Color.Yellow â†’ 6\r\n    // Color.Purple â†’ 20\r\n    // Color.Gray â†’ 21\r\n    // Color[5] â†’ Blue\r\n\r\n\r\n  [1]: http://www.typescriptlang.org/Handbook#basic-types-enum\r\n  [2]: https://lodash.com/docs#mixin"},{"score":1,"body_markdown":"What is an enum in **my** opinion: It&#39;s an immutable object that is always accessible and you can compare items with eachother, but the items have common properties/methods, but the objects themselves or the values cannot be changed and they are instantiated only once.\r\n\r\nEnums are imho used for comparing datatypes, settings, actions to take/reply things like that. \r\n\r\nSo for this you need objects with the same instance so you can check if it is a enum type `if(something instanceof enum)`\r\nAlso if you get an enum object you want to be able to do stuff with it, regardless of the enum type, it should always respond in the same way.\r\n\r\nIn my case its comparing values of datatypes, but it could be anything, from modifying blocks in facing direction in a 3d game to passing values on to a specific object type registry.\r\n\r\nKeeping in mind it is javascript and doesn&#39;t provide fixed enum type, you end up always making your own implementation and as this thread shows there are legions of implementations without one being the absoulte correct.\r\n\r\n\r\n----------\r\n\r\n\r\nThis is what I use for Enums. Since enums are immutable(or should be at least heh) I freeze the objects so they can&#39;t be manipulated easely.\r\n\r\nThe enums can be used by EnumField.STRING and they have their own methods that will work with their types.\r\nTo test if something passed to an object you can use `if(somevar instanceof EnumFieldSegment)`\r\n\r\nIt may not be the most elegant solution and i&#39;m open for improvements, but this type of immutable enum(unless you unfreeze it) is exactly the usecase I needed.\r\n\r\nI also realise I could have overridden the prototype with a {} but my mind works better with this format ;-) shoot me.\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n     * simple parameter object instantiator\r\n     * @param name\r\n     * @param value\r\n     * @returns\r\n     */\r\n    function p(name,value) {\r\n    \tthis.name = name;\r\n    \tthis.value = value;\r\n    \treturn Object.freeze(this);\r\n    }\r\n    /**\r\n     * EnumFieldSegmentBase\r\n     */\r\n    function EnumFieldSegmentBase() {\r\n    \tthis.fieldType = &quot;STRING&quot;;\r\n    }\r\n    function dummyregex() {\r\n    }\r\n    dummyregex.prototype.test = function(str) {\r\n    \tif(this.fieldType === &quot;STRING&quot;) {\r\n    \t\tmaxlength = arguments[1];\r\n    \t\treturn str.length &lt;= maxlength;\r\n    \t}\r\n    \treturn true;\r\n    };\r\n    \r\n    dummyregexposer = new dummyregex();\r\n    EnumFieldSegmentBase.prototype.getInputRegex = function() { \r\n    \tswitch(this.fieldType) {\r\n    \t\tcase &quot;STRING&quot; : \treturn dummyregexposer;  \r\n    \t\tcase &quot;INT&quot;: \t\treturn /^(\\d+)?$/;\r\n    \t\tcase &quot;DECIMAL2&quot;:\treturn /^\\d+(\\.\\d{1,2}|\\d+|\\.)?$/;\r\n    \t\tcase &quot;DECIMAL8&quot;: \treturn /^\\d+(\\.\\d{1,8}|\\d+|\\.)?$/;\r\n    \t\t// boolean is tricky dicky. if its a boolean false, if its a string if its empty 0 or false its  false, otherwise lets see what Boolean produces\r\n    \t\tcase &quot;BOOLEAN&quot;: \treturn dummyregexposer;\r\n    \t}\r\n    };\r\n    EnumFieldSegmentBase.prototype.convertToType = function($input) {\r\n    \tvar val = $input;\r\n    \tswitch(this.fieldType) {\r\n    \t\tcase &quot;STRING&quot; : \t\tval = $input;break;\r\n    \t\tcase &quot;INT&quot;: \t\tval==&quot;&quot;? val=0 :val = parseInt($input);break;\r\n    \t\tcase &quot;DECIMAL2&quot;:\tif($input === &quot;&quot; || $input === null) {$input = &quot;0&quot;}if($input.substr(-1) === &quot;.&quot;){$input = $input+0};val = new Decimal2($input).toDP(2);break;\r\n    \t\tcase &quot;DECIMAL8&quot;: \tif($input === &quot;&quot; || $input === null) {$input = &quot;0&quot;}if($input.substr(-1) === &quot;.&quot;){$input = $input+0};val = new Decimal8($input).toDP(8);break;\r\n    \t\t// boolean is tricky dicky. if its a boolean false, if its a string if its empty 0 or false its  false, otherwise lets see what Boolean produces\r\n    \t\tcase &quot;BOOLEAN&quot;: \tval = (typeof $input == &#39;boolean&#39; ? $input : (typeof $input === &#39;string&#39; ? (($input === &quot;false&quot; || $input === &quot;&quot; || $input === &quot;0&quot;) ? false : true) : new Boolean($input).valueOf()))  ;break;\r\n    \t}\r\n    \treturn val;\r\n    };\r\n    EnumFieldSegmentBase.prototype.convertToString = function($input) {\r\n    \tvar val = $input;\r\n    \tswitch(this.fieldType) {\r\n    \t\tcase &quot;STRING&quot;: \t\tval = $input;break;\r\n    \t\tcase &quot;INT&quot;: \t\tval = $input+&quot;&quot;;break;\r\n    \t\tcase &quot;DECIMAL2&quot;:\tval = $input.toPrecision(($input.toString().indexOf(&#39;.&#39;) === -1 ? $input.toString().length+2 : $input.toString().indexOf(&#39;.&#39;)+2)) ;break;\r\n    \t\tcase &quot;DECIMAL8&quot;: \tval = $input.toPrecision(($input.toString().indexOf(&#39;.&#39;) === -1 ? $input.toString().length+8 : $input.toString().indexOf(&#39;.&#39;)+8)) ;break;\r\n    \t\tcase &quot;BOOLEAN&quot;: \tval = $input ? &quot;true&quot; : &quot;false&quot;  ;break;\r\n    \t}\r\n    \treturn val;\r\n    };\r\n    EnumFieldSegmentBase.prototype.compareValue = function($val1,$val2) {\r\n    \tvar val = false;\r\n    \tswitch(this.fieldType) {\r\n    \t\tcase &quot;STRING&quot;: \t\tval = ($val1===$val2);break;\r\n    \t\tcase &quot;INT&quot;: \t\tval = ($val1===$val2);break;\r\n    \t\tcase &quot;DECIMAL2&quot;:\tval = ($val1.comparedTo($val2)===0);break;\r\n    \t\tcase &quot;DECIMAL8&quot;: \tval = ($val1.comparedTo($val2)===0);break;\r\n    \t\tcase &quot;BOOLEAN&quot;: \tval = ($val1===$val2);break;\r\n    \t}\r\n    \treturn val;\r\n    };\r\n    \r\n    /**\r\n     * EnumFieldSegment is an individual segment in the \r\n     * EnumField\r\n     * @param $array An array consisting of object p\r\n     */\r\n    function EnumFieldSegment() {\r\n    \tfor(c=0;c&lt;arguments.length;c++) {\r\n    \t\tif(arguments[c] instanceof p) {\r\n    \t\t\tthis[arguments[c].name] = arguments[c].value;\r\n    \t\t}\r\n    \t}\r\n    \treturn Object.freeze(this); \r\n    }\r\n    EnumFieldSegment.prototype = new EnumFieldSegmentBase();\r\n    EnumFieldSegment.prototype.constructor = EnumFieldSegment;\r\n    \r\n    \r\n    /**\r\n     * Simple enum to show what type of variable a Field type is.\r\n     * @param STRING\r\n     * @param INT\r\n     * @param DECIMAL2\r\n     * @param DECIMAL8\r\n     * @param BOOLEAN\r\n     * \r\n     */\r\n    EnumField = Object.freeze({STRING: \t\tnew EnumFieldSegment(new p(&quot;fieldType&quot;,&quot;STRING&quot;)), \r\n    \t\t\t\t\t\t\tINT: \t\tnew EnumFieldSegment(new p(&quot;fieldType&quot;,&quot;INT&quot;)), \r\n    \t\t\t\t\t\t\tDECIMAL2: \tnew EnumFieldSegment(new p(&quot;fieldType&quot;,&quot;DECIMAL2&quot;)), \r\n    \t\t\t\t\t\t\tDECIMAL8: \tnew EnumFieldSegment(new p(&quot;fieldType&quot;,&quot;DECIMAL8&quot;)), \r\n    \t\t\t\t\t\t\tBOOLEAN:\tnew EnumFieldSegment(new p(&quot;fieldType&quot;,&quot;BOOLEAN&quot;))});"},{"score":4,"body_markdown":"I&#39;ve just published an NPM package [gen_enum][1] allows you to create Enum data structure in Javascript quickly:\r\n\r\n    var genEnum = require(&#39;gen_enum&#39;);\r\n    \r\n    var AppMode = genEnum(&#39;SIGN_UP, LOG_IN, FORGOT_PASSWORD&#39;);\r\n    var curMode = AppMode.LOG_IN;\r\n    console.log(curMode.isLogIn()); // output true \r\n    console.log(curMode.isSignUp()); // output false \r\n    console.log(curMode.isForgotPassword()); // output false \r\n\r\nOne nice thing about this little tool is in modern environment (including nodejs and IE 9+ browsers) the returned Enum object is immutable.\r\n\r\nFor more information please checkout https://github.com/greenlaw110/enumjs\r\n\r\n**Updates**\r\n\r\nI obsolete `gen_enum` package and merge the function into [constjs][2] package, which provides more features including immutable objects, JSON string deserialization, string constants and bitmap generation etc. Checkout https://www.npmjs.com/package/constjs for more information \r\n\r\nTo upgrade from `gen_enum` to `constjs` just change the statement\r\n\r\n    var genEnum = require(&#39;gen_enum&#39;);\r\n\r\nto\r\n\r\n    var genEnum = require(&#39;constjs&#39;).enum;\r\n\r\n\r\n\r\n  [1]: https://www.npmjs.com/package/gen_enum\r\n  [2]: https://www.npmjs.com/package/constjs"},{"score":0,"body_markdown":"    var DaysEnum = Object.freeze ({ monday: {}, tuesday: {}, ... });\r\n\r\nYou don&#39;t need to specify an *id*, you can just use an empty object to compare enums. \r\n\r\n    if (incommingEnum === DaysEnum.monday) //incommingEnum is monday\r\n\r\n**EDIT:** If you are going to serialize the object (to JSON for instance) you&#39;ll the *id* again.\r\n\r\n- [( taken from Gabriel Llamas comment )][1]\r\n- [( edit based on Stijn de Witt&#39;s comment )][2]\r\n\r\n\r\n  [1]: https://stackoverflow.com/questions/287903/enums-in-javascript#comment12864576_5040502\r\n  [2]: https://stackoverflow.com/questions/287903/enums-in-javascript/30045582?noredirect=1#comment71130974_30045582"},{"score":56,"body_markdown":"In most modern browsers, there is a [symbol][1] primitive data type which can be used to create an enumeration. It will ensure type safety of the enum as each symbol value is guaranteed by JavaScript to be unique, i.e. `Symbol() != Symbol()`. For example:\r\n\r\n    const COLOR = Object.freeze({RED: Symbol(), BLUE: Symbol()});\r\n  \r\nTo simplify debugging, you can add a description to enum values:\r\n\r\n    const COLOR = Object.freeze({RED: Symbol(&quot;RED&quot;), BLUE: Symbol(&quot;BLUE&quot;)});\r\n\r\n[Plunker demo][2]\r\n\r\nOn [GitHub][3] you can find a wrapper that simplifies the code required to initialize the enum:\r\n\r\n    const color = new Enum(&quot;RED&quot;, &quot;BLUE&quot;)\r\n\r\n    color.RED.toString() // Symbol(RED)\r\n    color.getName(color.RED) // RED\r\n    color.size // 2\r\n    color.values() // Symbol(RED), Symbol(BLUE)\r\n    color.toString() // RED,BLUE\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\r\n  [2]: http://plnkr.co/edit/rGjzZlUF4HPdllaTQ3OW?p=preview\r\n  [3]: https://github.com/zhaber/symbol-enum"},{"score":6,"body_markdown":"IE8 does Not support freeze() method.  \r\nSource: http://kangax.github.io/compat-table/es5/, Click on &quot;Show obsolete browsers?&quot; on top, and check IE8 &amp; freeze row col intersection.\r\n\r\nIn my current game project, I have used below, since few customers still use IE8:\r\n\r\n    var CONST_WILD_TYPES = {\r\n        REGULAR: &#39;REGULAR&#39;,\r\n        EXPANDING: &#39;EXPANDING&#39;,\r\n        STICKY: &#39;STICKY&#39;,\r\n        SHIFTING: &#39;SHIFTING&#39;\r\n    };\r\n\r\nWe could also do:  \r\n\r\n    var CONST_WILD_TYPES = {\r\n        REGULAR: &#39;RE&#39;,\r\n        EXPANDING: &#39;EX&#39;,\r\n        STICKY: &#39;ST&#39;,\r\n        SHIFTING: &#39;SH&#39;\r\n    };\r\n\r\nor even this:  \r\n\r\n    var CONST_WILD_TYPES = {\r\n        REGULAR: &#39;1&#39;,\r\n        EXPANDING: &#39;2&#39;,\r\n        STICKY: &#39;3&#39;,\r\n        SHIFTING: &#39;4&#39;\r\n    };\r\n\r\nThe last one, seems most efficient for string, it reduces your total bandwidth if you have server &amp; client exchanging this data.  \r\nOf course, now it&#39;s your duty to make sure there are no conflicts in the data (RE, EX, etc. must be unique, also 1, 2, etc. should be unique). Note that you need to maintain these forever for backward compatibility.  \r\n\r\nAssignment:\r\n\r\n    var wildType = CONST_WILD_TYPES.REGULAR;\r\n\r\nComparision:\r\n\r\n    if (wildType === CONST_WILD_TYPES.REGULAR) {\r\n        // do something here\r\n    }\r\n"},{"score":15,"body_markdown":"Create an object literal:\r\n    \r\n    const Modes = {\r\n      DRAGGING: &#39;drag&#39;,\r\n      SCALING:  &#39;scale&#39;,\r\n      CLICKED:  &#39;click&#39;\r\n    };"},{"score":3,"body_markdown":"It&#39;s easy to use, I think. https://stackoverflow.com/a/32245370/4365315\r\n\r\n    var A = {a:11, b:22}, \r\n    enumA = new TypeHelper(A);\r\n    \r\n    if(enumA.Value === A.b || enumA.Key === &quot;a&quot;){ \r\n    ... \r\n    }\r\n    \r\n    var keys = enumA.getAsList();//[object, object]\r\n    \r\n    //set\r\n    enumA.setType(22, false);//setType(val, isKey)\r\n    \r\n    enumA.setType(&quot;a&quot;, true);\r\n    \r\n    enumA.setTypeByIndex(1);\r\n\r\nUPDATE:\r\n\r\nThere is my helper codes(`TypeHelper`).\r\n\r\n&lt;!-- begin snippet: js hide: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var Helper = {\r\n        isEmpty: function (obj) {\r\n            return !obj || obj === null || obj === undefined || Array.isArray(obj) &amp;&amp; obj.length === 0;\r\n        },\r\n\r\n        isObject: function (obj) {\r\n            return (typeof obj === &#39;object&#39;);\r\n        },\r\n\r\n        sortObjectKeys: function (object) {\r\n            return Object.keys(object)\r\n                .sort(function (a, b) {\r\n                    c = a - b;\r\n                    return c\r\n                });\r\n        },\r\n        containsItem: function (arr, item) {\r\n            if (arr &amp;&amp; Array.isArray(arr)) {\r\n                return arr.indexOf(item) &gt; -1;\r\n            } else {\r\n                return arr === item;\r\n            }\r\n        },\r\n\r\n        pushArray: function (arr1, arr2) {\r\n            if (arr1 &amp;&amp; arr2 &amp;&amp; Array.isArray(arr1)) {\r\n                arr1.push.apply(arr1, Array.isArray(arr2) ? arr2 : [arr2]);\r\n            }\r\n        }\r\n    };\r\n    function TypeHelper() {\r\n        var _types = arguments[0],\r\n            _defTypeIndex = 0,\r\n            _currentType,\r\n            _value,\r\n            _allKeys = Helper.sortObjectKeys(_types);\r\n\r\n        if (arguments.length == 2) {\r\n            _defTypeIndex = arguments[1];\r\n        }\r\n\r\n        Object.defineProperties(this, {\r\n            Key: {\r\n                get: function () {\r\n                    return _currentType;\r\n                },\r\n                set: function (val) {\r\n                    _currentType.setType(val, true);\r\n                },\r\n                enumerable: true\r\n            },\r\n            Value: {\r\n                get: function () {\r\n                    return _types[_currentType];\r\n                },\r\n                set: function (val) {\r\n                    _value.setType(val, false);\r\n                },\r\n                enumerable: true\r\n            }\r\n        });\r\n        this.getAsList = function (keys) {\r\n            var list = [];\r\n            _allKeys.forEach(function (key, idx, array) {\r\n                if (key &amp;&amp; _types[key]) {\r\n\r\n                    if (!Helper.isEmpty(keys) &amp;&amp; Helper.containsItem(keys, key) || Helper.isEmpty(keys)) {\r\n                        var json = {};\r\n                        json.Key = key;\r\n                        json.Value = _types[key];\r\n                        Helper.pushArray(list, json);\r\n                    }\r\n                }\r\n            });\r\n            return list;\r\n        };\r\n\r\n        this.setType = function (value, isKey) {\r\n            if (!Helper.isEmpty(value)) {\r\n                Object.keys(_types).forEach(function (key, idx, array) {\r\n                    if (Helper.isObject(value)) {\r\n                        if (value &amp;&amp; value.Key == key) {\r\n                            _currentType = key;\r\n                        }\r\n                    } else if (isKey) {\r\n                        if (value &amp;&amp; value.toString() == key.toString()) {\r\n                            _currentType = key;\r\n                        }\r\n                    } else if (value &amp;&amp; value.toString() == _types[key]) {\r\n                        _currentType = key;\r\n                    }\r\n                });\r\n            } else {\r\n                this.setDefaultType();\r\n            }\r\n            return isKey ? _types[_currentType] : _currentType;\r\n        };\r\n\r\n        this.setTypeByIndex = function (index) {\r\n            for (var i = 0; i &lt; _allKeys.length; i++) {\r\n                if (index === i) {\r\n                    _currentType = _allKeys[index];\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        this.setDefaultType = function () {\r\n            this.setTypeByIndex(_defTypeIndex);\r\n        };\r\n\r\n        this.setDefaultType();\r\n    }\r\n\r\n    var TypeA = {\r\n        &quot;-1&quot;: &quot;Any&quot;,\r\n        &quot;2&quot;: &quot;2L&quot;,\r\n        &quot;100&quot;: &quot;100L&quot;,\r\n        &quot;200&quot;: &quot;200L&quot;,\r\n        &quot;1000&quot;: &quot;1000L&quot;\r\n    };\r\n\r\n    var enumA = new TypeHelper(TypeA, 4);\r\n\r\n    document.writeln(&quot;Key = &quot;, enumA.Key,&quot;, Value = &quot;, enumA.Value, &quot;&lt;br&gt;&quot;);\r\n\r\n\r\n    enumA.setType(&quot;200L&quot;, false);\r\n    document.writeln(&quot;Key = &quot;, enumA.Key,&quot;, Value = &quot;, enumA.Value, &quot;&lt;br&gt;&quot;);\r\n\r\n    enumA.setDefaultType();\r\n    document.writeln(&quot;Key = &quot;, enumA.Key,&quot;, Value = &quot;, enumA.Value, &quot;&lt;br&gt;&quot;);\r\n\r\n\r\n    enumA.setTypeByIndex(1);\r\n    document.writeln(&quot;Key = &quot;, enumA.Key,&quot;, Value = &quot;, enumA.Value, &quot;&lt;br&gt;&quot;);\r\n\r\n    document.writeln(&quot;is equals = &quot;, (enumA.Value == TypeA[&quot;2&quot;]));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n\r\n   \r\n    "},{"score":7,"body_markdown":"I came up with [this](https://github.com/vivin/enumjs) approach which is modeled after enums in Java. These are type-safe, and so you can perform `instanceof` checks as well.\r\n\r\nYou can define enums like this:\r\n\r\n    var Days = Enum.define(&quot;Days&quot;, [&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;]);\r\n\r\n`Days` now refers to the `Days` enum:\r\n    \r\n    Days.Monday instanceof Days; // true\r\n    \r\n    Days.Friday.name(); // &quot;Friday&quot;\r\n    Days.Friday.ordinal(); // 4\r\n    \r\n    Days.Sunday === Days.Sunday; // true\r\n    Days.Sunday === Days.Friday; // false\r\n    \r\n    Days.Sunday.toString(); // &quot;Sunday&quot;\r\n    \r\n    Days.toString() // &quot;Days { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday } &quot;\r\n    \r\n    Days.values().map(function(e) { return e.name(); }); //[&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;]\r\n    Days.values()[4].name(); //&quot;Friday&quot;\r\n    \r\n    Days.fromName(&quot;Thursday&quot;) === Days.Thursday // true\r\n    Days.fromName(&quot;Wednesday&quot;).name() // &quot;Wednesday&quot;\r\n    Days.Friday.fromName(&quot;Saturday&quot;).name() // &quot;Saturday&quot;\r\n\r\nThe implementation:\r\n\r\n    var Enum = (function () {\r\n        /**\r\n         * Function to define an enum\r\n         * @param typeName - The name of the enum.\r\n         * @param constants - The constants on the enum. Can be an array of strings, or an object where each key is an enum\r\n         * constant, and the values are objects that describe attributes that can be attached to the associated constant.\r\n         */\r\n        function define(typeName, constants) {\r\n    \r\n            /** Check Arguments **/\r\n            if (typeof typeName === &quot;undefined&quot;) {\r\n                throw new TypeError(&quot;A name is required.&quot;);\r\n            }\r\n    \r\n            if (!(constants instanceof Array) &amp;&amp; (Object.getPrototypeOf(constants) !== Object.prototype)) {\r\n    \r\n                throw new TypeError(&quot;The constants parameter must either be an array or an object.&quot;);\r\n    \r\n            } else if ((constants instanceof Array) &amp;&amp; constants.length === 0) {\r\n    \r\n                throw new TypeError(&quot;Need to provide at least one constant.&quot;);\r\n    \r\n            } else if ((constants instanceof Array) &amp;&amp; !constants.reduce(function (isString, element) {\r\n                    return isString &amp;&amp; (typeof element === &quot;string&quot;);\r\n                }, true)) {\r\n    \r\n                throw new TypeError(&quot;One or more elements in the constant array is not a string.&quot;);\r\n    \r\n            } else if (Object.getPrototypeOf(constants) === Object.prototype &amp;&amp; !Object.keys(constants).reduce(function (isObject, constant) {\r\n                    return Object.getPrototypeOf(constants[constant]) === Object.prototype;\r\n                }, true)) {\r\n    \r\n                throw new TypeError(&quot;One or more constants do not have an associated object-value.&quot;);\r\n    \r\n            }\r\n    \r\n            var isArray = (constants instanceof Array);\r\n            var isObject = !isArray;\r\n    \r\n            /** Private sentinel-object used to guard enum constructor so that no one else can create enum instances **/\r\n            function __() { };\r\n    \r\n            /** Dynamically define a function with the same name as the enum we want to define. **/\r\n            var __enum = new Function([&quot;__&quot;],\r\n                &quot;return function &quot; + typeName + &quot;(sentinel, name, ordinal) {&quot; +\r\n                    &quot;if(!(sentinel instanceof __)) {&quot; +\r\n                        &quot;throw new TypeError(\\&quot;Cannot instantiate an instance of &quot; + typeName + &quot;.\\&quot;);&quot; +\r\n                    &quot;}&quot; +\r\n    \r\n                    &quot;this.__name = name;&quot; +\r\n                    &quot;this.__ordinal = ordinal;&quot; +\r\n                &quot;}&quot;\r\n            )(__);\r\n    \r\n            /** Private objects used to maintain enum instances for values(), and to look up enum instances for fromName() **/\r\n            var __values = [];\r\n            var __dict = {};\r\n    \r\n            /** Attach values() and fromName() methods to the class itself (kind of like static methods). **/\r\n            Object.defineProperty(__enum, &quot;values&quot;, {\r\n                value: function () {\r\n                    return __values;\r\n                }\r\n            });\r\n    \r\n            Object.defineProperty(__enum, &quot;fromName&quot;, {\r\n                value: function (name) {\r\n                    var __constant = __dict[name]\r\n                    if (__constant) {\r\n                        return __constant;\r\n                    } else {\r\n                        throw new TypeError(typeName + &quot; does not have a constant with name &quot; + name + &quot;.&quot;);\r\n                    }\r\n                }\r\n            });\r\n    \r\n            /**\r\n             * The following methods are available to all instances of the enum. values() and fromName() need to be\r\n             * available to each constant, and so we will attach them on the prototype. But really, they&#39;re just\r\n             * aliases to their counterparts on the prototype.\r\n             */\r\n            Object.defineProperty(__enum.prototype, &quot;values&quot;, {\r\n                value: __enum.values\r\n            });\r\n    \r\n            Object.defineProperty(__enum.prototype, &quot;fromName&quot;, {\r\n                value: __enum.fromName\r\n            });\r\n    \r\n            Object.defineProperty(__enum.prototype, &quot;name&quot;, {\r\n                value: function () {\r\n                    return this.__name;\r\n                }\r\n            });\r\n    \r\n            Object.defineProperty(__enum.prototype, &quot;ordinal&quot;, {\r\n                value: function () {\r\n                    return this.__ordinal;\r\n                }\r\n            });\r\n    \r\n            Object.defineProperty(__enum.prototype, &quot;valueOf&quot;, {\r\n                value: function () {\r\n                    return this.__name;\r\n                }\r\n            });\r\n    \r\n            Object.defineProperty(__enum.prototype, &quot;toString&quot;, {\r\n                value: function () {\r\n                    return this.__name;\r\n                }\r\n            });\r\n    \r\n            /**\r\n             * If constants was an array, we can the element values directly. Otherwise, we will have to use the keys\r\n             * from the constants object.\r\n             */\r\n            var _constants = constants;\r\n            if (isObject) {\r\n                _constants = Object.keys(constants);\r\n            }\r\n    \r\n            /** Iterate over all constants, create an instance of our enum for each one, and attach it to the enum type **/\r\n            _constants.forEach(function (name, ordinal) {\r\n                // Create an instance of the enum\r\n                var __constant = new __enum(new __(), name, ordinal);\r\n    \r\n                // If constants was an object, we want to attach the provided attributes to the instance.\r\n                if (isObject) {\r\n                    Object.keys(constants[name]).forEach(function (attr) {\r\n                        Object.defineProperty(__constant, attr, {\r\n                            value: constants[name][attr]\r\n                        });\r\n                    });\r\n                }\r\n    \r\n                // Freeze the instance so that it cannot be modified.\r\n                Object.freeze(__constant);\r\n    \r\n                // Attach the instance using the provided name to the enum type itself.\r\n                Object.defineProperty(__enum, name, {\r\n                    value: __constant\r\n                });\r\n    \r\n                // Update our private objects\r\n                __values.push(__constant);\r\n                __dict[name] = __constant;\r\n            });\r\n    \r\n            /** Define a friendly toString method for the enum **/\r\n            var string = typeName + &quot; { &quot; + __enum.values().map(function (c) {\r\n                    return c.name();\r\n                }).join(&quot;, &quot;) + &quot; } &quot;;\r\n    \r\n            Object.defineProperty(__enum, &quot;toString&quot;, {\r\n                value: function () {\r\n                    return string;\r\n                }\r\n            });\r\n    \r\n            /** Freeze our private objects **/\r\n            Object.freeze(__values);\r\n            Object.freeze(__dict);\r\n    \r\n            /** Freeze the prototype on the enum and the enum itself **/\r\n            Object.freeze(__enum.prototype);\r\n            Object.freeze(__enum);\r\n    \r\n            /** Return the enum **/\r\n            return __enum;\r\n        }\r\n    \r\n        return {\r\n            define: define\r\n        }\r\n    \r\n    })();"},{"score":3,"body_markdown":"I wrote **enumerationjs** a [very tiny library to address the issue](https://github.com/sveinburne/enumerationjs#top) which **ensures type safety**, allow enum constants to **inherit from a prototype**, guaranties enum constants and enum types to be immutable + many little features. It allows to refactor a lot of code and move some logic inside the enum definition. Here is an example : \r\n\r\n    var CloseEventCodes = new Enumeration(&quot;closeEventCodes&quot;, {\r\n      CLOSE_NORMAL:          { _id: 1000, info: &quot;Connection closed normally&quot; },\r\n      CLOSE_GOING_AWAY:      { _id: 1001, info: &quot;Connection closed going away&quot; },\r\n      CLOSE_PROTOCOL_ERROR:  { _id: 1002, info: &quot;Connection closed due to protocol error&quot;  },\r\n      CLOSE_UNSUPPORTED:     { _id: 1003, info: &quot;Connection closed due to unsupported operation&quot; },\r\n      CLOSE_NO_STATUS:       { _id: 1005, info: &quot;Connection closed with no status&quot; },\r\n      CLOSE_ABNORMAL:        { _id: 1006, info: &quot;Connection closed abnormally&quot; },\r\n      CLOSE_TOO_LARGE:       { _id: 1009, info: &quot;Connection closed due to too large packet&quot; }\r\n    },{ talk: function(){\r\n        console.log(this.info); \r\n      }\r\n    });\r\n\r\n\r\n    CloseEventCodes.CLOSE_TOO_LARGE.talk(); //prints &quot;Connection closed due to too large packet&quot;\r\n    CloseEventCodes.CLOSE_TOO_LARGE instanceof CloseEventCodes //evaluates to true\r\n\r\n`Enumeration` is basically a factory. \r\n\r\n[Fully documented guide available here.](https://github.com/sveinburne/enumerationjs/blob/master/JS.GUIDE.MD#top) Hope this helps. \r\n\r\n"},{"score":4,"body_markdown":"I&#39;ve made an Enum class that can fetch values AND names at O(1). It can also generate an Object Array containing all Names and Values.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function Enum(obj) {\r\n        // Names must be unique, Values do not.\r\n        // Putting same values for different Names is risky for this implementation\r\n    \r\n        this._reserved = {\r\n            _namesObj: {},\r\n            _objArr: [],\r\n            _namesArr: [],\r\n            _valuesArr: [],\r\n            _selectOptionsHTML: &quot;&quot;\r\n        };\r\n    \r\n        for (k in obj) {\r\n            if (obj.hasOwnProperty(k)) {\r\n                this[k] = obj[k];\r\n                this._reserved._namesObj[obj[k]] = k;\r\n            }\r\n        }\r\n    }\r\n    (function () {\r\n        this.GetName = function (val) {\r\n            if (typeof this._reserved._namesObj[val] === &quot;undefined&quot;)\r\n                return null;\r\n            return this._reserved._namesObj[val];\r\n        };\r\n    \r\n        this.GetValue = function (name) {\r\n            if (typeof this[name] === &quot;undefined&quot;)\r\n                return null;\r\n            return this[name];\r\n        };\r\n    \r\n        this.GetObjArr = function () {\r\n            if (this._reserved._objArr.length == 0) {\r\n                var arr = [];\r\n                for (k in this) {\r\n                    if (this.hasOwnProperty(k))\r\n                        if (k != &quot;_reserved&quot;)\r\n                            arr.push({\r\n                                Name: k,\r\n                                Value: this[k]\r\n                            });\r\n                }\r\n                this._reserved._objArr = arr;\r\n            }\r\n            return this._reserved._objArr;\r\n        };\r\n    \r\n        this.GetNamesArr = function () {\r\n            if (this._reserved._namesArr.length == 0) {\r\n                var arr = [];\r\n                for (k in this) {\r\n                    if (this.hasOwnProperty(k))\r\n                        if (k != &quot;_reserved&quot;)\r\n                            arr.push(k);\r\n                }\r\n                this._reserved._namesArr = arr;\r\n            }\r\n            return this._reserved._namesArr;\r\n        };\r\n    \r\n        this.GetValuesArr = function () {\r\n            if (this._reserved._valuesArr.length == 0) {\r\n                var arr = [];\r\n                for (k in this) {\r\n                    if (this.hasOwnProperty(k))\r\n                        if (k != &quot;_reserved&quot;)\r\n                            arr.push(this[k]);\r\n                }\r\n                this._reserved._valuesArr = arr;\r\n            }\r\n            return this._reserved._valuesArr;\r\n        };\r\n    \r\n        this.GetSelectOptionsHTML = function () {\r\n            if (this._reserved._selectOptionsHTML.length == 0) {\r\n                var html = &quot;&quot;;\r\n                for (k in this) {\r\n                    if (this.hasOwnProperty(k))\r\n                        if (k != &quot;_reserved&quot;)\r\n                            html += &quot;&lt;option value=&#39;&quot; + this[k] + &quot;&#39;&gt;&quot; + k + &quot;&lt;/option&gt;&quot;;\r\n                }\r\n                this._reserved._selectOptionsHTML = html;\r\n            }\r\n            return this._reserved._selectOptionsHTML;\r\n        };\r\n    }).call(Enum.prototype);\r\n\r\n\r\n\r\n\r\n\r\n\r\nYou can init&#39;d it like this:\r\n\r\n    var enum1 = new Enum({\r\n        item1: 0,\r\n        item2: 1,\r\n        item3: 2\r\n    });\r\n\r\nTo fetch a value (like Enums in C#):\r\n\r\n    var val2 = enum1.item2;\r\n\r\nTo fetch a name for a value (can be ambiguous when putting the same value for different names):\r\n\r\n    var name1 = enum1.GetName(0);  // &quot;item1&quot;\r\n\r\nTo get an array with each name &amp; value in an object:\r\n\r\n    var arr = enum1.GetObjArr();\r\n\r\nWill generate:\r\n\r\n    [{ Name: &quot;item1&quot;, Value: 0}, { ... }, ... ]\r\n\r\nYou can also get the html select options readily:\r\n\r\n    var html = enum1.GetSelectOptionsHTML();\r\n\r\nWhich holds:\r\n\r\n    &quot;&lt;option value=&#39;0&#39;&gt;item1&lt;/option&gt;...&quot;"},{"score":2,"body_markdown":"You can try this:\r\n\r\n     \r\n    \r\n       var Enum = Object.freeze({\r\n                Role: Object.freeze({ Administrator: 1, Manager: 2, Supervisor: 3 }),\r\n        \t\tColor:Object.freeze({RED : 0, GREEN : 1, BLUE : 2 })\r\n                });\r\n        \r\n        alert(Enum.Role.Supervisor);\r\n        alert(Enum.Color.GREEN);\r\n        var currentColor=0;\r\n        if(currentColor == Enum.Color.RED) {\r\n           alert(&#39;Its Red&#39;);\r\n        }"},{"score":4,"body_markdown":"You can do something like this\r\n\r\n\r\n        var Enum = (function(foo) {\r\n    \r\n        var EnumItem = function(item){\r\n            if(typeof item == &quot;string&quot;){\r\n                this.name = item;\r\n            } else {\r\n                this.name = item.name;\r\n            }\r\n        }\r\n        EnumItem.prototype = new String(&quot;DEFAULT&quot;);\r\n        EnumItem.prototype.toString = function(){\r\n            return this.name;\r\n        }\r\n        EnumItem.prototype.equals = function(item){\r\n            if(typeof item == &quot;string&quot;){\r\n                return this.name == item;\r\n            } else {\r\n                return this == item &amp;&amp; this.name == item.name;\r\n            }\r\n        }\r\n    \r\n        function Enum() {\r\n            this.add.apply(this, arguments);\r\n            Object.freeze(this);\r\n        }\r\n        Enum.prototype.add = function() {\r\n            for (var i in arguments) {\r\n                var enumItem = new EnumItem(arguments[i]);\r\n                this[enumItem.name] = enumItem;\r\n            }\r\n        };\r\n        Enum.prototype.toList = function() {\r\n            return Object.keys(this);\r\n        };\r\n        foo.Enum = Enum;\r\n        return Enum;\r\n    })(this);\r\n    var STATUS = new Enum(&quot;CLOSED&quot;,&quot;PENDING&quot;, { name : &quot;CONFIRMED&quot;, ackd : true });\r\n    var STATE = new Enum(&quot;CLOSED&quot;,&quot;PENDING&quot;,&quot;CONFIRMED&quot;,{ name : &quot;STARTED&quot;},{ name : &quot;PROCESSING&quot;});\r\n\r\nAs defined in this library.\r\nhttps://github.com/webmodule/foo/blob/master/foo.js#L217\r\n\r\nComplete example\r\nhttps://gist.github.com/lnt/bb13a2fd63cdb8bce85fd62965a20026\r\n"},{"score":4,"body_markdown":"**Simplest solution:**\r\n\r\nCreate\r\n------\r\n\r\n    var Status = Object.freeze({\r\n        &quot;Connecting&quot;:0,\r\n        &quot;Ready&quot;:1,\r\n        &quot;Loading&quot;:2,\r\n        &quot;Processing&quot;: 3\r\n    });\r\n\r\nGet Value\r\n---------\r\n\r\n    console.log(Status.Ready) // 1\r\n\r\nGet Key\r\n---------\r\n\r\n    console.log(Object.keys(Status)[Status.Ready]) // Ready"},{"score":4,"body_markdown":"Even though [only static methods][1] (and not static properties) are supported in ES2015 (see [here][2] as well, &amp;sect;15.2.2.2), curiously you can use the below with Babel with the `es2015` preset:\r\n\r\n    class CellState {\r\n        v: string;\r\n        constructor(v: string) {\r\n            this.v = v;\r\n            Object.freeze(this);\r\n        }\r\n        static EMPTY       = new CellState(&#39;e&#39;);\r\n        static OCCUPIED    = new CellState(&#39;o&#39;);\r\n        static HIGHLIGHTED = new CellState(&#39;h&#39;);\r\n        static values      = function(): Array&lt;CellState&gt; {\r\n            const rv = [];\r\n            rv.push(CellState.EMPTY);\r\n            rv.push(CellState.OCCUPIED);\r\n            rv.push(CellState.HIGHLIGHTED);\r\n            return rv;\r\n        }\r\n    }\r\n    Object.freeze(CellState);\r\n\r\nI found this to be working as expected even across modules (e.g. importing the `CellState` enum from another module) and also when I import a module using Webpack.\r\n\r\n**The advantage this method has over most other answers is that you can use it alongside a static type checker** (e.g. [Flow][3]) and you can assert, at development time using static type checking, that your variables, parameters, etc. are of the specific `CellState` &quot;enum&quot; rather than some other enum (which would be impossible to distinguish if you used generic objects or symbols).\r\n\r\n&lt;h1&gt;update&lt;/h1&gt;\r\nThe above code has a deficiency in that it allows one to create additional objects of type `CellState` (even though one can&#39;t assign them to the static fields of `CellState` since it&#39;s frozen). Still, the below more refined code offers the following advantages:\r\n\r\n 1. no more objects of type `CellState` may be created\r\n 2. you are guaranteed that no two enum instances are assigned the same code\r\n 3. utility method to get the enum back from a string representation\r\n 4. the `values` function that returns all instances of the enum does not have to create the return value in the above, manual (and error-prone) way.\r\n\r\n\r\n\r\n        &#39;use strict&#39;;\r\n     \r\n        class Status {\r\n     \r\n        constructor(code, displayName = code) {\r\n            if (Status.INSTANCES.has(code))\r\n                throw new Error(`duplicate code value: [${code}]`);\r\n            if (!Status.canCreateMoreInstances)\r\n                throw new Error(`attempt to call constructor(${code}`+\r\n               `, ${displayName}) after all static instances have been created`);\r\n            this.code        = code;\r\n            this.displayName = displayName;\r\n            Object.freeze(this);\r\n            Status.INSTANCES.set(this.code, this);\r\n        }\r\n    \r\n        toString() {\r\n            return `[code: ${this.code}, displayName: ${this.displayName}]`;\r\n        }\r\n        static INSTANCES   = new Map();\r\n        static canCreateMoreInstances      = true;\r\n    \r\n        // the values:\r\n        static ARCHIVED    = new Status(&#39;Archived&#39;);\r\n        static OBSERVED    = new Status(&#39;Observed&#39;);\r\n        static SCHEDULED   = new Status(&#39;Scheduled&#39;);\r\n        static UNOBSERVED  = new Status(&#39;Unobserved&#39;);\r\n        static UNTRIGGERED = new Status(&#39;Untriggered&#39;);\r\n    \r\n        static values      = function() {\r\n            return Array.from(Status.INSTANCES.values());\r\n        }\r\n        \r\n        static fromCode(code) {\r\n            if (!Status.INSTANCES.has(code))\r\n                throw new Error(`unknown code: ${code}`);\r\n            else\r\n                return Status.INSTANCES.get(code);\r\n        }\r\n        }\r\n    \r\n        Status.canCreateMoreInstances = false;\r\n        Object.freeze(Status);\r\n        exports.Status = Status;\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes\r\n  [2]: http://exploringjs.com/es6/ch_classes.html#_inside-the-body-of-a-class-definition\r\n  [3]: https://flowtype.org/"},{"score":1,"body_markdown":"The Alien solution is to make things as simple as possible:\r\n\r\n 1. use enum keyword (reserved in javascript)\r\n 2. If enum keyword is just reserved but not implemented in your javascript, define the following\r\n\r\n        const enumerate = spec =&gt; spec.split(/\\s*,\\s*/)\r\n          .reduce((e, n) =&gt; Object.assign(e,{[n]:n}), {}) \r\n\r\nNow, you can easily use it\r\n\r\n    const kwords = enumerate(&quot;begin,end, procedure,if&quot;)\r\n    console.log(kwords, kwords.if, kwords.if == &quot;if&quot;, kwords.undef)\r\n\r\nI see no reason to make the enum values explicit variables. The scripts are morphic anyway and it makes no difference if part of your code is a string or valid code. What really matters is that you do not need to deal with tons of quotation marks whenever use or define them. \r\n\r\n\r\n\r\n\r\n"},{"score":16,"body_markdown":"In [ES7][1] , you can do an elegant ENUM relying on static attributes: \r\n\r\n\r\n    class ColorEnum  {\r\n        static RED = 0 ;\r\n        static GREEN = 1;\r\n        static BLUE = 2;\r\n    }\r\n\r\nthen \r\n\r\n    if (currentColor === ColorEnum.GREEN ) {/*-- coding --*/}\r\n\r\n\r\nThe advantage ( of using class instead of literal object) is to have a parent class `Enum` then all your Enums will **extends** that class.  \r\n \r\n\r\n     class ColorEnum  extends Enum {/*....*/}\r\n\r\n\r\n\r\n  [1]: https://babeljs.io/docs/plugins/transform-class-properties/\r\n"},{"score":-1,"body_markdown":"You could try using [https://bitbucket.org/snippets/frostbane/aAjxM][1].\r\n\r\n    my.namespace.ColorEnum = new Enum(\r\n        &quot;RED = 0&quot;,\r\n        &quot;GREEN&quot;,\r\n        &quot;BLUE&quot;\r\n    )\r\n\r\nIt should work up to ie8.\r\n\r\n  [1]: https://bitbucket.org/snippets/frostbane/aAjxM"},{"score":0,"body_markdown":"You can use a simple funcion to invert keys and values, it will work with arrays also as it converts numerical integer strings to numbers. The code is small, simple and reusable for this and other use cases.\r\n\r\n \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var objInvert = function (obj) {\r\n        var invert = {}\r\n        for (var i in obj) {\r\n          if (i.match(/^\\d+$/)) i = parseInt(i,10)\r\n          invert[obj[i]] = i\r\n        }\r\n        return invert\r\n    }\r\n     \r\n    var musicStyles = Object.freeze(objInvert([&#39;ROCK&#39;, &#39;SURF&#39;, &#39;METAL&#39;,\r\n    &#39;BOSSA-NOVA&#39;,&#39;POP&#39;,&#39;INDIE&#39;]))\r\n\r\n    console.log(musicStyles)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":5,"body_markdown":"es7 way, (iterator, freeze), usage:\r\n\r\n    const ThreeWiseMen = new Enum(&#39;Melchior&#39;, &#39;Caspar&#39;, &#39;Balthazar&#39;)\r\n\r\n    for (let name of ThreeWiseMen)\r\n        console.log(name)\r\n\r\n\r\n    // with a given key\r\n    let key = ThreeWiseMen.Melchior\r\n    \r\n    console.log(key in ThreeWiseMen) // true (string conversion, also true: &#39;Melchior&#39; in ThreeWiseMen)\r\n    \r\n    for (let entry from key.enum)\r\n         console.log(entry)\r\n    \r\n\r\n    // prevent alteration (throws TypeError in strict mode)\r\n    ThreeWiseMen.Me = &#39;Me too!&#39;\r\n    ThreeWiseMen.Melchior.name = &#39;Foo&#39;\r\n\r\ncode:\r\n\r\n    class EnumKey {\r\n\r\n\t\tconstructor(props) { Object.freeze(Object.assign(this, props)) }\r\n\r\n\t\ttoString() { return this.name }\r\n\r\n\t}\r\n\r\n\texport class Enum {\r\n\r\n\t\tconstructor(...keys) {\r\n\t\t\t\r\n\t\t\tfor (let [index, key] of keys.entries()) {\r\n\r\n\t\t\t\tObject.defineProperty(this, key, {\r\n\r\n\t\t\t\t\tvalue: new EnumKey({ name:key, index, enum:this }),\r\n\t\t\t\t\tenumerable: true,\r\n\r\n\t\t\t\t})\r\n\r\n\t\t\t}\r\n\r\n\t\t\tObject.freeze(this)\r\n\r\n\t\t}\r\n\r\n\t\t*[Symbol.iterator]() {\r\n\r\n\t\t\tfor (let key of Object.keys(this))\r\n\t\t\t\tyield this[key]\r\n\r\n\t\t}\r\n\r\n\t\ttoString() { return [...this].join(&#39;, &#39;) }\r\n\r\n\t}\r\n\r\n\r\n "},{"score":27,"body_markdown":"Use Javascript [Proxies][1]\r\n-------------------\r\n\r\n**TLDR:** Add this class to your utility methods and use it throughout your code, it mocks Enum behavior from traditional programming languages, and actually throws errors when you try to either access an enumerator that does not exist or add/update an enumerator. No need to rely on `Object.freeze()`.\r\n\r\n    class Enum {\r\n      constructor(enumObj) {\r\n        const handler = {\r\n          get(target, name) {\r\n            if (typeof target[name] != &#39;undefined&#39;) {\r\n              return target[name];\r\n            }\r\n            throw new Error(`No such enumerator: ${name}`);\r\n          },\r\n          set() {\r\n            throw new Error(&#39;Cannot add/update properties on an Enum instance after it is defined&#39;)\r\n          }\r\n        };\r\n    \r\n        return new Proxy(enumObj, handler);\r\n      }\r\n    }\r\n\r\nThen create enums by instantiating the class:\r\n\r\n    const roles = new Enum({\r\n      ADMIN: &#39;Admin&#39;,\r\n      USER: &#39;User&#39;,\r\n    });\r\n\r\n\r\n----------\r\n\r\n\r\n**Full Explanation:** \r\n\r\nOne very beneficial feature of Enums that you get from traditional languages is that they blow up (throw a compile-time error) if you try to access an enumerator which does not exist. \r\n\r\nBesides freezing the mocked enum structure to prevent additional values from accidentally/maliciously being added, none of the other answers address that intrinsic feature of Enums.\r\n\r\nAs you are probably aware, accessing non-existing members in JavaScript simply returns `undefined` and does not blow up your code. Since enumerators are predefined constants (i.e. days of the week), there should never be a case when an enumerator should be undefined.\r\n\r\nDon&#39;t get me wrong, JavaScript&#39;s behavior of returning `undefined` when accessing undefined properties is actually a very powerful feature of language, but it&#39;s not a feature you want when you are trying to mock traditional Enum structures. \r\n\r\nThis is where Proxy objects shine. Proxies were standardized in the language with the introduction of ES6 (ES2015). Here&#39;s the description from MDN: \r\n\r\n&gt; The Proxy object is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function\r\n&gt; invocation, etc).\r\n\r\nSimilar to a web server proxy, JavaScript proxies are able to intercept operations on objects (with the use of &quot;traps&quot;, call them hooks if you like) and allow you to perform various checks, actions and/or manipulations before they complete (or in some cases stopping the operations altogether which is exactly what we want to do if and when we try to reference an enumerator which does not exist).\r\n\r\nHere&#39;s a contrived example that uses the Proxy object to mimic Enums. The enumerators in this example are standard HTTP Methods (i.e. &quot;GET&quot;, &quot;POST&quot;, etc.):\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // Class for creating enums (13 lines)\r\n    // Feel free to add this to your utility library in \r\n    // your codebase and profit! Note: As Proxies are an ES6 \r\n    // feature, some browsers/clients may not support it and \r\n    // you may need to transpile using a service like babel\r\n\r\n    class Enum {\r\n      // The Enum class instantiates a JavaScript Proxy object.\r\n      // Instantiating a `Proxy` object requires two parameters, \r\n      // a `target` object and a `handler`. We first define the handler,\r\n      // then use the handler to instantiate a Proxy.\r\n\r\n      // A proxy handler is simply an object whose properties\r\n      // are functions which define the behavior of the proxy \r\n      // when an operation is performed on it. \r\n      \r\n      // For enums, we need to define behavior that lets us check what enumerator\r\n      // is being accessed and what enumerator is being set. This can be done by \r\n      // defining &quot;get&quot; and &quot;set&quot; traps.\r\n      constructor(enumObj) {\r\n        const handler = {\r\n          get(target, name) {\r\n            if (typeof target[name] != &#39;undefined&#39;) {\r\n              return target[name]\r\n            }\r\n            throw new Error(`No such enumerator: ${name}`)\r\n          },\r\n          set() {\r\n            throw new Error(&#39;Cannot add/update properties on an Enum instance after it is defined&#39;)\r\n          }\r\n        }\r\n\r\n\r\n        // Freeze the target object to prevent modifications\r\n        return new Proxy(enumObj, handler)\r\n      }\r\n    }\r\n\r\n\r\n    // Now that we have a generic way of creating Enums, lets create our first Enum!\r\n    const httpMethods = new Enum({\r\n      DELETE: &quot;DELETE&quot;,\r\n      GET: &quot;GET&quot;,\r\n      OPTIONS: &quot;OPTIONS&quot;,\r\n      PATCH: &quot;PATCH&quot;,\r\n      POST: &quot;POST&quot;,\r\n      PUT: &quot;PUT&quot;\r\n    })\r\n\r\n    // Sanity checks\r\n    console.log(httpMethods.DELETE)\r\n    // logs &quot;DELETE&quot;\r\n\r\n    try {\r\n      httpMethods.delete = &quot;delete&quot;\r\n    } catch (e) {\r\n    console.log(&quot;Error: &quot;, e.message)\r\n    }\r\n    // throws &quot;Cannot add/update properties on an Enum instance after it is defined&quot;\r\n\r\n    try {\r\n      console.log(httpMethods.delete)\r\n    } catch (e) {\r\n      console.log(&quot;Error: &quot;, e.message)\r\n    }\r\n    // throws &quot;No such enumerator: delete&quot;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n----------\r\n\r\n\r\n**ASIDE: What the heck is a proxy?**\r\n\r\nI remember when I first started seeing the word proxy everywhere, it definitely didn&#39;t make sense to me for a long time. If that&#39;s you right now, I think an easy way to generalize proxies is to think of them as software, institutions, or even people that act as intermediaries or middlemen between two servers, companies, or people. \r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"},{"score":4,"body_markdown":"This is how Typescript translates it&#39;s `enum` into Javascript:\r\n\r\n    var makeEnum = function(obj) {\r\n        obj[ obj[&#39;Active&#39;] = 1 ] = &#39;Active&#39;;\r\n        obj[ obj[&#39;Closed&#39;] = 2 ] = &#39;Closed&#39;;\r\n        obj[ obj[&#39;Deleted&#39;] = 3 ] = &#39;Deleted&#39;;\r\n    }\r\n\r\nNow:\r\n\r\n    makeEnum( NewObj = {} )\r\n    // =&gt; {1: &quot;Active&quot;, 2: &quot;Closed&quot;, 3: &quot;Deleted&quot;, Active: 1, Closed: 2, Deleted: 3}\r\n\r\nAt first I was confused why `obj[1]` returns `&#39;Active&#39;`, but then realised that its dead simple - **Assignment operator** assigns value and then returns it:\r\n\r\n    obj[&#39;foo&#39;] = 1\r\n    // =&gt; 1"},{"score":35,"body_markdown":"# &#120294;&#120306;&#120313;&#120307;-&#120279;&#120306;&#120320;&#120304;&#120319;&#120310;&#120317;&#120321;&#120310;&#120323;&#120306; &#120280;&#120325;&#120321;&#120306;&#120315;&#120320;&#120310;&#120303;&#120313;&#120306; &#120297;&#120302;&#120319;&#120310;&#120302;&#120303;&#120313;&#120306; &#120289;&#120302;&#120314;&#120306;&#120320;\r\n\r\nLet&#39;s cut straight to the problem: file size. Every other answer listed here bloats your minified code to the extreme. I present to you that for the best possible reduction in code size by minification, performance, readability of code, large scale project management, and syntax hinting in many code editors, this is the correct way to do enumerations: underscore-notation variables.\r\n\r\n\r\n---\r\n\r\n\r\n# ![Underscore-Notation Variables][1]\r\n\r\nAs demonstrated in the chart above and example below, here are five easy steps to get started: \r\n\r\n&lt;ol&gt;\r\n&lt;li&gt;Determine a name for the enumeration group. Think of a noun that can describe the purpose of the enumeration or at least the entries in the enumeration. For example, a group of enumerations representing colors choosable by the user might be better named COLORCHOICES than COLORS.&lt;/li&gt;\r\n&lt;li&gt;Decide whether enumerations in the group are mutually-exclusive or independent. If mutually-exclusive, start each enumerated variable name with &lt;code&gt;ENUM_&lt;/code&gt;. If independent or side-by-side, use &lt;code&gt;INDEX_&lt;/code&gt;.&lt;/li&gt;\r\n&lt;li&gt;For each entry, create a new local variable whose name starts with &lt;code&gt;ENUM_&lt;/code&gt; or &lt;code&gt;INDEX_&lt;/code&gt;, then the name of the group, then an underscore, then a unique friendly name for the property&lt;/li&gt;\r\n&lt;li&gt;Add a &lt;code&gt;ENUMLENGTH_&lt;/code&gt;, &lt;code&gt;ENUMLEN_&lt;/code&gt;, &lt;code&gt;INDEXLENGTH_&lt;/code&gt;, or &lt;code&gt;INDEXLEN_&lt;/code&gt; (whether &lt;code&gt;LEN_&lt;/code&gt; or &lt;code&gt;LENGTH_&lt;/code&gt; is personal preference) enumerated variable at the very end. You should use this variable wherever possible in your code to ensure that adding an extra entry to the enumeration and incrementing this value won&#39;t break your code.&lt;/li&gt;\r\n&lt;li&gt;Give each successive enumerated variable a value one more than the last, starting at 0. There are comments on this page that say &lt;code&gt;0&lt;/code&gt; should not be used as an enumerated value because &lt;code&gt;0 == null&lt;/code&gt;, &lt;code&gt;0 == false&lt;/code&gt;, &lt;code&gt;0 == &quot;&quot;&lt;/code&gt;, and other JS craziness. I submit to you that, to avoid this problem and boost performance at the same time, always use &lt;code&gt;===&lt;/code&gt; and never let &lt;code&gt;==&lt;/code&gt; appear in your code except with &lt;code&gt;typeof&lt;/code&gt; (e.x. &lt;code&gt;typeof X == &quot;string&quot;&lt;/code&gt;). In all my years of using &lt;code&gt;===&lt;/code&gt;, I have never once had a problem with using 0 as an enumeration value. If you are still squeamish, then &lt;code&gt;1&lt;/code&gt; could be used as the starting value in &lt;code&gt;ENUM_&lt;/code&gt; enumerations (but not in &lt;code&gt;INDEX_&lt;/code&gt; enumerations) without performance penalty in many cases.&lt;/li&gt;\r\n&lt;/ol&gt;\r\n\r\n    const ENUM_COLORENUM_RED   = 0;\r\n    const ENUM_COLORENUM_GREEN = 1;\r\n    const ENUM_COLORENUM_BLUE  = 2;\r\n    const ENUMLEN_COLORENUM    = 3;\r\n    \r\n    // later on\r\n    \r\n    if(currentColor === ENUM_COLORENUM_RED) {\r\n       // whatever\r\n    }\r\n\r\nHere is how I remember when to use `INDEX_` and when to use `ENUM_`:\r\n\r\n    // Precondition: var arr = []; //\r\n    arr[INDEX_] = ENUM_;\r\n\r\nHowever, `ENUM_` can, in certain circumstances, be appropriate as an index such as when counting the occurrences of each item.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const ENUM_PET_CAT = 0,\r\n          ENUM_PET_DOG = 1,\r\n          ENUM_PET_RAT = 2,\r\n          ENUMLEN_PET  = 3;\r\n\r\n    var favoritePets = [ENUM_PET_CAT, ENUM_PET_DOG, ENUM_PET_RAT,\r\n                        ENUM_PET_DOG, ENUM_PET_DOG, ENUM_PET_CAT,\r\n                        ENUM_PET_RAT, ENUM_PET_CAT, ENUM_PET_DOG];\r\n\r\n    var petsFrequency = [];\r\n\r\n    for (var i=0; i&lt;ENUMLEN_PET; i=i+1|0)\r\n      petsFrequency[i] = 0;\r\n\r\n    for (var i=0, len=favoritePets.length|0, petId=0; i&lt;len; i=i+1|0)\r\n      petsFrequency[petId = favoritePets[i]|0] = (petsFrequency[petId]|0) + 1|0;\r\n\r\n    console.log({\r\n        &quot;cat&quot;: petsFrequency[ENUM_PET_CAT],\r\n        &quot;dog&quot;: petsFrequency[ENUM_PET_DOG],\r\n        &quot;rat&quot;: petsFrequency[ENUM_PET_RAT]\r\n    });\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nObserve that, in the code above, it&#39;s really easy to add in a new kind of pet: you would just have to append a new entry after `ENUM_PET_RAT` and update `ENUMLEN_PET` accordingly. It might be more difficult and buggy to add a new entry in other systems of enumeration.\r\n\r\n\r\n---\r\n\r\n# &#120280;&#120325;&#120321;&#120306;&#120315;&#120305; &#120296;&#120317;&#120317;&#120306;&#120319;&#120304;&#120302;&#120320;&#120306; &#120297;&#120302;&#120319;&#120310;&#120302;&#120303;&#120313;&#120306;&#120320; &#120298;&#120310;&#120321;&#120309; &#120276;&#120305;&#120305;&#120310;&#120321;&#120310;&#120316;&#120315; \r\n\r\n\r\nAdditionally, this syntax of enumerations allows for clear and concise class extending as seen below. To extend a class, add an incrementing number to the `LEN_` entry of the parent class. Then, finish out the subclass with its own `LEN_` entry so that the subclass may be extended further in the future.\r\n\r\n![Addition extension diagram][2]\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    (function(window){\r\n        &quot;use strict&quot;;\r\n        var parseInt = window.parseInt;\r\n\r\n        // use INDEX_ when representing the index in an array instance\r\n        const INDEX_PIXELCOLOR_TYPE = 0, // is a ENUM_PIXELTYPE\r\n              INDEXLEN_PIXELCOLOR   = 1,\r\n              INDEX_SOLIDCOLOR_R    = INDEXLEN_PIXELCOLOR+0,\r\n              INDEX_SOLIDCOLOR_G    = INDEXLEN_PIXELCOLOR+1,\r\n              INDEX_SOLIDCOLOR_B    = INDEXLEN_PIXELCOLOR+2,\r\n              INDEXLEN_SOLIDCOLOR   = INDEXLEN_PIXELCOLOR+3,\r\n              INDEX_ALPHACOLOR_R    = INDEXLEN_PIXELCOLOR+0,\r\n              INDEX_ALPHACOLOR_G    = INDEXLEN_PIXELCOLOR+1,\r\n              INDEX_ALPHACOLOR_B    = INDEXLEN_PIXELCOLOR+2,\r\n              INDEX_ALPHACOLOR_A    = INDEXLEN_PIXELCOLOR+3,\r\n              INDEXLEN_ALPHACOLOR   = INDEXLEN_PIXELCOLOR+4,\r\n        // use ENUM_ when representing a mutually-exclusive species or type\r\n              ENUM_PIXELTYPE_SOLID = 0,\r\n              ENUM_PIXELTYPE_ALPHA = 1,\r\n              ENUM_PIXELTYPE_UNKNOWN = 2,\r\n              ENUMLEN_PIXELTYPE    = 2;\r\n\r\n        function parseHexColor(inputString) {\r\n            var rawstr = inputString.trim().substring(1);\r\n            var result = [];\r\n            if (rawstr.length === 8) {\r\n                result[INDEX_PIXELCOLOR_TYPE] = ENUM_PIXELTYPE_ALPHA;\r\n                result[INDEX_ALPHACOLOR_R] = parseInt(rawstr.substring(0,2), 16);\r\n                result[INDEX_ALPHACOLOR_G] = parseInt(rawstr.substring(2,4), 16);\r\n                result[INDEX_ALPHACOLOR_B] = parseInt(rawstr.substring(4,6), 16);\r\n                result[INDEX_ALPHACOLOR_A] = parseInt(rawstr.substring(4,6), 16);\r\n            } else if (rawstr.length === 4) {\r\n                result[INDEX_PIXELCOLOR_TYPE] = ENUM_PIXELTYPE_ALPHA;\r\n                result[INDEX_ALPHACOLOR_R] = parseInt(rawstr[0], 16) * 0x11;\r\n                result[INDEX_ALPHACOLOR_G] = parseInt(rawstr[1], 16) * 0x11;\r\n                result[INDEX_ALPHACOLOR_B] = parseInt(rawstr[2], 16) * 0x11;\r\n                result[INDEX_ALPHACOLOR_A] = parseInt(rawstr[3], 16) * 0x11;\r\n            } else if (rawstr.length === 6) {\r\n                result[INDEX_PIXELCOLOR_TYPE] = ENUM_PIXELTYPE_SOLID;\r\n                result[INDEX_SOLIDCOLOR_R] = parseInt(rawstr.substring(0,2), 16);\r\n                result[INDEX_SOLIDCOLOR_G] = parseInt(rawstr.substring(2,4), 16);\r\n                result[INDEX_SOLIDCOLOR_B] = parseInt(rawstr.substring(4,6), 16);\r\n            } else if (rawstr.length === 3) {\r\n                result[INDEX_PIXELCOLOR_TYPE] = ENUM_PIXELTYPE_SOLID;\r\n                result[INDEX_SOLIDCOLOR_R] = parseInt(rawstr[0], 16) * 0x11;\r\n                result[INDEX_SOLIDCOLOR_G] = parseInt(rawstr[1], 16) * 0x11;\r\n                result[INDEX_SOLIDCOLOR_B] = parseInt(rawstr[2], 16) * 0x11;\r\n            } else {\r\n                result[INDEX_PIXELCOLOR_TYPE] = ENUM_PIXELTYPE_UNKNOWN;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // the red component of green\r\n        console.log(parseHexColor(&quot;#0f0&quot;)[INDEX_SOLIDCOLOR_R]);\r\n        // the alpha of transparent purple\r\n        console.log(parseHexColor(&quot;#f0f7&quot;)[INDEX_ALPHACOLOR_A]); \r\n        // the enumerated array for turquoise\r\n        console.log(parseHexColor(&quot;#40E0D0&quot;));\r\n    })(self);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n \r\n(Length: 2,450 bytes)\r\n\r\nSome may say that this is less practical than other solutions: it waists tons of space, it takes a long time to write, and it is not coated with sugar syntax. Those people would be right if they do not minify their code. However, no reasonable person would leave unminified code in the end product. For this minification, Closure Compiler is the best I have yet to find. Online access can be found [here][3]. Closure compiler is able to take all of this enumeration data and inline it, making your Javascript be super duper small and run super duper fast. Thus, Minify with Closure Compiler. Observe.\r\n\r\n\r\n\r\n---\r\n\r\n# &#120288;&#120310;&#120315;&#120310;&#120307;&#120326; &#120298;&#120310;&#120321;&#120309; [&#120278;&#120313;&#120316;&#120320;&#120322;&#120319;&#120306; &#120278;&#120316;&#120314;&#120317;&#120310;&#120313;&#120306;&#120319;][3]\r\n\r\nClosure compiler is able to perform some pretty incredible optimizations via inferences that are way beyond the capacities of any other Javascript minifier. Closure Compiler is able to inline primitive variables set to a fixed value. Closure Compiler is also able to make inferences based upon these inlined values and eliminate unused blocks in if-statements and loops. \r\n\r\n![Wringing code via Closure Compiler][4]\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    &#39;use strict&#39;;(function(e){function d(a){a=a.trim().substring(1);var b=[];8===a.length?(b[0]=1,b[1]=c(a.substring(0,2),16),b[2]=c(a.substring(2,4),16),b[3]=c(a.substring(4,6),16),b[4]=c(a.substring(4,6),16)):4===a.length?(b[1]=17*c(a[0],16),b[2]=17*c(a[1],16),b[3]=17*c(a[2],16),b[4]=17*c(a[3],16)):6===a.length?(b[0]=0,b[1]=c(a.substring(0,2),16),b[2]=c(a.substring(2,4),16),b[3]=c(a.substring(4,6),16)):3===a.length?(b[0]=0,b[1]=17*c(a[0],16),b[2]=17*c(a[1],16),b[3]=17*c(a[2],16)):b[0]=2;return b}var c=\r\n    e.parseInt;console.log(d(&quot;#0f0&quot;)[1]);console.log(d(&quot;#f0f7&quot;)[4]);console.log(d(&quot;#40E0D0&quot;))})(self);\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n(Length: 605 bytes)\r\n\r\nClosure Compiler rewards you for coding smarter and organizing your code well because, whereas many minifiers punish organized code with a bigger minified file size, Closure Compiler is able to sift through all your cleanliness and sanity to output an even smaller file size if you use tricks like variable name enumerations. That, in this one mind, is the holy grail of coding: a tool that both assists your code with a smaller minified size and assists your mind by training better programming habits. \r\n\r\n\r\n\r\n---\r\n\r\n# &#120294;&#120314;&#120302;&#120313;&#120313;&#120306;&#120319; &#120278;&#120316;&#120305;&#120306; &#120294;&#120310;&#120327;&#120306;\r\n\r\n\r\nNow, let us see how big the equivalent file would be without any of these enumerations.\r\n&lt;br /&gt;&lt;br /&gt;\r\n\r\n[Source Without Using Enumerations][5] (length: 1,973 bytes (477 bytes shorter than enumerated code!))&lt;br /&gt;\r\n[Minified Without Using Enumerations][6] (length: 843 bytes (238 bytes **longer than enumerated code**))\r\n\r\n![Chart of code sizes][7]\r\n\r\n&lt;br /&gt;&lt;br /&gt;\r\n\r\nAs seen, without enumerations, the source code is shorter at the cost of a larger minified code. I do not know about you; but I know for sure that I do not incorporate source code into the end product. Thus, this form of enumerations is far superior insomuch that it results in smaller minified file sizes.\r\n\r\n\r\n---\r\n\r\n# &#120278;&#120316;&#120316;&#120317;&#120306;&#120319;&#120302;&#120321;&#120310;&#120323;&#120306; &#129309; &#120277;&#120322;&#120308; &#120281;&#120310;&#120325;&#120310;&#120315;&#120308;\r\n\r\n\r\nAnother advantage about this form of enumeration is that it can be used to easily manage large scale projects without sacrificing minified code size. When working on a large project with lots of other people, it might be beneficial to explicitly mark and label the variable names with who created the code so that the original creator of the code can be quickly identified for collaborative bug fixing.\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // JG = Jack Giffin\r\n    const ENUM_JG_COLORENUM_RED   = 0,\r\n          ENUM_JG_COLORENUM_GREEN = 1,\r\n          ENUM_JG_COLORENUM_BLUE  = 2,\r\n          ENUMLEN_JG_COLORENUM    = 3;\r\n\r\n    // later on\r\n\r\n    if(currentColor === ENUM_JG_COLORENUM_RED) {\r\n       // whatever\r\n    }\r\n\r\n    // PL = Pepper Loftus\r\n    // BK = Bob Knight\r\n    const ENUM_PL_ARRAYTYPE_UNSORTED   = 0,\r\n          ENUM_PL_ARRAYTYPE_ISSORTED   = 1,\r\n          ENUM_BK_ARRAYTYPE_CHUNKED    = 2, // added by Bob Knight\r\n          ENUM_JG_ARRAYTYPE_INCOMPLETE = 3, // added by jack giffin\r\n          ENUMLEN_PL_COLORENUM         = 4;\r\n\r\n    // later on\r\n\r\n    if(\r\n      randomArray === ENUM_PL_ARRAYTYPE_UNSORTED ||\r\n      randomArray === ENUM_BK_ARRAYTYPE_CHUNKED\r\n    ) {\r\n       // whatever\r\n    }\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n---\r\n\r\n# &#120294;&#120322;&#120317;&#120306;&#120319;&#120310;&#120316;&#120319; &#120291;&#120306;&#120319;&#120307;&#120316;&#120319;&#120314;&#120302;&#120315;&#120304;&#120306; &lt;sub&gt;&lt;sub&gt;&lt;sub&gt;&lt;sub&gt;&lt;img src=&quot;https://i.stack.imgur.com/OoOrv.png&quot; /&gt;&lt;/sub&gt;&lt;/sub&gt;&lt;/sub&gt;&lt;/sub&gt;\r\n\r\nFurther, this form of enumeration is also much faster after minification. In normal named properties, the browser has to use hashmaps to look up where the property is on the object. Although JIT compilers intelligently cache this location on the object, there is still tremendous overhead due to special cases such as deleting a lower property from the object.\r\n\r\n&lt;img src=&quot;https://v8.dev/_img/elements-kinds/lattice.svg&quot; /&gt;\r\n\r\nBut, with continuous non-sparse integer-indexed [PACKED_ELEMENTS][8] arrays, the browser is able to skip much of that overhead because the index of the value in the internal array is already specified. Yes, according to the ECMAScript standard, all properties are supposed to be treated as strings. Nevertheless, this aspect of the ECMAScript standard is very misleading about performance because all browsers have special optimizations for numeric indexes in arrays.\r\n\r\n\r\n    /// Hashmaps are slow, even with JIT juice\r\n    var ref = {};\r\n    ref.count = 10;\r\n    ref.value = &quot;foobar&quot;;\r\n\r\n\r\nCompare the code above to the code below.\r\n\r\n\r\n    /// Arrays, however, are always lightning fast\r\n    const INDEX_REFERENCE_COUNT = 0;\r\n    const INDEX_REFERENCE_VALUE = 1;\r\n    const INDEXLENGTH_REFERENCE = 2;\r\n    \r\n    var ref = [];\r\n    ref[INDEX_REFERENCE_COUNT] = 10;\r\n    ref[INDEX_REFERENCE_VALUE] = &quot;foobar&quot;;\r\n\r\n\r\nOne might object to the code with enumerations seeming to be much longer than the code with ordinary objects, but looks can be deceiving. It is important to remember that source code size is not proportional to output size when using the epic Closure Compiler. Observe.\r\n\r\n\r\n    /// Hashmaps are slow, even with JIT juice\r\n    var a={count:10,value:&quot;foobar&quot;};\r\n\r\nThe minified code without enumerations is above and the minified code with enumerations is below.\r\n\r\n\r\n    /// Arrays, however, are always lightning fast\r\n    var a=[10,&quot;foobar&quot;];\r\n\r\n\r\nThe example above demonstrates that, in addition to having superior performance, the enumerated code also results in a smaller minified file size.\r\n\r\n\r\n\r\n---\r\n\r\n# &#120280;&#120302;&#120320;&#120326; &#120279;&#120306;&#120303;&#120322;&#120308;&#120308;&#120310;&#120315;&#120308;\r\n\r\nFurthermore, this one&#39;s personal *cherry on the top* is using this form of enumerations along with the [CodeMirror][9] text editor in Javascript mode. CodeMirror&#39;s Javascript syntax highlighting mode highlights local variables in the current scope. That way, you know instantly when you type in a variable name correctly because if the variable name was previously declared with the `var` keyword, then the variable name turns a special color (cyan by default). Even if you do not use CodeMirror, then at least the browser throws a helpful &lt;code&gt;*[variable name]* is not defined&lt;/code&gt; exception when executing code with mistyped enumeration names. Also, JavaScript tools such as JSLint and Closure Compiler are very loud about telling you when you mistype in an enumeration variable name. CodeMirror, the browser, and various Javascript tools put together make debugging this form of enumeration very simple and really easy.\r\n\r\n![CodeMirror highlighting demonstration][10]\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const ENUM_COLORENUM_RED   = 0,\r\n          ENUM_COLORENUM_GREEN = 1,\r\n          ENUM_COLORENUM_BLUE  = 2,\r\n          ENUMLEN_COLORENUM    = 3;\r\n    var currentColor = ENUM_COLORENUM_GREEN;\r\n    \r\n    if(currentColor === ENUM_COLORENUM_RED) {\r\n       // whatever\r\n    }\r\n    \r\n    if(currentColor === ENUM_COLORENUM_DNE) {\r\n       // whatever\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIn the above snippet, you were alerted with an error because `ENUM_COLORENUM_DNE` does not exist.\r\n\r\n---\r\n\r\n# &#120278;&#120316;&#120315;&#120304;&#120313;&#120322;&#120320;&#120310;&#120316;&#120315;\r\n\r\nI think its safe to say that this methodology of enumeration is indeed the best way to go not just for minified code size, but also for performance, debugging, and collaboration.\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/vUCWq.png\r\n  [2]: https://i.stack.imgur.com/xIHxl.png\r\n  [3]: https://closure-compiler.appspot.com/\r\n  [4]: https://i.stack.imgur.com/2cadt.jpg\r\n  [5]: https://pastebin.com/embed_iframe/fcX5fN2V\r\n  [6]: https://pastebin.com/embed_iframe/97K6XLdU\r\n  [7]: https://i.stack.imgur.com/DX0nA.png\r\n  [8]: https://v8.dev/blog/elements-kinds#the-elements-kind-lattice\r\n  [9]: https://codemirror.net/\r\n  [10]: https://i.stack.imgur.com/sSyEB.png"},{"score":0,"body_markdown":"This answer is an alternative approach for specific circumstances.  I needed a set of bitmask constants based on attribute sub-values (cases where an attribute value is an array or list of values). It encompasses the equivalent of several overlapping enums. \r\n\r\nI created a class to both store and generate the bitmask values. I can then use the pseudo-constant bitmask values this way to test, for example, if green is present in an RGB value: \r\n\r\n    if (value &amp; Ez.G) {...}\r\n\r\nIn my code I create only one instance of this class.  There doesn&#39;t seem to be a clean way to do this without instantiating at least one instance of the class. Here is the class declaration and bitmask value generation code:\r\n\r\n    class Ez {\r\n    constructor() {\r\n        let rgba = [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;, &quot;A&quot;];\r\n        let rgbm = rgba.slice();\r\n        rgbm.push(&quot;M&quot;);              // for feColorMatrix values attribute\r\n        this.createValues(rgba);\r\n        this.createValues([&quot;H&quot;, &quot;S&quot;, &quot;L&quot;]);\r\n        this.createValues([rgba, rgbm]);\r\n        this.createValues([attX, attY, attW, attH]);\r\n    }\r\n    createValues(a) {                // a for array\r\n        let i, j;\r\n        if (isA(a[0])) {             // max 2 dimensions\r\n            let k = 1;\r\n            for (i of a[0]) {\r\n                for (j of a[1]) {\r\n                    this[i + j] = k;\r\n                    k *= 2;\r\n                }\r\n            }\r\n        }\r\n        else {                       // 1D array is simple loop\r\n            for (i = 0, j = 1; i &lt; a.length; i++, j *= 2)\r\n                this[a[i]] = j;\r\n       }\r\n    }\r\nThe 2D array is for the SVG feColorMatrix values attribute, which is a 4x5 matrix of RGBA by RGBAM, where M is a multiplier. The resulting Ez properties are Ez.RR, Ez.RG, etc.\r\n"},{"score":2,"body_markdown":"    class Enum {\r\n      constructor (...vals) {\r\n        vals.forEach( val =&gt; {\r\n          const CONSTANT = Symbol(val);\r\n          Object.defineProperty(this, val.toUpperCase(), {\r\n            get () {\r\n              return CONSTANT;\r\n            },\r\n            set (val) {\r\n              const enum_val = &quot;CONSTANT&quot;;\r\n              // generate TypeError associated with attempting to change the value of a constant\r\n              enum_val = val;\r\n            }\r\n          });\r\n        });\r\n      }\r\n    }\r\n\r\nExample of usage:\r\n\r\n    const COLORS = new Enum(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);"},{"score":1,"body_markdown":"Read all the answers and didn&#39;t found any non-verbose and DRY solution.\r\nI use this one-liner:\r\n```\r\nconst modes = [&#39;DRAW&#39;, &#39;SCALE&#39;, &#39;DRAG&#39;].reduce((o, v) =&gt; ({ ...o, [v]: v }), {});\r\n```\r\nit generates an object with human-readable values:\r\n```\r\n{\r\n  DRAW: &#39;DRAW&#39;,\r\n  SCALE: &#39;SCALE&#39;,\r\n  DRAG: &#39;DRAG&#39;\r\n}\r\n```\r\n"},{"score":5,"body_markdown":"I wasn&#39;t satisfied with any of the answers, so I made *Yet Another Enum (YEA!)*.\r\n\r\nThis implementation:\r\n\r\n- uses more up-to-date JS\r\n- requires just the declaration of this one class to easily create enums\r\n- has mapping by name (`colors.RED`), string (`colors[&quot;RED&quot;]`), and index (`colors[0]`), but you only need to pass in the strings as an array\r\n- binds equivalent `toString()` and `valueOf()` functions to each enum object (if this is somehow not desired, one can simply remove it - small overhead for JS though)\r\n- has optional global naming/storage by name string\r\n- freezes the enum object once created so that it can&#39;t be modified\r\n\r\nSpecial thanks to [Andre &#39;Fi&#39;&#39;s answer][1] for some inspiration.\r\n\r\n----------\r\n\r\n**The codes:**\r\n```js\r\nclass Enums {\r\n  static create({ name = undefined, items = [] }) {\r\n    let newEnum = {};\r\n    newEnum.length = items.length;\r\n    newEnum.items = items;\r\n    for (let itemIndex in items) {\r\n      //Map by name.\r\n      newEnum[items[itemIndex]] = parseInt(itemIndex, 10);\r\n      //Map by index.\r\n      newEnum[parseInt(itemIndex, 10)] = items[itemIndex];\r\n    }\r\n    newEnum.toString = Enums.enumToString.bind(newEnum);\r\n    newEnum.valueOf = newEnum.toString;\r\n    //Optional naming and global registration.\r\n    if (name != undefined) {\r\n      newEnum.name = name;\r\n      Enums[name] = newEnum;\r\n    }\r\n    //Prevent modification of the enum object.\r\n    Object.freeze(newEnum);\r\n    return newEnum;\r\n  }\r\n  static enumToString() {\r\n    return &quot;Enum &quot; +\r\n      (this.name != undefined ? this.name + &quot; &quot; : &quot;&quot;) +\r\n      &quot;[&quot; + this.items.toString() + &quot;]&quot;;\r\n  }\r\n}\r\n```\r\n\r\n----------\r\n\r\n\r\n**Usage:**\r\n```js\r\nlet colors = Enums.create({\r\n  name: &quot;COLORS&quot;,\r\n  items: [ &quot;RED&quot;, &quot;GREEN&quot;, &quot;BLUE&quot;, &quot;PORPLE&quot; ]\r\n});\r\n\r\n//Global access, if named.\r\nEnums.COLORS;\r\n\r\ncolors.items; //Array(4) [ &quot;RED&quot;, &quot;GREEN&quot;, &quot;BLUE&quot;, &quot;PORPLE&quot; ]\r\ncolors.length; //4\r\n\r\ncolors.RED; //0\r\ncolors.GREEN; //1\r\ncolors.BLUE; //2\r\ncolors.PORPLE; //3\r\ncolors[0]; //&quot;RED&quot;\r\ncolors[1]; //&quot;GREEN&quot;\r\ncolors[2]; //&quot;BLUE&quot;\r\ncolors[3]; //&quot;PORPLE&quot;\r\n\r\ncolors.toString(); //&quot;Enum COLORS [RED,GREEN,BLUE,PORPLE]&quot;\r\n\r\n//Enum frozen, makes it a real enum.\r\ncolors.RED = 9001;\r\ncolors.RED; //0\r\n```\r\n\r\n\r\n  [1]: https://stackoverflow.com/a/6672823/1599699"},{"score":3,"body_markdown":"This can be useful:\r\n\r\n```js\r\nconst [CATS, DOGS, BIRDS] = ENUM();\r\n```\r\n\r\nThe implementation is simple and efficient:\r\n\r\n```js\r\nfunction * ENUM(count=1) { while(true) yield count++ }\r\n```\r\n\r\nA generator can yield the exact sequence of integers required, without knowing how many constants there are. It can also support an optional argument that specifies which (possibly negative) number to start from (defaulting to `1`)."},{"score":-1,"body_markdown":"\r\n\r\n    export const ButtonType = Object.freeze({ \r\n       DEFAULT: &#39;default&#39;, \r\n       BIG: &#39;big&#39;, \r\n       SMALL: &#39;small&#39;\r\n    })\r\n\r\nsource: https://medium.com/@idanlevi2/enum-in-javascript-5f2ff500f149 "},{"score":0,"body_markdown":"The [com.recoyxgroup.javascript.enum](https://npmjs.com/package/com.recoyxgroup.javascript.enum) package allows you to properly define enum and flags enum classes, where:\r\n\r\n- Every constant is represented as an immutable `{ _value: someNumber }`\r\n- Every constant has a property attached to the enum class (E.CONSTANT_NAME)\r\n- Every constant has a friendly String (`constantName`)\r\n- Every constant has a Number (`someNumber`)\r\n- You can declare custom properties/methods using `E.prototype`.\r\n\r\nWherever a specific enum is expected, the convention is to do `E(v)`, like this:\r\n\r\n```javascript\r\nconst { FlagsEnum } from &#39;com.recoyxgroup.javascript.enum&#39;;\r\n\r\nconst Rights = FlagsEnum(&#39;Rights&#39;, [\r\n    &#39;ADMINISTRATION&#39;,\r\n    &#39;REVIEW&#39;,\r\n]);\r\n\r\nfunction fn(rights) {\r\n    rights = Rights(rights);\r\n    console.log(&#39;administration&#39; in rights, &#39;review&#39; in rights);\r\n}\r\n\r\nfn( [&#39;administration&#39;, &#39;review&#39;] ); // true true\r\nfn( &#39;administration&#39; ); // true false\r\nfn( undefined ); // false false\r\n\r\nvar r = Rights.ADMINISTRATION;\r\nconsole.log( r == &#39;administration&#39; );\r\n```\r\n\r\nAs you can see, you can still compare the value to a String.\r\n\r\nDefinitions can be more specific:\r\n\r\n```\r\nconst E = FlagsEnum(&#39;E&#39;, [\r\n    [&#39;Q&#39;, 0x10],\r\n    [&#39;K&#39;, &#39;someB&#39;],\r\n    [&#39;L&#39;, [0x40, &#39;someL&#39;]],\r\n]);\r\n```\r\n\r\nFlagsEnum products &gt; Instance properties/methods\r\n\r\n- number (was going to be valueOf(), but because of JS ==, had to be &#39;number&#39;)\r\n- set()\r\n- exclude()\r\n- toggle()\r\n- filter()\r\n- valueOf()\r\n- toString()"},{"score":3,"body_markdown":"**Update 05.11.2020:**&lt;br&gt;\r\nModified to include static fields and methods to closer replicate &quot;true&quot; enum behavior.\r\n\r\nHas anyone tried doing this with a class that contains private fields and &quot;get&quot; accessors?\r\nI realize private class fields are still experimental at this point but it seems to work for the purposes of creating a class with immutable fields/properties. Browser support is decent as well. The only &quot;major&quot; browsers that don&#39;t support it are Firefox (which I&#39;m sure they will soon) and IE (who cares).\r\n\r\n*DISCLAIMER*:&lt;br&gt;\r\nI am not a developer. I was just looking for an answer to this question and started thinking about how I sometimes create &quot;enhanced&quot; enums in C# by creating classes with private fields and restricted property accessors.\r\n\r\n***Sample Class***\r\n\r\n    class Sizes {\r\n        // Private Fields\r\n        static #_SMALL = 0;\r\n        static #_MEDIUM = 1;\r\n        static #_LARGE = 2;\r\n\r\n        // Accessors for &quot;get&quot; functions only (no &quot;set&quot; functions)\r\n        static get SMALL() { return this.#_SMALL; }\r\n        static get MEDIUM() { return this.#_MEDIUM; }\r\n        static get LARGE() { return this.#_LARGE; }\r\n    }\r\nYou should now be able to call your enums directly.\r\n\r\n    Sizes.SMALL; // 0\r\n    Sizes.MEDIUM; // 1\r\n    Sizes.LARGE; // 2\r\nThe combination of using private fields and limited accessors means that the enum values are well protected.\r\n\r\n    Sizes.SMALL = 10 // Sizes.SMALL is still 0\r\n    Sizes._SMALL = 10 // Sizes.SMALL is still 0\r\n    Sizes.#_SMALL = 10 // Sizes.SMALL is still 0\r\n"},{"score":1,"body_markdown":"There are basically two types of enums, global (like C) and object-like (like TypeScript). For global enums, do something like this-\r\n```javascript\r\n// Note that // enum is optional, though it makes it look slightly better.\r\nconst // enum\r\n  SUNDAY = 1,\r\n  MONDAY = 2,\r\n  TUESDAY = 3,\r\n  WEDNSDAY = 4,\r\n  THURSDAY = 5,\r\n  FRIDAY = 6,\r\n  SATURDAY = 7;\r\n```\r\nAnd for object-like enums, do this (like Artur Czajka&#39;s answer)-\r\n```javascript\r\n// A trailing comma isn&#39;t required but is a good habit.\r\nconst Days = Object.freeze({\r\n  SUNDAY = 1,\r\n  MONDAY = 2,\r\n  TUESDAY = 3,\r\n  WEDSNDAY = 4,\r\n  THURSDAY = 5,\r\n  FRIDAY = 6,\r\n  SATURDAY = 7,\r\n});\r\n```\r\nor\r\n```javascript\r\nconst Days = {\r\n  SUNDAY = 1,\r\n  MONDAY = 2,\r\n  TUESDAY = 3,\r\n  WEDSNDAY = 4,\r\n  THURSDAY = 5,\r\n  FRIDAY = 6,\r\n  SATURDAY = 7,\r\n};\r\nObject.freeze(Days);\r\n```\r\nThe first way to declare object-like enums looks slightly cleaner. By the way, global and object-like enums aren&#39;t really correct terms, I made them up.\r\n\r\nEdit:\r\n\r\nA solution made (for global enums) by Aral Roca, it looks amazing but has a con of being slow (like 0.1 seconds slow)-\r\n```javascript\r\nfunction* ENUM(count = 1) {\r\n  while (true) yield count++;\r\n}\r\n```\r\nand then\r\n```javascript\r\nconst [ RED, GREEN, BLUE ] = ENUM();\r\n```"},{"score":0,"body_markdown":"Here&#39;s my take on a (flagged) `Enum` factory. Here&#39;s a [working demo][1].\r\n\r\n    /*\r\n     * Notes: \r\n     * The proxy handler enables case insensitive property queries\r\n     * BigInt is used to enable bitflag strings /w length &gt; 52\r\n    */\r\n    function EnumFactory() {\r\n      const proxyfy = {\r\n        construct(target, args) { \r\n          const caseInsensitiveHandler = { \r\n              get(target, key) {\r\n              return target[key.toUpperCase()] || target[key];\t\r\n            } \r\n          };\r\n          const proxified = new Proxy(new target(...args), caseInsensitiveHandler ); \r\n          return Object.freeze(proxified);\r\n        },\r\n      }\r\n      const ProxiedEnumCtor = new Proxy(EnumCtor, proxyfy);\r\n      const throwIf = (\r\n          assertion = false, \r\n          message = `Unspecified error`, \r\n          ErrorType = Error ) =&gt; \r\n          assertion &amp;&amp; (() =&gt; { throw new ErrorType(message); })();\r\n      const hasFlag = (val, sub) =&gt; {\r\n        throwIf(!val || !sub, &quot;valueIn: missing parameters&quot;, RangeError);\r\n        const andVal = (sub &amp; val);\r\n        return andVal !== BigInt(0) &amp;&amp; andVal === val;\r\n      };\r\n    \r\n      function EnumCtor(values) {\r\n        throwIf(values.constructor !== Array || \r\n        \t\tvalues.length &lt; 2 || \r\n            values.filter( v =&gt; v.constructor !== String ).length &gt; 0,\r\n          `EnumFactory: expected Array of at least 2 strings`, TypeError);\r\n        const base = BigInt(1);\r\n        this.NONE = BigInt(0);\r\n        values.forEach( (v, i) =&gt; this[v.toUpperCase()] = base&lt;&lt;BigInt(i) );\r\n      }\r\n    \r\n      EnumCtor.prototype = {\r\n        get keys() { return Object.keys(this).slice(1); },\r\n        subset(sub) {\r\n          const arrayValues = this.keys;\r\n          return new ProxiedEnumCtor(\r\n            [...sub.toString(2)].reverse()\r\n              .reduce( (acc, v, i) =&gt; ( +v &lt; 1 ? acc : [...acc, arrayValues[i]] ), [] )\r\n          );\r\n        },\r\n        getLabel(enumValue) {\r\n          const tryLabel = Object.entries(this).find( value =&gt; value[1] === enumValue );\r\n          return !enumValue || !tryLabel.length ? \r\n            &quot;getLabel: no value parameter or value not in enum&quot; :\r\n            tryLabel.shift();\r\n        },\r\n        hasFlag(val, sub = this) { return hasFlag(val, sub); },\r\n      };\r\n      \r\n      return arr =&gt; new ProxiedEnumCtor(arr);\r\n    }\r\n\r\n  [1]: https://jsfiddle.net/KooiInc/1527adxq/\r\n"}],"score":2167}