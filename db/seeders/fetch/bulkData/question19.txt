{"body":"I&#39;m trying to create globally-unique identifiers in JavaScript.  I&#39;m not sure what routines are available on all browsers, how &quot;random&quot; and seeded the built-in random number generator is, etc.\r\n\r\nThe GUID / UUID should be at least 32 characters and should stay in the ASCII range to avoid trouble when passing them around.\r\n","title":"How to create a GUID / UUID","answers":[{"score":2438,"body_markdown":"UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier), according to [RFC 4122][1], are identifiers designed to provide certain uniqueness guarantees.\r\n\r\nWhile it is possible to implement an RFC-compliant UUIDs in a few lines of JavaScript code (e.g., see [@broofa&#39;s answer][2], below) there are several common pitfalls:\r\n\r\n* Invalid id format (UUIDs must be of the form &quot;`xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx`&quot;, where x is one of [0-9, a-f] *M* is one of [1-5], and *N* is [8, 9, a, or b]\r\n* Use of a low-quality source of randomness (such as `Math.random`)\r\n\r\nThus, developers writing code for production environments are encouraged to use a rigorous, well-maintained implementation such as the [uuid][3] module.\r\n\r\n  [1]: https://www.ietf.org/rfc/rfc4122.txt\r\n  [2]: https://stackoverflow.com/a/2117523/109538\r\n  [3]: https://github.com/uuidjs/uuid\r\n\r\n\r\n\r\n"},{"score":58,"body_markdown":"From [sagi shkedy&#39;s technical blog][1]:\r\n\r\n    function generateGuid() {\r\n      var result, i, j;\r\n      result = &#39;&#39;;\r\n      for(j=0; j&lt;32; j++) {\r\n        if( j == 8 || j == 12 || j == 16 || j == 20)\r\n          result = result + &#39;-&#39;;\r\n        i = Math.floor(Math.random()*16).toString(16).toUpperCase();\r\n        result = result + i;\r\n      }\r\n      return result;\r\n    }\r\n\r\nThere are other methods that involve using an [ActiveX][2] control, but stay away from these!\r\n\r\nI thought it was worth pointing out that no GUID generator can guarantee unique keys (check the [Wikipedia article][3]). There is always a chance of collisions. A GUID simply offers a large enough universe of keys to reduce the change of collisions to almost nil.\r\n\r\n  [1]: http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html\r\n  [2]: https://en.wikipedia.org/wiki/ActiveX\r\n  [3]: http://en.wikipedia.org/wiki/Globally_Unique_Identifier\r\n"},{"score":171,"body_markdown":"Here&#39;s some code based on [RFC 4122][1], section 4.4 (Algorithms for Creating a UUID from Truly Random or Pseudo-Random Number).\r\n\r\n    function createUUID() {\r\n        // http://www.ietf.org/rfc/rfc4122.txt\r\n        var s = [];\r\n        var hexDigits = &quot;0123456789abcdef&quot;;\r\n        for (var i = 0; i &lt; 36; i++) {\r\n            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\r\n        }\r\n        s[14] = &quot;4&quot;;  // bits 12-15 of the time_hi_and_version field to 0010\r\n        s[19] = hexDigits.substr((s[19] &amp; 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01\r\n        s[8] = s[13] = s[18] = s[23] = &quot;-&quot;;\r\n\r\n        var uuid = s.join(&quot;&quot;);\r\n        return uuid;\r\n    }\r\n\r\n\r\n  [1]: http://www.ietf.org/rfc/rfc4122.txt"},{"score":31,"body_markdown":"This creates a version 4 UUID (created from pseudo random numbers):\r\n\r\n```javascript\r\nfunction uuid()\r\n{\r\n   var chars = &#39;0123456789abcdef&#39;.split(&#39;&#39;);\r\n\r\n   var uuid = [], rnd = Math.random, r;\r\n   uuid[8] = uuid[13] = uuid[18] = uuid[23] = &#39;-&#39;;\r\n   uuid[14] = &#39;4&#39;; // version 4\r\n\r\n   for (var i = 0; i &lt; 36; i++)\r\n   {\r\n      if (!uuid[i])\r\n      {\r\n         r = 0 | rnd()*16;\r\n\r\n         uuid[i] = chars[(i == 19) ? (r &amp; 0x3) | 0x8 : r &amp; 0xf];\r\n      }\r\n   }\r\n\r\n   return uuid.join(&#39;&#39;);\r\n}\r\n```\r\n\r\nHere is a sample of the UUIDs generated:\r\n\r\n```none\r\n682db637-0f31-4847-9cdf-25ba9613a75c\r\n97d19478-3ab2-4aa1-b8cc-a1c3540f54aa\r\n2eed04c9-2692-456d-a0fd-51012f947136\r\n```\r\n\r\n\r\n\r\n"},{"score":4397,"body_markdown":"For an [RFC4122](https://www.ietf.org/rfc/rfc4122.txt) version 4 compliant solution, this one-liner(ish) solution is the most compact I could come up with:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function uuidv4() {\r\n      return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function(c) {\r\n        var r = Math.random() * 16 | 0, v = c == &#39;x&#39; ? r : (r &amp; 0x3 | 0x8);\r\n        return v.toString(16);\r\n      });\r\n    }\r\n\r\n    console.log(uuidv4());\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n**Update, 2015-06-02**:  Be aware that UUID uniqueness relies heavily on the underlying random number generator (RNG).  The solution above uses `Math.random()` for brevity, however `Math.random()` is *not* guaranteed to be a high-quality RNG.  See Adam Hyland&#39;s [excellent writeup on Math.random()][1] for details.  For a more robust solution, consider using the [uuid module][2], which uses higher quality RNG APIs.\r\n\r\n**Update, 2015-08-26**: As a side-note, this [gist][3] describes how to determine how many IDs can be generated before reaching a certain probability of collision.  For example, with 3.26x10&lt;sup&gt;15&lt;/sup&gt; version 4 RFC4122 UUIDs you have a 1-in-a-million chance of collision.\r\n\r\n**Update, 2017-06-28**: A [good article from Chrome developers][4] discussing the state of `Math.random` PRNG quality in Chrome, Firefox, and Safari.  tl;dr - As of late-2015 it&#39;s &quot;pretty good&quot;, but not cryptographic quality.  To address that issue, here&#39;s an updated version of the above solution that uses ES6, the `crypto` API, and [a bit of JavaScript wizardry I can&#39;t take credit for][5]:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function uuidv4() {\r\n      return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =&gt;\r\n        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16)\r\n      );\r\n    }\r\n\r\n    console.log(uuidv4());\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**Update, 2020-01-06**: There is a [proposal in the works][6] for a standard `uuid` module as part of the JavaScript language\r\n\r\n  [1]: http://bocoup.com/weblog/random-numbers/\r\n  [2]: https://github.com/uuidjs/uuid\r\n  [3]: https://gist.githubusercontent.com/aristus/f0c311df98d92e367df0\r\n  [4]: https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html\r\n  [5]: https://gist.github.com/jed/982883\r\n  [6]: https://github.com/tc39/proposal-uuid\r\n\r\n"},{"score":21,"body_markdown":"      // RFC 4122\r\n      //\r\n      // A UUID is 128 bits long\r\n      //\r\n      // String representation is five fields of 4, 2, 2, 2, and 6 bytes.\r\n      // Fields represented as lowercase, zero-filled, hexadecimal strings, and\r\n      // are separated by dash characters\r\n      //\r\n      // A version 4 UUID is generated by setting all but six bits to randomly\r\n      // chosen values\r\n      var uuid = [\r\n        Math.random().toString(16).slice(2, 10),\r\n        Math.random().toString(16).slice(2, 6),\r\n\r\n        // Set the four most significant bits (bits 12 through 15) of the\r\n        // time_hi_and_version field to the 4-bit version number from Section\r\n        // 4.1.3\r\n        (Math.random() * .0625 /* 0x.1 */ + .25 /* 0x.4 */).toString(16).slice(2, 6),\r\n\r\n        // Set the two most significant bits (bits 6 and 7) of the\r\n        // clock_seq_hi_and_reserved to zero and one, respectively\r\n        (Math.random() * .25 /* 0x.4 */ + .5 /* 0x.8 */).toString(16).slice(2, 6),\r\n\r\n        Math.random().toString(16).slice(2, 14)].join(&#39;-&#39;);\r\n"},{"score":62,"body_markdown":"Here&#39;s a solution dated Oct. 9, 2011 from a comment by user *jed* at https://gist.github.com/982883:\r\n\r\n    UUIDv4 = function b(a){return a?(a^Math.random()*16&gt;&gt;a/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,b)}\r\n\r\nThis accomplishes the same goal as the [current highest-rated answer][1], but in 50+ fewer bytes by exploiting coercion, recursion, and exponential notation. For those curious how it works, here&#39;s the annotated form of an older version of the function:\r\n\r\n    UUIDv4 =\r\n\r\n\tfunction b(\r\n\t  a // placeholder\r\n\t){\r\n\t  return a // if the placeholder was passed, return\r\n\t\t? ( // a random number from 0 to 15\r\n\t\t  a ^ // unless b is 8,\r\n\t\t  Math.random() // in which case\r\n\t\t  * 16 // a random number from\r\n\t\t  &gt;&gt; a/4 // 8 to 11\r\n\t\t  ).toString(16) // in hexadecimal\r\n\t\t: ( // or otherwise a concatenated string:\r\n\t\t  [1e7] + // 10000000 +\r\n\t\t  -1e3 + // -1000 +\r\n\t\t  -4e3 + // -4000 +\r\n\t\t  -8e3 + // -80000000 +\r\n\t\t  -1e11 // -100000000000,\r\n\t\t  ).replace( // replacing\r\n\t\t\t/[018]/g, // zeroes, ones, and eights with\r\n\t\t\tb // random hex digits\r\n\t\t  )\r\n\t}\r\n\r\n  [1]: https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\r\n"},{"score":36,"body_markdown":"    var uuid = function() {\r\n    \tvar buf = new Uint32Array(4);\r\n    \twindow.crypto.getRandomValues(buf);\r\n    \tvar idx = -1;\r\n    \treturn &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function(c) {\r\n    \t\tidx++;\r\n    \t\tvar r = (buf[idx&gt;&gt;3] &gt;&gt; ((idx%8)*4))&amp;15;\r\n    \t\tvar v = c == &#39;x&#39; ? r : (r&amp;0x3|0x8);\r\n    \t\treturn v.toString(16);\r\n    \t});\r\n    };\r\n\r\nEDIT:\r\n\r\nRevisited my project that was using this function and disliked the verbosity. - But needed proper randomness.\r\n\r\nA version based on Briguy37&#39;s answer and some bitwise operators to extract nibble sized windows from the buffer.\r\n\r\nShould adhere to the RFC Type 4 (random) schema, since I had Problems last time parsing non-compliant uuids with Java&#39;s UUID."},{"score":67,"body_markdown":"Here is a combination of the [top voted answer][1], with a workaround for [Chrome&#39;s collisions][2]:\r\n\r\n\r\n    generateGUID = (typeof(window.crypto) != &#39;undefined&#39; &amp;&amp; \r\n                    typeof(window.crypto.getRandomValues) != &#39;undefined&#39;) ?\r\n        function() {\r\n            // If we have a cryptographically secure PRNG, use that\r\n            // https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript\r\n            var buf = new Uint16Array(8);\r\n            window.crypto.getRandomValues(buf);\r\n            var S4 = function(num) {\r\n                var ret = num.toString(16);\r\n                while(ret.length &lt; 4){\r\n                    ret = &quot;0&quot;+ret;\r\n                }\r\n                return ret;\r\n            };\r\n            return (S4(buf[0])+S4(buf[1])+&quot;-&quot;+S4(buf[2])+&quot;-&quot;+S4(buf[3])+&quot;-&quot;+S4(buf[4])+&quot;-&quot;+S4(buf[5])+S4(buf[6])+S4(buf[7]));\r\n        }\r\n    \r\n        :\r\n    \r\n        function() {\r\n            // Otherwise, just use Math.random\r\n            // https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\r\n            return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function(c) {\r\n                var r = Math.random()*16|0, v = c == &#39;x&#39; ? r : (r&amp;0x3|0x8);\r\n                return v.toString(16);\r\n            });\r\n        };\r\n\r\n[On jsbin][3] if you want to test it.\r\n\r\n\r\n  [1]: https://stackoverflow.com/a/2117523/11236\r\n  [2]: https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript\r\n  [3]: http://jsbin.com/uqives/3"},{"score":840,"body_markdown":"I really like how clean [Broofa&#39;s answer][1] is, but it&#39;s unfortunate that [poor implementations of `Math.random`][2] leave the chance for collision.  \r\n\r\nHere&#39;s a similar [RFC4122][3] version 4 compliant solution that solves that issue by offsetting the first 13 hex numbers by a hex portion of the timestamp, and once depleted offsets by a hex portion of the microseconds since pageload.  That way, even if `Math.random` is on the same seed, both clients would have to generate the UUID the exact same number of microseconds since pageload (if high-perfomance time is supported) AND at the exact same millisecond (or 10,000+ years later) to get the same UUID:   \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function generateUUID() { // Public Domain/MIT\r\n        var d = new Date().getTime();//Timestamp\r\n        var d2 = (performance &amp;&amp; performance.now &amp;&amp; (performance.now()*1000)) || 0;//Time in microseconds since page-load or 0 if unsupported\r\n        return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function(c) {\r\n            var r = Math.random() * 16;//random number between 0 and 16\r\n            if(d &gt; 0){//Use timestamp until depleted\r\n                r = (d + r)%16 | 0;\r\n                d = Math.floor(d/16);\r\n            } else {//Use microseconds since page-load if supported\r\n                r = (d2 + r)%16 | 0;\r\n                d2 = Math.floor(d2/16);\r\n            }\r\n            return (c === &#39;x&#39; ? r : (r &amp; 0x3 | 0x8)).toString(16);\r\n        });\r\n    }\r\n\r\n    console.log(generateUUID())\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n&lt;br/&gt;\r\n[Here&#39;s a fiddle to test.][4]\r\n\r\n\r\n  [1]: https://stackoverflow.com/a/2117523/508537\r\n  [2]: https://stackoverflow.com/q/6906916/508537\r\n  [3]: http://www.ietf.org/rfc/rfc4122.txt\r\n  [4]: https://jsfiddle.net/briguy37/8eacgpnq/"},{"score":15,"body_markdown":"Adjusted my own UUID/GUID generator with some extras &lt;a href=&quot;http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx&quot;&gt;here&lt;/a&gt;.\r\n\r\nI&#39;m using &lt;a href=&quot;http://baagoe.com/en/RandomMusings/javascript/&quot;&gt;the following Kybos&lt;/a&gt; random number generator to be a bit more cryptographically sound.\r\n\r\nBelow is my script with the Mash and Kybos methods from baagoe.com excluded.\r\n\r\n&lt;pre&gt;&lt;code&gt;//UUID/Guid Generator\r\n// use: UUID.create() or UUID.createSequential()\r\n// convenience:  UUID.empty, UUID.tryParse(string)\r\n(function(w){\r\n  // From http://baagoe.com/en/RandomMusings/javascript/\r\n  // Johannes Baag&#195;&#184;e &amp;lt;baagoe@baagoe.com&amp;gt;, 2010\r\n  //function Mash() {...};\r\n\r\n  // From http://baagoe.com/en/RandomMusings/javascript/\r\n  //function Kybos() {...};\r\n\r\n  var rnd = Kybos();\r\n\r\n  //UUID/GUID Implementation from http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx\r\n  var UUID = {\r\n    &quot;empty&quot;: &quot;00000000-0000-0000-0000-000000000000&quot;\r\n    ,&quot;parse&quot;: function(input) {\r\n      var ret = input.toString().trim().toLowerCase().replace(/^[\\s\\r\\n]+|[\\{\\}]|[\\s\\r\\n]+$/g, &quot;&quot;);\r\n      if ((/[a-f0-9]{8}\\-[a-f0-9]{4}\\-[a-f0-9]{4}\\-[a-f0-9]{4}\\-[a-f0-9]{12}/).test(ret))\r\n        return ret;\r\n      else\r\n        throw new Error(&quot;Unable to parse UUID&quot;);\r\n    }\r\n    ,&quot;createSequential&quot;: function() {\r\n      var ret = new Date().valueOf().toString(16).replace(&quot;-&quot;,&quot;&quot;)\r\n      for (;ret.length &amp;lt; 12; ret = &quot;0&quot; + ret);\r\n      ret = ret.substr(ret.length-12,12); //only least significant part\r\n      for (;ret.length &amp;lt; 32;ret += Math.floor(rnd() * 0xffffffff).toString(16));\r\n      return [ret.substr(0,8), ret.substr(8,4), &quot;4&quot; + ret.substr(12,3), &quot;89AB&quot;[Math.floor(Math.random()*4)] + ret.substr(16,3),  ret.substr(20,12)].join(&quot;-&quot;);\r\n    }\r\n    ,&quot;create&quot;: function() {\r\n      var ret = &quot;&quot;;\r\n      for (;ret.length &amp;lt; 32;ret += Math.floor(rnd() * 0xffffffff).toString(16));\r\n      return [ret.substr(0,8), ret.substr(8,4), &quot;4&quot; + ret.substr(12,3), &quot;89AB&quot;[Math.floor(Math.random()*4)] + ret.substr(16,3),  ret.substr(20,12)].join(&quot;-&quot;);\r\n    }\r\n    ,&quot;random&quot;: function() {\r\n      return rnd();\r\n    }\r\n    ,&quot;tryParse&quot;: function(input) {\r\n      try {\r\n        return UUID.parse(input);\r\n      } catch(ex) {\r\n        return UUID.empty;\r\n      }\r\n    }\r\n  };\r\n  UUID[&quot;new&quot;] = UUID.create;\r\n\r\n  w.UUID = w.Guid = UUID;\r\n}(window || this));&lt;/code&gt;&lt;/pre&gt;"},{"score":12,"body_markdown":"The better way:\r\n\r\n    function(\r\n      a,b                // placeholders\r\n    ){\r\n      for(               // loop :)\r\n          b=a=&#39;&#39;;        // b - result , a - numeric variable\r\n          a++&lt;36;        // \r\n          b+=a*51&amp;52  // if &quot;a&quot; is not 9 or 14 or 19 or 24\r\n                      ?  //  return a random number or 4\r\n             (\r\n               a^15      // if &quot;a&quot; is not 15\r\n                  ?      // genetate a random number from 0 to 15\r\n               8^Math.random()*\r\n               (a^20?16:4)  // unless &quot;a&quot; is 20, in which case a random number from 8 to 11\r\n                  :\r\n               4            //  otherwise 4\r\n               ).toString(16)\r\n                      :\r\n             &#39;-&#39;            //  in other cases (if &quot;a&quot; is 9,14,19,24) insert &quot;-&quot;\r\n          );\r\n      return b\r\n     }\r\n\r\nMinimized:\r\n\r\n    function(a,b){for(b=a=&#39;&#39;;a++&lt;36;b+=a*51&amp;52?(a^15?8^Math.random()*(a^20?16:4):4).toString(16):&#39;-&#39;);return b}"},{"score":27,"body_markdown":"JavaScript project on GitHub - https://github.com/LiosK/UUID.js\r\n\r\n&gt; **UUID.js The RFC-compliant UUID generator for JavaScript.**\r\n&gt; \r\n&gt; See RFC 4122 http://www.ietf.org/rfc/rfc4122.txt.\r\n&gt; \r\n&gt; **Features Generates RFC 4122 compliant UUIDs.**\r\n&gt; \r\n&gt; Version 4 UUIDs (UUIDs from random numbers) and version 1 UUIDs\r\n&gt; (time-based UUIDs) are available.\r\n&gt; \r\n&gt; UUID object allows a variety of access to the UUID including access to\r\n&gt; the UUID fields.\r\n&gt; \r\n&gt; Low timestamp resolution of JavaScript is compensated by random\r\n&gt; numbers."},{"score":69,"body_markdown":"Here is a totally non-compliant but very performant implementation to generate an ASCII-safe GUID-like unique identifier.\r\n\r\n    function generateQuickGuid() {\r\n        return Math.random().toString(36).substring(2, 15) +\r\n            Math.random().toString(36).substring(2, 15);\r\n    }\r\n\r\nGenerates 26 [a-z0-9] characters, yielding a UID that is both shorter and more unique than RFC compliant GUIDs. Dashes can be trivially added if human-readability matters.\r\n\r\nHere are usage examples and timings for this function and several of this question&#39;s other answers. The timing was performed under Chrome m25, 10 million iterations each.\r\n\r\n    &gt;&gt;&gt; generateQuickGuid()\r\n    &quot;nvcjf1hs7tf8yyk4lmlijqkuo9&quot;\r\n    &quot;yq6gipxqta4kui8z05tgh9qeel&quot;\r\n    &quot;36dh5sec7zdj90sk2rx7pjswi2&quot;\r\n    runtime: 32.5s\r\n\r\n    &gt;&gt;&gt; GUID() // John Millikin\r\n    &quot;7a342ca2-e79f-528e-6302-8f901b0b6888&quot;\r\n    runtime: 57.8s\r\n\r\n    &gt;&gt;&gt; regexGuid() // broofa\r\n    &quot;396e0c46-09e4-4b19-97db-bd423774a4b3&quot;\r\n    runtime: 91.2s\r\n\r\n    &gt;&gt;&gt; createUUID() // Kevin Hakanson\r\n    &quot;403aa1ab-9f70-44ec-bc08-5d5ac56bd8a5&quot;\r\n    runtime: 65.9s\r\n\r\n    &gt;&gt;&gt; UUIDv4() // Jed Schmidt\r\n    &quot;f4d7d31f-fa83-431a-b30c-3e6cc37cc6ee&quot;\r\n    runtime: 282.4s\r\n    \r\n    &gt;&gt;&gt; Math.uuid() // broofa\r\n    &quot;5BD52F55-E68F-40FC-93C2-90EE069CE545&quot;\r\n    runtime: 225.8s\r\n\r\n    &gt;&gt;&gt; Math.uuidFast() // broofa\r\n    &quot;6CB97A68-23A2-473E-B75B-11263781BBE6&quot;\r\n    runtime: 92.0s\r\n\r\n    &gt;&gt;&gt; Math.uuidCompact() // broofa\r\n    &quot;3d7b7a06-0a67-4b67-825c-e5c43ff8c1e8&quot;\r\n    runtime: 229.0s\r\n\r\n    &gt;&gt;&gt; bitwiseGUID() // jablko\r\n    &quot;baeaa2f-7587-4ff1-af23-eeab3e92&quot;\r\n    runtime: 79.6s\r\n\r\n    &gt;&gt;&gt;&gt; betterWayGUID() // Andrea Turri\r\n    &quot;383585b0-9753-498d-99c3-416582e9662c&quot;\r\n    runtime: 60.0s\r\n\r\n    &gt;&gt;&gt;&gt; UUID() // John Fowler\r\n    &quot;855f997b-4369-4cdb-b7c9-7142ceaf39e8&quot;\r\n    runtime: 62.2s\r\n\r\nHere is the timing code.\r\n\r\n    var r;\r\n    console.time(&#39;t&#39;); \r\n    for (var i = 0; i &lt; 10000000; i++) { \r\n        r = FuncToTest(); \r\n    };\r\n    console.timeEnd(&#39;t&#39;);"},{"score":15,"body_markdown":"For those wanting an rfc4122 version 4 compliant solution with speed considerations (few calls to Math.random()):\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var rand = Math.random;\r\n\r\n    function UUID() {\r\n        var nbr, randStr = &quot;&quot;;\r\n        do {\r\n            randStr += (nbr = rand()).toString(16).substr(3, 6);\r\n        } while (randStr.length &lt; 30);\r\n        return (\r\n            randStr.substr(0, 8) + &quot;-&quot; +\r\n            randStr.substr(8, 4) + &quot;-4&quot; +\r\n            randStr.substr(12, 3) + &quot;-&quot; +\r\n            ((nbr*4|0)+8).toString(16) + // [89ab]\r\n            randStr.substr(15, 3) + &quot;-&quot; +\r\n            randStr.substr(18, 12)\r\n        );\r\n    }\r\n\r\n    console.log( UUID() );\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe above function should have a decent balance between speed and randomness.\r\n\r\n\r\n\r\n"},{"score":31,"body_markdown":"Simple JavaScript module as a combination of best answers in this thread.\r\n\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var crypto = window.crypto || window.msCrypto || null; // IE11 fix\r\n\r\n    var Guid = Guid || (function() {\r\n\r\n      var EMPTY = &#39;00000000-0000-0000-0000-000000000000&#39;;\r\n\r\n      var _padLeft = function(paddingString, width, replacementChar) {\r\n        return paddingString.length &gt;= width ? paddingString : _padLeft(replacementChar + paddingString, width, replacementChar || &#39; &#39;);\r\n      };\r\n\r\n      var _s4 = function(number) {\r\n        var hexadecimalResult = number.toString(16);\r\n        return _padLeft(hexadecimalResult, 4, &#39;0&#39;);\r\n      };\r\n\r\n      var _cryptoGuid = function() {\r\n        var buffer = new window.Uint16Array(8);\r\n        window.crypto.getRandomValues(buffer);\r\n        return [_s4(buffer[0]) + _s4(buffer[1]), _s4(buffer[2]), _s4(buffer[3]), _s4(buffer[4]), _s4(buffer[5]) + _s4(buffer[6]) + _s4(buffer[7])].join(&#39;-&#39;);\r\n      };\r\n\r\n      var _guid = function() {\r\n        var currentDateMilliseconds = new Date().getTime();\r\n        return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function(currentChar) {\r\n          var randomChar = (currentDateMilliseconds + Math.random() * 16) % 16 | 0;\r\n          currentDateMilliseconds = Math.floor(currentDateMilliseconds / 16);\r\n          return (currentChar === &#39;x&#39; ? randomChar : (randomChar &amp; 0x7 | 0x8)).toString(16);\r\n        });\r\n      };\r\n\r\n      var create = function() {\r\n        var hasCrypto = crypto != &#39;undefined&#39; &amp;&amp; crypto !== null,\r\n          hasRandomValues = typeof(window.crypto.getRandomValues) != &#39;undefined&#39;;\r\n        return (hasCrypto &amp;&amp; hasRandomValues) ? _cryptoGuid() : _guid();\r\n      };\r\n\r\n      return {\r\n        newGuid: create,\r\n        empty: EMPTY\r\n      };\r\n    })();\r\n\r\n    // DEMO: Create and show GUID\r\n    console.log(Guid.newGuid());\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nUsage: \r\n&gt;&gt; **Guid.newGuid()**\r\n\r\n&gt;&gt; &quot;c6c2d12f-d76b-5739-e551-07e6de5b0807&quot;\r\n\r\n&gt;&gt; **Guid.empty**\r\n\r\n&gt;&gt; &quot;00000000-0000-0000-0000-000000000000&quot;\r\n"},{"score":96,"body_markdown":"Fastest GUID like string generator method in the format `XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`. This does not generate standard-compliant GUID.\r\n\r\nTen million executions of this implementation take just 32.5 seconds, which is the fastest I&#39;ve ever seen in a browser (the only solution without loops/iterations).\r\n\r\nThe function is as simple as:\r\n\r\n    /**\r\n     * Generates a GUID string.\r\n     * @returns {string} The generated GUID.\r\n     * @example af8a8416-6e18-a307-bd9c-f2c947bbb3aa\r\n     * @author Slavik Meltser.\r\n     * @link http://slavik.meltser.info/?p=142\r\n     */\r\n    function guid() {\r\n        function _p8(s) {\r\n            var p = (Math.random().toString(16)+&quot;000000000&quot;).substr(2,8);\r\n            return s ? &quot;-&quot; + p.substr(0,4) + &quot;-&quot; + p.substr(4,4) : p ;\r\n        }\r\n        return _p8() + _p8(true) + _p8(true) + _p8();\r\n    }\r\n\r\nTo test the performance, you can run this code:\r\n    \r\n    console.time(&#39;t&#39;); \r\n    for (var i = 0; i &lt; 10000000; i++) { \r\n        guid(); \r\n    };\r\n    console.timeEnd(&#39;t&#39;);\r\n\r\nI&#39;m sure most of you will understand what I did there, but maybe there is at least one person that will need an explanation:\r\n\r\n**The algorithm:**\r\n\r\n - The `Math.random()` function returns a decimal number between 0 and 1 with 16 digits after the decimal fraction point (for\r\n   example `0.4363923368509859`).\r\n - Then we take this number and convert\r\n   it to a string with base 16 (from the example above we&#39;ll get\r\n   `0.6fb7687f`).  \r\n   `Math.random().toString(16)`.\r\n - Then we cut off the `0.` prefix (`0.6fb7687f` =&gt;\r\n   `6fb7687f`) and get a string with eight hexadecimal\r\n   characters long.  \r\n   `(Math.random().toString(16).substr(2,8)`.\r\n - Sometimes the `Math.random()` function will return\r\n   shorter number (for example `0.4363`), due to zeros at the end (from the example above, actually the number is `0.4363000000000000`). That&#39;s why I&#39;m appending to this string `&quot;000000000&quot;` (a string with nine zeros) and then cutting it off with `substr()` function to make it nine characters exactly (filling zeros to the right).\r\n - The reason for adding exactly nine zeros is because of the worse case scenario, which is when the `Math.random()` function will return exactly 0 or 1 (probability of 1/10^16 for each one of them). That&#39;s why we needed to add nine zeros to it (`&quot;0&quot;+&quot;000000000&quot;` or `&quot;1&quot;+&quot;000000000&quot;`), and then cutting it off from the second index (3rd character) with a length of eight characters. For the rest of the cases, the addition of zeros will not harm the result because it is cutting it off anyway.  \r\n   `Math.random().toString(16)+&quot;000000000&quot;).substr(2,8)`.\r\n\r\n**The assembly:**\r\n\r\n - The GUID is in the following format `XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`.\r\n - I divided the GUID into 4 pieces, each piece divided into 2 types (or formats): `XXXXXXXX` and `-XXXX-XXXX`.\r\n - Now I&#39;m building the GUID using these 2 types to assemble the GUID with call 4 pieces, as follows: `XXXXXXXX` `-XXXX-XXXX` `-XXXX-XXXX` `XXXXXXXX`.\r\n - To differ between these two types, I added a flag parameter to a pair creator function `_p8(s)`, the `s` parameter tells the function whether to add dashes or not.\r\n - Eventually we build the GUID with the following chaining: `_p8() + _p8(true) + _p8(true) + _p8()`, and return it.\r\n\r\n[Link to this post on my blog](http://slavik.meltser.info/the-efficient-way-to-create-guid-uuid-in-javascript/)\r\n\r\n**Enjoy! :-)**"},{"score":11,"body_markdown":"I know, it is an old question. Just for completeness, if your environment is SharePoint, there is a utility function called `SP.Guid.newGuid` ([msdn link](http://msdn.microsoft.com/en-us/library/ee659495(v=office.14).aspx)) which creates a new guid. This function is inside the sp.init.js file. If you rewrite this function (to remove some other dependencies from other private functions), it looks like this:\r\n\r\n    var newGuid = function () {\r\n        var result = &#39;&#39;;\r\n        var hexcodes = &quot;0123456789abcdef&quot;.split(&quot;&quot;);\r\n    \r\n        for (var index = 0; index &lt; 32; index++) {\r\n            var value = Math.floor(Math.random() * 16);\r\n    \r\n            switch (index) {\r\n            case 8:\r\n                result += &#39;-&#39;;\r\n                break;\r\n            case 12:\r\n                value = 4;\r\n                result += &#39;-&#39;;\r\n                break;\r\n            case 16:\r\n                value = value &amp; 3 | 8;\r\n                result += &#39;-&#39;;\r\n                break;\r\n            case 20:\r\n                result += &#39;-&#39;;\r\n                break;\r\n            }\r\n            result += hexcodes[value];\r\n        }\r\n        return result;\r\n    };\r\n\r\n"},{"score":6,"body_markdown":"It is important that to use well tested code that is maintained by more than 1 contributors instead of whipping your own stuff for this. This is one of the places where you probably want to prefer most stable code than shortest possible clever version that works in X browser but doesn&#39;t take in to account idiosyncrasies of Y which would often lead to very hard to investigate bugs than manifests only randomly for some users. Personally I use uuid-js at https://github.com/aurigadl/uuid-js which bower enabled so I can take updates easily."},{"score":449,"body_markdown":"broofa&#39;s answer is pretty slick, indeed - impressively clever, really...  rfc4122 compliant, somewhat readable, and compact.  Awesome!\r\n\r\nBut if you&#39;re looking at that regular expression, those many `replace()` callbacks, `toString()`&#39;s and `Math.random()` function calls (where he&#39;s only using 4 bits of the result and wasting the rest), you may start to wonder about performance.  Indeed, joelpt even decided to toss out RFC for generic GUID speed with `generateQuickGUID`.\r\n\r\n**But, can we get speed *and* RFC compliance?  I say, YES!**  Can we maintain readability?  Well...  Not really, but it&#39;s easy if you follow along.\r\n\r\nBut first, my results, compared to broofa, `guid` (the accepted answer), and the non-rfc-compliant `generateQuickGuid`:\r\n\r\n```\r\n                  Desktop   Android\r\n           broofa: 1617ms   12869ms\r\n               e1:  636ms    5778ms\r\n               e2:  606ms    4754ms\r\n               e3:  364ms    3003ms\r\n               e4:  329ms    2015ms\r\n               e5:  147ms    1156ms\r\n               e6:  146ms    1035ms\r\n               e7:  105ms     726ms\r\n             guid:  962ms   10762ms\r\ngenerateQuickGuid:  292ms    2961ms\r\n  - Note: 500k iterations, results will vary by browser/cpu.\r\n```\r\n\r\nSo by my 6th iteration of optimizations, I beat the most popular answer by over **12X**, the accepted answer by over **9X**, and the fast-non-compliant answer by **2-3X**.  And I&#39;m still rfc4122 compliant.\r\n\r\nInterested in how?  I&#39;ve put the full source on http://jsfiddle.net/jcward/7hyaC/3/ and on http://jsperf.com/uuid-generator-opt/4\r\n\r\nFor an explanation, let&#39;s start with broofa&#39;s code:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function broofa() {\r\n        return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function(c) {\r\n            var r = Math.random()*16|0, v = c == &#39;x&#39; ? r : (r&amp;0x3|0x8);\r\n            return v.toString(16);\r\n        });\r\n    }\r\n\r\n    console.log(broofa())\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nSo it replaces `x` with any random hex digit, `y` with random data (except forcing the top 2 bits to `10` per the RFC spec), and the regex doesn&#39;t match the `-` or `4` characters, so he doesn&#39;t have to deal with them.  Very, very slick.\r\n\r\nThe first thing to know is that function calls are expensive, as are regular expressions (though he only uses 1, it has 32 callbacks, one for each match, and in each of the 32 callbacks it calls Math.random() and v.toString(16)).\r\n\r\nThe first step toward performance is to eliminate the RegEx and its callback functions and use a simple loop instead.  This means we have to deal with the `-` and `4` characters whereas broofa did not.  Also, note that we can use String Array indexing to keep his slick String template architecture:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function e1() {\r\n        var u=&#39;&#39;,i=0;\r\n        while(i++&lt;36) {\r\n            var c=&#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;[i-1],r=Math.random()*16|0,v=c==&#39;x&#39;?r:(r&amp;0x3|0x8);\r\n            u+=(c==&#39;-&#39;||c==&#39;4&#39;)?c:v.toString(16)\r\n        }\r\n        return u;\r\n    }\r\n\r\n    console.log(e1())\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nBasically, the same inner logic, except we check for `-` or `4`, and using a while loop (instead of `replace()` callbacks) gets us an almost 3X improvement!\r\n\r\nThe next step is a small one on the desktop but makes a decent difference on mobile.  Let&#39;s make fewer Math.random() calls and utilize all those random bits instead of throwing 87% of them away with a random buffer that gets shifted out each iteration.  Let&#39;s also move that template definition out of the loop, just in case it helps:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function e2() {\r\n        var u=&#39;&#39;,m=&#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;,i=0,rb=Math.random()*0xffffffff|0;\r\n        while(i++&lt;36) {\r\n            var c=m[i-1],r=rb&amp;0xf,v=c==&#39;x&#39;?r:(r&amp;0x3|0x8);\r\n            u+=(c==&#39;-&#39;||c==&#39;4&#39;)?c:v.toString(16);rb=i%8==0?Math.random()*0xffffffff|0:rb&gt;&gt;4\r\n        }\r\n        return u\r\n    }\r\n\r\n    console.log(e2())\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThis saves us 10-30% depending on platform.  Not bad.  But the next big step gets rid of the toString function calls altogether with an optimization classic - the look-up table.  A simple 16-element lookup table will perform the job of toString(16) in much less time:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function e3() {\r\n        var h=&#39;0123456789abcdef&#39;;\r\n        var k=&#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;;\r\n        /* same as e4() below */\r\n    }\r\n    function e4() {\r\n        var h=[&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;];\r\n        var k=[&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;-&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;-&#39;,&#39;4&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;-&#39;,&#39;y&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;-&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;];\r\n        var u=&#39;&#39;,i=0,rb=Math.random()*0xffffffff|0;\r\n        while(i++&lt;36) {\r\n            var c=k[i-1],r=rb&amp;0xf,v=c==&#39;x&#39;?r:(r&amp;0x3|0x8);\r\n            u+=(c==&#39;-&#39;||c==&#39;4&#39;)?c:h[v];rb=i%8==0?Math.random()*0xffffffff|0:rb&gt;&gt;4\r\n        }\r\n        return u\r\n    }\r\n\r\n    console.log(e4())\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe next optimization is another classic.  Since we&#39;re only handling 4-bits of output in each loop iteration, let&#39;s cut the number of loops in half and process 8-bits each iteration.  This is tricky since we still have to handle the RFC compliant bit positions, but it&#39;s not too hard.  We then have to make a larger lookup table (16x16, or 256) to store 0x00 - 0xff, and we build it only once, outside the e5() function.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var lut = []; for (var i=0; i&lt;256; i++) { lut[i] = (i&lt;16?&#39;0&#39;:&#39;&#39;)+(i).toString(16); }\r\n    function e5() {\r\n        var k=[&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;-&#39;,&#39;x&#39;,&#39;x&#39;,&#39;-&#39;,&#39;4&#39;,&#39;x&#39;,&#39;-&#39;,&#39;y&#39;,&#39;x&#39;,&#39;-&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;x&#39;];\r\n        var u=&#39;&#39;,i=0,rb=Math.random()*0xffffffff|0;\r\n        while(i++&lt;20) {\r\n            var c=k[i-1],r=rb&amp;0xff,v=c==&#39;x&#39;?r:(c==&#39;y&#39;?(r&amp;0x3f|0x80):(r&amp;0xf|0x40));\r\n            u+=(c==&#39;-&#39;)?c:lut[v];rb=i%4==0?Math.random()*0xffffffff|0:rb&gt;&gt;8\r\n        }\r\n        return u\r\n    }\r\n\r\n    console.log(e5())\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nI tried an e6() that processes 16-bits at a time, still using the 256-element LUT, and it showed the diminishing returns of optimization.  Though it had fewer iterations, the inner logic was complicated by the increased processing, and it performed the same on desktop, and only ~10% faster on mobile.\r\n\r\nThe final optimization technique to apply - unroll the loop.  Since we&#39;re looping a fixed number of times, we can technically write this all out by hand.  I tried this once with a single random variable r that I kept re-assigning, and performance tanked.  But with four variables assigned random data up front, then using the lookup table, and applying the proper RFC bits, this version smokes them all:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var lut = []; for (var i=0; i&lt;256; i++) { lut[i] = (i&lt;16?&#39;0&#39;:&#39;&#39;)+(i).toString(16); }\r\n    function e7()\r\n    {\r\n        var d0 = Math.random()*0xffffffff|0;\r\n        var d1 = Math.random()*0xffffffff|0;\r\n        var d2 = Math.random()*0xffffffff|0;\r\n        var d3 = Math.random()*0xffffffff|0;\r\n        return lut[d0&amp;0xff]+lut[d0&gt;&gt;8&amp;0xff]+lut[d0&gt;&gt;16&amp;0xff]+lut[d0&gt;&gt;24&amp;0xff]+&#39;-&#39;+\r\n        lut[d1&amp;0xff]+lut[d1&gt;&gt;8&amp;0xff]+&#39;-&#39;+lut[d1&gt;&gt;16&amp;0x0f|0x40]+lut[d1&gt;&gt;24&amp;0xff]+&#39;-&#39;+\r\n        lut[d2&amp;0x3f|0x80]+lut[d2&gt;&gt;8&amp;0xff]+&#39;-&#39;+lut[d2&gt;&gt;16&amp;0xff]+lut[d2&gt;&gt;24&amp;0xff]+\r\n        lut[d3&amp;0xff]+lut[d3&gt;&gt;8&amp;0xff]+lut[d3&gt;&gt;16&amp;0xff]+lut[d3&gt;&gt;24&amp;0xff];\r\n    }\r\n\r\n    console.log(e7())\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nModualized:  http://jcward.com/UUID.js - `UUID.generate()`\r\n\r\nThe funny thing is, generating 16 bytes of random data is the easy part.  The whole trick is expressing it in String format with RFC compliance, and it&#39;s most tightly accomplished with 16 bytes of random data, an unrolled loop and lookup table.\r\n\r\nI hope my logic is correct -- it&#39;s very easy to make a mistake in this kind of tedious bit-work.  But the outputs look good to me.  I hope you enjoyed this mad ride through code optimization!\r\n\r\n**Be advised:** my primary goal was to show and teach potential optimization strategies.  Other answers cover important topics such as collisions and truly random numbers, which are important for generating good UUIDs."},{"score":11,"body_markdown":"This one is based on date, and add a random suffix to &quot;ensure&quot; uniqueness.\r\nWorks well for css identifiers.\r\nIt always returns something like and is easy to hack:\r\n\r\nuid-139410573297741\r\n\r\n\r\n    var getUniqueId = function (prefix) {\r\n                var d = new Date().getTime();\r\n                d += (parseInt(Math.random() * 100)).toString();\r\n                if (undefined === prefix) {\r\n                    prefix = &#39;uid-&#39;;\r\n                }\r\n                d = prefix + d;\r\n                return d;\r\n            };"},{"score":4,"body_markdown":"I&#39;m using this below function, hope it may be useful.\r\n    \r\n        \r\n        function NewGuid()\r\n             {\r\n               var sGuid=&quot;&quot;;\r\n               for (var i=0; i&lt;32; i++)\r\n                {\r\n                  sGuid+=Math.floor(Math.random()*0xF).toString(0xF);\r\n                }\r\n               return sGuid;\r\n             }"},{"score":2,"body_markdown":"For my use-case, I required id generation that was guaranteed to be unique globally; without exception. I struggled with the problem for a while, and came up with a solution called tuid (Truly Unique ID). It generates an id with the first 32 characters being system-generated and the remaining digits representing milliseconds since epoch. In situations where I need to generate id&#39;s on client-side javascript, it works well. Have a look:\r\n\r\nhttps://github.com/mongoh/tuid"},{"score":28,"body_markdown":"Well, this has a bunch of answers already, but unfortunately there&#39;s not a &quot;true&quot; random in the bunch. The version below is an adaptation of broofa&#39;s answer, but updated to include a &quot;true&quot; random function that uses crypto libraries where available, and the Alea() function as a fallback.\r\n\r\n      Math.log2 = Math.log2 || function(n){ return Math.log(n) / Math.log(2); }\r\n      Math.trueRandom = (function() {\r\n      var crypt = window.crypto || window.msCrypto;\r\n\r\n      if (crypt &amp;&amp; crypt.getRandomValues) {\r\n          // if we have a crypto library, use it\r\n          var random = function(min, max) {\r\n              var rval = 0;\r\n              var range = max - min;\r\n              if (range &lt; 2) {\r\n                  return min;\r\n              }\r\n\r\n              var bits_needed = Math.ceil(Math.log2(range));\r\n              if (bits_needed &gt; 53) {\r\n                throw new Exception(&quot;We cannot generate numbers larger than 53 bits.&quot;);\r\n              }\r\n              var bytes_needed = Math.ceil(bits_needed / 8);\r\n              var mask = Math.pow(2, bits_needed) - 1;\r\n              // 7776 -&gt; (2^13 = 8192) -1 == 8191 or 0x00001111 11111111\r\n\r\n              // Create byte array and fill with N random numbers\r\n              var byteArray = new Uint8Array(bytes_needed);\r\n              crypt.getRandomValues(byteArray);\r\n\r\n              var p = (bytes_needed - 1) * 8;\r\n              for(var i = 0; i &lt; bytes_needed; i++ ) {\r\n                  rval += byteArray[i] * Math.pow(2, p);\r\n                  p -= 8;\r\n              }\r\n\r\n              // Use &amp; to apply the mask and reduce the number of recursive lookups\r\n              rval = rval &amp; mask;\r\n\r\n              if (rval &gt;= range) {\r\n                  // Integer out of acceptable range\r\n                  return random(min, max);\r\n              }\r\n              // Return an integer that falls within the range\r\n              return min + rval;\r\n          }\r\n          return function() {\r\n              var r = random(0, 1000000000) / 1000000000;\r\n              return r;\r\n          };\r\n      } else {\r\n          // From https://web.archive.org/web/20120502223108/http://baagoe.com/en/RandomMusings/javascript/\r\n          // Johannes Baag&#195;&#184;e &lt;baagoe@baagoe.com&gt;, 2010\r\n          function Mash() {\r\n              var n = 0xefc8249d;\r\n\r\n              var mash = function(data) {\r\n                  data = data.toString();\r\n                  for (var i = 0; i &lt; data.length; i++) {\r\n                      n += data.charCodeAt(i);\r\n                      var h = 0.02519603282416938 * n;\r\n                      n = h &gt;&gt;&gt; 0;\r\n                      h -= n;\r\n                      h *= n;\r\n                      n = h &gt;&gt;&gt; 0;\r\n                      h -= n;\r\n                      n += h * 0x100000000; // 2^32\r\n                  }\r\n                  return (n &gt;&gt;&gt; 0) * 2.3283064365386963e-10; // 2^-32\r\n              };\r\n\r\n              mash.version = &#39;Mash 0.9&#39;;\r\n              return mash;\r\n          }\r\n\r\n          // From http://baagoe.com/en/RandomMusings/javascript/\r\n          function Alea() {\r\n              return (function(args) {\r\n                  // Johannes Baag&#195;&#184;e &lt;baagoe@baagoe.com&gt;, 2010\r\n                  var s0 = 0;\r\n                  var s1 = 0;\r\n                  var s2 = 0;\r\n                  var c = 1;\r\n\r\n                  if (args.length == 0) {\r\n                      args = [+new Date()];\r\n                  }\r\n                  var mash = Mash();\r\n                  s0 = mash(&#39; &#39;);\r\n                  s1 = mash(&#39; &#39;);\r\n                  s2 = mash(&#39; &#39;);\r\n\r\n                  for (var i = 0; i &lt; args.length; i++) {\r\n                      s0 -= mash(args[i]);\r\n                      if (s0 &lt; 0) {\r\n                          s0 += 1;\r\n                      }\r\n                      s1 -= mash(args[i]);\r\n                      if (s1 &lt; 0) {\r\n                          s1 += 1;\r\n                      }\r\n                      s2 -= mash(args[i]);\r\n                      if (s2 &lt; 0) {\r\n                          s2 += 1;\r\n                      }\r\n                  }\r\n                  mash = null;\r\n\r\n                  var random = function() {\r\n                      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\r\n                      s0 = s1;\r\n                      s1 = s2;\r\n                      return s2 = t - (c = t | 0);\r\n                  };\r\n                  random.uint32 = function() {\r\n                      return random() * 0x100000000; // 2^32\r\n                  };\r\n                  random.fract53 = function() {\r\n                      return random() +\r\n                          (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\r\n                  };\r\n                  random.version = &#39;Alea 0.9&#39;;\r\n                  random.args = args;\r\n                  return random;\r\n\r\n              }(Array.prototype.slice.call(arguments)));\r\n          };\r\n          return Alea();\r\n      }\r\n    }());\r\n\r\n    Math.guid = function() {\r\n        return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function(c)    {\r\n          var r = Math.trueRandom() * 16 | 0,\r\n              v = c == &#39;x&#39; ? r : (r &amp; 0x3 | 0x8);\r\n          return v.toString(16);\r\n      });\r\n    };"},{"score":16,"body_markdown":"I wanted to understand broofa&#39;s answer, so I expanded it and added comments:\r\n\r\n    var uuid = function () {\r\n        return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(\r\n            /[xy]/g,\r\n            function (match) {\r\n                /*\r\n                * Create a random nibble. The two clever bits of this code:\r\n                *\r\n                * - Bitwise operations will truncate floating point numbers\r\n                * - For a bitwise OR of any x, x | 0 = x\r\n                *\r\n                * So:\r\n                *\r\n                * Math.random * 16\r\n                *\r\n                * creates a random floating point number\r\n                * between 0 (inclusive) and 16 (exclusive) and\r\n                *\r\n                * | 0\r\n                *\r\n                * truncates the floating point number into an integer.\r\n                */\r\n                var randomNibble = Math.random() * 16 | 0;\r\n                \r\n                /*\r\n                * Resolves the variant field. If the variant field (delineated\r\n                * as y in the initial string) is matched, the nibble must\r\n                * match the mask (where x is a do-not-care bit):\r\n                *\r\n                * 10xx\r\n                *\r\n                * This is achieved by performing the following operations in\r\n                * sequence (where x is an intermediate result):\r\n                *\r\n                * - x &amp; 0x3, which is equivalent to x % 3\r\n                * - x | 0x8, which is equivalent to x + 8\r\n                *\r\n                * This results in a nibble between 8 inclusive and 11 exclusive,\r\n                * (or 1000 and 1011 in binary), all of which satisfy the variant\r\n                * field mask above.\r\n                */\r\n                var nibble = (match == &#39;y&#39;) ?\r\n                    (randomNibble &amp; 0x3 | 0x8) :\r\n                    randomNibble;\r\n\r\n                /*\r\n                * Ensure the nibble integer is encoded as base 16 (hexadecimal).\r\n                */\r\n                return nibble.toString(16);\r\n            }\r\n        );\r\n    };"},{"score":4,"body_markdown":"A simple solution to generate unique identification is to use time token and add random number to it. I prefer to prefix it with &quot;uuid-&quot;.&lt;br /&gt;&lt;br /&gt;\r\nBelow function will generate random string of type: &lt;strong&gt;uuid-14d93eb1b9b4533e6&lt;/strong&gt;. One doesn&#39;t need to generate 32 chars random string. 16 char random string is more than sufficient in this case to provide the unique UUIDs in javascript.\r\n&lt;pre&gt;\r\nvar createUUID = function() {\r\n  return&quot;uuid-&quot;+((new Date).getTime().toString(16)+Math.floor(1E7*Math.random()).toString(16));\r\n}\r\n&lt;/pre&gt;"},{"score":11,"body_markdown":"Simple code that uses `crypto.getRandomValues(a)` on [supported browsers][1] (IE11+, iOS7+, FF21+, Chrome, Android Chrome). Avoids using `Math.random()` because that can cause collisions (for example 20 collisions for 4000 generated uuids in a real situation by [Muxa][2]).\r\n\r\n    function uuid() {\r\n    \tfunction randomDigit() {\r\n    \t\tif (crypto &amp;&amp; crypto.getRandomValues) {\r\n    \t\t\tvar rands = new Uint8Array(1);\r\n    \t\t\tcrypto.getRandomValues(rands);\r\n    \t\t\treturn (rands[0] % 16).toString(16);\r\n    \t\t} else {\r\n    \t\t\treturn ((Math.random() * 16) | 0).toString(16);\r\n    \t\t}\r\n    \t}\r\n    \tvar crypto = window.crypto || window.msCrypto;\r\n    \treturn &#39;xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx&#39;.replace(/x/g, randomDigit);\r\n    }\r\n\r\nNotes:\r\n\r\n - Optimised for code readability not speed, so suitable for say a few hundred uuid&#39;s per second. Generates about 10000 uuid() per second in Chromium on my laptop using http://jsbin.com/fuwigo/1 to measure performance.\r\n - Only uses 8 for &quot;y&quot; because that simplifies code readability (y is allowed to be 8, 9, A or B).\r\n\r\n  [1]: http://caniuse.com/#search=getRandomValues\r\n  [2]: https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript\r\n"},{"score":0,"body_markdown":"Just thought I&#39;d post yet another way of doing the same thing.\r\n\r\n    function guid() {\r\n      var chars = [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;];\r\n      var str = &quot;&quot;;\r\n      for(var i=0;i&lt;36;i++) {\r\n        var str = str + ((i == 8 || i == 13 || i == 18 || i == 23) ? &quot;-&quot; : chars[Math.floor(Math.random()*chars.length)]);\r\n      };\r\n      return str;\r\n    }"},{"score":46,"body_markdown":"You can use node-uuid (https://github.com/kelektiv/node-uuid)\r\n\r\nSimple, fast generation of [RFC4122][1] UUIDS.\r\n\r\nFeatures:\r\n\r\n - Generate RFC4122 version 1 or version 4 UUIDs\r\n - Runs in node.js and browsers.\r\n - Cryptographically strong random # generation on supporting platforms.\r\n - Small footprint (Want something smaller? [Check this out!][2])\r\n\r\n---\r\n\r\n**Install Using NPM:**\r\n\r\n    npm install uuid\r\n\r\n---\r\n\r\n**Or Using uuid via browser:**\r\n\r\nDownload Raw File (uuid v1): https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js\r\nDownload Raw File (uuid v4): https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js\r\n\r\n---\r\n\r\nWant even smaller? Check this out: https://gist.github.com/jed/982883\r\n\r\n---\r\n\r\n**Usage:**\r\n\r\n    // Generate a v1 UUID (time-based)\r\n    const uuidV1 = require(&#39;uuid/v1&#39;);\r\n    uuidV1(); // -&gt; &#39;6c84fb90-12c4-11e1-840d-7b25c5ee775a&#39;\r\n\r\n    // Generate a v4 UUID (random)\r\n    const uuidV4 = require(&#39;uuid/v4&#39;);\r\n    uuidV4(); // -&gt; &#39;110ec58a-a0f2-4ac4-8393-c866d813b8d1&#39;\r\n\r\n    // Generate a v5 UUID (namespace)\r\n    const uuidV5 = require(&#39;uuid/v5&#39;);\r\n    \r\n    // ... using predefined DNS namespace (for domain names)\r\n    uuidV5(&#39;hello.example.com&#39;, v5.DNS)); // -&gt; &#39;fdda765f-fc57-5604-a269-52a7df8164ec&#39;\r\n    \r\n    // ... using predefined URL namespace (for, well, URLs)\r\n    uuidV5(&#39;http://example.com/hello&#39;, v5.URL); // -&gt; &#39;3bbcee75-cecc-5b56-8031-b6641c1ed1f1&#39;\r\n    \r\n    // ... using a custom namespace\r\n    const MY_NAMESPACE = &#39;(previously generated unique uuid string)&#39;;\r\n    uuidV5(&#39;hello&#39;, MY_NAMESPACE); // -&gt; &#39;90123e1c-7512-523e-bb28-76fab9f2f73d&#39;\r\n\r\n\r\n  [1]: http://www.ietf.org/rfc/rfc4122.txt\r\n  [2]: https://gist.github.com/982883\r\n\r\n---\r\n\r\n**ES6:**\r\n\r\n    import uuid from &#39;uuid/v4&#39;;\r\n    const id = uuid();"},{"score":4,"body_markdown":"You could use the npm package *guid*, a guid generator and validator.\r\n\r\nhttps://www.npmjs.com/package/guid\r\n\r\n\r\nExample:\r\n\r\n    Guid.raw();\r\n    // -&gt; &#39;6fdf6ffc-ed77-94fa-407e-a7b86ed9e59d&#39;\n\n\n**UPDATE:** This package has been deprecated. Use **uuid** instead. \n\nhttps://www.npmjs.com/package/uuid\n\nExample: \n\n    const uuidv4 = require(&#39;uuid/v4&#39;);\n    uuidv4(); // ⇨ &#39;10ba038e-48da-487b-96e8-8d3b99b6d18a&#39;\n\n "},{"score":2,"body_markdown":"Just in case anyone dropping by google is seeking a small utility library, ShortId (https://www.npmjs.com/package/shortid) meets all the requirements of this question. It allows specifying allowed characters and length, and guarantees non-sequential, non-repeating strings.\r\n\r\nTo make this more of a real answer, the core of that library uses the following logic to produce its short ids:\r\n\r\n    function encode(lookup, number) {\r\n        var loopCounter = 0;\r\n        var done;\r\n    \r\n        var str = &#39;&#39;;\r\n    \r\n        while (!done) {\r\n            str = str + lookup( ( (number &gt;&gt; (4 * loopCounter)) &amp; 0x0f ) | randomByte() );\r\n            done = number &lt; (Math.pow(16, loopCounter + 1 ) );\r\n            loopCounter++;\r\n        }\r\n        return str;\r\n    }\r\n    \r\n    /** Generates the short id */\r\n    function generate() {\r\n    \r\n        var str = &#39;&#39;;\r\n    \r\n        var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\r\n    \r\n        if (seconds === previousSeconds) {\r\n            counter++;\r\n        } else {\r\n            counter = 0;\r\n            previousSeconds = seconds;\r\n        }\r\n    \r\n        str = str + encode(alphabet.lookup, version);\r\n        str = str + encode(alphabet.lookup, clusterWorkerId);\r\n        if (counter &gt; 0) {\r\n            str = str + encode(alphabet.lookup, counter);\r\n        }\r\n        str = str + encode(alphabet.lookup, seconds);\r\n    \r\n        return str;\r\n    }\r\n\r\nI have not edited this to reflect _only_ the most basic parts of this approach, so the above code includes some additional logic from the library. If you are curious about everything it is doing, take a look at the source: https://github.com/dylang/shortid/tree/master/lib"},{"score":2,"body_markdown":"Hi here is an working example it generates 32-digit Unique UUID.   \r\n\r\n    function generateUUID() {\r\n          var d = new Date();\r\n          var k = d.getTime();\r\n         var str = k.toString(16).slice(1)\r\n        var UUID= &#39;xxxx-xxxx-4xxx-yxxx-xzx&#39;.replace(/[xy]/g, function (c)\r\n          {\r\n            var r = Math.random() * 16 | 0;\r\n            v = c == &#39;x&#39; ? r : (r &amp; 3 | 8);\r\n            return v.toString(16);\r\n          });\r\n          var newString = UUID.replace(/[z]/, str)\r\n          return newString;\r\n        }\r\n        var x = generateUUID()\r\n        console.log(x,x.length)\r\n\r\n  [1]: https://jsfiddle.net/ashish0019/b81z5y16/"},{"score":3,"body_markdown":"I found this script useful for creating GUIDs in JavaScript\r\n\r\nhttps://github.com/addui/GUIDJS\r\n\r\n    var myGuid = GUID();"},{"score":0,"body_markdown":"This may be of use to someone...\r\n\r\n    var d = new Date().valueOf();\r\n    var n = d.toString();\r\n    var result = &#39;&#39;;\r\n    var length = 32;\r\n    var p = 0;\r\n    var chars = &#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;;\r\n    \r\n    for (var i = length; i &gt; 0; --i){\r\n    \tresult += ((i &amp; 1) &amp;&amp; n.charAt(p) ? &#39;&lt;b&gt;&#39; + n.charAt(p) + &#39;&lt;/b&gt;&#39; : chars[Math.floor(Math.random() * chars.length)]);\r\n    \tif(i &amp; 1) p++;\r\n    };\r\n\r\nhttps://jsfiddle.net/j0evrdf1/1/"},{"score":0,"body_markdown":"    function randomHex(length) {\r\n        var random_string = &#39;&#39;;\r\n        if(!length){\r\n            length = 1;\r\n        }\r\n        for(var i=0; i&lt;length; i+=1){\r\n            random_string += Math.floor(Math.random() * 15).toString(16);\r\n        }\r\n        return random_string;\r\n    }\r\n\r\n    function guid() {\r\n        return randomHex(8);\r\n    }"},{"score":3,"body_markdown":"Here you can find a very small function that generates uuids https://gist.github.com/jed/982883\r\n\r\nOne of the final versions is:\r\n\r\n    function b(\r\n      a                  // placeholder\r\n    ){\r\n      var cryptoObj = window.crypto || window.msCrypto; // for IE 11\r\n      return a           // if the placeholder was passed, return\r\n        ? (              // a random number from 0 to 15\r\n          a ^            // unless b is 8,\r\n          cryptoObj.getRandomValues(new Uint8Array(1))[0]  // in which case\r\n          % 16           // a random number from\r\n          &gt;&gt; a/4         // 8 to 11\r\n          ).toString(16) // in hexadecimal\r\n        : (              // or otherwise a concatenated string:\r\n          [1e7] +        // 10000000 +\r\n          -1e3 +         // -1000 +\r\n          -4e3 +         // -4000 +\r\n          -8e3 +         // -80000000 +\r\n          -1e11          // -100000000000,\r\n          ).replace(     // replacing\r\n            /[018]/g,    // zeroes, ones, and eights with\r\n            b            // random hex digits\r\n          )\r\n    }"},{"score":12,"body_markdown":"If you just need a random 128 bit string in no particular format you can use:\r\n\r\n    function uuid() {\r\n        return crypto.getRandomValues(new Uint32Array(4)).join(&#39;-&#39;);\r\n    }\r\n\r\nWhich will return something like `2350143528-4164020887-938913176-2513998651`."},{"score":168,"body_markdown":"    let uniqueId = Date.now().toString(36) + Math.random().toString(36).substring(2);\r\n\r\n&lt;!-- begin snippet: js hide: true console: false babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    document.getElementById(&quot;unique&quot;).innerHTML =\r\n      Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;div id=&quot;unique&quot;&gt;\r\n    &lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf ID&#39;s are generated more than 1 millisecond apart, they are 100% unique.\r\n\r\nIf two ID&#39;s are generated at shorter intervals, and assuming that the random method is truly random, this would generate ID&#39;s that are 99.99999999999999% likely to be globally unique (collision in 1 of 10^15)\r\n\r\nYou can increase this number by adding more digits, but to generate 100% unique ID&#39;s you will need to use a global counter.\r\n\r\nif you need RFC compatibility, this formatting will pass as a valid version 4 GUID:\r\n\r\n    let u = Date.now().toString(16) + Math.random().toString(16) + &#39;0&#39;.repeat(16);\r\n    let guid = [u.substr(0,8), u.substr(8,4), &#39;4000-8&#39; + u.substr(13,3), u.substr(16,12)].join(&#39;-&#39;);\r\n\r\n&lt;!-- begin snippet: js hide: true console: false babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let u = Date.now().toString(16)+Math.random().toString(16)+&#39;0&#39;.repeat(16);\r\n    let guid = [u.substr(0,8), u.substr(8,4), &#39;4000-8&#39; + u.substr(13,3), u.substr(16,12)].join(&#39;-&#39;);\r\n    document.getElementById(&quot;unique&quot;).innerHTML = guid;\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;div id=&quot;unique&quot;&gt;\r\n    &lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nEdit: The above code follow the intention, but not the letter of the RFC. Among other discrepancies it&#39;s a few random digits short. (Add more random digits if you need it) The upside is that this it&#39;s really fast :)\r\nYou can [test validity of your GUID here][1]\r\n\r\n\r\n  [1]: https://www.freecodeformat.com/validate-uuid-guid.php"},{"score":13,"body_markdown":"ES6 sample\r\n\r\n    const guid=()=&gt; {\r\n      const s4=()=&gt; Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);     \r\n      return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4() + s4() + s4()}`;\r\n    }"},{"score":12,"body_markdown":"Just another more readable variant with just two mutations.\r\n\r\n    function uuid4()\r\n    {\r\n      function hex (s, b)\r\n      {\r\n        return s +\r\n          (b &gt;&gt;&gt; 4   ).toString (16) +  // high nibble\r\n          (b &amp; 0b1111).toString (16);   // low nibble\r\n      }\r\n    \r\n      let r = crypto.getRandomValues (new Uint8Array (16));\r\n    \r\n      r[6] = r[6] &gt;&gt;&gt; 4 | 0b01000000; // Set type 4: 0100\r\n      r[8] = r[8] &gt;&gt;&gt; 3 | 0b10000000; // Set variant: 100\r\n    \r\n      return r.slice ( 0,  4).reduce (hex, &#39;&#39; ) +\r\n             r.slice ( 4,  6).reduce (hex, &#39;-&#39;) +\r\n             r.slice ( 6,  8).reduce (hex, &#39;-&#39;) +\r\n             r.slice ( 8, 10).reduce (hex, &#39;-&#39;) +\r\n             r.slice (10, 16).reduce (hex, &#39;-&#39;);\r\n    }\r\n"},{"score":3,"body_markdown":"For those who are using Javascript on Windows (e.g. WScript / CScript / MSHTA). One can use `ActiveX`. Specifically, the `Scriptlet.Typelib` object:\r\n\r\n    WScript.Echo((new ActiveXObject(&quot;Scriptlet.TypeLib&quot;)).Guid)\r\n\r\nNote that this answer only works on the technologies I listed, it will not work any browser, not even Microsoft Edge! So, your mileage will vary with this answer."},{"score":3,"body_markdown":"Based on the work of broofa, I&#39;ve added some more randomness by adding the timestamp to `math.random()`\r\n\r\nHope it might help\r\n\r\n    function uuidv4() {\r\n        return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function (c) {\r\n            var r = parseFloat(&#39;0.&#39; + Math.random().toString().replace(&#39;0.&#39;, &#39;&#39;) + new Date().getTime()) * 16 | 0,\r\n                v = c == &#39;x&#39; ? r : (r &amp; 0x3 | 0x8);\r\n            return v.toString(16);\r\n        });\r\n    }"},{"score":0,"body_markdown":"For science. I haven&#39;t seen anyone do this yet... its not v4 compliant, but could easily be altered to be. Its just an example of extending the *Uint8Array* type, and using *crypto.getRandomValues()* to generate the uuid byte values.\r\n\r\n    class uuid extends Uint8Array {\r\n            constructor() {\r\n                super(16)\r\n                /* not v4, just some random bytes */\r\n                window.crypto.getRandomValues(this)\r\n            }\r\n            toString() {\r\n                let id = new String()\r\n                for (let i = 0; i &lt; this.length; i++) {\r\n                    /*convert uint8 to hex string */\r\n                    let hex = this[i].toString(16).toUpperCase()\r\n                    \r\n                    /*add zero padding*/\r\n                    while (hex.length &lt; 2) {\r\n                        hex = String(0).concat(hex)\r\n                    }\r\n                    id += hex\r\n                    \r\n                    /* add dashes */\r\n                    if (i == 4 || i == 6 || i == 8 || i == 10 || i == 16){\r\n                        id += &#39;-&#39;\r\n                    }\r\n                }\r\n                return id\r\n            }\r\n        }"},{"score":5,"body_markdown":"I couldn&#39;t find any answer that uses a single 16-octet `TypedArray` and a `DataView`, so I think the following solution for generating a version 4 UUID per [the RFC](https://www.ietf.org/rfc/rfc4122.txt) will stand on its own here:\r\n\r\n\tfunction uuid4() {\r\n\t\tconst ho = (n, p) =&gt; n.toString(16).padStart(p, 0); /// Return the hexadecimal text representation of number `n`, padded with zeroes to be of length `p`\r\n\t\tconst view = new DataView(new ArrayBuffer(16)); /// Create a view backed by a 16-byte buffer\r\n\t\tcrypto.getRandomValues(new Uint8Array(view.buffer)); /// Fill the buffer with random data\r\n\t\tview.setUint8(6, (view.getUint8(6) &amp; 0xf) | 0x40); /// Patch the 6th byte to reflect a version 4 UUID\r\n\t\tview.setUint8(8, (view.getUint8(8) &amp; 0x3f) | 0x80); /// Patch the 8th byte to reflect a variant 1 UUID (version 4 UUIDs are)\r\n\t\treturn `${ho(view.getUint32(0), 8)}-${ho(view.getUint16(4), 4)}-${ho(view.getUint16(6), 4)}-${ho(view.getUint16(8), 4)}-${ho(view.getUint32(10), 8)}${ho(view.getUint16(14), 4)}`; /// Compile the canonical textual form from the array data\r\n\t}\r\n\r\nI prefer it because it only relies on functions available to the standard ECMAScript platform.\r\n\r\nTake note of the fact that at the time of writing this, `getRandomValues` is not something implemented for the `crypto` object in Node.js. However, it has the equivalent `randomBytes` function which may be used instead."},{"score":8,"body_markdown":"OK, using **uuid** package, it support for **version 1, 3, 4 and 5 UUIDs** do:\r\n\r\n    yarn add uuid\r\n\r\nand then:\r\n\r\n    const uuidv1 = require(&#39;uuid/v1&#39;);\r\n    uuidv1(); // ⇨ &#39;45745c60-7b1a-11e8-9c9c-2d42b21b1a3e&#39;\r\n    \r\nYou can also do it with fully-specified options:\r\n    \r\n    const v1options = {\r\n      node: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab],\r\n      clockseq: 0x1234,\r\n      msecs: new Date(&#39;2011-11-01&#39;).getTime(),\r\n      nsecs: 5678\r\n    };\r\n    uuidv1(v1options); // ⇨ &#39;710b962e-041c-11e1-9234-0123456789ab&#39;\r\n\r\nFor more info, visit the npm page [here][1]\r\n\r\n\r\n  [1]: https://www.npmjs.com/package/uuid"},{"score":2,"body_markdown":"We can use replace and crypto.getRandomValues to get an output like this :\r\n\r\n`xxxxxxxx-xxxx-4xxx-xxxx-xxxxxxxxxxxx`\r\n\r\n[![enter image description here][1]][1]\r\n\r\nIf we are looking for an opti solution, we have to replace `crypto.getRandomValues(new Uint8Array(1))[0]` by an array(32).\r\n\r\n```\r\nconst uuidv4 = () =&gt;\r\n  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt;\r\n    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16)\r\n  );\r\n\r\nconsole.log(uuidv4());\r\n```\r\n\r\nTo get this code :\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function uuidv4() {\r\n      let bytes = window.crypto.getRandomValues(new Uint8Array(32));\r\n      const randomBytes = () =&gt; (bytes = bytes.slice(1)) &amp;&amp; bytes[0];\r\n\r\n      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt; \r\n          (c ^ randomBytes() &amp; 15 &gt;&gt; c / 4).toString(16)\r\n        );\r\n    }\r\n\r\n\r\n    for (var i = 0; i &lt; 10; i++)\r\n      console.log(uuidv4());\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n# Collision :\r\n\r\nWe can do like google analytics and add a timestamp with : `uuidv4() + &quot;.&quot; + (+new Date())`.\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/OJWv4.png"},{"score":2,"body_markdown":"The UUID currently has a proposal for addition to the standard library and can be supported here https://github.com/tc39/proposal-uuid \r\n\r\nThe proposal encompasses having UUID as the following:\r\n\r\n    // We&#39;re not yet certain as to how the API will be accessed (whether it&#39;s in the global, or a\r\n    // future built-in module), and this will be part of the investigative process as we continue\r\n    // working on the proposal.\r\n    uuid(); // &quot;52e6953d-edbe-4953-be2e-65ed3836b2f0&quot;\r\n\r\nThis implemtation follows the same layout as the V4 random uuid generation found here: https://www.npmjs.com/package/uuid\r\n\r\n    const uuidv4 = require(&#39;uuid/v4&#39;);\r\n    uuidv4(); // ⇨ &#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed&#39;\r\n\r\nI think it&#39;s noteworthy to understand how much bandwidth could be saved by this having an official implementation in the standard library. The authors of the proposal have also noted: \r\n\r\nThe 12 kb uuid module is downloaded from npm &gt; 62,000,000 times a month (June 2019); making it available in the standard library eventually saves TBs of bandwidth globally. If we continue to address user needs, such as uuid, with the standard library, bandwidth savings add up."},{"score":2,"body_markdown":"A typescript version of broofa&#39;s update from 2017-06-28, based on `crypto` API:\r\n\r\n    function genUUID() {\r\n    \t\t// Reference: https://stackoverflow.com/a/2117523/709884\r\n    \t\treturn (&quot;10000000-1000-4000-8000-100000000000&quot;).replace(/[018]/g, s =&gt; {\r\n    \t\t\tconst c = Number.parseInt(s, 10)\r\n    \t\t\treturn (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16)\r\n    \t\t})\r\n    }\r\n\r\nReasons:\r\n\r\n - Use of `+` between `number[]` and `number` isn&#39;t valid\r\n - The conversion from `string` to `number` has to be explicit\r\n\r\n"},{"score":3,"body_markdown":"Old question, so this might never float to the top, but I&#39;ve built on everything mentioned here to produce something twice as fast, portable all environments, including node, and upgraded from Math.random() to crypto-strength randomness. You might not think uuid needs crypto strength, but what that means is even less chance of a collision, which is the entire point of a uuid.\r\n```\r\nfunction random() {\r\n    const\r\n        fourBytesOn = 0xffffffff, // 4 bytes, all 32 bits on: 4294967295\r\n        c = typeof crypto === &quot;object&quot;\r\n            ? crypto // node or most browsers\r\n            : typeof msCrypto === &quot;object&quot; // stinky non-standard IE\r\n                ? msCrypto // eslint-disable-line no-undef\r\n                : null; // what old or bad environment are we running in?\r\n        return c\r\n            ? c.randomBytes\r\n                ? parseInt(c.randomBytes(4).toString(&quot;hex&quot;), 16) / (fourBytesOn + 1) - Number.EPSILON // node\r\n                : c.getRandomValues(new Uint32Array(1))[0] / (fourBytesOn + 1) - Number.EPSILON // browsers\r\n            : Math.random();\r\n}\r\n\r\nfunction uuidV4() { // eslint-disable-line complexity\r\n    // if possible, generate a single random value, 128 bits (16 bytes) in length\r\n    // in an environment where that is not possible, generate and make use of 4 32-bit (4-byte) random values\r\n    // use crypto-grade randomness when available, else Math.random()\r\n    const\r\n        c = typeof crypto === &quot;object&quot;\r\n            ? crypto // node or most browsers\r\n            : typeof msCrypto === &quot;object&quot; // stinky non-standard IE\r\n                ? msCrypto // eslint-disable-line no-undef\r\n            : null; // what old or bad environment are we running in?\r\n    let\r\n        byteArray = c\r\n            ? c.randomBytes\r\n                ? c.randomBytes(16) // node\r\n                : c.getRandomValues(new Uint8Array(16)) // browsers\r\n            : null,\r\n        uuid = [ ];\r\n\r\n    /* eslint-disable no-bitwise */\r\n    if ( ! byteArray) { // no support for generating 16 random bytes in one shot -- this will be slower\r\n        const\r\n            int = [\r\n                random() * 0xffffffff | 0,\r\n                random() * 0xffffffff | 0,\r\n                random() * 0xffffffff | 0,\r\n                random() * 0xffffffff | 0\r\n            ];\r\n        byteArray = [ ];\r\n        for (let i = 0; i &lt; 256; i++) {\r\n            byteArray[i] = int[i &lt; 4 ? 0 : i &lt; 8 ? 1 : i &lt; 12 ? 2 : 3] &gt;&gt; i % 4 * 8 &amp; 0xff;\r\n        }\r\n    }\r\n    byteArray[6] = byteArray[6] &amp; 0x0f | 0x40; // always 4, per RFC, indicating the version\r\n    byteArray[8] = byteArray[8] &amp; 0x3f | 0x80; // constrained to [89ab], per RFC for version 4\r\n    for (let i = 0; i &lt; 16; ++i) {\r\n        uuid[i] = (byteArray[i] &lt; 16 ? &quot;0&quot; : &quot;&quot;) + byteArray[i].toString(16);\r\n    }\r\n    uuid =\r\n        uuid[ 0] + uuid[ 1] + uuid[ 2] + uuid[ 3] + &quot;-&quot; +\r\n        uuid[ 4] + uuid[ 5]                       + &quot;-&quot; +\r\n        uuid[ 6] + uuid[ 7]                       + &quot;-&quot; +\r\n        uuid[ 8] + uuid[ 9]                       + &quot;-&quot; +\r\n        uuid[10] + uuid[11] + uuid[12] + uuid[13] + uuid[14] + uuid[15];\r\n    return uuid;\r\n    /* eslint-enable no-bitwise */\r\n}\r\n```"},{"score":1,"body_markdown":"Don&#39;t use **Math.random** in anycase since it generated a non-cryptographic source of random numbers\r\n\r\nSolution below using **crypto.getRandomValues**\r\n\r\n    function uuidv4() {\r\n      return &quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;.replace(/[xy]/g, (c) =&gt; {\r\n        // tslint:disable-next-line: no-bitwise\r\n        const r =\r\n          (window.crypto.getRandomValues(new Uint32Array(1))[0] *\r\n            Math.pow(2, -32) * 16) |\r\n          0;\r\n        // tslint:disable-next-line: no-bitwise\r\n        const v = c === &quot;x&quot; ? r : (r &amp; 0x3) | 0x8;\r\n        return v.toString(16);\r\n      });\r\n    }\r\n\r\nThis [link][1] helps your to understand the Insecure Randomness thrown by Fortify Scanner\r\n\r\n\r\n  [1]: https://help.semmle.com/wiki/display/JS/Insecure+randomness"},{"score":11,"body_markdown":"The native `URL.createObjectURL` is generating an uuid. You can take advantage of this.\r\n\r\n```js\r\nfunction uuid() {\r\n  const url = URL.createObjectURL(new Blob())\r\n  const [id] = url.toString().split(&#39;/&#39;).reverse()\r\n  URL.revokeObjectURL(url)\r\n  return id\r\n}\r\n```"},{"score":4,"body_markdown":"Because i can, i thought i should share my solution, since it is a very fascinating problem and it has so many solutions.\r\n\r\nIt works for nodejs too, if you replace `let buffer = new Uint8Array(); crypto.getRandomValues` with `let buffer = crypto.randomBytes(16)`\r\n\r\nI hope it helps somebody.\r\nIt should beat most regex solutions in performance.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const hex = &#39;0123456789ABCDEF&#39;\r\n\r\n    let generateToken = function() {\r\n        let buffer = new Uint8Array(16)\r\n        \r\n        crypto.getRandomValues(buffer)\r\n\r\n        buffer[6] = 0x40 | (buffer[6] &amp; 0xF)\r\n        buffer[8] = 0x80 | (buffer[8] &amp; 0xF)\r\n\r\n        let segments = []\r\n\r\n        for (let i = 0; i &lt; 16; ++i) {\r\n            segments.push(hex[(buffer[i] &gt;&gt; 4 &amp; 0xF)])\r\n            segments.push(hex[(buffer[i] &gt;&gt; 0 &amp; 0xF)])\r\n\r\n            if (i == 3 || i == 5 || i == 7 || i == 9) {\r\n                segments.push(&#39;-&#39;)\r\n            }\r\n        }\r\n\r\n        return segments.join(&#39;&#39;)\r\n    }\r\n\r\n    for (let i = 0; i &lt; 100; ++i) {\r\n      console.log(generateToken())\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nPerformance charts, everybody loves them: [jsbench][1]\r\n\r\nHave fun and thank you for all the other solutions, some served my quite long.\r\n\r\n\r\n  [1]: https://jsbench.me/zikcgk6woj/1"},{"score":0,"body_markdown":"    var guid = createMyGuid();\r\n    \r\n    function createMyGuid()  \r\n    {  \r\n       return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function(c) {  \r\n          var r = Math.random()*16|0, v = c === &#39;x&#39; ? r : (r&amp;0x3|0x8);  \r\n          return v.toString(16);  \r\n       });  \r\n    }\r\n\r\n"},{"score":1,"body_markdown":"**UUID with timestamp built in (emitter/parser)**  \r\nI will also post my simple approach to generating a valid UUID v4 with very strong uniqueness and fast runtime. The basic idea is not new, but approach is different. I use a timestamp in milliseconds from the `date.now()` (in Node.js library, which I&#39;ll point later, I use nanoseconds timestamp from `process.hrtime.bigint()`), and then add a random 5 digit number (`10000-90000`) to the end of the timestamp string. After merging the strings, I just form a valid UUID from digits and a pair of special characters, so that my UUID consists only of digits and a few non-numeric characters. Please check it out below:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    /*\r\n     * uuid-timestamp (emitter)\r\n     * UUID v4 based on timestamp\r\n     *\r\n     * Created by tarkh\r\n     * tarkh.com (C) 2020\r\n     */\r\n    const uuidEmit = () =&gt; {\r\n      // Get now time\r\n      const n = Date.now();\r\n      // Generate random\r\n      const r = Math.random();\r\n      // Stringify now time and generate additional random number\r\n      const s = String(n) + String(~~(r*9e4)+1e4);\r\n      // Form UUID and return it\r\n      return `${s.slice(0,8)}-${s.slice(8,12)}-4${s.slice(12,15)}-${[8,9,&#39;a&#39;,&#39;b&#39;][~~(r*3)]}${s.slice(15,18)}-${s.slice(s.length-12)}`;\r\n    };\r\n\r\n    // Generate 5 UUIDs\r\n    console.log(`${uuidEmit()}\r\n    ${uuidEmit()}\r\n    ${uuidEmit()}\r\n    ${uuidEmit()}\r\n    ${uuidEmit()}`);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nLooking at the results, you obviously see that the first part of UUIDs is the same, and then comes randomness. This is because I inserted the timestamp into the UUID linearly. The code will produce a new UUID every millisecond (nanosecond in Node.js library) + add a random 5-digit number to the end, so we end up with very approximate collision probability around 1 in 10 million per second. If we use Node.js library, our very approximate collision probability goes to 1 in 10 billion per second.\r\n\r\n**Timestamp built into the UUID**  \r\nSince we insert a timestamp into the UUID linearly, we get a feature (good or bad - depends on the task) - ability to easily extract this timestamp back from the UUID. This way we can understand when UUID was released:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    /*\r\n     * uuid-timestamp (parser)\r\n     * UUID v4 based on timestamp\r\n     *\r\n     * Created by tarkh\r\n     * tarkh.com (C) 2020\r\n     */\r\n    const uuidParse = (uuid) =&gt; {\r\n      // Get current timestamp string length\r\n      let tl = String(Date.now()).length;\r\n      // Strip out timestamp from UUID\r\n      let ts = &#39;&#39;;\r\n      let i = -1;\r\n      while(tl--) {\r\n        i++;\r\n        if(i===8||i===13||i===14||i===18||i===19||i===23) {\r\n          tl++;\r\n          continue;\r\n        }\r\n        ts += uuid[i];\r\n      }\r\n      return Number(ts);\r\n    };\r\n\r\n    // Get the timestamp when UUID was emitted\r\n    const time = uuidParse(&#39;15970688-7109-4530-8114-887109530114&#39;);\r\n\r\n    // Covert timestamp to date and print it\r\n    console.log(new Date(time).toUTCString());\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**Node.js**  \r\nNPM version of my code above available as [Node.js module][1]. This version is even more powerful in generating unique values, because instead of millisecond timestamp it uses `nanoseconds` from combination of system time and `process.hrtime.bigint()` diff.\r\n\r\n**Benchmarks**  \r\nAt the end of my post, I want to do some performance tests based on some of the answers from this topic. Of course, my decision is not the fastest, but it certainly takes the top positions.  \r\n[Check jsBench here][2]\r\n\r\n\r\n  [1]: https://www.npmjs.com/package/uuid-timestamp\r\n  [2]: https://jsben.ch/bvtX3"},{"score":1,"body_markdown":"Necromancing. \r\n\r\nEffectively, a Guid, or UUID as it is called in non-microsoft-circles, is just a 128-Bit cryptographic random number, with the uuid version number (1-5) being at a fixed location byte. \r\n\r\nSo when you just generate a bunch of random numbers betwween 0 and 65535 and hex-encode them, like this: \r\n\r\n    function guid()\r\n    {\r\n        function s4()\r\n        {\r\n            return Math.floor(Math.random() * 65536).toString(16).padStart(4, &#39;0&#39;)\r\n        } // End Function s4 \r\n    \r\n        return s4() + s4() + &#39;-&#39; + s4() + &#39;-&#39; + &quot;4&quot; + s4().substr(1) + &#39;-&#39; + s4() + &#39;-&#39; + s4() + s4() + s4();\r\n    } // End Function guid \r\n\r\nyou get a valid GUID, but due to the random-implementation, it&#39;s not cryptographically secure. \r\n\r\nTo generate a cryptographically secure GUID, you need to use window.crypto (or window.msCrypto for Internet Exploder). \r\n\r\nThat goes like this:\r\n\r\n    function cryptGuid()\r\n    { \r\n        var array = new Uint16Array(8);\r\n        (window.crypto || window.msCrypto).getRandomValues(array);\r\n        var dataView = new DataView(array.buffer);\r\n        \r\n        var parts = [];\r\n    \r\n        for(var i = 0; i &lt; array.length; ++i)\r\n        {\r\n            // 0&amp;1,2,3,4,5-7 dataView.getUint16(0-7)\r\n            if(i&gt;1 &amp;&amp; i&lt;6) parts.push(&quot;-&quot;);\r\n            parts.push(dataView.getUint16(i).toString(16).padStart(4, &#39;0&#39;));\r\n        }\r\n    \r\n        parts[5] = &quot;4&quot; + parts[5].substr(1);\r\n        // console.log(parts);\r\n        return parts.join(&#39;&#39;).toUpperCase();// .toLowerCase();\r\n    }\r\n    \r\n    cryptGuid();\r\n\r\nPlus you have to decide, if you return the number as lower-or upper-case character string.\r\nCertain software require lowercase characters (e.g. Reporting Service), while others generate uppercase characters (SQL-Server). "},{"score":0,"body_markdown":"There are many correct answers here, but sadly, included code samples are quite cryptic and difficult to understand.  This is how I create version 4 (random) UUIDs.\r\n\r\nNote that following pieces of code make use of binary literals for improved readability, thus require ECMAScript 6.\r\n\r\n### Node version\r\n\r\n```js\r\nfunction uuid4() {\r\n  let array = new Uint8Array(16)\r\n  crypto.randomFillSync(array)\r\n\r\n  // manipulate 9th byte\r\n  array[8] &amp;= 0b00111111 // clear first two bits\r\n  array[8] |= 0b10000000 // set first two bits to 10\r\n\r\n  // manipulate 7th byte\r\n  array[6] &amp;= 0b00001111 // clear first four bits\r\n  array[6] |= 0b01000000 // set first four bits to 0100\r\n\r\n  const pattern = &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&quot;\r\n  let idx = 0\r\n\r\n  return pattern.replace(\r\n    /XX/g,\r\n    () =&gt; array[idx++].toString(16).padStart(2, &quot;0&quot;), // padStart ensures leading zero, if needed\r\n  )\r\n}\r\n```\r\n\r\n### Browser version\r\n\r\nOnly the 2nd line is different.\r\n\r\n```js\r\nfunction uuid4() {\r\n  let array = new Uint8Array(16)\r\n  crypto.getRandomValues(array)\r\n\r\n  // manipulate 9th byte\r\n  array[8] &amp;= 0b00111111 // clear first two bits\r\n  array[8] |= 0b10000000 // set first two bits to 10\r\n\r\n  // manipulate 7th byte\r\n  array[6] &amp;= 0b00001111 // clear first four bits\r\n  array[6] |= 0b01000000 // set first four bits to 0100\r\n\r\n  const pattern = &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&quot;\r\n  let idx = 0\r\n\r\n  return pattern.replace(\r\n    /XX/g,\r\n    () =&gt; array[idx++].toString(16).padStart(2, &quot;0&quot;), // padStart ensures leading zero, if needed\r\n  )\r\n}\r\n```\r\n\r\n### Tests\r\n\r\nAnd finally, corresponding tests (Jasmine).\r\n\r\n```js\r\ndescribe(&quot;.uuid4()&quot;, function() {\r\n  it(&quot;returns a UUIDv4 string&quot;, function() {\r\n    const uuidPattern = &quot;XXXXXXXX-XXXX-4XXX-YXXX-XXXXXXXXXXXX&quot;\r\n    const uuidPatternRx = new RegExp(uuidPattern.\r\n      replaceAll(&quot;X&quot;, &quot;[0-9a-f]&quot;).\r\n      replaceAll(&quot;Y&quot;, &quot;[89ab]&quot;))\r\n\r\n    for (let attempt = 0; attempt &lt; 1000; attempt++) {\r\n      let retval = uuid4()\r\n      expect(retval.length).toEqual(36)\r\n      expect(retval).toMatch(uuidPatternRx)\r\n    }\r\n  })\r\n})\r\n```\r\n\r\n### UUID v4 explained\r\n\r\nA very good explanation of UUID version 4 is here: https://www.cryptosys.net/pki/uuid-rfc4122.html.\r\n\r\n### Final notes\r\n\r\nAlso, there are plenty of third-party packages.  However, as long as you have just basic needs, I don&#39;t recommend them.  Really, there is not much to win and pretty much to lose.  Authors may pursue for tiniest bits of performance, &quot;fix&quot; things which aren&#39;t supposed to be fixed, and when it comes to security, it is a risky idea.  Similarly, they may introduce other bugs or incompatibilities.  Careful updates require time.  "}],"score":4380}