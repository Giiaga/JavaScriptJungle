{"body":"What is the difference between using `call` and `apply` to invoke a function?\r\n\r\n    var func = function() {\r\n      alert(&#39;hello!&#39;);\r\n    };\r\n\r\n`func.apply();` vs `func.call();`\r\n\r\nAre there performance differences between the two aforementioned methods? When is it best to use `call` over `apply` and vice versa?","title":"What is the difference between call and apply?","answers":[{"score":236,"body_markdown":"K. Scott Allen has [a nice writeup](http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx) on the matter.\r\n\r\nBasically, they differ on how they handle function arguments.  \r\n\r\n&gt; The apply() method is identical to call(), except apply() requires an array as the second parameter. The array represents the arguments for the target method.&quot;\r\n\r\nSo:\r\n\r\n    // assuming you have f\r\n    function f(message) { ... }\r\n    f.call(receiver, &quot;test&quot;);\r\n    f.apply(receiver, [&quot;test&quot;]);\r\n\r\n"},{"score":3718,"body_markdown":"The difference is that `apply` lets you invoke the function with ```arguments``` as an array; `call` requires the parameters be listed explicitly. A useful mnemonic is _&quot;**A** for **a**rray and **C** for **c**omma.&quot;_\r\n\r\nSee MDN&#39;s documentation on [apply][1] and [call][2].\r\n\r\nPseudo syntax:\r\n\r\n`theFunction.apply(valueForThis, arrayOfArgs)`\r\n\r\n`theFunction.call(valueForThis, arg1, arg2, ...)`\r\n\r\nThere is also, as of ES6, the possibility to [`spread`][3] the array for use with the `call` function, you can see the compatibilities [here][4].\r\n\r\nSample code:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function theFunction(name, profession) {\r\n        console.log(&quot;My name is &quot; + name + &quot; and I am a &quot; + profession +&quot;.&quot;);\r\n    }\r\n    theFunction(&quot;John&quot;, &quot;fireman&quot;);\r\n    theFunction.apply(undefined, [&quot;Susan&quot;, &quot;school teacher&quot;]);\r\n    theFunction.call(undefined, &quot;Claude&quot;, &quot;mathematician&quot;);\r\n    theFunction.call(undefined, ...[&quot;Matthew&quot;, &quot;physicist&quot;]); // used with the spread operator\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n[1]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply\r\n[2]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call\r\n[3]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator\r\n[4]: http://kangax.github.io/compat-table/es6/"},{"score":164,"body_markdown":"To answer the part about when to use each function, use `apply` if you don&#39;t know the number of arguments you will be passing, or if they are already in an array or array-like object (like the `arguments` object to forward your own arguments. Use `call` otherwise, since there&#39;s no need to wrap the arguments in an array.\r\n\r\n    f.call(thisObject, a, b, c); // Fixed number of arguments\r\n\r\n    f.apply(thisObject, arguments); // Forward this function&#39;s arguments\r\n\r\n    var args = [];\r\n    while (...) {\r\n        args.push(some_value());\r\n    }\r\n    f.apply(thisObject, args); // Unknown number of arguments\r\n\r\nWhen I&#39;m not passing any arguments (like your example), I prefer `call` since I&#39;m *calling* the function. `apply` would imply you are *applying* the function to the (non-existent) arguments.\r\n\r\nThere shouldn&#39;t be any performance differences, except maybe if you use `apply` and wrap the arguments in an array (e.g. `f.apply(thisObject, [a, b, c])` instead of `f.call(thisObject, a, b, c)`). I haven&#39;t tested it, so there could be differences, but it would be very browser specific. It&#39;s likely that `call` is faster if you don&#39;t already have the arguments in an array and `apply` is faster if you do."},{"score":94,"body_markdown":"While this is an old topic, I just wanted to point out that .call is slightly faster than .apply. I can&#39;t tell you exactly why.\r\n\r\nSee jsPerf, http://jsperf.com/test-call-vs-apply/3\r\n\r\n---\r\n[`UPDATE!`]\r\n\r\nDouglas Crockford mentions briefly the difference between the two, which may help explain the performance difference... http://youtu.be/ya4UHuXNygM?t=15m52s\r\n\r\nApply takes an array of arguments, while Call takes zero or more individual parameters! Ah hah!\r\n\r\n`.apply(this, [...])`\r\n\r\n`.call(this, param1, param2, param3, param4...)`"},{"score":23,"body_markdown":"I&#39;d like to show an example, where the &#39;valueForThis&#39; argument is used:\r\n\r\n    Array.prototype.push = function(element) {\r\n       /*\r\n       Native code*, that uses &#39;this&#39;       \r\n       this.put(element);\r\n       */\r\n    }\r\n    var array = [];\r\n    array.push(1);\r\n    array.push.apply(array,[2,3]);\r\n    Array.prototype.push.apply(array,[4,5]);\r\n    array.push.call(array,6,7);\r\n    Array.prototype.push.call(array,8,9);\r\n    //[1, 2, 3, 4, 5, 6, 7, 8, 9] \r\n\r\n**details: http://es5.github.io/#x15.4.4.7*"},{"score":115,"body_markdown":"Here&#39;s a good mnemonic.  &lt;b&gt;A&lt;/b&gt;pply uses &lt;b&gt;A&lt;/b&gt;rrays and &lt;b&gt;A&lt;/b&gt;lways takes one or two Arguments.  When you use &lt;b&gt;C&lt;/b&gt;all you have to &lt;b&gt;C&lt;/b&gt;ount the number of arguments."},{"score":6,"body_markdown":"We can differentiate call and apply methods as below\r\n\r\nCALL : A function with argument provide individually.\r\nIf you know the arguments to be passed or there are no argument to pass you can use call.\r\n\r\n\r\nAPPLY : Call a function with argument provided as an array. You can use apply if you don&#39;t know how many argument are going to pass to the function.\r\n\r\nThere is a advantage of using apply over call, we don&#39;t need to change the number of argument only we can change a array that is passed.\r\n\r\nThere is not big difference in performance. But we can say call is bit faster as compare to apply because an array need to evaluate in apply method."},{"score":77,"body_markdown":"Follows an extract from [Closure: The Definitive Guide by Michael Bolin](http://www.amazon.com/Closure-Definitive-Guide-Michael-Bolin/dp/1449381871). It might look a bit lengthy, but it&#39;s saturated with a lot of insight. From &quot;Appendix B. Frequently Misunderstood JavaScript Concepts&quot;:\r\n\r\n-----------\r\n\r\nWhat `this` Refers to When a Function is Called\r\n=================\r\n\r\nWhen calling a function of the form `foo.bar.baz()`, the object `foo.bar` is referred to as the receiver. When the function is called, it is the receiver that is used as the value for `this`:\r\n\r\n    var obj = {};\r\n    obj.value = 10;\r\n    /** @param {...number} additionalValues */\r\n    obj.addValues = function(additionalValues) {\r\n      for (var i = 0; i &lt; arguments.length; i++) {\r\n        this.value += arguments[i];\r\n      }\r\n      return this.value;\r\n    };\r\n    // Evaluates to 30 because obj is used as the value for &#39;this&#39; when\r\n    // obj.addValues() is called, so obj.value becomes 10 + 20.\r\n    obj.addValues(20);\r\n\r\nIf there is no explicit receiver when a function is called, then the global object becomes the receiver. As explained in &quot;goog.global&quot; on page 47, window is the global object when JavaScript is executed in a web browser. This leads to some surprising behavior:\r\n\r\n    var f = obj.addValues;\r\n    // Evaluates to NaN because window is used as the value for &#39;this&#39; when\r\n    // f() is called. Because and window.value is undefined, adding a number to\r\n    // it results in NaN.\r\n    f(20);\r\n    // This also has the unintentional side effect of adding a value to window:\r\n    alert(window.value); // Alerts NaN\r\n\r\nEven though `obj.addValues` and `f` refer to the same function, they behave differently when called because the value of the receiver is different in each call. For this reason, when calling a function that refers to `this`, it is important to ensure that `this` will have the correct value when it is called. To be clear, if `this` were not referenced in the function body, then the behavior of `f(20)` and `obj.addValues(20)` would be the same.\r\n\r\n\r\nBecause functions are first-class objects in JavaScript, they can have their own methods. All functions have the methods `call()` and `apply()` which make it possible to redefine the receiver (i.e., the object that `this` refers to) when calling the function. The method signatures are as follows:\r\n\r\n    /**\r\n    * @param {*=} receiver to substitute for &#39;this&#39;\r\n    * @param {...} parameters to use as arguments to the function\r\n    */\r\n    Function.prototype.call;\r\n    /**\r\n    * @param {*=} receiver to substitute for &#39;this&#39;\r\n    * @param {Array} parameters to use as arguments to the function\r\n    */\r\n    Function.prototype.apply;\r\n\r\nNote that the only difference between `call()` and `apply()` is that `call()` receives the function parameters as individual arguments, whereas `apply()` receives them as a single array:\r\n\r\n    // When f is called with obj as its receiver, it behaves the same as calling\r\n    // obj.addValues(). Both of the following increase obj.value by 60:\r\n    f.call(obj, 10, 20, 30);\r\n    f.apply(obj, [10, 20, 30]);\r\n\r\nThe following calls are equivalent, as `f` and `obj.addValues` refer to the same function:\r\n\r\n    obj.addValues.call(obj, 10, 20, 30);\r\n    obj.addValues.apply(obj, [10, 20, 30]);\r\n\r\nHowever, since neither `call()` nor `apply()` uses the value of its own receiver to substitute for the receiver argument when it is unspecified, the following will not work:\r\n\r\n    // Both statements evaluate to NaN\r\n    obj.addValues.call(undefined, 10, 20, 30);\r\n    obj.addValues.apply(undefined, [10, 20, 30]);\r\n\r\nThe value of `this` can never be `null` or `undefined` when a function is called. When `null` or `undefined` is supplied as the receiver to `call()` or `apply()`, the global object is used as the value for receiver instead. Therefore, the previous code has the same undesirable side effect of adding a property named `value` to the global object.\r\n\r\nIt may be helpful to think of a function as having no knowledge of the variable to which it is assigned. This helps reinforce the idea that the value of this will be bound when the function is called rather than when it is defined.\r\n\r\n------------\r\nEnd of extract."},{"score":10,"body_markdown":"Here&#39;s a small-ish post, I wrote on this:\r\n\r\nhttp://sizeableidea.com/call-versus-apply-javascript/\r\n\r\n    var obj1 = { which : &quot;obj1&quot; },\r\n    obj2 = { which : &quot;obj2&quot; };\r\n \r\n    function execute(arg1, arg2){\r\n        console.log(this.which, arg1, arg2);\r\n    }\r\n \r\n    //using call\r\n    execute.call(obj1, &quot;dan&quot;, &quot;stanhope&quot;);\r\n    //output: obj1 dan stanhope\r\n \r\n    //using apply\r\n    execute.apply(obj2, [&quot;dan&quot;, &quot;stanhope&quot;]);\r\n    //output: obj2 dan stanhope\r\n \r\n    //using old school\r\n    execute(&quot;dan&quot;, &quot;stanhope&quot;);\r\n    //output: undefined &quot;dan&quot; &quot;stanhope&quot;\r\n\r\n"},{"score":21,"body_markdown":"Call() takes comma-separated arguments, ex: \r\n    \r\n`.call(scope, arg1, arg2, arg3)` \r\n\r\nand apply() takes an array of arguments, ex: \r\n\r\n`.apply(scope, [arg1, arg2, arg3])` \r\n\r\nhere are few more usage examples: \r\nhttp://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/"},{"score":35,"body_markdown":"\r\nIt is useful at times for one object to borrow the function of another object, meaning that the borrowing object simply executes the lent function as if it were its own.  \r\n \r\n **A small code example:**\r\n   \r\n    var friend = {\r\n        car: false,\r\n        lendCar: function ( canLend ){\r\n          this.car = canLend;\r\n     }\r\n\r\n    }; \r\n    \r\n    var me = {\r\n        car: false,\r\n        gotCar: function(){\r\n          return this.car === true;\r\n      }\r\n    };\r\n\r\n    console.log(me.gotCar()); // false\r\n\r\n    friend.lendCar.call(me, true); \r\n\r\n    console.log(me.gotCar()); // true\r\n\r\n    friend.lendCar.apply(me, [false]);\r\n\r\n    console.log(me.gotCar()); // false\r\n\r\nThese methods are very useful for giving objects temporary functionality.\r\n\r\n\r\n\r\n"},{"score":12,"body_markdown":"Fundamental difference is that `call()` accepts an ***argument list***, while `apply()` accepts a ***single array of arguments***."},{"score":4,"body_markdown":"Even though `call` and `apply` achive the same thing, I think there is atleast one place where you cannot use `call` but can only use `apply`. That is when you want to support inheritance and want to call the constructor.\r\n\r\nHere is a function allows you to create classes which also supports creating classes by extending other classes.\r\n\r\n    function makeClass( properties ) {\r\n        var ctor = properties[&#39;constructor&#39;] || function(){}\r\n        var Super = properties[&#39;extends&#39;];\r\n        var Class = function () {\r\n                     // Here &#39;call&#39; cannot work, only &#39;apply&#39; can!!!\r\n                     if(Super)\r\n                        Super.apply(this,arguments);  \r\n                     ctor.apply(this,arguments);\r\n                    }\r\n         if(Super){\r\n            Class.prototype = Object.create( Super.prototype );\r\n            Class.prototype.constructor = Class;\r\n         }\r\n         Object.keys(properties).forEach( function(prop) {\r\n               if(prop!==&#39;constructor&#39; &amp;&amp; prop!==&#39;extends&#39;)\r\n                Class.prototype[prop] = properties[prop];\r\n         });\r\n       return Class; \r\n    }\r\n    \r\n    //Usage\r\n    var Car = makeClass({\r\n                 constructor: function(name){\r\n                             this.name=name;\r\n                            },\r\n                 yourName: function() {\r\n                         return this.name;\r\n                       }\r\n              });\r\n    //We have a Car class now\r\n     var carInstance=new Car(&#39;Fiat&#39;);\r\n    carInstance.youName();// ReturnsFiat\r\n    \r\n    var SuperCar = makeClass({\r\n                   constructor: function(ignore,power){\r\n                         this.power=power;\r\n                      },\r\n                   extends:Car,\r\n                   yourPower: function() {\r\n                        return this.power;\r\n                      }\r\n                  });\r\n    //We have a SuperCar class now, which is subclass of Car\r\n    var superCar=new SuperCar(&#39;BMW xy&#39;,2.6);\r\n    superCar.yourName();//Returns BMW xy\r\n    superCar.yourPower();// Returns 2.6"},{"score":26,"body_markdown":"Another example with Call, Apply and Bind.\r\nThe difference between Call and Apply is evident, but **Bind** works like this:\r\n\r\n 1. Bind returns an instance of a function that can be executed\r\n 2. First Parameter is &#39;*this*&#39;\r\n 3. Second parameter is a *Comma separated* list of arguments (like *Call*)\r\n\r\n} \r\n\r\n    function Person(name) {\r\n        this.name = name; \r\n    }\r\n    Person.prototype.getName = function(a,b) { \r\n         return this.name + &quot; &quot; + a + &quot; &quot; + b; \r\n    }\r\n        \r\n    var reader = new Person(&#39;John Smith&#39;);\r\n    \r\n    reader.getName = function() {\r\n       // Apply and Call executes the function and returns value\r\n\r\n       // Also notice the different ways of extracting &#39;getName&#39; prototype\r\n       var baseName = Object.getPrototypeOf(this).getName.apply(this,[&quot;is a&quot;, &quot;boy&quot;]);\r\n       console.log(&quot;Apply: &quot; + baseName);\r\n\r\n       var baseName = Object.getPrototypeOf(reader).getName.call(this, &quot;is a&quot;, &quot;boy&quot;); \r\n       console.log(&quot;Call: &quot; + baseName);\r\n\r\n       // Bind returns function which can be invoked\r\n       var baseName = Person.prototype.getName.bind(this, &quot;is a&quot;, &quot;boy&quot;); \r\n       console.log(&quot;Bind: &quot; + baseName());\r\n    }\r\n        \r\n    reader.getName();\r\n    /* Output\r\n    Apply: John Smith is a boy\r\n    Call: John Smith is a boy\r\n    Bind: John Smith is a boy\r\n    */"},{"score":5,"body_markdown":"Difference between these to methods are, how you want to pass the parameters.\r\n\r\n“A for array and C for comma” is a handy mnemonic."},{"score":5,"body_markdown":"Call and apply both are used to force the `this` value when a function is executed. The only difference is that `call` takes `n+1` arguments where 1 is `this` and `&#39;n&#39; arguments`. `apply` takes only two arguments, one is `this` the other is argument array.\r\n\r\nThe advantage I see in `apply` over `call` is that we can easily delegate a function call to other function without much effort;\r\n\r\n    function sayHello() {\r\n      console.log(this, arguments);\r\n    }\r\n\r\n    function hello() {\r\n      sayHello.apply(this, arguments);\r\n    }\r\n\r\n    var obj = {name: &#39;my name&#39;}\r\n    hello.call(obj, &#39;some&#39;, &#39;arguments&#39;);\r\n\r\nObserve how easily we delegated `hello` to `sayHello` using `apply`, but with `call` this is very difficult to achieve."},{"score":19,"body_markdown":"From [**the MDN docs on Function.prototype.apply()**][1] :\r\n\r\n&gt; The apply() method calls a function with a given `this` value and\r\n&gt; arguments provided as an array (or an array-like object).\r\n&gt; \r\n&gt; ###Syntax\r\n&gt; \r\n&gt;     fun.apply(thisArg, [argsArray])\r\n\r\nFrom [**the MDN docs on Function.prototype.call()**][2] :\r\n\r\n&gt; The call() method calls a function with a given `this` value and arguments provided individually.\r\n&gt; \r\n&gt; ###Syntax\r\n&gt; \r\n&gt;     fun.call(thisArg[, arg1[, arg2[, ...]]])\r\n\r\n\r\nFrom [**Function.apply and Function.call in JavaScript**][3] :\r\n\r\n&gt; The apply() method is identical to call(), except apply() requires an\r\n&gt; array as the second parameter. The array represents the arguments for\r\n&gt; the target method.\r\n\r\n-----------------\r\n\r\n### Code example :\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var doSomething = function() {\r\n        var arr = [];\r\n        for(i in arguments) {\r\n            if(typeof this[arguments[i]] !== &#39;undefined&#39;) {\r\n                arr.push(this[arguments[i]]);\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    \r\n    var output = function(position, obj) {\r\n        document.body.innerHTML += &#39;&lt;h3&gt;output &#39; + position + &#39;&lt;/h3&gt;&#39; + JSON.stringify(obj) + &#39;\\n&lt;br&gt;\\n&lt;br&gt;&lt;hr&gt;&#39;;\r\n    }\r\n    \r\n    output(1, doSomething(\r\n        &#39;one&#39;,\r\n        &#39;two&#39;,\r\n        &#39;two&#39;,\r\n        &#39;one&#39;\r\n    ));\r\n    \r\n    output(2, doSomething.apply({one : &#39;Steven&#39;, two : &#39;Jane&#39;}, [\r\n        &#39;one&#39;,\r\n        &#39;two&#39;,\r\n        &#39;two&#39;,\r\n        &#39;one&#39;\r\n    ]));\r\n    \r\n    output(3, doSomething.call({one : &#39;Steven&#39;, two : &#39;Jane&#39;},\r\n        &#39;one&#39;,\r\n        &#39;two&#39;,\r\n        &#39;two&#39;,\r\n        &#39;one&#39;\r\n    ));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nSee also [**this Fiddle**][4].\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\r\n  [3]: http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx\r\n  [4]: https://jsfiddle.net/k7y5o0d6/9/"},{"score":8,"body_markdown":"The difference is that `call()` takes the function arguments separately, and `apply()` takes the function arguments in an array."},{"score":4,"body_markdown":"The main difference is, using call, we can change the scope and pass arguments as normal, but apply lets you call it using arguments as an Array (pass them as an array). But in terms of what they to do in your code, they are pretty similar.\r\n\r\n&gt; While the syntax of this function is almost identical to that of\r\n&gt; apply(), the fundamental difference is that call() accepts an argument\r\n&gt; list, while apply() accepts a single array of arguments.\r\n\r\nSo as you see, there is not a big difference, but still, there are cases we prefer using call() or apply(). For example, look at the code below, which finding the smallest and largest number in an array from MDN, using the apply method:\r\n\r\n    // min/max number in an array\r\n    var numbers = [5, 6, 2, 3, 7];\r\n    \r\n    // using Math.min/Math.max apply\r\n    var max = Math.max.apply(null, numbers); \r\n    // This about equal to Math.max(numbers[0], ...)\r\n    // or Math.max(5, 6, ...)\r\n    \r\n    var min = Math.min.apply(null, numbers)\r\n\r\nSo the main difference is just the way we passing the arguments:&lt;br&gt; &lt;br&gt; \r\n**Call:**&lt;br&gt; \r\n\r\n    function.call(thisArg, arg1, arg2, ...);\r\n\r\n**Apply:**&lt;br&gt; \r\n\r\n    function.apply(thisArg, [argsArray]);\r\n"},{"score":4,"body_markdown":"## Summary: ##\r\n\r\nBoth `call()` and `apply()` are methods which are located on `Function.prototype`. Therefore they are available on every function object via the prototype chain. Both `call()` and `apply()` can execute a function with a specified value of the `this`.\r\n\r\nThe main difference between `call()` and `apply()` is the way you have to pass in arguments into it. In both `call()` and `apply()` you pass as a first argument the object you want to be the value as `this`. The other arguments differ in the following way:\r\n\r\n - With `call()` you have to put in the arguments normally (starting from the second argument)\r\n - With `apply()` you have to pass in array of arguments.\r\n\r\nExample:\r\n--------\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let obj = {\r\n      val1: 5,\r\n      val2: 10\r\n    }\r\n\r\n    const summation = function (val3, val4) {\r\n      return  this.val1 + this.val2 + val3 + val4;\r\n    }\r\n\r\n    console.log(summation.apply(obj, [2 ,3]));\r\n    // first we assign we value of this in the first arg\r\n    // with apply we have to pass in an array\r\n\r\n\r\n    console.log(summation.call(obj, 2, 3));\r\n    // with call we can pass in each arg individually\r\n\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nWhy would I need to use these functions?\r\n----------------------------------------\r\n\r\nThe `this` value can be tricky sometimes in javascript. The value of `this` determined **when a function is executed not when a function is defined.** If our function is dependend on a right `this` binding we can use `call()` and `apply()` to enforce this behaviour. For example:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var name = &#39;unwantedGlobalName&#39;;\r\n\r\n    const obj =  {\r\n      name: &#39;Willem&#39;,\r\n      sayName () { console.log(this.name);}\r\n    }\r\n\r\n\r\n    let copiedMethod = obj.sayName;\r\n    // we store the function in the copiedmethod variable\r\n\r\n\r\n\r\n    copiedMethod();\r\n    // this is now window, unwantedGlobalName gets logged\r\n\r\n    copiedMethod.call(obj);\r\n    // we enforce this to be obj, Willem gets logged\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":2,"body_markdown":"Let me add a little detail to this.\r\n\r\nthese two calls are almost equivalent:\r\n\r\n    func.call(context, ...args); // pass an array as list with spread operator\r\n\r\n    func.apply(context, args);   // is same as using apply\r\n\r\nThere’s only a minor difference:\r\n\r\n&gt;  - The `spread` operator ... allows passing ***iterable*** `args` as the list to call.\r\n&gt;  - The `apply` accepts only ***array-like*** args.\r\n\r\nSo, these calls complement each other. Where we expect an *iterable*, `call` works, where we expect an *array-like*, `apply` works.\r\n\r\nAnd for objects that are both *iterable* and *array-like*, like a real array, we technically could use any of them, but ***apply*** will probably be **faster** because most JavaScript engines internally optimize it better.\r\n\r\n"},{"score":0,"body_markdown":"A well explained by [flatline][1]. I just want to add a simple example. which makes it easy to understand for beginners.\r\n\r\n    \r\n\r\n    func.call(context, args1 , args2 ); // pass arguments as &quot;,&quot; saprated value\r\n\r\n    func.apply(context, [args1 , args2 ]);   //  pass arguments as &quot;Array&quot;\r\n    \r\nwe also use &quot;Call&quot; and &quot;Apply&quot; method for changing  **reference** as defined in code below \r\n \r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n\r\n\r\n        let Emp1 = {\r\n            name: &#39;X&#39;,\r\n            getEmpDetail: function (age, department) {\r\n                console.log(&#39;Name :&#39;, this.name, &#39;  Age :&#39;, age, &#39;  Department :&#39;, department)\r\n            }\r\n        }\r\n        Emp1.getEmpDetail(23, &#39;Delivery&#39;)\r\n\r\n        // 1st approch of chenging &quot;this&quot;\r\n        let Emp2 = {\r\n            name: &#39;Y&#39;,\r\n            getEmpDetail: Emp1.getEmpDetail\r\n        }\r\n        Emp2.getEmpDetail(55, &#39;Finance&#39;)\r\n\r\n        // 2nd approch of changing &quot;this&quot; using &quot;Call&quot; and &quot;Apply&quot;\r\n        let Emp3 = {\r\n            name: &#39;Z&#39;,\r\n        }\r\n\r\n        Emp1.getEmpDetail.call(Emp3, 30, &#39;Admin&#39;)        \r\n    // here we have change the ref from **Emp1 to Emp3**  object\r\n    // now this will print &quot;Name =  X&quot; because it is pointing to Emp3 object\r\n        Emp1.getEmpDetail.apply(Emp3, [30, &#39;Admin&#39;]) //\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n \r\n\r\n\r\n  [1]: https://stackoverflow.com/a/1986909/9224597"},{"score":0,"body_markdown":"The `call()` method calls a function with a given `this` value and arguments provided individually.[![enter image description here][1]][1]\r\n\r\n\r\n`apply()` - \r\nSimilar to the `call()` method, the first parameter in the `apply()` method sets the `this` value which is the object upon which the function is invoked. In this case, it&#39;s the `obj` object above. The only difference between the `apply()` and `call()` method is that the second parameter of the `apply()` method accepts the arguments to the actual function as an array.\r\n[![enter image description here][2]][2]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/vwr0B.jpg\r\n  [2]: https://i.stack.imgur.com/orgBS.jpg"},{"score":0,"body_markdown":"Both call and apply the same way. It calls immediately when we use call and apply.\r\n\r\nBoth call and apply takes &quot;this&quot; parameter as the first argument and the second argument only differs.\r\n\r\nthe call takes the arguments of the functions as a list  (comma )\r\nApply takes the arguments of the functions as an array.\r\n\r\nYou can find the complete difference between bind, call, and apply in the bellow youtube video.\r\n\r\nhttps://www.youtube.com/watch?v=G-EfxnG0DtY&amp;t=180s\r\n\r\n "}],"score":3169}