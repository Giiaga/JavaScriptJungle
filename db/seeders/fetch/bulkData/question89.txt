{"body":"I&#39;m not that into dynamic programming languages but I&#39;ve written my fair share of JavaScript code. I never really got my head around this prototype-based programming, does any one know how this works? \n\n    var obj = new Object();\n    obj.prototype.test = function() { alert(&#39;Hello?&#39;); };\n    var obj2 = new obj();\n    obj2.test();\n\nI remember a lot discussion I had with people a while back (I&#39;m not exactly sure what I&#39;m doing) but as I understand it, there&#39;s no concept of a class. It&#39;s just an object, and instances of those objects are clones of the original, right?\n\nBut what is the exact purpose of this &quot;.prototype&quot; property in JavaScript? How does it relate to instantiating objects?\n\n### Update: correct way ###\n\n    var obj = new Object(); // not a functional object\n    obj.prototype.test = function() { alert(&#39;Hello?&#39;); }; // this is wrong!\n    \n    function MyObject() {} // a first class functional object\n    MyObject.prototype.test = function() { alert(&#39;OK&#39;); } // OK\n\nAlso these [slides][1] really helped a lot.\n\n  [1]: http://ejohn.org/apps/learn/#64\n\n","title":"How does JavaScript .prototype work?","answers":[{"score":77,"body_markdown":"`prototype` allows you to make classes. if you do not use `prototype` then it becomes a static.\r\n\r\nHere is a short example.\r\n\r\n    var obj = new Object();\r\n    obj.test = function() { alert(&#39;Hello?&#39;); };\r\n\r\nIn the above case, you have static funcation call test. This function can be accessed only by obj.test where you can imagine obj to be a class.\r\n\r\nwhere as in the below code\r\n\r\n    function obj()\r\n    {\r\n    }\r\n\r\n    obj.prototype.test = function() { alert(&#39;Hello?&#39;); };\r\n    var obj2 = new obj();\r\n    obj2.test();\r\n\r\nThe obj has become a class which can now be instantiated. Multiple instances of obj can exist and they all have the `test` function.\r\n\r\nThe above is my understanding. I am making it a community wiki, so people can correct me if I am wrong."},{"score":22,"body_markdown":"&gt; what is the exact purpose of this &quot;.prototype&quot; property?\r\n\r\nThe interface to standard classes become extensible. For example, you are using the `Array` class and you also need to add a custom serializer for all your array objects. Would you spend time coding up a subclass, or use composition or ... The prototype property solves this by letting the users control the exact set of members/methods available to a class.\r\n\r\nThink of prototypes as an extra vtable-pointer. When some members are missing from the original class, the prototype is looked up at runtime."},{"score":30,"body_markdown":"Javascript doesn&#39;t have inheritance in the usual sense, but it has the prototype chain.\r\n\r\nprototype chain\r\n---------------\r\n\r\nIf a member of an object can&#39;t be found in the object it looks for it in the prototype chain. The chain consists of other objects. The prototype of a given instance can be accessed with the `__proto__` variable. Every object has one, as there is no difference between classes and instances in javascript.\r\n\r\nThe advantage of adding a function / variable to the prototype is that it has to be in the memory only once, not for every instance.\r\n\r\nIt&#39;s also useful for inheritance, because the prototype chain can consist of many other objects."},{"score":1024,"body_markdown":"Every JavaScript object [has an internal &quot;slot&quot;][1] called `[[Prototype]]` whose value is either `null` or an `object`. You can think of a slot as a property on an object, internal to the JavaScript engine, hidden from the code you write. The square brackets around `[[Prototype]]` are deliberate, and are an ECMAScript specification convention to denote internal slots. \r\n\r\nThe value pointed at by the `[[Prototype]]` of an object, is colloquially known as &quot;the prototype of that object.&quot; \r\n\r\nIf you access a property via the dot (`obj.propName`) or bracket (`obj[&#39;propName&#39;]`) notation, and the object does not directly have such a property (ie. an *own property*, checkable via `obj.hasOwnProperty(&#39;propName&#39;)`), the runtime looks for a property with that name on the object referenced by the `[[Prototype]]` instead. If the `[[Prototype]]` *also* does not have such a property, its `[[Prototype]]` is checked in turn, and so on. In this way, the original object&#39;s *prototype chain* is walked until a match is found, or its end is reached. At the top of the prototype chain is the `null` value.\r\n\r\nModern JavaScript implementations allow read and/or write access to the `[[Prototype]]` in the following ways:\r\n\r\n1. The `new` operator (configures the prototype chain on the default object returned from a constructor function),\r\n2. The `extends` keyword (configures the prototype chain when using the class syntax),\r\n3. `Object.create` will set the supplied argument as the `[[Prototype]]` of the resulting object,\r\n4. `Object.getPrototypeOf` and `Object.setPrototypeOf` (get/set the `[[Prototype]]` _after_ object creation), and\r\n5. The standardized accessor (ie. getter/setter) property named `__proto__` (similar to 4.)\r\n\r\n`Object.getPrototypeOf` and `Object.setPrototypeOf` are preferred over `__proto__`, in part because the behavior of `o.__proto__` [is unusual][2] when an object has a prototype of `null`.\r\n\r\nAn object&#39;s `[[Prototype]]` is initially set during object creation.\r\n\r\nIf you create a new object via `new Func()`, the object&#39;s `[[Prototype]]` will, by default, be set to the object referenced by `Func.prototype`.\r\n\r\nNote that, therefore, **all classes, and all functions that can be used with the `new` operator, have a property named `.prototype` in addition to their own `[[Prototype]]` internal slot.** This dual use of the word &quot;prototype&quot; is the source of endless confusion amongst newcomers to the language.\r\n\r\nUsing `new` with constructor functions allows us to simulate classical inheritance in JavaScript; although JavaScript&#39;s inheritance system is - as we have seen - prototypical, and not class-based.\r\n\r\nPrior to the introduction of class syntax to JavaScript, constructor functions were the only way to simulate classes. We can think of properties of the object referenced by the constructor function&#39;s `.prototype` property as shared members; ie. members which are the same for each instance. In class-based systems, methods are implemented the same way for each instance, so methods are conceptually added to the `.prototype` property; an object&#39;s fields, however, are instance-specific and are therefore added to the object itself during construction.\r\n\r\nWithout the class syntax, developers had to manually configure the prototype chain to achieve similar functionality to classical inheritance. This led to a preponderance of different ways to achieve this. \r\n\r\nHere&#39;s one way:\r\n\r\n```javascript\r\nfunction Child() {}\r\nfunction Parent() {}\r\nParent.prototype.inheritedMethod = function () { return &#39;this is inherited&#39; }\r\n\r\nfunction inherit(child, parent) {\r\n  child.prototype = Object.create(parent.prototype)\r\n  child.prototype.constructor = child\r\n  return child;\r\n}\r\n\r\nChild = inherit(Child, Parent)\r\nconst o = new Child\r\nconsole.log(o.inheritedMethod()) // &#39;this is inherited&#39;\r\n```\r\n\r\n...and here&#39;s another way:\r\n\r\n```javascript\r\nfunction Child() {}\r\nfunction Parent() {}\r\nParent.prototype.inheritedMethod = function () { return &#39;this is inherited&#39; }\r\n\r\nfunction inherit(child, parent) {\r\n    function tmp() {}\r\n    tmp.prototype = parent.prototype\r\n    const proto = new tmp()\r\n    proto.constructor = child\r\n    child.prototype = proto\r\n    return child\r\n}\r\n\r\nChild = inherit(Child, Parent)\r\nconst o = new Child\r\nconsole.log(o.inheritedMethod()) // &#39;this is inherited&#39;\r\n```\r\n\r\nThe class syntax introduced in ES2015 simplifies things, by providing `extends` as the &quot;one true way&quot; to configure the prototype chain in order to simulate classical inheritance in JavaScript.\r\n\r\nSo, similar to the code above, if you use the class syntax to create a new object like so:\r\n\r\n```javascript\r\nclass Parent { inheritedMethod() { return &#39;this is inherited&#39; } }\r\nclass Child extends Parent {}\r\n\r\nconst o = new Child\r\nconsole.log(o.inheritedMethod()) // &#39;this is inherited&#39;\r\n```\r\n...the resulting object&#39;s `[[Prototype]]` will be set to an instance of `Parent`, whose `[[Prototype]]`, in turn, is `Parent.prototype`.\r\n\r\nFinally, if you create a new object via `Object.create(foo)`, the resulting object&#39;s `[[Prototype]]` will be set to `foo`.\r\n\r\n\r\n  [1]: https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ordinary-object-internal-methods-and-internal-slots\r\n  [2]: https://stackoverflow.com/a/35458348/38522"},{"score":14,"body_markdown":"When a constructor creates an object, that object implicitly references the constructor’s “prototype” property for the purpose of resolving property references. The constructor’s “prototype” property can be referenced by the program expression constructor.prototype, and properties added to an object’s prototype are shared, through inheritance, by all objects sharing the prototype."},{"score":1803,"body_markdown":" \r\nIn a language implementing classical inheritance like Java, C# or C++ you start by creating a class--a blueprint for your objects--and then you can create new objects from that class or you can extend the class, defining a new class that augments the original class.\r\n\r\nIn JavaScript you first create an object (there is no concept of class), then you can augment your own object or create new objects from it. It&#39;s not difficult, but a little foreign and hard to metabolize for somebody used to the classical way.\r\n\r\nExample:\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    //Define a functional object to hold persons in JavaScript\r\n    var Person = function(name) {\r\n      this.name = name;\r\n    };\r\n\r\n    //Add dynamically to the already defined object a new getter\r\n    Person.prototype.getName = function() {\r\n      return this.name;\r\n    };\r\n\r\n    //Create a new object of type Person\r\n    var john = new Person(&quot;John&quot;);\r\n\r\n    //Try the getter\r\n    alert(john.getName());\r\n\r\n    //If now I modify person, also John gets the updates\r\n    Person.prototype.sayMyName = function() {\r\n      alert(&#39;Hello, my name is &#39; + this.getName());\r\n    };\r\n\r\n    //Call the new method on john\r\n    john.sayMyName();\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\nUntil now I&#39;ve been extending the base object, now I create another object and then inheriting from Person.\r\n\r\n    //Create a new object of type Customer by defining its constructor. It&#39;s not \r\n    //related to Person for now.\r\n    var Customer = function(name) {\r\n        this.name = name;\r\n    };\r\n\r\n    //Now I link the objects and to do so, we link the prototype of Customer to \r\n    //a new instance of Person. The prototype is the base that will be used to \r\n    //construct all new instances and also, will modify dynamically all already \r\n    //constructed objects because in JavaScript objects retain a pointer to the \r\n    //prototype\r\n    Customer.prototype = new Person();     \r\n\r\n    //Now I can call the methods of Person on the Customer, let&#39;s try, first \r\n    //I need to create a Customer.\r\n    var myCustomer = new Customer(&#39;Dream Inc.&#39;);\r\n    myCustomer.sayMyName();\r\n\r\n    //If I add new methods to Person, they will be added to Customer, but if I\r\n    //add new methods to Customer they won&#39;t be added to Person. Example:\r\n    Customer.prototype.setAmountDue = function(amountDue) {\r\n        this.amountDue = amountDue;\r\n    };\r\n    Customer.prototype.getAmountDue = function() {\r\n        return this.amountDue;\r\n    };\r\n\r\n    //Let&#39;s try:       \r\n    myCustomer.setAmountDue(2000);\r\n    alert(myCustomer.getAmountDue());\r\n\r\n&lt;!-- begin snippet: js hide: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var Person = function (name) {\r\n        this.name = name;\r\n    };\r\n    Person.prototype.getName = function () {\r\n        return this.name;\r\n    };\r\n    var john = new Person(&quot;John&quot;);\r\n    alert(john.getName());\r\n    Person.prototype.sayMyName = function () {\r\n        alert(&#39;Hello, my name is &#39; + this.getName());\r\n    };\r\n    john.sayMyName();\r\n    var Customer = function (name) {\r\n        this.name = name;\r\n    };\r\n    Customer.prototype = new Person();\r\n\r\n    var myCustomer = new Customer(&#39;Dream Inc.&#39;);\r\n    myCustomer.sayMyName();\r\n    Customer.prototype.setAmountDue = function (amountDue) {\r\n        this.amountDue = amountDue;\r\n    };\r\n    Customer.prototype.getAmountDue = function () {\r\n        return this.amountDue;\r\n    };\r\n    myCustomer.setAmountDue(2000);\r\n    alert(myCustomer.getAmountDue());\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nWhile as said I can&#39;t call setAmountDue(), getAmountDue() on a Person.\r\n\r\n    //The following statement generates an error.\r\n    john.setAmountDue(1000);\r\n\r\n"},{"score":66,"body_markdown":"After reading this thread, I feel confused with JavaScript Prototype Chain, then I found these charts \r\n\r\n[http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance](http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance)\r\n![*[[protytype]]* and `prototype` property of function objects][1]\r\n\r\n*it&#39;s a clear chart to show JavaScript Inheritance by Prototype Chain*\r\n\r\nand \r\n\r\n[http://www.javascriptbank.com/javascript/article/JavaScript_Classical_Inheritance/](http://www.javascriptbank.com/javascript/article/JavaScript_Classical_Inheritance/)\r\n\r\n*this one contains a example with code and several nice diagrams.*\r\n\r\n&gt; prototype chain ultimately falls back to Object.prototype. \r\n\r\n&gt; prototype chain can be technically extended as long as you want, each time by setting the prototype of the subclass equal to an object of the parent class.\r\n\r\n\r\n\r\nHope it&#39;s also helpful for you to understand JavaScript Prototype Chain.\r\n\r\n\r\n  [1]: http://i.stack.imgur.com/rcGmc.png"},{"score":41,"body_markdown":"Every object has an internal property, _[[Prototype]]_, linking it to another object:\r\n\r\n    object [[Prototype]] → anotherObject\r\n\r\nIn traditional javascript, the linked object is the `prototype` property of a function:\r\n\r\n    object [[Prototype]] → aFunction.prototype\r\n\r\nSome environments expose _[[Prototype]]_ as `__proto__`:\r\n\r\n    anObject.__proto__ === anotherObject\r\n\r\nYou create the _[[Prototype]]_ link when creating an object.\r\n\r\n    // (1) Object.create:\r\n    var object = Object.create(anotherObject)\r\n    // object.__proto__ = anotherObject\r\n\r\n    // (2) ES6 object initializer:\r\n    var object = { __proto__: anotherObject };\r\n    // object.__proto__ = anotherObject\r\n\r\n    // (3) Traditional JavaScript:\r\n    var object = new aFunction;\r\n    // object.__proto__ = aFunction.prototype\r\n\r\nSo these statements are equivalent:\r\n\r\n    var object = Object.create(Object.prototype);\r\n    var object = { __proto__: Object.prototype }; // ES6 only\r\n    var object = new Object;\r\n\r\nYou can&#39;t actually see the link target (`Object.prototype`) in a [new](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new) statement; instead the target is implied by the constructor (`Object`).\r\n\r\nRemember:\r\n\r\n- Every object has a link, _[[Prototype]]_, sometimes exposed as [\\__proto__][1].\r\n- Every function has a `prototype` property, initially holding an empty object.\r\n- Objects created with [new](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new) are linked to the `prototype` property of their constructor.\r\n- If a function is never used as a constructor, its `prototype` property will go unused.\r\n- If you don&#39;t need a constructor, use [Object.create](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) instead of `new`.\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"},{"score":16,"body_markdown":"I found it helpful to explain the &quot;prototype chain&quot; as recursive convention when `obj_n.prop_X` is being referenced:\r\n\r\nif `obj_n.prop_X` doesn&#39;t exist, check `obj_n+1.prop_X` where `obj_n+1 = obj_n.[[prototype]]`\r\n\r\nIf the `prop_X` is finally found in the k-th prototype object then\r\n\r\n`obj_1.prop_X = obj_1.[[prototype]].[[prototype]]..(k-times)..[[prototype]].prop_X`\r\n\r\nYou can find a graph of the relation of Javascript objects by their properties here:\r\n\r\n&lt;a href=&quot;www.jsobjects.org&quot;&gt; ![js objects graph][1] &lt;/a&gt;\r\n\r\nhttp://jsobjects.org\r\n\r\n  [1]: http://i.stack.imgur.com/2tGyY.jpg"},{"score":187,"body_markdown":"This is a very simple prototype based object model that would be considered as a sample during the explanation, with no comment yet:\r\n\r\n    function Person(name){\r\n        this.name = name;\r\n    }\r\n    Person.prototype.getName = function(){\r\n        console.log(this.name);\r\n    }\r\n    var person = new Person(&quot;George&quot;);\r\n\r\n---------------------------------------------------------------------------------\r\n\r\n\r\nThere are some crucial points that we have to consider before going through the prototype concept.\r\n\r\n1- How JavaScript functions actually work:\r\n==========================================\r\n\r\nTo take the first step we have to figure out, how JavaScript functions actually work , as a class like function using **`this`** keyword in it or just as a regular function with its arguments, what it does and what it returns.\r\n\r\nLet&#39;s say we want to create a `Person` object model. but in this step I&#39;m gonna be trying to **do the same exact thing without using `prototype` and `new` keyword**.\r\n\r\nSo in this step **`functions`**, **`objects`** and **`this`** keyword, are all we have.\r\n\r\nThe first question would be **how `this` keyword could be useful without using `new` keyword**.\r\n\r\nSo to answer that let&#39;s say we have an empty object, and two functions like:\r\n\r\n    var person = {};\r\n    function Person(name){  this.name = name;  }\r\n\r\n    function getName(){\r\n        console.log(this.name);\r\n    }\r\n\r\nand now **without using `new` keyword** how we could use these functions. So JavaScript has 3 different ways to do that:\r\n\r\na. first way is just to call the function as a regular function:\r\n-------------------------------------------------------------\r\n\r\n    Person(&quot;George&quot;);\r\n    getName();//would print the &quot;George&quot; in the console\r\n\r\nin this case, this would be the current context object, which is usually is the global  `window` object in the browser or `GLOBAL` in `Node.js`. It means we would have, window.name in browser or GLOBAL.name in Node.js, with &quot;George&quot; as its value.\r\n\r\nb. We can **attach** them to an object, as its properties\r\n------------------------------------------------------------------\r\n\r\n-**The easiest way** to do this is modifying the empty `person` object, like:\r\n\r\n    person.Person = Person;\r\n    person.getName = getName;\r\n\r\nthis way we can call them like:\r\n\r\n    person.Person(&quot;George&quot;);\r\n    person.getName();// --&gt;&quot;George&quot;\r\n\r\nand now the `person` object is like:\r\n\r\n    Object {Person: function, getName: function, name: &quot;George&quot;}\r\n\r\n-------------------------------\r\n\r\n-**The other way to attach a property** to an object is using the `prototype` of that object that can be find in any JavaScript object with the name of `__proto__`, and I have tried to explain it a bit on the summary part. So we could get the similar result by doing:\r\n\r\n    person.__proto__.Person = Person;\r\n    person.__proto__.getName = getName;\r\n\r\n**But** this way what we actually are doing is modifying the `Object.prototype`, because whenever we create a JavaScript object using literals (`{ ... }`), it gets created based on `Object.prototype`, which means it gets attached to the newly created object as an attribute named **`__proto__`** , so if we change it, as we have done on our previous code snippet, all the JavaScript objects would get changed, not a good practice. So what could be the better practice now:\r\n\r\n    person.__proto__ = {\r\n        Person: Person,\r\n        getName: getName\r\n    };\r\n\r\nand now other objects are in peace, but it still doesn&#39;t seem to be a good practice. So we have still one more solutions, but to use this solution we should get back to that line of code where `person` object got created (`var person = {};`) then change it like:\r\n\r\n    var propertiesObject = {\r\n        Person: Person,\r\n        getName: getName\r\n    };\r\n    var person = Object.create(propertiesObject);\r\n\r\nwhat it does is creating a new JavaScript `Object` and attach the `propertiesObject` to the `__proto__` attribute. So to make sure you can do:\r\n\r\n    console.log(person.__proto__===propertiesObject); //true\r\nBut the tricky point here is you have access to all the properties defined in `__proto__` on the first level of the `person` object(read the summary part for more detail).\r\n\r\n-----------------------------\r\n\r\n\r\n\r\nas you see using any of these two way `this` would exactly point to the `person` object.\r\n\r\n\r\nc. JavaScript has another way to provide the function with `this`, which is using [call](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call) or [apply](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) to invoke the function.\r\n------------------------------------------------------------------------\r\n\r\n&gt; The apply() method calls a function with a given this value and\r\n&gt; arguments provided as an array (or an array-like object).\r\n&gt; \r\n\r\nand\r\n\r\n&gt; The call() method calls a function with a given this value and\r\n&gt; arguments provided individually.\r\n\r\nthis way which is my favorite, we can easily call our functions like:\r\n    \r\n    Person.call(person, &quot;George&quot;);\r\nor\r\n\r\n    //apply is more useful when params count is not fixed\r\n    Person.apply(person, [&quot;George&quot;]);\r\n\r\n    getName.call(person);   \r\n    getName.apply(person);\r\n\r\nthese 3 methods are the important initial steps to figure out the .prototype functionality.\r\n\r\n-------------------------------------------\r\n\r\n2- How does the `new` keyword work?\r\n====================================\r\n\r\nthis is the second step to understand the `.prototype` functionality.this is what I use to simulate the process:\r\n\r\n    function Person(name){  this.name = name;  }\r\n    my_person_prototype = { getName: function(){ console.log(this.name); } };\r\n\r\nin this part I&#39;m gonna be trying to take all the steps which JavaScript takes, without using the `new` keyword and `prototype`, when you use `new` keyword. so when we do `new Person(&quot;George&quot;)`, `Person` function serves as a constructor, These are what JavaScript does, one by one:\r\n\r\na. first of all it makes an empty object, basically an empty hash like:\r\n--------------------------------------------------------------------\r\n\r\n    var newObject = {};\r\n\r\nb. the next step that JavaScript takes is to **attach** the all prototype objects to the newly created object\r\n------------------------------------------------------------------------\r\n\r\nwe have `my_person_prototype` here similar to the prototype object.\r\n\r\n    for(var key in my_person_prototype){\r\n        newObject[key] = my_person_prototype[key];\r\n    }\r\n\r\nIt is not the way that JavaScript actually attaches the properties that are defined in the prototype. The actual way is related to the prototype chain concept.\r\n\r\n----------\r\n\r\na. &amp; b. Instead of these two steps you can have the exact same result by doing:\r\n------------------------------------------------------------------------\r\n\r\n    var newObject = Object.create(my_person_prototype);\r\n    //here you can check out the __proto__ attribute\r\n    console.log(newObject.__proto__ === my_person_prototype); //true\r\n    //and also check if you have access to your desired properties\r\n    console.log(typeof newObject.getName);//&quot;function&quot;\r\n\r\nnow we can call the `getName` function in our `my_person_prototype`:\r\n\r\n    newObject.getName();\r\n\r\n\r\nc. then it gives that object to the constructor,\r\n------------------------------------------------\r\nwe can do this with our sample like:\r\n\r\n    Person.call(newObject, &quot;George&quot;);\r\nor\r\n\r\n    Person.apply(newObject, [&quot;George&quot;]);\r\n\r\nthen the constructor can do whatever it wants, because **this** inside of that constructor is the object that was just created.\r\n\r\nnow the end result before simulating the other steps:\r\n    Object {name: &quot;George&quot;}\r\n\r\n\r\n\r\n\r\n----------\r\n\r\nSummary:\r\n--------\r\n\r\nBasically, when you use the **new** keyword on a function, you are calling on that and that function serves as a constructor, so when you say:\r\n\r\n    new FunctionName()\r\n\r\nJavaScript internally makes an object, an empty hash and then it gives that object to the constructor, then the constructor can do whatever it wants, because **this** inside of that constructor is the object that was just created and then it gives you that object of course if you haven&#39;t used the return statement in your function or if you&#39;ve put a `return undefined;` at the end of your function body.\r\n\r\nSo when JavaScript goes to look up a property on an object, the first thing it does, is it looks it up on that object. And then there is a secret property **`[[prototype]]`** which we usually have it like **`__proto__`** and that property is what JavaScript looks at next. And when it looks through the **`__proto__`**, as far as it is again another JavaScript object, it has its own **`__proto__`** attribute, it goes up and up until it gets to the point where the next **`__proto__`** is null. The point is the only object in JavaScript that its **`__proto__`** attribute is null is `Object.prototype` object:\r\n\r\n    console.log(Object.prototype.__proto__===null);//true\r\nand that&#39;s how inheritance works in JavaScript.\r\n\r\n![The prototype chain][1]\r\n\r\nIn other words, when you have a prototype property on a function and you call a new on that, after JavaScript finishes looking at that newly created object for properties, it will go look at the function&#39;s `.prototype` and also it is possible that this object has its own internal prototype. and so on.\r\n\r\n\r\n  [1]: http://i.stack.imgur.com/JnpBV.png"},{"score":79,"body_markdown":"## The seven Koans of prototype\r\n\r\nAs Ciro San descended Mount Fire Fox after deep meditation, his mind was clear and peaceful.\r\n\r\nHis hand however, was restless, and by itself grabbed a brush and jotted down the following notes.\r\n\r\n---\r\n\r\n**0)** Two different things can be called &quot;prototype&quot;:\r\n\r\n- the prototype property, as in `obj.prototype`\r\n\r\n- the prototype internal property, denoted as `[[Prototype]]` [in ES5](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2).\r\n\r\n    It can be retrieved via the ES5 `Object.getPrototypeOf()`.\r\n\r\n    Firefox makes it accessible through the `__proto__` property as an extension. [ES6 now mentions](http://www.ecma-international.org/ecma-262/6.0/#sec-additional-ecmascript-features-for-web-browsers) some optional requirements for `__proto__`.\r\n\r\n---\r\n\r\n**1)** Those concepts exist to answer the question:\r\n\r\n&gt; When I do `obj.property`, where does JS look for `.property`?\r\n\r\nIntuitively, classical inheritance should affect property lookup.\r\n\r\n---\r\n\r\n**2)**\r\n\r\n- `__proto__` is used for the dot `.` property lookup as in `obj.property`. \r\n- `.prototype` is *not* used for lookup directly, only indirectly as it determines `__proto__` at object creation with `new`.\r\n\r\nLookup order is:\r\n\r\n- `obj` properties added with `obj.p = ...` or `Object.defineProperty(obj, ...)`\r\n- properties of `obj.__proto__`\r\n- properties of `obj.__proto__.__proto__`, and so on\r\n- if some `__proto__` is `null`, return `undefined`.\r\n\r\nThis is the so-called *prototype chain*.\r\n\r\nYou can avoid `.` lookup with `obj.hasOwnProperty(&#39;key&#39;)` and `Object.getOwnPropertyNames(f)`\r\n\r\n---\r\n\r\n**3)** There are two main ways to set `obj.__proto__`:\r\n\r\n-   `new`:\r\n\r\n        var F = function() {}\r\n        var f = new F()\r\n\r\n    then `new` has set:\r\n\r\n        f.__proto__ === F.prototype\r\n\r\n    *This* is where `.prototype` gets used.\r\n\r\n-   `Object.create`:\r\n\r\n         f = Object.create(proto)\r\n\r\n    sets:\r\n\r\n        f.__proto__ === proto\r\n\r\n---\r\n\r\n**4)** The code:\r\n\r\n    var F = function(i) { this.i = i }\r\n    var f = new F(1)\r\n\r\nCorresponds to the following diagram (some `Number` stuff is omitted):\r\n\r\n```\r\n(Function)       (  F  )                                      (f)-----&gt;(1)\r\n |  ^             | | ^                                        |   i    |\r\n |  |             | | |                                        |        |\r\n |  |             | | +-------------------------+              |        |\r\n |  |constructor  | |                           |              |        |\r\n |  |             | +--------------+            |              |        |\r\n |  |             |                |            |              |        |\r\n |  |             |                |            |              |        |\r\n |[[Prototype]]   |[[Prototype]]   |prototype   |constructor   |[[Prototype]]\r\n |  |             |                |            |              |        |\r\n |  |             |                |            |              |        |\r\n |  |             |                | +----------+              |        |\r\n |  |             |                | |                         |        |\r\n |  |             |                | | +-----------------------+        |\r\n |  |             |                | | |                                |\r\n v  |             v                v | v                                |\r\n(Function.prototype)              (F.prototype)                         |\r\n |                                 |                                    |\r\n |                                 |                                    |\r\n |[[Prototype]]                    |[[Prototype]]          [[Prototype]]|\r\n |                                 |                                    |\r\n |                                 |                                    |\r\n | +-------------------------------+                                    |\r\n | |                                                                    |\r\n v v                                                                    v\r\n(Object.prototype)                                       (Number.prototype)\r\n | | ^\r\n | | |\r\n | | +---------------------------+\r\n | |                             |\r\n | +--------------+              |\r\n |                |              |\r\n |                |              |\r\n |[[Prototype]]   |constructor   |prototype\r\n |                |              |\r\n |                |              |\r\n |                | -------------+\r\n |                | |\r\n v                v |\r\n(null)           (Object)\r\n```\r\n\r\nThis diagram shows many language predefined object nodes:\r\n\r\n- `null`\r\n- `Object`\r\n- `Object.prototype`\r\n- `Function`\r\n- `Function.prototype`\r\n- `1`\r\n- `Number.prototype` (can be found with `(1).__proto__`, parenthesis mandatory to satisfy syntax)\r\n\r\nOur 2 lines of code only created the following new objects:\r\n\r\n- `f`\r\n- `F`\r\n- `F.prototype`\r\n\r\n`i` is now a property of `f` because when you do:\r\n\r\n    var f = new F(1)\r\n\r\nit evaluates `F` with `this` being the value that `new` will return, which then gets assigned to `f`.\r\n\r\n---\r\n\r\n**5)** `.constructor` normally comes from `F.prototype` through the `.` lookup:\r\n\r\n    f.constructor === F\r\n    !f.hasOwnProperty(&#39;constructor&#39;)\r\n    Object.getPrototypeOf(f) === F.prototype\r\n    F.prototype.hasOwnProperty(&#39;constructor&#39;)\r\n    F.prototype.constructor === f.constructor\r\n\r\nWhen we write `f.constructor`, JavaScript does the `.` lookup as:\r\n\r\n- `f` does not have `.constructor`\r\n- `f.__proto__ === F.prototype` has `.constructor === F`, so take it\r\n\r\nThe result `f.constructor == F` is intuitively correct, since `F` is used to construct `f`, e.g. set fields, much like in classic OOP languages. \r\n\r\n---\r\n\r\n**6)** Classical inheritance syntax can be achieved by manipulating prototypes chains.\r\n\r\nES6 adds the `class` and `extends` keywords, which are mostly syntax sugar for previously possible prototype manipulation madness.\r\n\r\n    class C {\r\n        constructor(i) {\r\n            this.i = i\r\n        }\r\n        inc() {\r\n            return this.i + 1\r\n        }\r\n    }\r\n\r\n    class D extends C {\r\n        constructor(i) {\r\n            super(i)\r\n        }\r\n        inc2() {\r\n            return this.i + 2\r\n        }\r\n    }\r\n\r\n&lt;!-- --&gt;\r\n\r\n    // Inheritance syntax works as expected.\r\n    c = new C(1)\r\n    c.inc() === 2\r\n    (new D(1)).inc() === 2\r\n    (new D(1)).inc2() === 3\r\n\r\n&lt;!-- --&gt;\r\n\r\n    // &quot;Classes&quot; are just function objects.\r\n    C.constructor === Function\r\n    C.__proto__ === Function.prototype\r\n    D.constructor === Function\r\n    // D is a function &quot;indirectly&quot; through the chain.\r\n    D.__proto__ === C\r\n    D.__proto__.__proto__ === Function.prototype\r\n\r\n&lt;!-- --&gt;\r\n\r\n    // &quot;extends&quot; sets up the prototype chain so that base class\r\n    // lookups will work as expected\r\n    var d = new D(1)\r\n    d.__proto__ === D.prototype\r\n    D.prototype.__proto__ === C.prototype\r\n    // This is what `d.inc` actually does.\r\n    d.__proto__.__proto__.inc === C.prototype.inc\r\n\r\n&lt;!-- --&gt;\r\n\r\n    // Class variables\r\n    // No ES6 syntax sugar apparently:\r\n    // http://stackoverflow.com/questions/22528967/es6-class-variable-alternatives\r\n    C.c = 1\r\n    C.c === 1\r\n    // Because `D.__proto__ === C`.\r\n    D.c === 1\r\n    // Nothing makes this work.\r\n    d.c === undefined\r\n\r\nSimplified diagram without all predefined objects:\r\n\r\n```\r\n(c)-----&gt;(1)\r\n |   i\r\n |\r\n |\r\n |[[Prototype]]\r\n |\r\n |\r\n v    __proto__\r\n(C)&lt;--------------(D)         (d)\r\n| |                |           |\r\n| |                |           |\r\n| |prototype       |prototype  |[[Prototype]] \r\n| |                |           |\r\n| |                |           |\r\n| |                | +---------+\r\n| |                | |\r\n| |                | |\r\n| |                v v\r\n|[[Prototype]]    (D.prototype)--------&gt; (inc2 function object)\r\n| |                |             inc2\r\n| |                |\r\n| |                |[[Prototype]]\r\n| |                |\r\n| |                |\r\n| | +--------------+\r\n| | |\r\n| | |\r\n| v v\r\n| (C.prototype)-------&gt;(inc function object)\r\n|                inc\r\nv\r\nFunction.prototype\r\n```\r\n\r\nLet&#39;s take a moment to study how the following works:\r\n\r\n    c = new C(1)\r\n    c.inc() === 2\r\n\r\nThe first line sets `c.i` to `1` as explained in &quot;4)&quot;.\r\n\r\nOn the second line, when we do:\r\n\r\n    c.inc()\r\n\r\n- `.inc` is found through the `[[Prototype]]` chain: `c` -&gt; `C` -&gt; `C.prototype` -&gt; `inc`\r\n- when we call a function in Javascript as `X.Y()`, JavaScript automatically sets `this` to equal `X` inside the `Y()` function call! \r\n\r\nThe exact same logic also explains `d.inc` and `d.inc2`.\r\n\r\nThis article https://javascript.info/class#not-just-a-syntax-sugar mentions further effects of `class` worth knowing. Some of them may not be achievable without the `class` keyword (TODO check which):\r\n\r\n- `[[FunctionKind]]:&quot;classConstructor&quot;`, which forces the constructor to be called with new: https://stackoverflow.com/questions/44446650/what-is-the-reason-es6-class-constructors-cant-be-called-as-normal-functions\r\n- Class methods are non-enumerable. Can be done with `Object.defineProperty`.\r\n- Classes always `use strict`. Can be done with an explicit `use strict` for every function, which is admittedly tedious."},{"score":10,"body_markdown":"Let me tell you my understanding of prototypes. I am not going to compare the inheritance here with other languages. I wish people would stop comparing languages, and just understand the language as itself. Understanding prototypes and prototypal inheritance is so simple, as I will show you below.\r\n\r\nPrototype is like a model, based on which you create a product. The crucial point to understand is that when you create an object using another object as it&#39;s prototype, the link between the prototype and the product is ever-lasting. For instance:\r\n\r\n    var model = {x:2};\r\n    var product = Object.create(model);\r\n    model.y = 5;\r\n    product.y\r\n    =&gt;5\r\n\r\nEvery object contains an internal property called the [[prototype]], which can be accessed by the ```Object.getPrototypeOf()``` function. ```Object.create(model)``` creates a new object and sets it&#39;s [[prototype]] property to the object **model**. Hence when you do ```Object.getPrototypeOf(product)```, you will get the object **model**.\r\n\r\nProperties in the **product** are handled in the following way:\r\n\r\n - When a property is accessed to just read it&#39;s value, its looked up in the scope chain. The search for the variable starts from the **product** upwards to it&#39;s prototype. If such a variable is found in the search, the search is stopped right there, and the value is returned. If such a variable cannot be found in the scope chain, undefined is returned.\r\n - When a property is written(altered), then the property is always written on the **product** object. If the **product** does not have such a property already, it is implicitly created and written.\r\n\r\nSuch a linking of objects using the prototype property is called prototypal inheritance. There, it is so simple, agree?"},{"score":10,"body_markdown":"Another attempt to explain [JavaScript prototype-based inheritance](https://github.com/rus0000/jsinheritance) with better pictures\r\n\r\n\r\n[![Simple objects inheritanse][1]](https://github.com/rus0000/jsinheritance)\r\n\r\n\r\n  [1]: http://i.stack.imgur.com/6gEKe.png"},{"score":29,"body_markdown":"This article is long. But I am sure it will clear most of your queries \r\nregarding the &quot;prototypical&quot; nature of JavaScript Inheritance. And even more. Please read the complete article.\r\n\r\nJavaScript basically has two kinds of data types\r\n\r\n - ***Non objects*** \r\n - ***Objects***\r\n \r\n\r\n***Non objects***\r\n\r\nFollowing are the ***Non object*** data types\r\n\r\n - **string**\r\n - **number (including NaN and Infinity)**\r\n - **boolean values(true,false)** \r\n - **undefined**\r\n\r\nThese data types return following when you use the **typeof** operator \r\n\r\n**typeof** *&quot;string literal&quot;* (or a variable containing string literal)  === **&#39;string&#39;**\r\n\r\n**typeof** *5* (or any numeric literal or a variable containing numeric literal or ***NaN or Infynity***)  === **&#39;number&#39;**\r\n\r\n**typeof** *true* (or *false* or a variable containing *true* or *false*)  === **&#39;boolean&#39;**\r\n\r\n**typeof** *undefined* (or an undefined variable or a variable containing *undefined*) === **&#39;undefined&#39;**\r\n\r\nThe **string**,**number** and **boolean** data types can be represented both as **Objects** and **Non objects**.When they are represented as objects their typeof is always === &#39;object&#39;. We shall come back to this once we understand the object data types.\r\n\r\n\r\n***Objects***\r\n\r\nThe object datatypes can be further divided into two types\r\n\r\n 1. **Function type objects**\r\n 2. **Non Function type objects**\r\n\r\nThe **Function type objects** are the ones that return the string **&#39;function&#39;** with **typeof** operator. \r\nAll the user defined functions and all the JavaScript built in objects that can create new objects by using new operator fall into this category. For eg.\r\n\r\n - **Object**\r\n - **String** \r\n - **Number**  \r\n - **Boolean**\r\n - **Array** \r\n - **Typed Arrays**\r\n - **RegExp**\r\n - **Function** \r\n - All the other built in objects that can create new objects by using new operator\r\n - *function* **UserDefinedFunction**(){ /*user defined code */ }\r\n\r\nSo,\r\n**typeof(Object)** === **typeof(String)** === **typeof(Number)** === **typeof(Boolean)** === **typeof(Array)**  === **typeof(RegExp)** === **typeof(Function)**  === **typeof(UserDefinedFunction)** === **&#39;function&#39;**\r\n\r\nAll the ***Function type objects*** are actually instances of the built in JavaScript object **Function** (including the **Function** object i.e it is recursively defined). It is as if the these objects have been defined in the following way\r\n\r\n    var Object= new Function ([native code for object Object])\r\n    var String= new Function ([native code for object String])\r\n    var Number= new Function ([native code for object Number])\r\n    var Boolean= new Function ([native code for object Boolean])\r\n    var Array= new Function ([native code for object Array])\r\n    var RegExp= new Function ([native code for object RegExp])\r\n    var Function= new Function ([native code  for object Function])\r\n    var UserDefinedFunction= new Function (&quot;user defined code&quot;)\r\n\r\nAs mentioned, the ***Function type objects*** can further create new objects using the **new operator**. For e.g an object of type **Object**, **String**, **Number**, **Boolean**, **Array**, **RegExp**  Or **UserDefinedFunction** can be created by using\r\n\r\n    var a=new Object() or var a=Object() or var a={} //Create object of type Object\r\n    var a=new String() //Create object of type String\r\n    var a=new Number() //Create object of type Number\r\n    var a=new Boolean() //Create object of type Boolean\r\n    var a=new Array() or var a=Array() or var a=[]  //Create object of type Array\r\n    var a=new RegExp() or var a=RegExp() //Create object of type RegExp\r\n    var a=new UserDefinedFunction() \r\n\r\nThe objects thus created are all ***Non Function type objects*** and return their **typeof**===**&#39;object&#39;**. In all these cases the object &quot;a&quot; cannot further create \r\nobjects using operator new. So the following is wrong\r\n\r\n    var b=new a() //error. a is not typeof===&#39;function&#39;\r\n\r\nThe built in object **Math** is **typeof**===**&#39;object&#39;**. Hence a new object of type Math cannot be created by new operator.\r\n\r\n    var b=new Math() //error. Math is not typeof===&#39;function&#39;\r\n\r\n\r\nAlso notice that **Object**,**Array** and **RegExp** functions can create a new object without even using **operator new**. However the follwing ones don&#39;t.\r\n\r\n    var a=String() // Create a new Non Object string. returns a typeof===&#39;string&#39; \r\n    var a=Number() // Create a new Non Object Number. returns a typeof===&#39;number&#39;\r\n    var a=Boolean() //Create a new Non Object Boolean. returns a typeof===&#39;boolean&#39;\r\n\r\nThe user defined functions are special case. \r\n\r\n    var a=UserDefinedFunction() //may or may not create an object of type UserDefinedFunction() based on how it is defined.\r\n\r\nSince the ***Function type objects*** can create new objects they are also called ***Constructors***.\r\n\r\nEvery **Constructor/Function** (whether built in or user defined) when defined automatically has a property called **&quot;prototype&quot;** whose value by default is set as an object. This object itself has a property called **&quot;constructor&quot;** which by default references back the **Constructor/Function** .\r\n\r\nFor example when we define a function\r\n\r\n    function UserDefinedFunction()\r\n    {\r\n    }\r\n\r\nfollowing automatically happens\r\n\r\n    UserDefinedFunction.prototype={constructor:UserDefinedFunction}\r\n\r\nThis **&quot;prototype&quot; property** is only present in the **Function type objects** \r\n(and never in **Non Function type objects**). \r\n\r\nThis is because **when a new object is created (using new operator)it inherits all properties and methods from Constructor function&#39;s current prototype object i.e. an** ***internal reference*** **is created in the newly created object that references the object referenced by Constructor function&#39;s current prototype object.**\r\n\r\nThis **&quot;internal reference&quot;** that is created in the object for referencing inherited properties is known as the **object&#39;s prototype** (which references the object referenced by Constructor&#39;s **&quot;prototype&quot;** property but is different from it). For any object (Function or Non Function) this can be retrieved using **Object.getPrototypeOf()** method. Using this method one can trace the prototype chain of an object. \r\n\r\nAlso, **every object that is created** (**Function type** or **Non Function type**) has a **&quot;constructor&quot;** property which is inherited from the object referenced by prototype  property of the Constructor function. By default this **&quot;constructor&quot;** property references the **Constructor function** that created it (if the **Constructor Function&#39;s** default &quot;prototype&quot; is not changed). \r\n\r\nFor all ***Function type objects*** the constructor function is always\r\n***function Function(){}***\r\n\r\nFor ***Non Function type objects*** (e.g Javascript Built in  Math object) the constructor function is the function that created it.\r\nFor **Math** object it is ***function Object(){}***. \r\n\r\nAll the concept explained above can be a little daunting to understand without any supporting code. Please go through the following code line by line to understand the concept. Try to execute it to have a better understanding.\r\n\r\n    function UserDefinedFunction()\r\n    { \r\n    \r\n    } \r\n    \r\n    /* creating the above function automatically does the following as mentioned earlier\r\n    \r\n    UserDefinedFunction.prototype={constructor:UserDefinedFunction}\r\n    \r\n    */\r\n    \r\n    \r\n    var newObj_1=new UserDefinedFunction()\r\n    \r\n    alert(Object.getPrototypeOf(newObj_1)===UserDefinedFunction.prototype)  //Displays true\r\n    \r\n    alert(newObj_1.constructor) //Displays function UserDefinedFunction\r\n    \r\n    //Create a new property in UserDefinedFunction.prototype object\r\n    \r\n    UserDefinedFunction.prototype.TestProperty=&quot;test&quot;\r\n    \r\n    alert(newObj_1.TestProperty) //Displays &quot;test&quot;\r\n    \r\n    alert(Object.getPrototypeOf(newObj_1).TestProperty)// Displays &quot;test&quot;\r\n    \r\n    //Create a new Object\r\n    \r\n    var objA = {\r\n    \t\tproperty1 : &quot;Property1&quot;,\r\n    \t\tconstructor:Array\r\n    \r\n    }\r\n    \r\n    \r\n    //assign a new object to UserDefinedFunction.prototype\r\n    UserDefinedFunction.prototype=objA\r\n    \r\n    alert(Object.getPrototypeOf(newObj_1)===UserDefinedFunction.prototype)  //Displays false. The object referenced by UserDefinedFunction.prototype has changed\r\n    \r\n    //The internal reference does not change\r\n    alert(newObj_1.constructor) // This shall still Display function UserDefinedFunction\r\n    \r\n    alert(newObj_1.TestProperty) //This shall still Display &quot;test&quot; \r\n    \r\n    alert(Object.getPrototypeOf(newObj_1).TestProperty) //This shall still Display &quot;test&quot;\r\n    \r\n    \r\n    //Create another object of type UserDefinedFunction\r\n    var newObj_2= new UserDefinedFunction();\r\n    \r\n    alert(Object.getPrototypeOf(newObj_2)===objA) //Displays true.\r\n    \r\n    alert(newObj_2.constructor) //Displays function Array()\r\n    \r\n    alert(newObj_2.property1) //Displays &quot;Property1&quot;\r\n    \r\n    alert(Object.getPrototypeOf(newObj_2).property1) //Displays &quot;Property1&quot;\r\n    \r\n    //Create a new property in objA\r\n    objA.property2=&quot;property2&quot;\r\n    \r\n    alert(objA.property2) //Displays &quot;Property2&quot;\r\n    \r\n    alert(UserDefinedFunction.prototype.property2) //Displays &quot;Property2&quot;\r\n    \r\n    alert(newObj_2.property2) // Displays Property2\r\n    \r\n    alert(Object.getPrototypeOf(newObj_2).property2) //Displays  &quot;Property2&quot;\r\n\r\n \r\n\r\nThe prototype chain of every object ultimately traces back to Object.prototype (which itself does not have any prototype object) .\r\nFollowing code can be used for tracing the prototype chain of an object\r\n\r\n\r\n    var o=Starting object;\r\n    \t\t\t\r\n    do {\r\n    \talert(o + &quot;\\n&quot; + Object.getOwnPropertyNames(o))\r\n    \t\t\r\n    }while(o=Object.getPrototypeOf(o))\r\n\r\nThe prototype chain for various objects work out as follows.\r\n\r\n - Every Function object (including built in Function object)-&gt;\r\n   Function.prototype -&gt; Object.prototype -&gt; null   \r\n - Simple Objects (created By new Object() or {} including built in Math  object)-&gt;   Object.prototype -&gt; null\r\n - Object created with new or Object.create -&gt; One or More prototype chains -&gt; Object.prototype -&gt; null\r\n\r\nFor creating an object without any prototype use the following:\r\n\r\n    var o=Object.create(null)\r\n    alert(Object.getPrototypeOf(o)) //Displays null\r\n\r\nOne might think that setting the prototype property of the Constructor to null shall create an object with a null prototype. However in such cases the newly created object&#39;s prototype is set to Object.prototype and its constructor is set to function Object. This is demonstrated by the following code\r\n\r\n    function UserDefinedFunction(){}\r\n    UserDefinedFunction.prototype=null// Can be set to any non object value (number,string,undefined etc.)\r\n    \r\n    var o=new UserDefinedFunction()\r\n    alert(Object.getPrototypeOf(o)==Object.prototype)\t//Displays true\r\n    alert(o.constructor)\t//Displays Function Object\r\n\r\n\r\n\r\nFollowing in the summary of this article\r\n\r\n - There are two types of objects **Function types** and **Non Function types**\r\n - Only **Function type objects** can create a new object using the **operator new**. The objects thus created are **Non Function type** objects. The **Non Function type objects** cannot further create an object using **operator new**.\r\n\r\n - All **Function type objects** by default have a **&quot;prototype&quot;** property. This **&quot;prototype&quot;** property references an object that has a **&quot;constructor&quot;** property that by default references the **Function type object** itself.  \r\n\r\n - All objects (**Function type** and **Non Function type**) have a &quot;constructor&quot; property that by default references the **Function type object**/**Constructor** that created it.\r\n\r\n - Every object that gets created internally references the object referenced by\r\n   **&quot;prototype&quot;** property of the Constructor that created it. This object is known as the created ***object&#39;s prototype*** (which is different from Function type objects &quot;prototype&quot; property which it references) . This way the created object can directly access the methods and properties defined in object referenced by the Constructor&#39;s &quot;prototype&quot; property (at the time of object creation).\r\n\r\n - An **object&#39;s prototype** (and hence its inherited property names) can be retrieved using the **Object.getPrototypeOf()**   method. In fact this method \r\ncan be used for navigating the entire prototype chain of the object.\r\n\r\n - The prototype chain of every object ultimately traces back to Object.prototype (Unless the object is created using Object.create(null) in which case the object has no prototype).\r\n\r\n - **typeof(new Array())===&#39;object&#39;** is by design of language and not a mistake as pointed by [Douglas Crockford][1]  \r\n\r\n - Setting the prototype property of the Constructor to null(or undefined,number,true,false,string) shall not create an object with a null prototype. In such cases the newly created object&#39;s prototype is set to Object.prototype and its constructor is set to function Object. \r\n\r\nHope this helps.\r\n\r\n \r\n\r\n\r\n  [1]: http://javascript.crockford.com/survey.html"},{"score":20,"body_markdown":"[The Definitive Guide to Object-Oriented JavaScript](https://www.youtube.com/watch?v=PMfcsYzj-9M) - a very concise and clear ~30min video explanation of the asked question (Prototypal Inheritance topic begins from [5:45](https://youtu.be/PMfcsYzj-9M?t=344), although I&#39;d rather listen to the whole video). The author of this video also made JavaScript object visualizer website http://www.objectplayground.com/.[![enter image description here][1]][1]\r\n[![enter image description here][2]][2]\r\n\r\n\r\n  [1]: http://i.stack.imgur.com/Vf4qR.jpg\r\n  [2]: http://i.stack.imgur.com/xcRpT.jpg"},{"score":10,"body_markdown":"Consider the following `keyValueStore` object :\r\n\r\n    var keyValueStore = (function() {\r\n        var count = 0;\r\n        var kvs = function() {\r\n            count++;\r\n            this.data = {};\r\n            this.get = function(key) { return this.data[key]; };\r\n            this.set = function(key, value) { this.data[key] = value; };\r\n            this.delete = function(key) { delete this.data[key]; };\r\n            this.getLength = function() {\r\n                var l = 0;\r\n                for (p in this.data) l++;\r\n                return l;\r\n            }\r\n        };\r\n        \r\n        return  { // Singleton public properties\r\n            &#39;create&#39; : function() { return new kvs(); },\r\n            &#39;count&#39; : function() { return count; }\r\n        };\r\n    })();\r\n\r\nI can create a new instance of this object by doing this :\r\n\r\n    kvs = keyValueStore.create();\r\n\r\nEach instance of this object would have the following public properties :\r\n\r\n- `data`\r\n- `get` \r\n- `set`\r\n- `delete`\r\n- `getLength`\r\n\r\nNow, suppose we create 100 instances of this `keyValueStore` object. Even though `get`, `set`, `delete`, `getLength` will do the exact same thing for each of these 100 instances, every instance has its own copy of this function.\r\n\r\nNow, imagine if you could have just a single `get`, `set`, `delete` and `getLength` copy, and each instance would reference that same function. This would be better for performance and require less memory.\r\n\r\nThat&#39;s where prototypes come in. A prototype is a &quot;blueprint&quot; of properties that is inherited but not copied by instances. So this means that it exists only once in memory for all instances of an object and is shared by all of those instances.\r\n\r\nNow, consider the `keyValueStore` object again. I could rewrite it like this :\r\n\r\n    var keyValueStore = (function() {\r\n        var count = 0;\r\n        var kvs = function() {\r\n            count++;\r\n            this.data = {};\r\n        };\r\n    \r\n        kvs.prototype = {\r\n            &#39;get&#39; : function(key) { return this.data[key]; },\r\n            &#39;set&#39; : function(key, value) { this.data[key] = value; },\r\n            &#39;delete&#39; : function(key) { delete this.data[key]; },\r\n            &#39;getLength&#39; : function() {\r\n                var l = 0;\r\n                for (p in this.data) l++;\r\n                return l;\r\n            }\r\n        };\r\n    \r\n        return  {\r\n            &#39;create&#39; : function() { return new kvs(); },\r\n            &#39;count&#39; : function() { return count; }\r\n        };\r\n    })();\r\n\r\nThis does EXACTLY the same as the previous version of the `keyValueStore` object, except that all of its methods are now put in a prototype. What this means, is that all of the 100 instances now share these four methods instead of each having their own copy."},{"score":25,"body_markdown":"The concept of `prototypal` inheritance is one of the most complicated for many developers. Let&#39;s try to understand the root of problem to understand `prototypal inheritance` better. Let&#39;s start with a `plain` function. \r\n\r\n[![enter image description here][1]][1]\r\n\r\n\r\nIf we use a `new` operator on the `Tree function`, we call it as a `constructor` function. \r\n\r\n[![enter image description here][2]][2]\r\n\r\nEvery `JavaScript` function has a `prototype`. When you log the `Tree.prototype`, you get...\r\n\r\n[![enter image description here][3]][3]\r\n\r\n\r\nIf you look at the above `console.log()` output, you could a see a constructor property on `Tree.prototype` and a `__proto__` property too. The `__proto__` represents the `prototype` that this `function` is based off, and since this is just a plain `JavaScript function` with no `inheritance` set up yet, it refers to the `Object prototype` which is something just built in to JavaScript...\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\r\n\r\nThis has things like `.toString, .toValue, .hasOwnProperty` etc...\r\n\r\n`__proto__` which was brought my mozilla is deprecated and is replaced by `Object.getPrototypeOf` method to get the `object&#39;s prototype`. \r\n\r\n[![enter image description here][4]][4]\r\n\r\n    Object.getPrototypeOf(Tree.prototype); // Object {} \r\n\r\nLet&#39;s add a method to our `Tree` `prototype`. \r\n\r\n[![enter image description here][1]][1]\r\n\r\n\r\nWe have modified the `Root` and added a `function` branch to it. \r\n\r\n[![enter image description here][2]][2]\r\n\r\nThat means when you create an `instance` of `Tree`, you can call it&#39;s `branch` method.\r\n\r\n[![enter image description here][3]][3]\r\n\r\n\r\nWe can also add `primitives` or `objects` to our `Prototype`. \r\n\r\n[![enter image description here][4]][4]\r\n\r\n\r\nLet&#39;s add a `child-tree` to our `Tree`. \r\n\r\n[![enter image description here][5]][5]\r\n\r\n\r\nHere the `Child` inherits its `prototype` from Tree, what we are doing here is using `Object.create()` method to create a new object based off what you pass, here it is `Tree.prototype`. In this case what we&#39;re doing is setting the prototype of Child to a new object that looks identical to the `Tree` prototype. Next we are setting the `Child&#39;s constructor to Child`, if we don&#39;t it would point to `Tree()`. \r\n\r\n[![enter image description here][6]][6]\r\n\r\n\r\n`Child` now has its own `prototype`, its `__proto__` points to `Tree` and `Tree&#39;s prototype` points to base `Object`. \r\n\r\n    Child  \r\n    |\r\n     \\\r\n      \\\r\n       Tree.prototype\r\n       - branch\r\n       |\r\n       |\r\n        \\\r\n         \\\r\n          Object.prototype\r\n          -toString\r\n          -valueOf\r\n          -etc., etc.\r\n\r\nNow you create an `instance` of `Child` and call `branch` which is originally available in `Tree`. We haven&#39;t actually defined our `branch` on the `Child prototype`. BUT, in the `Root prototype` which Child inherits from. \r\n\r\n[![enter image description here][7]][7]\r\n\r\n\r\n**In JS everything is not an object, everything can act like an object.**\r\n\r\n`Javascript` has primitives like `strings, number, booleans, undefined, null.` They are not `object(i.e reference types)`, but certainly can act like an `object`. Let&#39;s look at an example here.\r\n\r\n[![enter image description here][8]][8]\r\n\r\n\r\nIn the first line of this listing, a `primitive` string value is assigned to name. The second line treats name like an `object` and calls `charAt(0)` using dot notation.\r\n\r\nThis is what happens behind the scenes:\r\n// what the `JavaScript` engine does\r\n\r\n[![enter image description here][9]][9]\r\n\r\n\r\nThe `String object` exists only for one statement before it’s destroyed (a process called `autoboxing`). Let&#39;s again get back to our `prototypal` `inheritance`. \r\n\r\n - `Javascript` supports inheritance via `delegation` based on\r\n   `prototypes`.\r\n - Each `Function` has a `prototype` property, which refers to another\r\n   object.\r\n - `properties/functions` are looked from the `object` itself or via\r\n   `prototype` chain if it does not exist\r\n\r\nA `prototype` in JS is an object which `yields` you to the parent of another `object`. **[ie.. delegation]** `Delegation` means that if you are unable to do something, you’ll tell someone else to do it for you.\r\n\r\n[![enter image description here][10]][10]\r\n\r\n\r\nhttps://jsfiddle.net/say0tzpL/1/\r\n\r\nIf you look up the above fiddle, dog has access to `toString` method, but its not available in it, but available via the prototype chain which delegates to `Object.prototype`\r\n\r\n[![enter image description here][11]][11]\r\n\r\n\r\nIf you look at the below one, we are trying to access the `call` method which is available in every `function`.\r\n\r\n[![enter image description here][12]][12]\r\n\r\n\r\nhttps://jsfiddle.net/rknffckc/\r\n\r\nIf you look up the above fiddle, `Profile` Function has access to `call` method, but its not available in it, but available via the prototype chain which delegates to `Function.prototype`\r\n\r\n[![enter image description here][13]][13]\r\n\r\n\r\n**Note:** `prototype` is a property of the function constructor, whereas `__proto__` is a property of the objects constructed from the function constructor. Every function comes with a `prototype` property whose value is an empty `object`. When we create an instance of the function, we get an internal property `[[Prototype]]` or `__proto__` whose reference is the prototype of the Function `constructor`.\r\n\r\n[![enter image description here][14]][14]\r\n\r\n\r\nThe above diagram looks bit complicated, but brings out the whole picture on how `prototype chaining` works. Let&#39;s walk through this slowly:\r\n\r\nThere are two instance `b1` and `b2`, whose constructor is `Bar` and parent is Foo and has two methods from prototype chain `identify` and `speak` via `Bar` and `Foo`\r\n\r\n[![enter image description here][15]][15]\r\n\r\n\r\nhttps://jsfiddle.net/kbp7jr7n/\r\n\r\nIf you look up the code above, we have `Foo` constructor who has the method `identify()` and `Bar` constructor which has `speak` method. We create two `Bar` instance `b1` and `b2` whose parent type is `Foo`. Now while calling `speak` method of `Bar`, we are able to identify the who is calling the speak via `prototype` chain. \r\n\r\n[![enter image description here][16]][16]\r\n\r\n\r\n`Bar` now has all the methods of `Foo` which are defined in its `prototype`. Let&#39;s dig further in understanding the `Object.prototype` and `Function.prototype` and how they are related. If you look up the constructor of `Foo`, `Bar` and `Object` are `Function constructor`.\r\n\r\n[![enter image description here][17]][17]\r\n\r\n\r\nThe `prototype` of `Bar` is `Foo`, `prototype` of `Foo` is `Object` and if you look closely the `prototype` of `Foo` is related to `Object.prototype`.\r\n\r\n[![enter image description here][18]][18]\r\n\r\n\r\nBefore we close this down, let&#39;s just wrap with a small piece of code here to **summarize everything above**. We are using `instanceof` operator here to check whether an `object` has in its `prototype` chain the `prototype` property of a `constructor` which below summarizes the entire big diagram. \r\n\r\n[![enter image description here][19]][19]\r\n\r\n\r\n  [1]: http://i.stack.imgur.com/BsHT0.png\r\n  [2]: http://i.stack.imgur.com/cU6Qh.png\r\n  [3]: http://i.stack.imgur.com/Xop8c.png\r\n  [4]: http://i.stack.imgur.com/GtcJO.png\r\n  [5]: http://i.stack.imgur.com/ggFON.png\r\n  [6]: http://i.stack.imgur.com/yiZcY.png\r\n  [7]: http://i.stack.imgur.com/k6BNb.png\r\n  [8]: http://i.stack.imgur.com/WVjiv.png\r\n  [9]: http://i.stack.imgur.com/l6MHc.png\r\n  [10]: http://i.stack.imgur.com/W0NUA.png\r\n  [11]: http://i.stack.imgur.com/lWILf.png\r\n  [12]: http://i.stack.imgur.com/iF4RN.png\r\n  [13]: http://i.stack.imgur.com/Mijkj.png\r\n  [14]: http://i.stack.imgur.com/HvzDP.png\r\n  [15]: http://i.stack.imgur.com/EllEL.png\r\n  [16]: http://i.stack.imgur.com/V7fH7.png\r\n  [17]: http://i.stack.imgur.com/wzzRu.png\r\n  [18]: http://i.stack.imgur.com/wEOxo.png\r\n  [19]: http://i.stack.imgur.com/n84uV.png\r\n\r\nI hope this add&#39;s some information, I know this kinda could be big to grasp... in simple words its **it&#39;s just objects linked to objects!!!!** "},{"score":25,"body_markdown":"It may help to categorise prototype chains into two categories.\r\n\r\nConsider the constructor:\r\n\r\n     function Person() {}\r\n\r\nThe value of `Object.getPrototypeOf(Person)` is a function. In fact, it is `Function.prototype`. Since `Person` was created as a function, it shares the same prototype function object that all functions have. It is the same as `Person.__proto__`, but that property should not be used. Anyway, with `Object.getPrototypeOf(Person)` you effectively walk up the ladder of what is called the prototype chain.\r\n\r\nThe chain in upward direction looks like this:\r\n\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`Person` → `Function.prototype` → `Object.prototype` (end point)\r\n\r\nImportant is that this prototype chain has little to do with the objects that `Person` can *construct*. Those constructed objects have their own prototype chain, and this chain can potentially have no close ancestor in common with the one mentioned above.\r\n\r\nTake for example this object:\r\n\r\n    var p = new Person();\r\n    \r\n*p* has no direct prototype-chain relationship with *Person*. Their relationship is a different one. The object *p* has its own prototype chain. Using `Object.getPrototypeOf`, you&#39;ll find the chain is as follows:\r\n\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`p` → `Person.prototype` → `Object.prototype` (end point)\r\n    \r\nThere is no function object in this chain (although that could be).\r\n\r\nSo `Person` seems related to two kinds of chains, which live their own lives. To &quot;jump&quot; from one chain to the other, you use:\r\n\r\n1. `.prototype`: jump from the constructor&#39;s chain to the created-object&#39;s chain. This property is thus only defined for function objects (as `new` can only be used on functions).\r\n\r\n2. `.constructor`: jump from the created-object&#39;s chain to the constructor&#39;s chain.\r\n\r\nHere is a visual presentation of the two prototype chains involved, represented as columns:\r\n\r\n[![enter image description here][1]][1]\r\n\r\nTo summarise:\r\n\r\n&gt; The `prototype` property gives no information of the *subject&#39;s* prototype chain, but of objects *created by* the subject. \r\n\r\nIt is no surprise that the name of the property `prototype` can lead to confusion. It would maybe have been clearer if this property had been named `prototypeOfConstructedInstances` or something along that line.\r\n\r\nYou can jump back and forth between the two prototype chains:\r\n\r\n    Person.prototype.constructor === Person\r\n\r\nThis symmetry can be broken by explicitly assigning a different object to the `prototype` property (more about that later).\r\n\r\n### Create one Function, Get Two Objects\r\n\r\n`Person.prototype` is an object that was created at the same time the function `Person` was created. It has `Person` as constructor, even though that constructor did not actually execute yet. So two objects are created at the same time:\r\n\r\n1. The function `Person` itself\r\n2. The object that will act as prototype when the function is called as a constructor\r\n\r\nBoth are objects, but they have different roles: the function object *constructs*, while the other object represents the prototype of any object that function will construct. The prototype object will become the parent of the constructed object in its prototype chain.\r\n\r\nSince a function is also an object, it also has its own parent in its own prototype chain, but recall that these two chains are about different things. \r\n\r\nHere are some equalities that could help grasp the issue -- all of these print `true`:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function Person() {};\r\n\r\n    // This is prototype chain info for the constructor (the function object):\r\n    console.log(Object.getPrototypeOf(Person) === Function.prototype);\r\n    // Step further up in the same hierarchy:\r\n    console.log(Object.getPrototypeOf(Function.prototype) === Object.prototype);\r\n    console.log(Object.getPrototypeOf(Object.prototype) === null);\r\n    console.log(Person.__proto__ === Function.prototype);\r\n    // Here we swap lanes, and look at the constructor of the constructor\r\n    console.log(Person.constructor === Function);\r\n    console.log(Person instanceof Function);\r\n\r\n    // Person.prototype was created by Person (at the time of its creation)\r\n    // Here we swap lanes back and forth:\r\n    console.log(Person.prototype.constructor === Person);\r\n    // Although it is not an instance of it:\r\n    console.log(!(Person.prototype instanceof Person));\r\n    // Instances are objects created by the constructor:\r\n    var p = new Person();\r\n    // Similarly to what was shown for the constructor, here we have\r\n    // the same for the object created by the constructor:\r\n    console.log(Object.getPrototypeOf(p) === Person.prototype);\r\n    console.log(p.__proto__ === Person.prototype);\r\n    // Here we swap lanes, and look at the constructor\r\n    console.log(p.constructor === Person);\r\n    console.log(p instanceof Person);\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n### Adding levels to the prototype chain\r\n\r\nAlthough a prototype object is created when you create a constructor function, you can ignore that object, and assign another object that should be used as prototype for any subsequent instances created by that constructor.\r\n\r\nFor instance:\r\n\r\n    function Thief() { }\r\n    var p = new Person();\r\n    Thief.prototype = p; // this determines the prototype for any new Thief objects:\r\n    var t = new Thief();\r\n\r\nNow the prototype chain of *t* is one step longer than that of *p*:\r\n\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`t` → `p` → `Person.prototype` → `Object.prototype` (end point)\r\n\r\nThe other prototype chain is not longer: `Thief` and `Person` are siblings sharing the same parent in their prototype chain:\r\n\r\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`Person`}   \r\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`Thief`&amp;nbsp; } → `Function.prototype` → `Object.prototype` (end point)\r\n\r\nThe earlier presented graphic can then be extended to this (the original `Thief.prototype` is left out):\r\n\r\n[![enter image description here][2]][2]\r\n\r\nThe blue lines represent prototype chains, the other coloured lines represent other relationships:\r\n\r\n- between an object and its constructor\r\n- between a constructor and the prototype object that will be used for constructing objects\r\n\r\n  [1]: https://i.stack.imgur.com/FPPdI.png\r\n  [2]: https://i.stack.imgur.com/m5DXc.png"},{"score":7,"body_markdown":"I always like analogies when it comes to understand this type of stuff. &#39;Prototypical inheritance&#39; is pretty confusing in comparison to class bass inheritance in my opinion, even though prototypes are much simpler paradigm. In fact with prototypes, there really is no inheritance, so the name in and of itself misleading, it&#39;s more a type of &#39;delegation&#39;.\r\n\r\nImagine this ....\r\n\r\nYou&#39;re in high-school, and you&#39;re in class and have a quiz that&#39;s due today, but you don&#39;t have a pen to fill out your answers. Doh!\r\n\r\nYou&#39;re sitting next to your friend Finnius, who might have a pen. You ask, and he looks around his desk unsuccessfully, but instead of saying &quot;I don&#39;t have a pen&quot;, he&#39;s a nice friend he checks with his other friend Derp if he has a pen. Derp does indeed have a spare pen and passes it back to Finnius, who passes it over to you to complete your quiz. Derp has entrusted the pen to Finnius, who has delegated the pen to you for use.\r\n\r\nWhat is important here is that Derp does not give the pen to you, as you don&#39;t have a direct *relationship* with him.\r\n\r\nThis, is a simplified example of how prototypes work, where a tree of data is searched for the thing you&#39;re looking for."},{"score":12,"body_markdown":"There&#39;s two distinct but related entities here that need explaining:\r\n\r\n  - The `.prototype` property of functions.\r\n  - The `[[Prototype]]`&lt;sup&gt;&lt;sup&gt;\\[1]&lt;/sup&gt;&lt;/sup&gt; property of all objects&lt;sup&gt;&lt;sup&gt;\\[2]&lt;/sup&gt;&lt;/sup&gt;. \r\n\r\nThese are two different things. \r\n\r\n## The `[[Prototype]]` property:\r\n\r\nThis is a property that exists on all&lt;sup&gt;&lt;sup&gt;\\[2]&lt;/sup&gt;&lt;/sup&gt; objects.\r\n\r\nWhat&#39;s stored here is another object, which, as an object itself, has a `[[Prototype]]` of its own that points to another object. That other object has a `[[Prototype]]` of its own. This story continues until you reach the prototypical object that provides methods that are accessible on all objects (like [`.toString`][1]).\r\n\r\nThe `[[Prototype]]` property is part of what forms the `[[Prototype]]` chain. This chain of `[[Prototype]]` objects is what is examined when, for example, `[[Get]]` or `[[Set]]` operations are performed on an object:\r\n\r\n    var obj = {}\r\n    obj.a         // [[Get]] consults prototype chain\r\n    obj.b = 20    // [[Set]] consults prototype chain\r\n\r\n## The `.prototype` property:\r\n\r\n*This is a property that is only found on functions.* Using a very simple function:\r\n\r\n    function Bar(){};\r\n\r\nThe `.prototype` property *holds an object* that will be assigned to `b.[[Prototype]]` when you do `var b = new Bar`. You can easily examine this:\r\n\r\n    // Both assign Bar.prototype to b1/b2[[Prototype]]\r\n    var b = new Bar;\r\n    // Object.getPrototypeOf grabs the objects [[Prototype]]\r\n    console.log(Object.getPrototypeOf(b) === Bar.prototype) // true\r\n\r\nOne of the most important `.prototype`s is that [of the `Object` function][2]. This prototype holds the prototypical object that all `[[Prototype]]` chains contain. On it, all the available methods for new objects are defined:\r\n\r\n    // Get properties that are defined on this object\r\n    console.log(Object.getOwnPropertyDescriptors(Object.prototype))\r\n\r\nNow, since `.prototype` is an object, it has a `[[Prototype]]` property. When you don&#39;t make any assignments to `Function.prototype`, the `.prototype`&#39;s `[[Prototype]]` points to the prototypical object (`Object.prototype`). This is automatically performed anytime you create a new function. \r\n\r\nThis way, any time you do `new Bar;` the prototype chain is set up for you, you get everything defined on `Bar.prototype` and everything defined on `Object.prototype`:\r\n\r\n    var b = new Bar;\r\n    // Get all Bar.prototype properties\r\n    console.log(b.__proto__ === Bar.prototype)\r\n    // Get all Object.prototype properties\r\n    console.log(b.__proto__.__proto__ === Object.prototype)\r\n\r\nWhen you *do* make assignments to `Function.prototype` all you are doing is extending the prototype chain to include another object. It&#39;s like an insertion in a singly linked list. \r\n\r\nThis basically alters the `[[Prototype]]` chain allowing properties that are defined on the object assigned to `Function.prototype` to be seen by any object created by the function.\r\n\r\n---\r\n\r\n&lt;sup&gt;\\[1: That won&#39;t confuse anyone; made available via [the `__proto__` property][3] in many implementations.&lt;/sup&gt;&lt;br&gt;\r\n&lt;sup&gt;\\[2]: All except [`null`][4].&lt;/sup&gt;\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null"},{"score":1,"body_markdown":"It&#39;s just that you already have an object with `Object.new` but you still don&#39;t have an object when using the constructor syntax."},{"score":3,"body_markdown":"another scheme showing **__proto__**, **prototype** and **constructor** relations:\r\n[![enter image description here][1]][1]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/uy5ce.png"},{"score":9,"body_markdown":"## Summary: ##\r\n\r\n - Functions are objects in javascript and thus can have properties\r\n - (Constructor) functions **always** have a prototype property\r\n - When a function is used as a constructor with the `new` keyword the object gets  prototype. A reference to this prototype can be found on the `__proto__` property of the newly created object.\r\n - This `__proto__` property refers to the `prototype` property of the constructor function.\r\n\r\nExample:\r\n---------\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function Person (name) {\r\n      this.name = name;\r\n    }\r\n\r\n    let me = new Person(&#39;willem&#39;);\r\n\r\n    console.log(Person.prototype) // Person has a prototype property\r\n\r\n    console.log(Person.prototype === me.__proto__) // the __proto__ property of the instance refers to prototype property of the function.\r\n\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nWhy is this usefull:\r\n--------------------\r\n\r\nJavascript has a mechanism when looking up properties on Objects which is called **&#39;prototypal inheritance&#39;**, here is what is basically does:\r\n\r\n - First is checked if the property is located on the Object itself. If so this property is returned.\r\n - If the property is not located on the object itself it will &#39;climb up the protochain&#39;. It basically looks at the object referred to by the __proto__ property. There it checks if the property is available on the object referred to by __proto__\r\n - If the property isn&#39;t located on the __proto__ object it will climb up the __proto__ chain all the way up to Object object.\r\n - If it cannot find the property nowhere on the object and its prototype chain it will return undefined.\r\n\r\n**For example:**\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function Person(name) {\r\n      this.name = name;\r\n    }\r\n\r\n    let mySelf = new Person(&#39;Willem&#39;);\r\n\r\n    console.log(mySelf.__proto__ === Person.prototype);\r\n\r\n    console.log(mySelf.__proto__.__proto__ === Object.prototype);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**Update:**\r\n\r\nThe  `__proto__` property has been deprecated, although it is implemented in most modern browsers a better way to obtain the prototype object reference would be:\r\n\r\n `Object.getPrototypeOf()`\r\n\r\n\r\n"},{"score":0,"body_markdown":"The **Prototype** creates **new object** by cloning existing **object**. So really when we think about prototype we can really think **cloning or making** a copy of something instead of making it up."},{"score":1,"body_markdown":"&gt; It&#39;s important to understand that there is a distinction between an object&#39;s prototype (which is available via `Object.getPrototypeOf(obj)`, or via the deprecated `__proto__` property) and the `prototype` property on constructor functions. The former is the property on each instance, and the latter is the property on the constructor. That is, `Object.getPrototypeOf(new Foobar())` refers to the same object as `Foobar.prototype`.\r\n\r\n\r\nReference: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes"},{"score":0,"body_markdown":"If you want to understand the concept of prototype and prototype based inheritance from the basics, check the official [MDN][1] docs, they explain it pretty well. \r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\r\n\r\n&gt; When it comes to inheritance, JavaScript only has one construct:\r\n&gt; objects. Each object has a private property which holds a link to\r\n&gt; another object called its prototype. That prototype object has a\r\n&gt; prototype of its own, and so on until an object is reached with null\r\n&gt; as its prototype. By definition, null has no prototype, and acts as\r\n&gt; the final link in this prototype chain.\r\n\r\nAlso, here&#39;s another good resource that explains using simple examples - https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain"}],"score":2073}