{"body":"How can I loop through all the entries in an array using JavaScript?\r\n\r\nI thought it was something like this:\r\n\r\n    forEach(instance in theArray)\r\n\r\nWhere `theArray` is my array, but this seems to be incorrect.\r\n\r\n","title":"For-each over an array in JavaScript","answers":[{"score":7246,"body_markdown":"&lt;!--\r\n\r\n=======================================================================\r\n**** EDITORS PLEASE READ THIS FIRST ****\r\n=======================================================================\r\n\r\nEdits are greatly appreciated, and there have been some good ones over the years. Sadly, they&#39;ve been outnumbered by quite poor ones I&#39;ve had to reject (if they were held for review) or roll back (if not).\r\n\r\nPLEASE PLEASE PLEASE:\r\n\r\n* DO NOT EDIT FOR STYLE (code style or prose style).\r\n\r\n* Be REALLY, REALLY SURE of the information you&#39;re adding or changing or taking away; I&#39;ve had to reject many edits over the years that were simply wrong. Double-check the spec, double-check by doing an experiment, and when in ANY doubt, don&#39;t make your change.\r\n\r\n* Please don&#39;t remove links to the ES2015 spec.\r\n\r\n* If you have time, by all means ADD links to MDN alongside the spec link for anything that links to a function (see the links on Array#forEach for an example). I just haven&#39;t had time yet.\r\n\r\nAgain, thank you for your edit, it&#39;s much appreciated.\r\n\r\n=======================================================================\r\n--&gt;\r\n\r\n**TL;DR**\r\n\r\n* Don&#39;t use `for-in` unless you use it with safeguards or are at least aware of why it might bite you.\r\n* Your best bets are usually\r\n\r\n * a `for-of` loop (ES2015+ only),\r\n * `Array#forEach` ([`spec`][1] | [`MDN`][2]) (or its relatives `some` and such) (ES5+ only),\r\n * a simple old-fashioned `for` loop,\r\n * or `for-in` with safeguards.\r\n\r\nBut there&#39;s **lots** more to explore, read on...\r\n\r\n----\r\n\r\nJavaScript has powerful semantics for looping through arrays and array-like objects. I&#39;ve split the answer into two parts: Options for genuine arrays, and options for things that are just array-*like*, such as the `arguments` object, other iterable objects (ES2015+), DOM collections, and so on.\r\n\r\nI&#39;ll quickly note that you can use the ES2015 options *now*, even on ES5 engines, by *transpiling* ES2015 to ES5. Search for &quot;ES2015 transpiling&quot; / &quot;ES6 transpiling&quot; for more...\r\n\r\nOkay, let&#39;s look at our options:\r\n\r\n## For Actual Arrays\r\n\r\nYou have three options in [ECMAScript&amp;nbsp;5][3] (&quot;ES5&quot;), the version most broadly supported at the moment, and two more added in [ECMAScript&amp;nbsp;2015][4] (&quot;ES2015&quot;, &quot;ES6&quot;):\r\n\r\n1. Use `forEach` and related (ES5+)\r\n2. Use a simple `for` loop\r\n3. Use `for-in` *correctly*\r\n4. Use `for-of` (use an iterator implicitly) (ES2015+)\r\n5. Use an iterator explicitly (ES2015+)\r\n\r\nDetails:\r\n\r\n### 1. Use `forEach` and related\r\n\r\nIn any vaguely-modern environment (so, not IE8) where you have access to the `Array` features added by ES5 (directly or using polyfills), you can use `forEach` ([`spec`][1] | [`MDN`][2]):\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\r\n    a.forEach(function(entry) {\r\n        console.log(entry);\r\n    });\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n`forEach` accepts a callback function and, optionally, a value to use as `this` when calling that callback (not used above). The callback is called for each entry in the array, in order, skipping non-existent entries in sparse arrays. Although I only used one argument above, the callback is called with three: The value of each entry, the index of that entry, and a reference to the array you&#39;re iterating over (in case your function doesn&#39;t already have it handy).\r\n\r\nUnless you&#39;re supporting obsolete browsers like IE8 (which NetApps shows at just over 4% market share as of this writing in September&amp;nbsp;2016), you can happily use `forEach` in a general-purpose web page without a shim. If you do need to support obsolete browsers, shimming/polyfilling `forEach` is easily done (search for &quot;es5 shim&quot; for several options).\r\n\r\n`forEach` has the benefit that you don&#39;t have to declare indexing and value variables in the containing scope, as they&#39;re supplied as arguments to the iteration function, and so nicely scoped to just that iteration.\r\n\r\nIf you&#39;re worried about the runtime cost of making a function call for each array entry, don&#39;t be; [details](http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html).\r\n\r\nAdditionally, `forEach` is the &quot;loop through them all&quot; function, but ES5 defined several other useful &quot;work your way through the array and do things&quot; functions, including:\r\n\r\n* [`every`][5] (stops looping the first time the callback returns `false` or something falsey)\r\n* [`some`][6] (stops looping the first time the callback returns `true` or something truthy)\r\n* [`filter`][7] (creates a new array including elements where the filter function returns `true` and omitting the ones where it returns `false`)\r\n* [`map`][8] (creates a new array from the values returned by the callback)\r\n* [`reduce`][9] (builds up a value by repeatedly calling the callback, passing in previous values; see the spec for the details; useful for summing the contents of an array and many other things)\r\n* [`reduceRight`][10] (like `reduce`, but works in descending rather than ascending order)\r\n\r\n### 2. Use a simple `for` loop\r\n\r\nSometimes the old ways are the best:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var index;\r\n    var a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\r\n    for (index = 0; index &lt; a.length; ++index) {\r\n        console.log(a[index]);\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf the length of the array won&#39;t change during the loop, and it&#39;s in performance-sensitive code (unlikely), a slightly more complicated version grabbing the length up front might be a ***tiny*** bit faster:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var index, len;\r\n    var a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\r\n    for (index = 0, len = a.length; index &lt; len; ++index) {\r\n        console.log(a[index]);\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nAnd/or counting backward:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var index;\r\n    var a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\r\n    for (index = a.length - 1; index &gt;= 0; --index) {\r\n        console.log(a[index]);\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nBut with modern JavaScript engines, it&#39;s rare you need to eke out that last bit of juice.\r\n\r\nIn ES2015 and higher, you can make your index and value variables local to the `for` loop:\r\n\r\n    let a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\r\n    for (let index = 0; index &lt; a.length; ++index) {\r\n        let value = a[index];\r\n        console.log(index, value);\r\n    }\r\n    //console.log(index);   // would cause &quot;ReferenceError: index is not defined&quot;\r\n    //console.log(value);   // would cause &quot;ReferenceError: value is not defined&quot;\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\r\n    for (let index = 0; index &lt; a.length; ++index) {\r\n        let value = a[index];\r\n        console.log(index, value);\r\n    }\r\n    try {\r\n        console.log(index);\r\n    } catch (e) {\r\n        console.error(e);   // &quot;ReferenceError: index is not defined&quot;\r\n    }\r\n    try {\r\n        console.log(value);\r\n    } catch (e) {\r\n        console.error(e);   // &quot;ReferenceError: value is not defined&quot;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nAnd when you do that, not just `value` but also `index` is recreated for each loop iteration, meaning closures created in the loop body keep a reference to the `index` (and `value`) created for that specific iteration:\r\n\r\n    let divs = document.querySelectorAll(&quot;div&quot;);\r\n    for (let index = 0; index &lt; divs.length; ++index) {\r\n        divs[index].addEventListener(&#39;click&#39;, e =&gt; {\r\n            console.log(&quot;Index is: &quot; + index);\r\n        });\r\n    }\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let divs = document.querySelectorAll(&quot;div&quot;);\r\n    for (let index = 0; index &lt; divs.length; ++index) {\r\n        divs[index].addEventListener(&#39;click&#39;, e =&gt; {\r\n            console.log(&quot;Index is: &quot; + index);\r\n        });\r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;div&gt;zero&lt;/div&gt;\r\n    &lt;div&gt;one&lt;/div&gt;\r\n    &lt;div&gt;two&lt;/div&gt;\r\n    &lt;div&gt;three&lt;/div&gt;\r\n    &lt;div&gt;four&lt;/div&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf you had five divs, you&#39;d get &quot;Index is: 0&quot; if you clicked the first and &quot;Index is: 4&quot; if you clicked the last. This does **not** work if you use `var` instead of `let`.\r\n\r\n### 3. Use `for-in` *correctly*\r\n\r\nYou&#39;ll get people telling you to use `for-in`, but [that&#39;s not what `for-in` is for][11]. `for-in` loops through the *enumerable properties of an object*, not the indexes of an array. **The order is not guaranteed**, not even in ES2015 (ES6). ES2015+ does define an order to object properties (via [`[[OwnPropertyKeys]]`](https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys), [`[[Enumerate]]`](https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-enumerate), and things that use them like [`Object.getOwnPropertyKeys`][12]), but it didn&#39;t define that `for-in` would follow that order; ES2020 did, though. (Details in [this other answer][13].)\r\n\r\nThe only real use cases for `for-in` on an array are:\r\n\r\n* It&#39;s a [*sparse* arrays][14] with **massive** gaps in it, or\r\n* You&#39;re using non-element properties and you want to include them in the loop\r\n\r\nLooking only at that first example: You can use `for-in` to visit those sparse array elements if you use appropriate safeguards:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // `a` is a sparse array\r\n    var key;\r\n    var a = [];\r\n    a[0] = &quot;a&quot;;\r\n    a[10] = &quot;b&quot;;\r\n    a[10000] = &quot;c&quot;;\r\n    for (key in a) {\r\n        if (a.hasOwnProperty(key)  &amp;&amp;        // These checks are\r\n            /^0$|^[1-9]\\d*$/.test(key) &amp;&amp;    // explained\r\n            key &lt;= 4294967294                // below\r\n            ) {\r\n            console.log(a[key]);\r\n        }\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nNote the three checks:\r\n\r\n1. That the object has its *own* property by that name (not one it inherits from its prototype), and\r\n\r\n2. That the key is all decimal digits (e.g., normal string form, not scientific notation), and\r\n\r\n3. That the key&#39;s value when coerced to a number is &lt;= 2^32 - 2 (which is 4,294,967,294). Where does that number come from? It&#39;s part of the definition of an array index [in the specification](https://tc39.github.io/ecma262/#array-index). Other numbers (non-integers, negative numbers, numbers greater than 2^32 - 2) are not array indexes. The reason it&#39;s 2^32 - **2** is that that makes the greatest index value one lower than 2^32 - **1**, which is the maximum value an array&#39;s `length` can have. (E.g., an array&#39;s length fits in a 32-bit unsigned integer.) *(Props to RobG for pointing out in a comment [on my blog post](http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html) that my previous test wasn&#39;t quite right.)*\r\n\r\nYou wouldn&#39;t do that in inline code, of course. You&#39;d write a utility function. Perhaps:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // Utility function for antiquated environments without `forEach`\r\n    var hasOwn = Object.prototype.hasOwnProperty;\r\n    var rexNum = /^0$|^[1-9]\\d*$/;\r\n    function sparseEach(array, callback, thisArg) {\r\n        var index;\r\n        for (var key in array) {\r\n            index = +key;\r\n            if (hasOwn.call(a, key) &amp;&amp;\r\n                rexNum.test(key) &amp;&amp;\r\n                index &lt;= 4294967294\r\n                ) {\r\n                callback.call(thisArg, array[key], index, array);\r\n            }\r\n        }\r\n    }\r\n\r\n    var a = [];\r\n    a[5] = &quot;five&quot;;\r\n    a[10] = &quot;ten&quot;;\r\n    a[100000] = &quot;one hundred thousand&quot;;\r\n    a.b = &quot;bee&quot;;\r\n\r\n    sparseEach(a, function(value, index) {\r\n        console.log(&quot;Value at &quot; + index + &quot; is &quot; + value);\r\n    });\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n### 4. Use `for-of` (use an iterator implicitly) (ES2015+)\r\n\r\nES2015 added [*iterators*][20] to JavaScript. The easiest way to use iterators is the new `for-of` statement. It looks like this:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\r\n    for (const val of a) {\r\n        console.log(val);\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nUnder the covers, that gets an *iterator* from the array and loops through it, getting the values from it. This doesn&#39;t have the issue that using `for-in` has, because it uses an iterator defined by the object (the array), and arrays define that their iterators iterate through their *entries* (not their properties). Unlike `for-in` in ES5, the order in which the entries are visited is the numeric order of their indexes.\r\n\r\n### 5. Use an iterator explicitly (ES2015+)\r\n\r\nSometimes, you might want to use an [iterator][20] *explicitly*. You can do that, too, although it&#39;s a lot clunkier than `for-of`. It looks like this:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\r\n    const it = a.values();\r\n    let entry;\r\n    while (!(entry = it.next()).done) {\r\n        console.log(entry.value);\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe iterator is an object matching the Iterator definition in the specification. Its `next` method returns a new *result object* each time you call it. The result object has a property, `done`, telling us whether it&#39;s done, and a property `value` with the value for that iteration. (`done` is optional if it would be `false`, `value` is optional if it would be `undefined`.)\r\n\r\nThe meaning of `value` varies depending on the iterator; arrays support (at least) three functions that return iterators:\r\n\r\n* `values()`: This is the one I used above. It returns an iterator where each `value` is the array entry for that iteration (`&quot;a&quot;`, `&quot;b&quot;`, and `&quot;c&quot;` in the example earlier).\r\n* `keys()`: Returns an iterator where each `value` is the key for that iteration (so for our `a` above, that would be `&quot;0&quot;`, then `&quot;1&quot;`, then `&quot;2&quot;`).\r\n* `entries()`: Returns an iterator where each `value` is an array in the form `[key, value]` for that iteration.\r\n\r\n## For Array-Like Objects\r\n\r\nAside from true arrays, there are also *array-like* objects that have a `length` property and properties with numeric names: `NodeList` instances, the `arguments` object, etc. How do we loop through their contents?\r\n\r\n### Use any of the options above for arrays\r\n\r\nAt least some, and possibly most or even all, of the array approaches above frequently apply equally well to array-like objects:\r\n\r\n1. **Use `forEach` and related (ES5+)**\r\n\r\n    The various functions on `Array.prototype` are &quot;intentionally generic&quot; and can usually be used on array-like objects via [`Function#call`][15] or [`Function#apply`][16]. (See the *Caveat for host-provided objects* at the end of this answer, but it&#39;s a rare issue.)\r\n\r\n    Suppose you wanted to use `forEach` on a `Node`&#39;s `childNodes` property. You&#39;d do this:\r\n\r\n        Array.prototype.forEach.call(node.childNodes, function(child) {\r\n            // Do something with `child`\r\n        });\r\n\r\n    If you&#39;re going to do that a lot, you might want to grab a copy of the function reference into a variable for reuse, e.g.:\r\n\r\n        // (This is all presumably in some scoping function)\r\n        var forEach = Array.prototype.forEach;\r\n\r\n        // Then later...\r\n        forEach.call(node.childNodes, function(child) {\r\n            // Do something with `child`\r\n        });\r\n           \r\n2. **Use a simple `for` loop**\r\n\r\n    Obviously, a simple `for` loop applies to array-like objects.\r\n\r\n3. **Use `for-in` *correctly***\r\n\r\n    `for-in` with the same safeguards as with an array should work with array-like objects as well; the caveat for host-provided objects on #1 above may apply.\r\n\r\n4. **Use `for-of` (use an iterator implicitly) (ES2015+)**\r\n\r\n    `for-of` uses the [iterator][20] provided by the object (if any). That includes host-provided objects. For instance, the specification for the `NodeList` from `querySelectorAll` was updated to support iteration. The spec for the `HTMLCollection` from `getElementsByTagName` was not.\r\n\r\n5. **Use an iterator explicitly (ES2015+)**\r\n\r\n    See #4.\r\n\r\n### Create a true array\r\n\r\nOther times, you may want to convert an array-like object into a true array. Doing that is surprisingly easy:\r\n\r\n1. **Use the `slice` method of arrays**\r\n\r\n    We can use the [`slice`](https://tc39.github.io/ecma262/#sec-array.prototype.slice) method of arrays, which like the other methods mentioned above is &quot;intentionally generic&quot; and so can be used with array-like objects, like this:\r\n\r\n        var trueArray = Array.prototype.slice.call(arrayLikeObject);\r\n\r\n    So for instance, if we want to convert a `NodeList` into a true array, we could do this:\r\n\r\n        var divs = Array.prototype.slice.call(document.querySelectorAll(&quot;div&quot;));\r\n\r\n    See the *Caveat for host-provided objects* below. In particular, note that this will fail in IE8 and earlier, which don&#39;t let you use host-provided objects as `this` like that.\r\n\r\n2. **Use spread syntax (`...`)**\r\n\r\n    It&#39;s also possible to use ES2015&#39;s [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) with JavaScript engines that support this feature. Like `for-of`, this uses the [iterator][20] provided by the object (see #4 in the previous section):\r\n\r\n        var trueArray = [...iterableObject];\r\n\r\n    So for instance, if we want to convert a `NodeList` into a true array, with spread syntax this becomes quite succinct:\r\n\r\n        var divs = [...document.querySelectorAll(&quot;div&quot;)];\r\n\r\n3. **Use `Array.from`**\r\n\r\n    `Array.from` [(spec)][17] | [(MDN)][18] (ES2015+, but easily polyfilled) creates an array from an array-like object, optionally passing the entries through a mapping function first. So:\r\n\r\n        var divs = Array.from(document.querySelectorAll(&quot;div&quot;));\r\n\r\n    Or if you wanted to get an array of the tag names of the elements with a given class, you&#39;d use the mapping function:\r\n\r\n        // Arrow function (ES2015):\r\n        var divs = Array.from(document.querySelectorAll(&quot;.some-class&quot;), element =&gt; element.tagName);\r\n\r\n        // Standard function (since `Array.from` can be shimmed):\r\n        var divs = Array.from(document.querySelectorAll(&quot;.some-class&quot;), function(element) {\r\n            return element.tagName;\r\n        });\r\n\r\n### Caveat for host-provided objects\r\n\r\nIf you use `Array.prototype` functions with *host-provided* array-like objects (DOM lists and other things provided by the browser rather than the JavaScript engine), you need to be sure to test in your target environments to make sure the host-provided object behaves properly. **Most do behave properly** (now), but it&#39;s important to test. The reason is that most of the `Array.prototype` methods you&#39;re likely to want to use rely on the host-provided object giving an honest answer to the abstract [`[[HasProperty]]`][19] operation. As of this writing, browsers do a very good job of this, but the 5.1 spec did allow for the possibility a host-provided object may not be honest. It&#39;s in [&#167;8.6.2](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2), several paragraphs below the big table near the beginning of that section), where it says:\r\n\r\n&gt; Host objects may implement these internal methods in any manner unless specified otherwise; for example, one possibility is that `[[Get]]` and `[[Put]]` for a particular host object indeed fetch and store property values but `[[HasProperty]]` always generates **false**.\r\n\r\n(I couldn&#39;t find the equivalent verbiage in the ES2015 spec, but it&#39;s bound to still be the case.) Again, as of this writing the common host-provided array-like objects in modern browsers [`NodeList` instances, for instance] **do** handle `[[HasProperty]]` correctly, but it&#39;s important to test.)\r\n\r\n\r\n  [1]: https://tc39.github.io/ecma262/#sec-array.prototype.foreach\r\n  [2]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n  [3]: http://ecma-international.org/ecma-262/5.1/\r\n  [4]: http://www.ecma-international.org/ecma-262/6.0/index.html\r\n  [5]: https://tc39.github.io/ecma262/#sec-array.prototype.every\r\n  [6]: https://tc39.github.io/ecma262/#sec-array.prototype.some\r\n  [7]: https://tc39.github.io/ecma262/#sec-array.prototype.filter\r\n  [8]: https://tc39.github.io/ecma262/#sec-array.prototype.map\r\n  [9]: https://tc39.github.io/ecma262/#sec-array.prototype.reduce\r\n  [10]: https://tc39.github.io/ecma262/#sec-array.prototype.reduceright\r\n  [11]: http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html\r\n  [12]: https://tc39.github.io/ecma262/#sec-object.getownpropertynames\r\n  [13]: https://stackoverflow.com/a/30919039/157247\r\n  [14]: http://en.wikipedia.org/wiki/Sparse_array\r\n  [15]: https://tc39.github.io/ecma262/#sec-function.prototype.call\r\n  [16]: https://tc39.github.io/ecma262/#sec-function.prototype.apply\r\n  [17]: https://tc39.github.io/ecma262/#sec-array.from\r\n  [18]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\r\n  [19]: https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p\r\n  [20]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\r\n"},{"score":533,"body_markdown":"**Note**: This answer is hopelessly out-of-date. For a more modern approach, look at [the methods available on an array][1]. Methods of interest might be:\r\n\r\n* forEach\r\n* map\r\n* filter\r\n* zip\r\n* reduce\r\n* every\r\n* some\r\n\r\n---\r\n\r\nThe standard way to iterate an array in [JavaScript][2] is a vanilla `for`-loop:\r\n\r\n    var length = arr.length,\r\n        element = null;\r\n    for (var i = 0; i &lt; length; i++) {\r\n      element = arr[i];\r\n      // Do something with element\r\n    }\r\n\r\nNote, however, that this approach is only good if you have a dense array, and each index is occupied by an element. If the array is sparse, then you can run into performance problems with this approach, since you will iterate over a lot of indices that do not *really* exist in the array. In this case, a `for .. in`-loop might be a better idea. **However**, you must use the appropriate safeguards to ensure that only the desired properties of the array (that is, the array elements) are acted upon, since the `for..in`-loop will also be enumerated in legacy browsers, or if the additional properties are defined as `enumerable`.\r\n\r\nIn [ECMAScript 5][3] there will be a forEach method on the array prototype, but it is not supported in legacy browsers. So to be able to use it consistently you must either have an environment that supports it (for example, [Node.js][4] for server side JavaScript), or use a &quot;Polyfill&quot;. The Polyfill for this functionality is, however, trivial and since it makes the code easier to read, it is a good polyfill to include.\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\r\n  [2]: http://en.wikipedia.org/wiki/JavaScript\r\n  [3]: https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition\r\n  [4]: http://en.wikipedia.org/wiki/Node.js\r\n\r\n"},{"score":47,"body_markdown":"If you want to loop over an array, use the standard three-part `for` loop.\r\n\r\n    for (var i = 0; i &lt; myArray.length; i++) {\r\n        var arrayItem = myArray[i];\r\n    }\r\n\r\nYou can get some performance optimisations by caching `myArray.length` or iterating over it backwards."},{"score":24,"body_markdown":"There isn&#39;t any `for each` loop in native [JavaScript][1]. You can either use libraries to get this functionality (I recommend [Underscore.js][2]), use a simple `for` in loop.\r\n\r\n    for (var instance in objects) {\r\n       ...\r\n    }\r\n\r\nHowever, note that there may be reasons to use an even simpler `for` loop (see Stack Overflow question *[Why is using “for…in” with array iteration such a bad idea?][3]*)\r\n   \r\n    var instance;\r\n    for (var i=0; i &lt; objects.length; i++) {\r\n        var instance = objects[i];\r\n        ...\r\n    }\r\n\r\n  [1]: http://en.wikipedia.org/wiki/JavaScript\r\n  [2]: http://en.wikipedia.org/wiki/Underscore.js\r\n  [3]: https://stackoverflow.com/questions/500504\r\n"},{"score":90,"body_markdown":"Some [C][1]-style languages use `foreach` to loop through enumerations. In JavaScript this is done with the [`for..in` loop structure][2]:\r\n\r\n    var index,\r\n        value;\r\n    for (index in obj) {\r\n        value = obj[index];\r\n    }\r\n\r\nThere is a catch. `for..in` will loop through each of the object&#39;s enumerable members, and the members on its prototype. To avoid reading values that are inherited through the object&#39;s prototype, simply check if the property belongs to the object:\r\n\r\n    for (i in obj) {\r\n        if (obj.hasOwnProperty(i)) {\r\n            //do stuff\r\n        }\r\n    }\r\n\r\nAdditionally, [ECMAScript 5][3] has added a [`forEach`][4] method to `Array.prototype` which can be used to enumerate over an array using a calback (the polyfill is in the docs so you can still use it for older browsers):\r\n\r\n    arr.forEach(function (val, index, theArray) {\r\n        //do stuff\r\n    });\r\n\r\nIt&#39;s important to note that `Array.prototype.forEach` doesn&#39;t break when the callback returns `false`. [jQuery][5] and [Underscore.js][6] provide their own variations on `each` to provide loops that can be short-circuited.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/C_%28programming_language%29\r\n  [2]: https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in\r\n  [3]: https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition\r\n  [4]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\r\n  [5]: http://en.wikipedia.org/wiki/JQuery\r\n  [6]: http://en.wikipedia.org/wiki/Underscore.js\r\n"},{"score":251,"body_markdown":"If you’re using the [**jQuery**](http://jquery.com/) library, you can use [**jQuery.each**](http://api.jquery.com/jQuery.each/):\r\n\r\n&lt;!-- language-all: lang-js --&gt;\r\n\r\n    $.each(yourArray, function(index, value) {\r\n      // do your stuff here\r\n    });\r\n\r\n**EDIT :** \r\n\r\nAs per question, user want code in javascript instead of jquery so the edit is\r\n\r\n    var length = yourArray.length;   \r\n    for (var i = 0; i &lt; length; i++) {\r\n      // Do something with yourArray[i].\r\n    }\r\n\r\n"},{"score":36,"body_markdown":"If you don&#39;t mind emptying the array:\r\n\r\n    var x;\r\n\r\n    while(x = y.pop()){ \r\n    \r\n        alert(x); //do something \r\n    \r\n    }\r\n\r\n`x` will contain the last value of `y` and it will be removed from the array. You can also use `shift()` which will give and remove the first item from `y`."},{"score":33,"body_markdown":"A **forEach** implementation ([see in jsFiddle][1]):\r\n\r\n    function forEach(list,callback) {\r\n      var length = list.length;\r\n      for (var n = 0; n &lt; length; n++) {\r\n        callback.call(list[n]);\r\n      }\r\n    }\r\n    \r\n    var myArray = [&#39;hello&#39;,&#39;world&#39;];\r\n    \r\n    forEach(\r\n      myArray,\r\n      function(){\r\n        alert(this); // do something\r\n      }\r\n    );\r\n\r\n\r\n  [1]: http://jsfiddle.net/nmoliveira/zNsyB/"},{"score":29,"body_markdown":"An easy solution now would be to use the [underscore.js library][1]. It&#39;s providing many useful tools, such as `each` and will automatically delegate the job to the native `forEach` if available.\r\n\r\n[A CodePen example][2] of how it works is:\r\n\r\n    var arr = [&quot;elemA&quot;, &quot;elemB&quot;, &quot;elemC&quot;];\r\n    _.each(arr, function(elem, index, ar)\r\n    {\r\n    ...\r\n    });\r\n\r\n###See also\r\n\r\n - [Documentation for native `Array.prototype.forEach()`][3].\r\n - In *[for_each...in][4]* (MDN) it is explained that `for each (variable in object)` is deprecated as the part of ECMA-357 ([EAX][5]) standard.\r\n - [for...of][6] (MDN) describes the next way of iterating using `for (variable of object)` as the part of the Harmony (ECMAScript&amp;nbsp;6) proposal.\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Underscore.js\r\n  [2]: http://codepen.io/Micka33/pen/nbyxf\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in\r\n  [5]: https://developer.mozilla.org/en-US/docs/E4X\r\n  [6]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of\r\n"},{"score":30,"body_markdown":"Probably the `for(i = 0; i &lt; array.length; i++)` loop is not the best choice. Why? If you have this:\r\n\r\n    var array = new Array();\r\n    array[1] = &quot;Hello&quot;;\r\n    array[7] = &quot;World&quot;;\r\n    array[11] = &quot;!&quot;;\r\n\r\nThe method will call from `array[0]` to `array[2]`. First, this will first reference variables you don&#39;t even have, second you would not have the variables in the array, and third this will make the code bolder. Look here, it&#39;s what I use:\r\n\r\n    for(var i in array){\r\n        var el = array[i];\r\n        //If you want &#39;i&#39; to be INT just put parseInt(i)\r\n        //Do something with el\r\n    }\r\n\r\nAnd if you want it to be a function, you can do this:\r\n\r\n    function foreach(array, call){\r\n        for(var i in array){\r\n            call(array[i]);\r\n        }\r\n    }\r\n\r\nIf you want to break, a little more logic:\r\n\r\n    function foreach(array, call){\r\n        for(var i in array){\r\n            if(call(array[i]) == false){\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\nExample:\r\n\r\n    foreach(array, function(el){\r\n        if(el != &quot;!&quot;){\r\n            console.log(el);\r\n        } else {\r\n            console.log(el+&quot;!!&quot;);\r\n        }\r\n    });\r\n\r\nIt returns:\r\n\r\n    //Hello\r\n    //World\r\n    //!!!\r\n"},{"score":30,"body_markdown":"There are three implementations of `foreach` in [jQuery][1] as follows.\r\n\r\n    var a = [3,2];\r\n    \r\n    $(a).each(function(){console.log(this.valueOf())}); //Method 1\r\n    $.each(a, function(){console.log(this.valueOf())}); //Method 2\r\n    $.each($(a), function(){console.log(this.valueOf())}); //Method 3\r\n\r\n  [1]: http://en.wikipedia.org/wiki/JQuery\r\n"},{"score":23,"body_markdown":"This is an iterator for NON-sparse list where the index starts at 0, which is the typical scenario when dealing with document.getElementsByTagName or document.querySelectorAll)\r\n\r\n\r\n    function each( fn, data ) {\r\n\r\n        if(typeof fn == &#39;string&#39;)\r\n            eval(&#39;fn = function(data, i){&#39; + fn + &#39;}&#39;);\r\n    \r\n        for(var i=0, L=this.length; i &lt; L; i++) \r\n            fn.call( this[i], data, i );   \r\n    \r\n        return this;\r\n    }\r\n\r\n    Array.prototype.each = each;  \r\n\r\n\r\n**Examples of usage:**\r\n\r\n**Example #1**\r\n\r\n    var arr = [];\r\n    [1, 2, 3].each( function(a){ a.push( this * this}, arr);\r\n    arr = [1, 4, 9]\r\n\r\n**Example #2**\r\n\r\n    each.call(document.getElementsByTagName(&#39;p&#39;), &quot;this.className = data;&quot;,&#39;blue&#39;);\r\n\r\nEach p tag gets `class=&quot;blue&quot;`\r\n\r\n**Example #3**\r\n\r\n    each.call(document.getElementsByTagName(&#39;p&#39;), \r\n        &quot;if( i % 2 == 0) this.className = data;&quot;,\r\n        &#39;red&#39;\r\n    );\r\n\r\nEvery other p tag gets `class=&quot;red&quot;`&gt;\r\n\r\n\r\n**Example #4**\r\n\r\n    each.call(document.querySelectorAll(&#39;p.blue&#39;), \r\n        function(newClass, i) {\r\n            if( i &lt; 20 )\r\n                this.className = newClass;\r\n        }, &#39;green&#39;\r\n    );\r\n\r\nAnd finally the first 20 blue p tags are changed to green\r\n        \r\n            \r\n\r\nCaution when using string as function: the function is created out-of-context and ought to be used only where you are certain of variable scoping.  Otherwise, better to pass functions where scoping is more intuitive."},{"score":12,"body_markdown":"jQuery way using `$.map`:\r\n\r\n    var data = [1, 2, 3, 4, 5, 6, 7];\r\n\r\n    var newData = $.map(data, function(element) {\r\n        if (element % 2 == 0) {\r\n            return element;\r\n        }\r\n    });\r\n\r\n    // newData = [2, 4, 6];\r\n"},{"score":127,"body_markdown":"# Loop backwards\r\n\r\nI think the *reverse* for loop deserves a mention here:\r\n\r\n    for (var i = array.length; i--; ) {\r\n         // process array[i]\r\n    }\r\n\r\n## Advantages:\r\n\r\n- You do not need to declare a temporary `len` variable, or compare against `array.length` on each iteration, either of which might be a minute optimisation.\r\n- **Removing siblings** from the DOM in reverse order is usually **more efficient**.  (The browser needs to do less shifting of elements in its internal arrays.)\r\n- If you **modify the array** while looping, at or after index *i* (for example you remove or insert an item at `array[i]`), then a forward loop would skip the item that shifted left into position *i*, or re-process the *i*th item that was shifted right.  In a traditional for loop, you *could* update *i* to point to the next item that needs processing - 1, but simply reversing the direction of iteration is often a **simpler** and [more elegant solution][1].\r\n- Similarly, when modifying or removing **nested** DOM elements, processing in reverse can **circumvent errors**. For example, consider modifying the innerHTML of a parent node before handling its children.  By the time the child node is reached it will be detached from the DOM, having been replaced by a newly created child when the parent&#39;s innerHTML was written.\r\n- It is **shorter** to type, and **read**, than some of the other options available.  Although it loses to `forEach()` and to ES6&#39;s `for ... of`.\r\n\r\n## Disadvantages:\r\n\r\n- It processes the items in reverse order.  If you were building a new array from the results, or printing things on screen, naturally **the output will be reversed** with respect to the original order.\r\n- Repeatedly inserting siblings into the DOM as a first child in order to retain their order is **less efficient**.  (The browser would keep having to shift things right.)  To create DOM nodes efficiently and in order, just loop forwards and append as normal (and also use a &quot;document fragment&quot;).\r\n- The reverse loop is **confusing** to junior developers.  (You may consider that an advantage, depending on your outlook.)\r\n\r\n\r\n--------\r\n\r\n\r\n## Should I always use it?\r\n\r\nSome developers use the reverse for loop *by default*, unless there is a good reason to loop forwards.\r\n\r\nAlthough the performance gains are usually insignificant, it sort of screams:\r\n\r\n&gt; &quot;Just do this to every item in the list, I don&#39;t care about the order!&quot;\r\n\r\nHowever in practice that is **not** actually a reliable indication of intent, since it is indistinguishable from those occasions when you ***do*** care about the order, and really do ***need*** to loop in reverse.  So in fact another construct would be needed to accurately express the &quot;don&#39;t care&quot; intent, something currently unavailable in most languages, including ECMAScript, but which could be called, for example, `forEachUnordered()`.\r\n\r\nIf order doesn&#39;t matter, and **efficiency** is a concern (in the innermost loop of a game or animation engine), then it may be acceptable to use the reverse for loop as your go-to pattern.  Just remember that seeing a reverse for loop in existing code **does not necessarily mean** that the order irrelevant!\r\n\r\n### It was better to use forEach()\r\n\r\nIn general for higher level code where **clarity and safety** are greater concerns, I previously recommended using [`Array::forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) as your default pattern for looping (although these days I prefer to use `for..of`).  Reasons to prefer `forEach` over a reverse loop are:\r\n\r\n- It is clearer to read.\r\n- It indicates that *i* is not going to be shifted within the block (which is always a possible surprise hiding in long `for` and `while` loops).\r\n- It gives you a free scope for closures.\r\n- It reduces leakage of local variables and accidental collision with (and mutation of) outer variables.\r\n\r\nThen when you do see the reverse for loop in your code, that is a hint that it is reversed for a good reason (perhaps one of the reasons described above).  And seeing a traditional forward for loop may indicate that shifting can take place.\r\n\r\n(If the discussion of intent makes no sense to you, then you and your code may benefit from watching Crockford&#39;s lecture on [Programming Style &amp; Your Brain](https://www.youtube.com/watch?v=taaEzHI9xyY&amp;t=480).)\r\n\r\n### It is now even better to use for..of!\r\n\r\nThere is a debate about whether `for..of` or `forEach()` are preferable:\r\n\r\n- For maximum browser support, `for..of` [requires a polyfill](https://github.com/airbnb/javascript/issues/1122#issuecomment-471169142) for iterators, making your app slightly slower to execute and slightly larger to download.\r\n\r\n- For that reason (and to encourage use of `map` and `filter`), [some front-end style guides](https://github.com/airbnb/javascript#iterators-and-generators) ban `for..of` completely!\r\n\r\n- But the above concerns is not applicable to Node.js applications, where `for..of` is now well supported.\r\n\r\n- And furthermore `await` [does not work](https://gist.github.com/joeytwiddle/37d2085425c049629b80956d3c618971) inside `forEach()`.  Using `for..of` is [the clearest pattern](https://github.com/airbnb/javascript/issues/1122#issuecomment-259876436) in this case.\r\n\r\nPersonally, I tend to use whatever looks easiest to read, unless performance or minification has become a major concern.  So these days I prefer to use `for..of` instead of `forEach()`, but I will always use `map` or `filter` or [`find`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) or [`some`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) when applicable. \r\n (For the sake of my colleagues, I rarely use [`reduce`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).)\r\n\r\n\r\n----------\r\n\r\n\r\n## How does it work?\r\n\r\n    for (var i = 0; i &lt; array.length; i++) { ... }   // Forwards\r\n\r\n    for (var i = array.length; i--; )    { ... }   // Reverse\r\n\r\nYou will notice that `i--` is the middle clause (where we usually see a comparison) and the last clause is empty (where we usually see `i++`).  That means that `i--` is also used as the *condition* for continuation.  Crucially, it is executed and checked *before* each iteration.\r\n\r\n- **How can it start at `array.length` without exploding?**\r\n\r\n  Because `i--` runs *before* each iteration, on the first iteration we will actually be accessing the item at `array.length - 1` which avoids any issues with &lt;strike&gt;Array-out-of-bounds&lt;/strike&gt; `undefined` items.\r\n\r\n- **Why doesn&#39;t it stop iterating before index 0?**\r\n\r\n  The loop will stop iterating when the condition `i--` evaluates to a falsey value (when it yields 0).\r\n\r\n  The trick is that unlike `--i`, the trailing `i--` operator decrements `i` but yields the value ***before*** the decrement.  Your console can demonstrate this:\r\n\r\n    `&gt; var i = 5; [i, i--, i];`\r\n\r\n    `[5, 5, 4]`\r\n\r\n  So on the final iteration, *i* was previously **1** and the `i--` expression changes it to **0** but actually yields **1** (truthy), and so the condition passes.  On the next iteration `i--` changes *i* to **-1** but yields **0** (falsey), causing execution to immediately drop out of the bottom of the loop.\r\n\r\n  In the traditional forwards for loop, `i++` and `++i` are interchangeable (as Douglas Crockford points out).  However in the reverse for loop, because our decrement is also our condition expression, we must stick with `i--` if we want to process the item at index 0.\r\n\r\n\r\n----------\r\n\r\n\r\n## Trivia\r\n\r\nSome people like to draw a little arrow in the reverse `for` loop, and end with a wink:\r\n\r\n    for (var i = array.length; i --&gt; 0 ;) {\r\n\r\n\r\n----------\r\n\r\n\r\n*Credits go to WYL for showing me the benefits and horrors of the reverse for loop.*\r\n\r\n\r\n  [1]: https://stackoverflow.com/questions/23186254/javascript-splice-changing-earlier-values-in-an-array/23186450#23186450"},{"score":36,"body_markdown":"I know this is an old post, and there are so many great answers already. For a little more completeness I figured I&#39;d throw in another one using [AngularJS][1]. Of course, this only applies if you&#39;re using Angular, obviously, nonetheless I&#39;d like to put it anyway.\r\n\r\n`angular.forEach` takes 2 arguments and an optional third argument. The first argument is the object (array) to iterate over, the second argument is the iterator function, and the optional third argument is the object context (basically referred to inside the loop as &#39;this&#39;.\r\n\r\nThere are different ways to use the forEach loop of angular. The simplest and probably most used is\r\n\r\n    var temp = [1, 2, 3];\r\n    angular.forEach(temp, function(item) {\r\n        //item will be each element in the array\r\n        //do something\r\n    });\r\n\r\nAnother way that is useful for copying items from one array to another is\r\n\r\n    var temp = [1, 2, 3];\r\n    var temp2 = [];\r\n    angular.forEach(temp, function(item) {\r\n        this.push(item); //&quot;this&quot; refers to the array passed into the optional third parameter so, in this case, temp2.\r\n    }, temp2);\r\n\r\nThough, you don&#39;t have to do that, you can simply do the following and it&#39;s equivalent to the previous example:\r\n\r\n    angular.forEach(temp, function(item) {\r\n        temp2.push(item);\r\n    });\r\n\r\nNow there are pros and cons of using the `angular.forEach` function as opposed to the built in vanilla-flavored `for` loop.\r\n\r\n**Pros**\r\n\r\n* Easy readability\r\n* Easy writability\r\n* If available, `angular.forEach` will use the ES5 forEach loop. Now, I will get to efficientcy in the cons section, as the forEach loops are *much* slower than the for loops. I mention this as a pro because it&#39;s nice to be consistent and standardized.\r\n\r\nConsider the following 2 nested loops, which do exactly the same thing. Let&#39;s say that we have 2 arrays of objects and each object contains an array of results, each of which has a Value property that&#39;s a string (or whatever). And let&#39;s say we need to iterate over each of the results and if they&#39;re equal then perform some action: \r\n\r\n    angular.forEach(obj1.results, function(result1) {\r\n        angular.forEach(obj2.results, function(result2) {\r\n            if (result1.Value === result2.Value) {\r\n                //do something\r\n            }\r\n        });\r\n    });\r\n\r\n    //exact same with a for loop\r\n    for (var i = 0; i &lt; obj1.results.length; i++) {\r\n        for (var j = 0; j &lt; obj2.results.length; j++) {\r\n            if (obj1.results[i].Value === obj2.results[j].Value) {\r\n                //do something\r\n            }\r\n        }\r\n    }\r\n\r\nGranted this is a very simple hypothetical example, but I&#39;ve written triple embedded for loops using the second approach and it was *very* hard to read, and write for that matter.\r\n\r\n**Cons**\r\n\r\n* Efficiency. `angular.forEach`, and the native `forEach`, for that matter, are both *so much* slower than the normal `for` loop....about [90% slower][2]. So for large data sets, best to stick to the native `for` loop.\r\n* No break, continue, or return support. `continue` is actually supported by &quot;[accident][3]&quot;, to continue in an `angular.forEach` you simple put a `return;` statement in the function like `angular.forEach(array, function(item) { if (someConditionIsTrue) return; });` which will cause it to continue out of the function for that iteration. This is also due to the fact that the native `forEach` does not support break or continue either.\r\n\r\nI&#39;m sure there&#39;s various other pros and cons as well, and please feel free to add any that you see fit. I feel that, bottom line, if you need efficiency, stick with just the native `for` loop for your looping needs. But, if your datasets are smaller and a some efficiency is okay to give up in exchange for readability and writability, then by all means throw an `angular.forEach` in that bad boy.\r\n\r\n  [1]: https://angularjs.org/\r\n  [2]: http://jsperf.com/angular-foreach-vs-native-for-loop/3\r\n  [3]: https://github.com/angular/angular.js/issues/263"},{"score":18,"body_markdown":"There&#39;s no inbuilt ability to break in `forEach`. To interrupt execution use the `Array#some` like below:\r\n\r\n\r\n    [1,2,3].some(function(number) {\r\n        return number === 1;\r\n    });\r\n\r\nThis works because `some` returns true as soon as any of the callbacks, executed in array order, returns true, short-circuiting the execution of the rest. \r\n[Original Answer][1]\r\nsee Array prototype for [some][2]\r\n\r\n\r\n  [1]: https://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break\r\n  [2]: http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.17"},{"score":16,"body_markdown":"I also would like to add this as a composition of a reverse loop and an answer above for someone that would like this syntax too.\r\n\r\n    var foo = [object,object,object];\r\n    for (var i = foo.length, item; item = foo[--i];) {\r\n        console.log(item);\r\n    }\r\n\r\n**Pros:**\r\n\r\nThe benefit for this: You have the reference already in the first like that won&#39;t need to be declared later with another line. It is handy when looping trough the object array.\r\n\r\n**Cons:**\r\n\r\nThis will break whenever the reference is false - falsey (undefined, etc.). It can be used as an advantage though. However, it would make it a little bit harder to read. And also depending on the browser it can be &quot;not&quot; optimized to work faster than the original one.\r\n"},{"score":31,"body_markdown":"**As of ECMAScript&amp;nbsp;6:**\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    list = [0, 1, 2, 3]\r\n    for (let obj of list) {\r\n        console.log(obj)\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nWhere `of` avoids the oddities associated with `in` and makes it work like the `for` loop of any other language, and `let` binds `i` within the loop as opposed to within the function.\r\n\r\nThe braces (`{}`) can be omitted when there is only one command (e.g. in the example above).\r\n"},{"score":20,"body_markdown":"ECMAScript&amp;nbsp;5 (the version on JavaScript) to work with Arrays:\r\n\r\n**forEach** - Iterates through every item in the array and do whatever you need with each item.\r\n\r\n    [&#39;C&#39;, &#39;D&#39;, &#39;E&#39;].forEach(function(element, index) {\r\n      console.log(element + &quot; is #&quot; + (index+1) + &quot; in the musical scale&quot;);\r\n    });\r\n\r\n    // Output\r\n    // C is the #1 in musical scale\r\n    // D is the #2 in musical scale\r\n    // E is the #3 in musical scale\r\n\r\nIn case, more interested on operation on array using some inbuilt feature.\r\n\r\n**map** - It creates a new array with the result of the callback function. This method is good to be used when you need to format the elements of your array.\r\n\r\n    // Let&#39;s upper case the items in the array\r\n    [&#39;bob&#39;, &#39;joe&#39;, &#39;jen&#39;].map(function(elem) {\r\n      return elem.toUpperCase();\r\n    });\r\n\r\n    // Output: [&#39;BOB&#39;, &#39;JOE&#39;, &#39;JEN&#39;]\r\n\r\n**reduce** - As the name says, it reduces the array to a single value by calling the given function passing in the current element and the result of the previous execution.\r\n\r\n    [1,2,3,4].reduce(function(previous, current) {\r\n      return previous + current;\r\n    });\r\n    // Output: 10\r\n    // 1st iteration: previous=1, current=2 =&gt; result=3\r\n    // 2nd iteration: previous=3, current=3 =&gt; result=6\r\n    // 3rd iteration: previous=6, current=4 =&gt; result=10\r\n\r\n**every** - Returns true or false if all the elements in the array pass the test in the callback function.\r\n\r\n    // Check if everybody has 18 years old of more.\r\n    var ages = [30, 43, 18, 5];\r\n    ages.every(function(elem) {\r\n      return elem &gt;= 18;\r\n    });\r\n\r\n    // Output: false\r\n\r\n\r\n**filter** - Very similar to every except that filter returns an array with the elements that return true to the given function.\r\n\r\n    // Finding the even numbers\r\n    [1,2,3,4,5,6].filter(function(elem){\r\n      return (elem % 2 == 0)\r\n    });\r\n\r\n    // Output: [2,4,6]\r\n\r\n"},{"score":22,"body_markdown":"There are **a few ways** to loop through an array in JavaScript, as below:\r\n\r\n**for** - it&#39;s **the most common one**. Full block of code for looping &lt;br/&gt;\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var languages = [&quot;Java&quot;, &quot;JavaScript&quot;, &quot;C#&quot;, &quot;Python&quot;];\r\n    var i, len, text;\r\n    for (i = 0, len = languages.length, text = &quot;&quot;; i &lt; len; i++) {\r\n        text += languages[i] + &quot;&lt;br&gt;&quot;;\r\n    }\r\n    document.getElementById(&quot;example&quot;).innerHTML = text;\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;p id=&quot;example&quot;&gt;&lt;/p&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**while** - loop while a condition is through. It seems to be the fastest loop &lt;br/&gt;\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var text = &quot;&quot;;\r\n    var i = 0;\r\n    while (i &lt; 10) {\r\n        text +=  i + &quot;) something&lt;br&gt;&quot;;\r\n        i++;\r\n    }\r\n    document.getElementById(&quot;example&quot;).innerHTML = text;\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;p id=&quot;example&quot;&gt;&lt;/p&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**do/while** - also loop through a block of code while the condition is true, will run at least one time &lt;br/&gt;\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var text = &quot;&quot;\r\n    var i = 0;\r\n\r\n    do {\r\n        text += i + &quot;) something &lt;br&gt;&quot;;\r\n        i++;\r\n    }\r\n    while (i &lt; 10);\r\n\r\n    document.getElementById(&quot;example&quot;).innerHTML = text;\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;p id=&quot;example&quot;&gt;&lt;/p&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**Functional loops** - `forEach`, `map`, `filter`, also `reduce` (they loop through the function, but they are used if you need to do something with your array, etc.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // For example, in this case we loop through the number and double them up using the map function\r\n    var numbers = [65, 44, 12, 4];\r\n    document.getElementById(&quot;example&quot;).innerHTML = numbers.map(function(num){return num * 2});\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;p id=&quot;example&quot;&gt;&lt;/p&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nFor more information and examples about functional programming on arrays, look at the blog post *[Functional programming in JavaScript: map, filter and reduce][1]*.\r\n\r\n  [1]: http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/\r\n\r\n\r\n"},{"score":8,"body_markdown":"A way closest to your idea would be to use `Array.forEach()` which accepts a closure function which will be executed for each element of the array.\r\n\r\n    myArray.forEach(\r\n      (item) =&gt; {\r\n        // Do something\r\n        console.log(item);\r\n      }\r\n    );\r\n\r\nAnother viable way would be to use `Array.map()` which works in the same way, but it also takes all values that you return and returns them in a new array (essentially mapping each element to a new one), like this:\r\n\r\n    var myArray = [1, 2, 3];\r\n    myArray = myArray.map(\r\n      (item) =&gt; {\r\n        return item + 1;\r\n      }\r\n    );\r\n\r\n    console.log(myArray); // [2, 3, 4]\r\n\r\n\r\n"},{"score":7,"body_markdown":"The lambda syntax doesn&#39;t usually work in Internet&amp;nbsp;Explorer&amp;nbsp;10  or below.\r\n\r\nI usually use the\r\n\r\n    [].forEach.call(arrayName,function(value,index){\r\n        console.log(&quot;value of the looped element&quot; + value);\r\n        console.log(&quot;index of the looped element&quot; + index);\r\n    });\r\n\r\n\r\nIf you are a jQuery *fan* and already have a jQuery file running, you should reverse the positions of the index and value parameters\r\n\r\n    $(&quot;#ul&gt;li&quot;).each(function(**index, value**){\r\n        console.log(&quot;value of the looped element&quot; + value);\r\n        console.log(&quot;index of the looped element&quot; + index);\r\n    });\r\n\r\n"},{"score":1,"body_markdown":"    var a = [&quot;car&quot;, &quot;bus&quot;, &quot;truck&quot;]\r\n    a.forEach(function(item, index) {\r\n        console.log(&quot;Index&quot; + index);\r\n        console.log(&quot;Element&quot; + item);\r\n    })"},{"score":6,"body_markdown":"If you want to use `forEach()`, it will look like - \r\n\r\n    theArray.forEach ( element =&gt; {\r\n        console.log(element);\r\n    });\r\n\r\nIf you want to use `for()`, it will look like -   \r\n\r\n    for(let idx = 0; idx &lt; theArray.length; idx++){\r\n        let element = theArray[idx];\r\n        console.log(element);\r\n    }\r\n"},{"score":5,"body_markdown":"If you have a massive array you should use [**`iterators`**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators) to gain some efficiency. Iterators are a property of certain JavaScript collections (like [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), [`Set`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set), [`String`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String), [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)). Even, [**`for..of`**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of) uses **`iterator`** under-the-hood.\r\n\r\nIterators improve efficiency by letting you consume the items in a list one at a time as if they were a stream. What makes an iterator special is how it traverses a collection. Other loops need to load the entire collection up front in order to iterate over it, whereas an iterator only needs to know the current position in the collection.             \r\n\r\n\r\nYou access the current item by calling the iterator’s `next` method. The next method will return the **`value`** of the current item and a **`boolean`** to indicate when you have reached the end of the collection. The following is an example of creating an iterator from an array.               \r\n                               \r\nTransform your regular array to iterator using [`values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values) method like this:               \r\n\r\n\r\n                             \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n        const myArr = [2,3,4]\r\n\r\n    let it = myArr.values();\r\n\r\n    console.log(it.next());\r\n    console.log(it.next());\r\n    console.log(it.next());\r\n    console.log(it.next());\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n                                     \r\n\r\n\r\n\r\n\r\n\r\n\r\n                            \r\n\r\n       \r\n\r\n\r\nYou can also transform your regular array to iterator using [`Symbol.iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator) like this:         \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const myArr = [2,3,4]\r\n\r\n    let it = myArr[Symbol.iterator]();\r\n\r\n    console.log(it.next());\r\n    console.log(it.next());\r\n    console.log(it.next());\r\n    console.log(it.next());\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nYou can also transform your regular `array` to an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators) like this:          \r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let myArr = [8, 10, 12];\r\n\r\n    function makeIterator(array) {\r\n        var nextIndex = 0;\r\n        \r\n        return {\r\n           next: function() {\r\n               return nextIndex &lt; array.length ?\r\n                   {value: array[nextIndex++], done: false} :\r\n                   {done: true};\r\n           }\r\n        };\r\n    };\r\n\r\n    var it = makeIterator(myArr);\r\n\r\n    console.log(it.next().value);   // {value: 8, done: false}\r\n    console.log(it.next().value);   // {value: 10, done: false}\r\n    console.log(it.next().value);   // {value: 12, done: false}\r\n    console.log(it.next().value);   // {value: undefined, done: true}\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n**NOTE**:                \r\n\r\n - Iterators are exhaustible in nature. \r\n - Objects are not `iterable` by default. Use [`for..in`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in) in that case because instead of values it works with keys.\r\n\r\nYou can read more about `iteration protocol` [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).  "},{"score":7,"body_markdown":"You can call forEach like this:\r\n\r\n\r\n`forEach` will iterate over the array you provide and for each iteration it will have `element` which holds the value of that iteration. If you need index you can get the current index by passing the `i` as the second parameter in the callback function for forEach. \r\n\r\nForeach is basically a High Order Function, Which takes another function as its parameter. \r\n\r\n \r\n\r\n    let theArray= [1,3,2];\r\n\r\n    theArray.forEach((element) =&gt; {\r\n      // Use the element of the array\r\n      console.log(element)\r\n    }\r\n\r\nOutput:\r\n\r\n    1\r\n    3\r\n    2\r\n\r\nYou can also iterate over an array like this:\r\n\r\n    for (let i=0; i&lt;theArray.length; i++) {\r\n      console.log(i); // i will have the value of each index\r\n    }\r\n\r\n  [1]: https://hackernoon.com/prototypes-in-javascript-5bba2990e04b\r\n\r\n"},{"score":5,"body_markdown":"Summary:\r\n-------\r\n\r\nWhen iterating over an array, we often want to accomplish one of the following goals:\r\n\r\n 1. We want to iterate over the array and create a new array:\r\n\r\n `Array.prototype.map` &lt;br&gt;&lt;br&gt;\r\n\r\n\r\n 2. We want to iterate over the array and don&#39;t create a new array:\r\n\r\n\r\n   `Array.prototype.forEach` &lt;br&gt;&lt;br&gt;\r\n   `for..of` **loop**\r\n\r\nIn JavaScript, there are many ways of accomplishing both of these goals. However, some are more convenient than others. Below you can find some commonly used methods (the most convenient IMO) to accomplish array iteration in JavaScript.\r\n\r\n## Creating new array: `Map`##\r\n\r\n`map()` is a function located on `Array.prototype` which can transform every element of an array and then returns a **new** array. `map()` takes as an argument a callback function and works in the following manner:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let arr = [1, 2, 3, 4, 5];\r\n\r\n    let newArr = arr.map((element, index, array) =&gt; {\r\n      return element * 2;\r\n    })\r\n\r\n    console.log(arr);\r\n    console.log(newArr);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe callback which we have passed into `map()` as an argument gets executed for every element. Then an array gets returned which has the same length as the original array. In this new array element is transformed by the callback function passed in as an argument to `map()`.\r\n\r\nThe distinct difference between `map` and another loop mechanism like `forEach` and a `for..of` loop is that **`map` returns a new array and leaves the old array intact** (except if you explicitly manipulate it with thinks like `splice`).\r\n\r\nAlso, note that the `map` function&#39;s callback provides the index number of the current iteration as a second argument. Furthermore, does the third argument provide the array on which `map` was called? Sometimes these properties can be very useful.\r\n\r\nLoop using `forEach`\r\n-------------------------\r\n\r\n`forEach` is a function which is located on `Array.prototype` which takes a callback function as an argument. It then executes this callback function for every element in the array. In contrast to the `map()` function, the forEach function returns nothing (`undefined`). For example:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let arr = [1, 2, 3, 4, 5];\r\n\r\n    arr.forEach((element, index, array) =&gt; {\r\n\r\n      console.log(element * 2);\r\n\r\n      if (index === 4) {\r\n        console.log(array)\r\n      }\r\n      // index, and oldArray are provided as 2nd and 3th argument by the callback\r\n\r\n    })\r\n\r\n    console.log(arr);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nJust like the `map` function, the `forEach` callback provides the index number of the current iteration as a second argument. Also, does the third argument provide the array on which `forEach` was called?\r\n\r\nLoop through elements using `for..of`\r\n-------------------------------------\r\n\r\nThe `for..of` loop loops through every element of an array (or any other iterable object). It works in the following manner:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let arr = [1, 2, 3, 4, 5];\r\n\r\n    for(let element of arr) {\r\n      console.log(element * 2);\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIn the above example, `element` stands for an array element and `arr` is the array which we want to loop. Note that the name `element` is arbitrary, and we could have picked any other name like &#39;el&#39; or something more declarative when this is applicable.\r\n\r\nDon&#39;t confuse the `for..in` loop with the `for..of` loop. `for..in` will loop through all enumerable properties of the array whereas the `for..of` loop will only loop through the array elements. For example:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let arr = [1, 2, 3, 4, 5];\r\n\r\n    arr.foo = &#39;foo&#39;;\r\n\r\n    for(let element of arr) {\r\n      console.log(element);\r\n    }\r\n\r\n    for(let element in arr) {\r\n      console.log(element);\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n"},{"score":10,"body_markdown":"**Using loops with ECMAScript&amp;nbsp;6  [destructuring][1] and the [spread operator][2]**\n\nDestructuring and using of the spread operator have proven quite useful for newcomers to ECMAScript&amp;nbsp;6 as being more human-readable/aesthetic, although some JavaScript veterans might consider it messy. Juniors or some other people might find it useful.\n\n&gt; The following examples will use the [`for...of`][3] statement and the [`.forEach`][4] method.\n&gt;\n&gt; **Examples 6, 7, and 8** can be used with any functional loops like `.map`, `.filter`, `.reduce`, `.sort`, `.every`, `.some`. For more information about these methods, check out the [Array Object][5].\n\n**Example 1:** Normal `for...of` loop - no tricks here.\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    let arrSimple = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\n\n    for (let letter of arrSimple) {\n      console.log(letter);\n    }\n\n&lt;!-- end snippet --&gt;\n\n**Example 2:** Split words to characters\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    let arrFruits = [&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;];\n\n    for (let [firstLetter, ...restOfTheWord] of arrFruits) {\n      // Create a shallow copy using the spread operator\n      let [lastLetter] = [...restOfTheWord].reverse();\n      console.log(firstLetter, lastLetter, restOfTheWord);\n    }\n\n&lt;!-- end snippet --&gt;\n\n**Example 3:** Looping with a `key` and `value`\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    // let arrSimple = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\n\n    // Instead of keeping an index in `i` as per example `for(let i = 0 ; i&lt;arrSimple.length;i++)`\n    // this example will use a multi-dimensional array of the following format type:\n    // `arrWithIndex: [number, string][]`\n\n    let arrWithIndex = [\n      [0, &#39;a&#39;],\n      [1, &#39;b&#39;],\n      [2, &#39;c&#39;],\n    ];\n\n    // Same thing can be achieved using `.map` method\n    // let arrWithIndex = arrSimple.map((i, idx) =&gt; [idx, i]);\n\n    // Same thing can be achieved using `Object.entries`\n    // NOTE: `Object.entries` method doesn&#39;t work on Internet Explorer  unless it&#39;s polyfilled\n    // let arrWithIndex = Object.entries(arrSimple);\n\n    for (let [key, value] of arrWithIndex) {\n      console.log(key, value);\n    }\n\n&lt;!-- end snippet --&gt;\n\n**Example 4:** Get object properties inline\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    let arrWithObjects = [{\n        name: &#39;Jon&#39;,\n        age: 32\n      },\n      {\n        name: &#39;Elise&#39;,\n        age: 33\n      }\n    ];\n\n    for (let { name, age: aliasForAge } of arrWithObjects) {\n      console.log(name, aliasForAge);\n    }\n\n&lt;!-- end snippet --&gt;\n\n**Example 5:** Get deep object properties of what you need\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    let arrWithObjectsWithArr = [{\n        name: &#39;Jon&#39;,\n        age: 32,\n        tags: [&#39;driver&#39;, &#39;chef&#39;, &#39;jogger&#39;]\n      },\n      {\n        name: &#39;Elise&#39;,\n        age: 33,\n        tags: [&#39;best chef&#39;, &#39;singer&#39;, &#39;dancer&#39;]\n      }\n    ];\n\n    for (let { name, tags: [firstItemFromTags, ...restOfTags] } of arrWithObjectsWithArr) {\n      console.log(name, firstItemFromTags, restOfTags);\n    }\n\n&lt;!-- end snippet --&gt;\n\n**Example 6:** Is **Example 3** used with `.forEach`\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    let arrWithIndex = [\n      [0, &#39;a&#39;],\n      [1, &#39;b&#39;],\n      [2, &#39;c&#39;],\n    ];\n\n    // Not to be confused here, `forEachIndex` is the real index\n    // `mappedIndex` was created by &quot;another user&quot;, so you can&#39;t really trust it\n\n    arrWithIndex.forEach(([mappedIndex, item], forEachIndex) =&gt; {\n      console.log(forEachIndex, mappedIndex, item);\n    });\n\n&lt;!-- end snippet --&gt;\n\n**Example 7:** Is **Example 4** used with `.forEach`\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    let arrWithObjects = [{\n        name: &#39;Jon&#39;,\n        age: 32\n      },\n      {\n        name: &#39;Elise&#39;,\n        age: 33\n      }\n    ];\n    // NOTE: Destructuring objects while using shorthand functions\n    // are required to be surrounded by parentheses\n    arrWithObjects.forEach( ({ name, age: aliasForAge }) =&gt; {\n      console.log(name, aliasForAge)\n    });\n\n&lt;!-- end snippet --&gt;\n\n**Example 8:** Is **Example 5** used with `.forEach`\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    let arrWithObjectsWithArr = [{\n        name: &#39;Jon&#39;,\n        age: 32,\n        tags: [&#39;driver&#39;, &#39;chef&#39;, &#39;jogger&#39;]\n      },\n      {\n        name: &#39;Elise&#39;,\n        age: 33,\n        tags: [&#39;best chef&#39;, &#39;singer&#39;, &#39;dancer&#39;]\n      }\n    ];\n\n    arrWithObjectsWithArr.forEach(({\n      name,\n      tags: [firstItemFromTags, ...restOfTags]\n    }) =&gt; {\n      console.log(name, firstItemFromTags, restOfTags);\n    });\n\n&lt;!-- end snippet --&gt;\n\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of\n  [4]: https://developer.mozilla.org/ro/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n  [5]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\n\n"},{"score":0,"body_markdown":"I come from Python, and I found this way much clearer.\r\n\r\ntheArray being the array, and `instance` being the elements of the array:\r\n\r\n    for (let instance of theArray)\r\n    {\r\n        console.log(&quot;The instance&quot;, instance);\r\n    }\r\n\r\nor\r\n\r\n    for (instance in theArray)\r\n    {\r\n        console.log(&quot;The instance&quot;, instance);\r\n    }\r\n\r\ncompare to:\r\n\r\n    theArray.forEach(function(instance) {\r\n        console.log(instance);\r\n    });\r\n\r\nBut at the end of the day both are doing the same thing.\r\n\r\n\r\n\r\n"},{"score":3,"body_markdown":"&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // Looping through arrays using the foreach ECMAScript 6 way\r\n\r\n    var data = new Array(1, 2, 3, 4, 5);\r\n    data.forEach((val,index) =&gt; {\r\n        console.log(&quot;index: &quot;, index); // Index\r\n        console.log(&quot;value: &quot;, val); // Value\r\n    });\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":2,"body_markdown":"If you want to keep your code in the functional way, use `map`:\r\n    \r\n    theArray.map(instance =&gt; do_something);\r\n\r\nIn this way you will generate a new array to future operation and will skip any not desirable side effect.\r\n\r\n\r\n\r\n"},{"score":6,"body_markdown":"If you want to loop through an array of objects with the arrow function:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let arr = [{name:&#39;john&#39;, age:50}, {name:&#39;clark&#39;, age:19}, {name:&#39;mohan&#39;, age:26}];\r\n\r\n    arr.forEach((person)=&gt;{\r\n      console.log(&#39;I am &#39; + person.name + &#39; and I am &#39; + person.age + &#39; old&#39;);\r\n    })\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":1,"body_markdown":"You can use the forEach() API (provided by JavaScript) which accepts a function as a callback and runs one time for each element present inside the array.\r\n\r\nSee *[Arrays in JavaScript: Part 2][1]*.\r\n\r\n  [1]: https://fullstackgeek.blogspot.com/2019/01/arrays-in-javascript-part-2.html\r\n"},{"score":0,"body_markdown":"[Mozilla documentation][1]\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    /* Get all forms */\r\n    document.querySelectorAll( &quot;form&quot; ).forEach( form =&gt; {\r\n\r\n      /* For each form, add the onsubmit event */\r\n      form.addEventListener( &quot;submit&quot;, event =&gt; {\r\n        event.preventDefault(); // Return false\r\n\r\n        /* Display it */\r\n        alert(event.target.action);\r\n        console.log(event.target);\r\n      } );\r\n\r\n    } );\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;form action=&quot;form1.php&quot; &gt;\r\n      &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;\r\n    &lt;/form&gt;\r\n    &lt;form action=&quot;form2.php&quot; &gt;\r\n      &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;\r\n    &lt;/form&gt;\r\n    &lt;form action=&quot;form3.php&quot; &gt;\r\n      &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;\r\n    &lt;/form&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://developer.mozilla.org/id/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n\r\n\r\n"},{"score":6,"body_markdown":"Performance\r\n-\r\n\r\nToday (2019-12-18) I perform test on my [macOS v10.13.6][1] (High Sierra), on Chrome v 79.0, Safari v13.0.4 and Firefox v71.0 (64 bit) - conclusions about optimisation (and *[micro-optimisation][2]* which usually is not worth to introduce it to code because the benefit is small, but code complexity grows).\r\n\r\n* It looks like the traditional `for i` (**Aa**) is a good choice to write fast code on all browsers.\r\n\r\n* The other solutions, like `for-of` (**Ad**), all in group **C.**... are usually 2 - 10 (and more) times slower than **Aa**, but for small arrays it is ok to use it - for the sake of increase code clarity.\r\n\r\n* The loops with array length cached in `n` (**Ab, Bb, Be**) are sometimes faster, sometimes not. Probably compilers automatically detect this situation and introduce caching. The speed differences between the cached and no-cached versions (**Aa, Ba, Bd**) are about ~1%, so it looks like introduce `n` is a *[micro-optimisation][2]*.\r\n\r\n* The `i--` like solutions where the loop starts from the last array element (**Ac, Bc**) are usually ~30% slower than forward solutions - probably the reason is the way of [CPU memory cache working][3] - forward memory reading is more optimal for CPU caching). **Is recommended to NOT USE such solutions.**\r\n\r\n\r\nDetails\r\n-\r\n\r\nIn tests we calculate the sum of array elements. I perform a test for small arrays (10 elements) and big arrays (1M elements) and divide them into three groups:\r\n\r\n* **A** - `for` tests\r\n* **B** - `while` tests\r\n* **C** - other/alternative methods\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n    //let arr = Array.from(Array(1000000), (x, i) =&gt; i%10);\r\n\r\n    function Aa(a, s=0) {\r\n      for(let i=0; i&lt;a.length; i++) {\r\n        s += a[i];\r\n      }\r\n      console.log(&#39;Aa=&#39;, s);\r\n    }\r\n\r\n    function Ab(a, s=0) {\r\n      let n = a.length;\r\n      for(let i=0; i&lt;n; i++) {\r\n        s += a[i];\r\n      }\r\n      console.log(&#39;Ab=&#39;, s);\r\n    }\r\n\r\n    function Ac(a, s=0) {\r\n      for(let i=a.length; i--;) {\r\n        s += a[i];\r\n      }\r\n      console.log(&#39;Ac=&#39;, s);\r\n    }\r\n\r\n    function Ad(a, s=0) {\r\n      for(let x of a) {\r\n        s += x;\r\n      }\r\n      console.log(&#39;Ad=&#39;, s);\r\n    }\r\n\r\n    function Ae(a, s=0) {\r\n      for(let i in a) if (a.hasOwnProperty(i)) {\r\n        s += a[i];\r\n      }\r\n      console.log(&#39;Ae=&#39;, s);\r\n    }\r\n\r\n    function Ba(a, s=0) {\r\n      let i = -1;\r\n      while(++i &lt; a.length) {\r\n        s+= a[i];\r\n      }\r\n      console.log(&#39;Ba=&#39;, s);\r\n    }\r\n\r\n    function Bb(a, s=0) {\r\n      let i = -1;\r\n      let n = a.length;\r\n      while(++i &lt; n) {\r\n        s+= a[i];\r\n      }\r\n      console.log(&#39;Bb=&#39;, s);\r\n    }\r\n\r\n    function Bc(a, s=0) {\r\n      let i = a.length;\r\n      while(i--) {\r\n        s += a[i];\r\n      }\r\n      console.log(&#39;Bc=&#39;, s);\r\n    }\r\n\r\n    function Bd(a, s=0) {\r\n      let i = 0;\r\n      do {\r\n        s+= a[i]\r\n      } while (++i &lt; a.length);\r\n      console.log(&#39;Bd=&#39;, s);\r\n    }\r\n\r\n    function Be(a, s=0) {\r\n      let i = 0;\r\n      let n = a.length;\r\n      do {\r\n        s += a[i]\r\n      } while (++i &lt; n);\r\n      console.log(&#39;Be=&#39;, s);\r\n    }\r\n\r\n    function Bf(a, s=0) {\r\n      const it = a.values(); \r\n      let e;\r\n      while (!(e = it.next()).done) { \r\n        s+= e.value; \r\n      }\r\n      console.log(&#39;Bf=&#39;, s);\r\n    }\r\n\r\n    function Ca(a, s=0) {\r\n      a.map(x =&gt; { s+=x });\r\n      console.log(&#39;Ca=&#39;, s);\r\n    }\r\n\r\n    function Cb(a, s=0) {\r\n      a.forEach(x =&gt; { s+=x });\r\n      console.log(&#39;Cb=&#39;, s);\r\n    }\r\n\r\n    function Cc(a, s=0) {\r\n      a.every(x =&gt; (s += x, 1));\r\n      console.log(&#39;Cc=&#39;, s);\r\n    }\r\n\r\n    function Cd(a, s=0) {\r\n      a.filter(x =&gt; { s+=x });\r\n      console.log(&#39;Cd=&#39;,s);\r\n    }\r\n\r\n    function Ce(a, s=0) {\r\n      a.reduce((z, c) =&gt; { s+=c }, 0);\r\n      console.log(&#39;Ce=&#39;, s);\r\n    }\r\n\r\n    function Cf(a, s=0) {\r\n      a.reduceRight((z, c) =&gt; { s += c }, 0);\r\n      console.log(&#39;Cf=&#39;, s);\r\n    }\r\n\r\n    function Cg(a, s=0) {\r\n      a.some(x =&gt; { s += x } );\r\n      console.log(&#39;Cg=&#39;, s);\r\n    }\r\n\r\n    function Ch(a, s=0) {\r\n      Array.from(a, x=&gt; s += x);\r\n      console.log(&#39;Cc=&#39;, s);\r\n    }\r\n\r\n\r\n    Aa(arr);\r\n    Ab(arr);\r\n    Ac(arr);\r\n    Ad(arr);\r\n    Ae(arr);\r\n\r\n    Ba(arr);\r\n    Bb(arr);\r\n    Bc(arr);\r\n    Bd(arr);\r\n    Be(arr);\r\n    Bf(arr);\r\n\r\n    Ca(arr);\r\n    Cb(arr);\r\n    Cc(arr);\r\n    Cd(arr);\r\n    Ce(arr);\r\n    Cf(arr);\r\n    Cg(arr);\r\n    Ch(arr);\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;p style=&quot;color: red&quot;&gt;This snippets only PRESENTS code used for benchmark - it not perform test itself&lt;/p&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n**Cross browser results**\r\n\r\nResults for all tested browsers\r\n\r\n[![Enter image description here][4]][4]browsers**\r\n\r\n**Array with 10 elements**\r\n\r\nResults for Chrome. You can perform the test on your machine [here](https://jsbench.me/pxk4bicjru).\r\n\r\n[![Enter image description here][5]][5]\r\n\r\n**Array with 1,000,000 elements**\r\n\r\nResults for Chrome. You can perform the test on your machine [here](https://jsbench.me/9uk4bj4svg)\r\n\r\n[![Enter image description here][6]][6]\r\n\r\n\r\n  [1]: https://en.wikipedia.org/wiki/MacOS_High_Sierra\r\n  [2]: https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000\r\n  [3]: https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus\r\n  [4]: https://i.stack.imgur.com/bSXp2.png\r\n  [5]: https://i.stack.imgur.com/VuCMw.png\r\n  [6]: https://i.stack.imgur.com/8JQf6.png\r\n\r\n"},{"score":4,"body_markdown":"You can use:\r\n\r\n1. ForEach\r\n\r\n        theArray.forEach(function (array, index) {\r\n    \t    console.log(index);\r\n        \tconsole.log(array);\r\n        });\r\n\r\n2. for\r\n\r\n        for(var i=0; i&lt;theArray.length; i++) {\r\n            console.log(i)\r\n        }\r\n\r\n3. map\r\n\r\n        theArray.map(x =&gt; console.log(x));\r\n\r\n4. map\r\n\r\n        theArray.filter(x =&gt; console.log(x));\r\n\r\nAnd there are many others for iteration.\r\n\r\n"},{"score":3,"body_markdown":"I&#39;d argue that `for/of` is the way to go:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\r\n\r\n    for (const v of arr) {\r\n      console.log(v); // Prints &quot;a&quot;, &quot;b&quot;, &quot;c&quot;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n* Unlike `for/in`, `for/of` skips non-numeric properties on the array. For example, if you set `arr.foo = &#39;test&#39;`, `for (var v in arr)` will loop through the `&#39;foo&#39;` key.\r\n\r\n* Unlike `forEach()`, `for/of` doesn&#39;t skip &quot;holes&quot; in arrays. `const arr = [&#39;a&#39;,, &#39;c&#39;]` is valid JavaScript, just the 2nd element is a &quot;hole&quot;. The array is functionally equivalent to `[&#39;a&#39;, undefined, &#39;c&#39;]`.\r\n\r\nYou can read more in [this blog post on `for/of` vs `forEach()`.][1]\r\n\r\n\r\n  [1]: https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript"},{"score":5,"body_markdown":"As per the new updated feature ECMAScript 6 (ES6) and ECMAScript 2015, you can use the following options with loops:\r\n\r\n&gt; **for loops**\r\n\r\n    for(var i = 0; i &lt; 5; i++){\r\n      console.log(i);\r\n    }\r\n\r\n    // Output: 0,1,2,3,4\r\n\r\n&gt; **for...in loops**\r\n\r\n    let obj = {&quot;a&quot;:1, &quot;b&quot;:2}\r\n\r\n    for(let k in obj){\r\n      console.log(k)\r\n    }\r\n\r\n    // Output: a,b\r\n\r\n&gt; **Array.forEach()**\r\n\r\n    let array = [1,2,3,4]\r\n\r\n    array.forEach((x) =&gt; {\r\n      console.log(x);\r\n    })\r\n\r\n    // Output: 1,2,3,4\r\n\r\n&gt; **for...of loops**\r\n\r\n    let array = [1,2,3,4]\r\n\r\n    for(let x of array){\r\n      console.log(x);\r\n    }\r\n\r\n    // Output: 1,2,3,4\r\n\r\n\r\n&gt; **while loops**\r\n\r\n    let x = 0\r\n\r\n    while(x &lt; 5){\r\n      console.log(x)\r\n      x++\r\n    }\r\n\r\n    // Output: 1,2,3,4\r\n\r\n\r\n\r\n&gt; **do...while loops**\r\n\r\n    let x = 0\r\n\r\n    do{\r\n      console.log(x)\r\n      x++\r\n    }while(x &lt; 5)\r\n\r\n    // Output: 1,2,3,4\r\n\r\n\r\n"},{"score":0,"body_markdown":"Using the **grep** function in jQuery, for example:\r\n\r\n    $.grep([0, 1, 2], function(n, i) {\r\n        return n &gt; 0;\r\n    });\r\n\r\n\r\n"},{"score":3,"body_markdown":"Suppose we have a array of subjects:\r\n\r\n  \r\n\r\n      let ddl = new Array();\r\n        if (subjects) {\r\n          subjects.forEach(function (s) {ddl.push({&quot;id&quot;: s.id,&quot;label&quot;: s.name});});\r\n        }"}],"score":4859}