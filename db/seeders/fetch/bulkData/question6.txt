{"body":"Usually I would expect a `String.contains()` method, but there doesn&#39;t seem to be one. \r\n\r\nWhat is a reasonable way to check for this?\r\n","title":"How to check whether a string contains a substring in JavaScript?","answers":[{"score":14214,"body_markdown":"ECMAScript&amp;nbsp;6  introduced [`String.prototype.includes`][3]:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const string = &quot;foo&quot;;\r\n    const substring = &quot;oo&quot;;\r\n\r\n    console.log(string.includes(substring));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n`includes` [doesn’t have Internet&amp;nbsp;Explorer support][2], though. In ECMAScript&amp;nbsp;5 or older environments, use [`String.prototype.indexOf`][1], which returns -1 when a substring cannot be found:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var string = &quot;foo&quot;;\r\n    var substring = &quot;oo&quot;;\r\n\r\n    console.log(string.indexOf(substring) !== -1);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf\r\n  [2]: https://caniuse.com/#feat=es6-string-includes\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\r\n"},{"score":602,"body_markdown":"[There is a `String.prototype.includes` in ES6][1]:\r\n\r\n    &quot;potato&quot;.includes(&quot;to&quot;);\r\n    &gt; true\r\n\r\nNote that this [does not work in Internet Explorer or some other old browsers](https://caniuse.com/?v=1#feat=es6-string-includes) with no or incomplete ES6 support. To make it work in old browsers, you may wish to use a transpiler like [Babel](https://babeljs.io/), a shim library like [es6-shim](https://github.com/paulmillr/es6-shim), or this [polyfill from MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes#Polyfill):\r\n\r\n    if (!String.prototype.includes) {\r\n      String.prototype.includes = function(search, start) {\r\n        &#39;use strict&#39;;\r\n        if (typeof start !== &#39;number&#39;) {\r\n          start = 0;\r\n        }\r\n    \r\n        if (start + search.length &gt; this.length) {\r\n          return false;\r\n        } else {\r\n          return this.indexOf(search, start) !== -1;\r\n        }\r\n      };\r\n    }\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes"},{"score":64,"body_markdown":"Another alternative is [KMP](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm) (Knuth–Morris–Pratt).\r\n\r\nThe KMP algorithm searches for a length-*m* substring in a length-*n* string in worst-case O(*n*+*m*) time, compared to a worst-case of O(*n*⋅*m*) for the naive algorithm, so using KMP may be reasonable if you care about worst-case time complexity.\r\n\r\nHere&#39;s a JavaScript implementation by Project Nayuki, taken from https://www.nayuki.io/res/knuth-morris-pratt-string-matching/kmp-string-matcher.js:\r\n\r\n    // Searches for the given pattern string in the given text string using the Knuth-Morris-Pratt string matching algorithm.\r\n    // If the pattern is found, this returns the index of the start of the earliest match in &#39;text&#39;. Otherwise -1 is returned.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function kmpSearch(pattern, text) {\r\n      if (pattern.length == 0)\r\n        return 0; // Immediate match\r\n\r\n      // Compute longest suffix-prefix table\r\n      var lsp = [0]; // Base case\r\n      for (var i = 1; i &lt; pattern.length; i++) {\r\n        var j = lsp[i - 1]; // Start by assuming we&#39;re extending the previous LSP\r\n        while (j &gt; 0 &amp;&amp; pattern.charAt(i) != pattern.charAt(j))\r\n          j = lsp[j - 1];\r\n        if (pattern.charAt(i) == pattern.charAt(j))\r\n          j++;\r\n        lsp.push(j);\r\n      }\r\n\r\n      // Walk through text string\r\n      var j = 0; // Number of chars matched in pattern\r\n      for (var i = 0; i &lt; text.length; i++) {\r\n        while (j &gt; 0 &amp;&amp; text.charAt(i) != pattern.charAt(j))\r\n          j = lsp[j - 1]; // Fall back in the pattern\r\n        if (text.charAt(i) == pattern.charAt(j)) {\r\n          j++; // Next char matched, increment position\r\n          if (j == pattern.length)\r\n            return i - (j - 1);\r\n        }\r\n      }\r\n      return -1; // Not found\r\n    }\r\n\r\n    console.log(kmpSearch(&#39;ays&#39;, &#39;haystack&#39;) != -1) // true\r\n    console.log(kmpSearch(&#39;asdf&#39;, &#39;haystack&#39;) != -1) // false\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [2]: https://www.nayuki.io/res/knuth-morris-pratt-string-matching/kmp-string-matcher.js\r\n"}],"score":7423}