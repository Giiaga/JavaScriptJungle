{"body":"I need to be able to merge two (very simple) JavaScript objects at runtime.  For example I&#39;d like to:\r\n\r\n    var obj1 = { food: &#39;pizza&#39;, car: &#39;ford&#39; }\r\n    var obj2 = { animal: &#39;dog&#39; }\r\n    \r\n    obj1.merge(obj2);\r\n    \r\n    //obj1 now has three properties: food, car, and animal\r\n\r\nDoes anyone have a script for this or know of a built in way to do this?  I do not need recursion, and I do not need to merge functions, just methods on flat objects.","title":"How can I merge properties of two JavaScript objects dynamically?","answers":[{"score":3114,"body_markdown":"**ECMAScript 2018 Standard Method**\r\n\r\nYou would use [object spread](https://github.com/tc39/proposal-object-rest-spread):\r\n\r\n\tlet merged = {...obj1, ...obj2};\r\n\r\n`merged` is now the union of `obj1` and `obj2`. Properties in `obj2` will overwrite those in `obj1`.\r\n\r\n\t/** There&#39;s no limit to the number of objects you can merge.\r\n\t *  Later properties overwrite earlier properties with the same name. */\r\n\tconst allRules = {...obj1, ...obj2, ...obj3};\r\n\r\n\r\n\r\nHere is also the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) for this syntax. If you&#39;re using babel you&#39;ll need the [babel-plugin-transform-object-rest-spread](https://babeljs.io/docs/en/babel-plugin-transform-object-rest-spread.html) plugin for it to work.\r\n\r\n**ECMAScript 2015 (ES6) Standard Method**\r\n\r\n\t/* For the case in question, you would do: */\r\n\tObject.assign(obj1, obj2);\r\n\r\n\t/** There&#39;s no limit to the number of objects you can merge.\r\n\t *  All objects get merged into the first object. \r\n\t *  Only the object in the first argument is mutated and returned.\r\n\t *  Later properties overwrite earlier properties with the same name. */\r\n\tconst allRules = Object.assign({}, obj1, obj2, obj3, etc);\r\n\r\n(see [MDN JavaScript Reference][1])\r\n\r\n----------\r\n**Method for ES5 and Earlier**\r\n\r\n    for (var attrname in obj2) { obj1[attrname] = obj2[attrname]; }\r\n\r\nNote that this will simply add all attributes of `obj2` to `obj1` which might not be what you want if you still want to use the unmodified `obj1`.\r\n\r\nIf you&#39;re using a framework that craps all over your prototypes then you have to get fancier with checks like `hasOwnProperty`, but that code will work for 99% of cases.\r\n\r\nExample function:\r\n\r\n    /**\r\n     * Overwrites obj1&#39;s values with obj2&#39;s and adds obj2&#39;s if non existent in obj1\r\n     * @param obj1\r\n     * @param obj2\r\n     * @returns obj3 a new object based on obj1 and obj2\r\n     */\r\n    function merge_options(obj1,obj2){\r\n    \tvar obj3 = {};\r\n    \tfor (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }\r\n    \tfor (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }\r\n    \treturn obj3;\r\n    }\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility"},{"score":13,"body_markdown":"[Prototype][1] has this:\r\n\r\n    Object.extend = function(destination,source) {\r\n        for (var property in source)\r\n            destination[property] = source[property];\r\n        return destination;\r\n    }\r\n\r\n`obj1.extend(obj2)` will do what you want.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework\r\n"},{"score":1202,"body_markdown":"jQuery also has a utility for this: http://api.jquery.com/jQuery.extend/.\r\n\r\nTaken from the jQuery documentation:\r\n\r\n    // Merge options object into settings object\r\n    var settings = { validate: false, limit: 5, name: &quot;foo&quot; };\r\n    var options  = { validate: true, name: &quot;bar&quot; };\r\n    jQuery.extend(settings, options);\r\n\r\n    // Now the content of settings object is the following:\r\n    // { validate: true, limit: 5, name: &quot;bar&quot; }\r\n\r\nThe above code will mutate the **existing object** named _`settings`_.\r\n\r\n\r\n---\r\n\r\nIf you want to create a **new object** without modifying either argument, use this:\r\n\r\n    var defaults = { validate: false, limit: 5, name: &quot;foo&quot; };\r\n    var options = { validate: true, name: &quot;bar&quot; };\r\n     \r\n    /* Merge defaults and options, without modifying defaults */\r\n    var settings = $.extend({}, defaults, options);\r\n\r\n    // The content of settings variable is now the following:\r\n    // {validate: true, limit: 5, name: &quot;bar&quot;}\r\n    // The &#39;defaults&#39; and &#39;options&#39; variables remained the same.\r\n\r\n[1]: http://api.jquery.com/jQuery.extend/\r\n"},{"score":271,"body_markdown":"I googled for code to merge object properties and ended up here. However since there wasn&#39;t any code for recursive merge I wrote it myself. (Maybe jQuery extend is recursive BTW?) Anyhow, hopefully someone else will find it useful as well.\r\n\r\n(Now the code does not use `Object.prototype` :)\r\n\r\nCode\r\n----\r\n\r\n    /*\r\n    * Recursively merge properties of two objects \r\n    */\r\n    function MergeRecursive(obj1, obj2) {\r\n      \r\n      for (var p in obj2) {\r\n        try {\r\n          // Property in destination object set; update its value.\r\n          if ( obj2[p].constructor==Object ) {\r\n            obj1[p] = MergeRecursive(obj1[p], obj2[p]);\r\n            \r\n          } else {\r\n            obj1[p] = obj2[p];\r\n            \r\n          }\r\n          \r\n        } catch(e) {\r\n          // Property in destination object not set; create it and set its value.\r\n          obj1[p] = obj2[p];\r\n          \r\n        }\r\n      }\r\n      \r\n      return obj1;\r\n    }\r\n  \r\n\r\nAn example\r\n----------\r\n\r\n    o1 = {  a : 1,\r\n            b : 2,\r\n            c : {\r\n              ca : 1,\r\n              cb : 2,\r\n              cc : {\r\n                cca : 100,\r\n                ccb : 200 } } };\r\n                \r\n    o2 = {  a : 10,\r\n            c : {\r\n              ca : 10,\r\n              cb : 20, \r\n              cc : {\r\n                cca : 101,\r\n                ccb : 202 } } };\r\n    \r\n    o3 = MergeRecursive(o1, o2);\r\n    \r\n\r\n**Produces object o3 like**\r\n \r\n    \r\n    o3 = {  a : 10,\r\n            b : 2,\r\n            c : {\r\n              ca : 10,\r\n              cb : 20,\r\n              cc : { \r\n                cca : 101,\r\n                ccb : 202 } } };"},{"score":41,"body_markdown":"The given solutions should be modified to check `source.hasOwnProperty(property)` in the `for..in` loops before assigning - otherwise, you end up copying the properties of the whole prototype chain, which is rarely desired..."},{"score":1,"body_markdown":"The correct implementation in [Prototype][1] should look like this:\r\n\r\n    var obj1 = {food: &#39;pizza&#39;, car: &#39;ford&#39;}\r\n    var obj2 = {animal: &#39;dog&#39;}\r\n\r\n    obj1 = Object.extend(obj1, obj2);\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework\r\n\r\n"},{"score":10,"body_markdown":"In [MooTools][1], there&#39;s [Object.merge()][2]:\r\n\r\n    Object.merge(obj1, obj2);\r\n\r\n  [1]: http://en.wikipedia.org/wiki/MooTools\r\n  [2]: http://mootools.net/docs/core/Types/Object#Object:Object-merge\r\n"},{"score":19,"body_markdown":"For not-too-complicated objects you could use [JSON][1]:\r\n\r\n    var obj1 = { food: &#39;pizza&#39;, car: &#39;ford&#39; }\r\n    var obj2 = { animal: &#39;dog&#39;, car: &#39;chevy&#39;}\r\n    var objMerge;\r\n\r\n    objMerge = JSON.stringify(obj1) + JSON.stringify(obj2);\r\n\r\n    // {&quot;food&quot;: &quot;pizza&quot;,&quot;car&quot;:&quot;ford&quot;}{&quot;animal&quot;:&quot;dog&quot;,&quot;car&quot;:&quot;chevy&quot;}\r\n\r\n    objMerge = objMerge.replace(/\\}\\{/, &quot;,&quot;); //  \\_ replace with comma for valid JSON\r\n\r\n    objMerge = JSON.parse(objMerge); // { food: &#39;pizza&#39;, animal: &#39;dog&#39;, car: &#39;chevy&#39;}\r\n    // Of same keys in both objects, the last object&#39;s value is retained_/\r\n\r\nMind you that in this example &quot;}{&quot; ***must not occur*** within a string!\r\n\r\n  [1]: http://en.wikipedia.org/wiki/JSON\r\n"},{"score":17,"body_markdown":"The best way for you to do this is to add a proper property that is non-enumerable using Object.defineProperty. \r\n\r\nThis way you will still be able to iterate over your objects properties without having the newly created &quot;extend&quot; that you would get if you were to create the property with Object.prototype.extend.\r\n\r\nHopefully this helps:\r\n\r\n&lt;pre&gt;\r\nObject.defineProperty(Object.prototype, &quot;extend&quot;, {\r\n    enumerable: false,\r\n    value: function(from) {\r\n        var props = Object.getOwnPropertyNames(from);\r\n        var dest = this;\r\n        props.forEach(function(name) {\r\n            if (name in dest) {\r\n                var destination = Object.getOwnPropertyDescriptor(from, name);\r\n                Object.defineProperty(dest, name, destination);\r\n            }\r\n        });\r\n        return this;\r\n    }\r\n});\r\n&lt;/pre&gt;\r\n\r\nOnce you have that working, you can do:\r\n\r\n&lt;pre&gt;\r\nvar obj = {\r\n    name: &#39;stack&#39;,\r\n    finish: &#39;overflow&#39;\r\n}\r\nvar replacement = {\r\n    name: &#39;stock&#39;\r\n};\r\n\r\nobj.extend(replacement);\r\n&lt;/pre&gt;\r\n\r\nI just wrote a blog post about it here: http://onemoredigit.com/post/1527191998/extending-objects-in-node-js"},{"score":10,"body_markdown":"I extended David Coallier&#39;s method:\r\n\r\n - Added the possibility to merge multiple objects\r\n - Supports deep objects\r\n - override parameter (that&#39;s detected if the last parameter is a boolean)\r\n\r\nIf override is false, no property gets overridden but new properties will be added.\r\n\r\nUsage:\r\nobj.merge(merges... [, override]);\r\n\r\nHere is my code:\r\n\r\n\tObject.defineProperty(Object.prototype, &quot;merge&quot;, {\r\n\t\tenumerable: false,\r\n\t\tvalue: function () {\r\n\t\t\tvar override = true,\r\n\t\t\t\tdest = this,\r\n\t\t\t\tlen = arguments.length,\r\n\t\t\t\tprops, merge, i, from;\r\n\t\t\t\t\r\n\t\t\tif (typeof(arguments[arguments.length - 1]) === &quot;boolean&quot;) {\r\n\t\t\t\toverride = arguments[arguments.length - 1];\r\n\t\t\t\tlen = arguments.length - 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (i = 0; i &lt; len; i++) {\r\n\t\t\t\tfrom = arguments[i];\r\n\t\t\t\tif (from != null) {\r\n\t\t\t\t\tObject.getOwnPropertyNames(from).forEach(function (name) {\r\n\t\t\t\t\t\tvar descriptor;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// nesting\r\n\t\t\t\t\t\tif ((typeof(dest[name]) === &quot;object&quot; || typeof(dest[name]) === &quot;undefined&quot;)\r\n\t\t\t\t\t\t\t\t&amp;&amp; typeof(from[name]) === &quot;object&quot;) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// ensure proper types (Array rsp Object)\r\n\t\t\t\t\t\t\tif (typeof(dest[name]) === &quot;undefined&quot;) {\r\n\t\t\t\t\t\t\t\tdest[name] = Array.isArray(from[name]) ? [] : {};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (override) {\r\n\t\t\t\t\t\t\t\tif (!Array.isArray(dest[name]) &amp;&amp; Array.isArray(from[name])) {\r\n\t\t\t\t\t\t\t\t\tdest[name] = [];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse if (Array.isArray(dest[name]) &amp;&amp; !Array.isArray(from[name])) {\r\n\t\t\t\t\t\t\t\t\tdest[name] = {};\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tdest[name].merge(from[name], override);\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// flat properties\r\n\t\t\t\t\t\telse if ((name in dest &amp;&amp; override) || !(name in dest)) {\r\n\t\t\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(from, name);\r\n\t\t\t\t\t\t\tif (descriptor.configurable) {\r\n\t\t\t\t\t\t\t\tObject.defineProperty(dest, name, descriptor);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n\r\n\r\nExamples and TestCases:\r\n\r\n\tfunction clone (obj) {\r\n\t\treturn JSON.parse(JSON.stringify(obj));\r\n\t}\r\n\tvar obj = {\r\n\t\tname : &quot;trick&quot;,\r\n\t\tvalue : &quot;value&quot;\r\n\t};\r\n\t\r\n\tvar mergeObj = {\r\n\t\tname : &quot;truck&quot;,\r\n\t\tvalue2 : &quot;value2&quot;\r\n\t};\r\n\t\r\n\tvar mergeObj2 = {\r\n\t\tname : &quot;track&quot;,\r\n\t\tvalue : &quot;mergeObj2&quot;,\r\n\t\tvalue2 : &quot;value2-mergeObj2&quot;,\r\n\t\tvalue3 : &quot;value3&quot;\r\n\t};\r\n\t\r\n\tassertTrue(&quot;Standard&quot;, clone(obj).merge(mergeObj).equals({\r\n\t\tname : &quot;truck&quot;,\r\n\t\tvalue : &quot;value&quot;,\r\n\t\tvalue2 : &quot;value2&quot;\r\n\t}));\r\n\t\r\n\tassertTrue(&quot;Standard no Override&quot;, clone(obj).merge(mergeObj, false).equals({\r\n\t\tname : &quot;trick&quot;,\r\n\t\tvalue : &quot;value&quot;,\r\n\t\tvalue2 : &quot;value2&quot;\r\n\t}));\r\n\t\r\n\tassertTrue(&quot;Multiple&quot;, clone(obj).merge(mergeObj, mergeObj2).equals({\r\n\t\tname : &quot;track&quot;,\r\n\t\tvalue : &quot;mergeObj2&quot;,\r\n\t\tvalue2 : &quot;value2-mergeObj2&quot;,\r\n\t\tvalue3 : &quot;value3&quot;\r\n\t}));\r\n\t\r\n\tassertTrue(&quot;Multiple no Override&quot;, clone(obj).merge(mergeObj, mergeObj2, false).equals({\r\n\t\tname : &quot;trick&quot;,\r\n\t\tvalue : &quot;value&quot;,\r\n\t\tvalue2 : &quot;value2&quot;,\r\n\t\tvalue3 : &quot;value3&quot;\r\n\t}));\r\n\t\r\n\tvar deep = {\r\n\t\tfirst : {\r\n\t\t\tname : &quot;trick&quot;,\r\n\t\t\tval : &quot;value&quot;\r\n\t\t},\r\n\t\tsecond : {\r\n\t\t\tfoo : &quot;bar&quot;\r\n\t\t}\r\n\t};\r\n\t\r\n\tvar deepMerge = {\r\n\t\tfirst : {\r\n\t\t\tname : &quot;track&quot;,\r\n\t\t\tanotherVal : &quot;wohoo&quot;\r\n\t\t},\r\n\t\tsecond : {\r\n\t\t\tfoo : &quot;baz&quot;,\r\n\t\t\tbar : &quot;bam&quot;\r\n\t\t},\r\n\t\tv : &quot;on first layer&quot;\r\n\t};\r\n\t\r\n\tassertTrue(&quot;Deep merges&quot;, clone(deep).merge(deepMerge).equals({\r\n\t\tfirst : {\r\n\t\t\tname : &quot;track&quot;,\r\n\t\t\tval : &quot;value&quot;,\r\n\t\t\tanotherVal : &quot;wohoo&quot;\r\n\t\t},\r\n\t\tsecond : {\r\n\t\t\tfoo : &quot;baz&quot;,\r\n\t\t\tbar : &quot;bam&quot;\r\n\t\t},\r\n\t\tv : &quot;on first layer&quot;\r\n\t}));\r\n\t\r\n\tassertTrue(&quot;Deep merges no override&quot;, clone(deep).merge(deepMerge, false).equals({\r\n\t\tfirst : {\r\n\t\t\tname : &quot;trick&quot;,\r\n\t\t\tval : &quot;value&quot;,\r\n\t\t\tanotherVal : &quot;wohoo&quot;\r\n\t\t},\r\n\t\tsecond : {\r\n\t\t\tfoo : &quot;bar&quot;,\r\n\t\t\tbar : &quot;bam&quot;\r\n\t\t},\r\n\t\tv : &quot;on first layer&quot;\r\n\t}));\r\n\t\r\n\tvar obj1 = {a: 1, b: &quot;hello&quot;};\r\n\tobj1.merge({c: 3});\r\n\tassertTrue(obj1.equals({a: 1, b: &quot;hello&quot;, c: 3}));\r\n\t\r\n\tobj1.merge({a: 2, b: &quot;mom&quot;, d: &quot;new property&quot;}, false);\r\n\tassertTrue(obj1.equals({a: 1, b: &quot;hello&quot;, c: 3, d: &quot;new property&quot;}));\r\n\t\r\n\tvar obj2 = {};\r\n\tobj2.merge({a: 1}, {b: 2}, {a: 3});\r\n\tassertTrue(obj2.equals({a: 3, b: 2}));\r\n\t\r\n\tvar a = [];\r\n\tvar b = [1, [2, 3], 4];\r\n\ta.merge(b);\r\n\tassertEquals(1, a[0]);\r\n\tassertEquals([2, 3], a[1]);\r\n\tassertEquals(4, a[2]);\r\n\t \r\n\t \r\n\tvar o1 = {};\r\n\tvar o2 = {a: 1, b: {c: 2}};\r\n\tvar o3 = {d: 3};\r\n\to1.merge(o2, o3);\r\n\tassertTrue(o1.equals({a: 1, b: {c: 2}, d: 3}));\r\n\to1.b.c = 99;\r\n\tassertTrue(o2.equals({a: 1, b: {c: 2}}));\r\n     \r\n\t// checking types with arrays and objects\r\n\tvar bo;\r\n\ta = [];\r\n\tbo = [1, {0:2, 1:3}, 4];\r\n\tb = [1, [2, 3], 4];\r\n\t\r\n\ta.merge(b);\r\n\tassertTrue(&quot;Array stays Array?&quot;, Array.isArray(a[1]));\r\n\t\r\n\ta = [];\r\n\ta.merge(bo);\r\n\tassertTrue(&quot;Object stays Object?&quot;, !Array.isArray(a[1]));\r\n\t\r\n\ta = [];\r\n\ta.merge(b);\r\n\ta.merge(bo);\r\n\tassertTrue(&quot;Object overrides Array&quot;, !Array.isArray(a[1]));\r\n\t\r\n\ta = [];\r\n\ta.merge(b);\r\n\ta.merge(bo, false);\r\n\tassertTrue(&quot;Object does not override Array&quot;, Array.isArray(a[1]));\r\n\t\r\n\ta = [];\r\n\ta.merge(bo);\r\n\ta.merge(b);\r\n\tassertTrue(&quot;Array overrides Object&quot;, Array.isArray(a[1]));\r\n\t\r\n\ta = [];\r\n\ta.merge(bo);\r\n\ta.merge(b, false);\r\n\tassertTrue(&quot;Array does not override Object&quot;, !Array.isArray(a[1]));\r\n    \r\nMy equals method can be found here: https://stackoverflow.com/questions/1068834/object-comparison-in-javascript/5522917#5522917"},{"score":1,"body_markdown":"I&#39;m kind of getting started with JavaScript, so correct me if I&#39;m wrong.\r\n\r\nBut wouldn&#39;t it be better if you could merge any number of objects? Here&#39;s how I do it using the native `Arguments` object.\r\n\r\nThe key to is that you can actually pass any number of arguments to a JavaScript function without defining them in the function declaration. You just can&#39;t access them without using the Arguments object.\r\n\r\n    function mergeObjects() (\r\n        var tmpObj = {};\r\n\r\n        for(var o in arguments) {\r\n            for(var m in arguments[o]) {\r\n                tmpObj[m] = arguments[o][m];\r\n            }\r\n        }\r\n        return tmpObj;\r\n    }\r\n"},{"score":2,"body_markdown":"Use:\r\n\r\n    //Takes any number of objects and returns one merged object\r\n    var objectMerge = function(){\r\n        var out = {};\r\n        if(!arguments.length)\r\n            return out;\r\n        for(var i=0; i&lt;arguments.length; i++) {\r\n            for(var key in arguments[i]){\r\n                out[key] = arguments[i][key];\r\n            }\r\n        }\r\n        return out;\r\n    }\r\n\r\nIt was tested with:\r\n\r\n    console.log(objectMerge({a:1, b:2}, {a:2, c:4}));\r\n\r\nIt results in:\r\n\r\n    { a: 2, b: 2, c: 4 }\r\n"},{"score":9,"body_markdown":"In [Ext&amp;nbsp;JS][1] 4 it can be done as follows:\r\n\r\n    var mergedObject = Ext.Object.merge(object1, object2)\r\n\r\n    // Or shorter:\r\n    var mergedObject2 = Ext.merge(object1, object2)\r\n\r\nSee *[merge( object ) : Object][2]*.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Ext_JS\r\n  [2]: http://docs.sencha.com/ext-js/4-0/#/api/Ext.Object-method-merge\r\n"},{"score":2,"body_markdown":"gossi&#39;s extension of David Coallier&#39;s method:\r\n\r\nCheck these two lines:\r\n\r\n    from = arguments[i];\r\n    Object.getOwnPropertyNames(from).forEach(function (name) {\r\n\r\nOne need to check &quot;from&quot; against null object... If for example merging an object that comes from an [Ajax][1] response, previously created on a server, an object property can have a value of &quot;null&quot;, and in that case the above code generates an error saying:\r\n\r\n&gt; &quot;from&quot; is not a valid object\r\n\r\nSo for example, wrapping the &quot;...Object.getOwnPropertyNames(from).forEach...&quot; function with an &quot;if (from != null) { ... }&quot; will prevent that error occurring.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Ajax_%28programming%29\r\n"},{"score":2,"body_markdown":"\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function extend(o, o1, o2){\r\n        if( !(o instanceof Object) ) o = {};\r\n\r\n        copy(o, o1);\r\n        if( o2 )\r\n            copy(o, o2)\r\n\r\n        function isObject(obj) {\r\n            var type = Object.prototype.toString.call(obj);\r\n            return obj === Object(obj) &amp;&amp; type != &#39;[object Array]&#39; &amp;&amp; type != &#39;[object Function]&#39;;\r\n        };\r\n\r\n        function copy(a,b){\r\n            // copy o2 to o\r\n            for( var key in b )\r\n                if( b.hasOwnProperty(key) ){\r\n                    if( isObject(b[key]) ){\r\n                        if( !isObject(a[key]) )\r\n                            a[key] = Object.assign({}, b[key]); \r\n                        else copy(a[key], b[key])\r\n                    }\r\n                    else\r\n                        a[key] = b[key];\r\n                }\r\n        }\r\n\r\n        return o;\r\n    };\r\n\r\n\r\n    var o1 = {a:{foo:1}, b:1},\r\n        o2 = {a:{bar:2}, b:[1], c:()=&gt;{}},\r\n        newMerged = extend({}, o1, o2);\r\n        \r\n    console.log( newMerged )\r\n    console.log( o1 )\r\n    console.log( o2 )\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":67,"body_markdown":"I need to merge objects today, and this question (and answers) helped me a lot. I tried some of the answers, but none of them fit my needs, so I combined some of the answers, added something myself and came up with a new merge function. Here it is:\r\n\r\n&lt;!-- language-all: lang-js --&gt;\r\n\r\n    var merge = function() {\r\n        var obj = {},\r\n            i = 0,\r\n            il = arguments.length,\r\n            key;\r\n        for (; i &lt; il; i++) {\r\n            for (key in arguments[i]) {\r\n                if (arguments[i].hasOwnProperty(key)) {\r\n                    obj[key] = arguments[i][key];\r\n                }\r\n            }\r\n        }\r\n        return obj;\r\n    };\r\n\r\nSome example usages:\r\n\r\n    var t1 = {\r\n        key1: 1,\r\n        key2: &quot;test&quot;,\r\n        key3: [5, 2, 76, 21]\r\n    };\r\n    var t2 = {\r\n        key1: {\r\n            ik1: &quot;hello&quot;,\r\n            ik2: &quot;world&quot;,\r\n            ik3: 3\r\n        }\r\n    };\r\n    var t3 = {\r\n        key2: 3,\r\n        key3: {\r\n            t1: 1,\r\n            t2: 2,\r\n            t3: {\r\n                a1: 1,\r\n                a2: 3,\r\n                a4: [21, 3, 42, &quot;asd&quot;]\r\n            }\r\n        }\r\n    };\r\n\r\n    console.log(merge(t1, t2));\r\n    console.log(merge(t1, t3));\r\n    console.log(merge(t2, t3));\r\n    console.log(merge(t1, t2, t3));\r\n    console.log(merge({}, t1, { key1: 1 }));\r\n"},{"score":7,"body_markdown":"Based on [Markus&#39;][1] and [vsync&#39; answer][2], this is an expanded version. The function takes any number of arguments. It can be used to set properties on [DOM][3] nodes and makes deep copies of values. However, the first argument is given by reference.\r\n\r\nTo detect a DOM node, the isDOMNode() function is used (see Stack&amp;nbsp;Overflow question *[JavaScript isDOM — How do you check if a JavaScript Object is a DOM Object?][4]*)\r\n\r\nIt was tested in [Opera][5] 11, Firefox 6, [Internet&amp;nbsp;Explorer&amp;nbsp;8][6] and Google Chrome 16.\r\n\r\nCode\r\n----\r\n\r\n    function mergeRecursive() {\r\n\r\n      // _mergeRecursive does the actual job with two arguments.\r\n      var _mergeRecursive = function (dst, src) {\r\n        if (isDOMNode(src) || typeof src !== &#39;object&#39; || src === null) {\r\n          return dst;\r\n        }\r\n\r\n        for (var p in src) {\r\n          if (!src.hasOwnProperty(p))\r\n            continue;\r\n          if (src[p] === undefined)\r\n            continue;\r\n          if ( typeof src[p] !== &#39;object&#39; || src[p] === null) {\r\n            dst[p] = src[p];\r\n          } else if (typeof dst[p]!==&#39;object&#39; || dst[p] === null) {\r\n            dst[p] = _mergeRecursive(src[p].constructor===Array ? [] : {}, src[p]);\r\n          } else {\r\n            _mergeRecursive(dst[p], src[p]);\r\n          }\r\n        }\r\n        return dst;\r\n      }\r\n\r\n      // Loop through arguments and merge them into the first argument.\r\n      var out = arguments[0];\r\n      if (typeof out !== &#39;object&#39; || out === null)\r\n        return out;\r\n      for (var i = 1, il = arguments.length; i &lt; il; i++) {\r\n        _mergeRecursive(out, arguments[i]);\r\n      }\r\n      return out;\r\n    }\r\n\r\n\r\nSome examples\r\n-------------\r\n\r\nSet innerHTML and style of a HTML Element\r\n\r\n    mergeRecursive(\r\n      document.getElementById(&#39;mydiv&#39;),\r\n      {style: {border: &#39;5px solid green&#39;, color: &#39;red&#39;}},\r\n      {innerHTML: &#39;Hello world!&#39;});\r\n\r\nMerge arrays and objects. Note that undefined can be used to preserv values in the lefthand array/object.\r\n\r\n    o = mergeRecursive({a:&#39;a&#39;}, [1,2,3], [undefined, null, [30,31]], {a:undefined, b:&#39;b&#39;});\r\n    // o = {0:1, 1:null, 2:[30,31], a:&#39;a&#39;, b:&#39;b&#39;}\r\n\r\nAny argument not beeing a JavaScript object (including null) will be ignored. Except for the first argument, also DOM nodes are discarded. Beware that i.e. strings, created like new String() are in fact objects.\r\n\r\n    o = mergeRecursive({a:&#39;a&#39;}, 1, true, null, undefined, [1,2,3], &#39;bc&#39;, new String(&#39;de&#39;));\r\n    // o = {0:&#39;d&#39;, 1:&#39;e&#39;, 2:3, a:&#39;a&#39;}\r\n\r\nIf you want to merge two objects into a new (without affecting any of the two) supply {} as first argument\r\n\r\n    var a={}, b={b:&#39;abc&#39;}, c={c:&#39;cde&#39;}, o;\r\n    o = mergeRecursive(a, b, c);\r\n    // o===a is true, o===b is false, o===c is false\r\n\r\n\r\n**Edit** (by ReaperSoon):\r\n\r\nTo also merge arrays\r\n\r\n    function mergeRecursive(obj1, obj2) {\r\n      if (Array.isArray(obj2)) { return obj1.concat(obj2); }\r\n      for (var p in obj2) {\r\n        try {\r\n          // Property in destination object set; update its value.\r\n          if ( obj2[p].constructor==Object ) {\r\n            obj1[p] = mergeRecursive(obj1[p], obj2[p]);\r\n          } else if (Array.isArray(obj2[p])) {\r\n          \tobj1[p] = obj1[p].concat(obj2[p]);\r\n          } else {\r\n            obj1[p] = obj2[p];\r\n          }\r\n        } catch(e) {\r\n          // Property in destination object not set; create it and set its value.\r\n          obj1[p] = obj2[p];\r\n        }\r\n      }\r\n      return obj1;\r\n    }\r\n\r\n  [1]: https://stackoverflow.com/questions/171251/how-can-i-merge-properties-of-two-javascript-objects-dynamically/383245#383245\r\n  [2]: https://stackoverflow.com/questions/171251/how-can-i-merge-properties-of-two-javascript-objects-dynamically/7965071#7965071\r\n  [3]: http://en.wikipedia.org/wiki/Document_Object_Model\r\n  [4]: https://stackoverflow.com/a/8736129/1131084\r\n  [5]: http://en.wikipedia.org/wiki/Opera_%28web_browser%29\r\n  [6]: http://en.wikipedia.org/wiki/Internet_Explorer_8\r\n"},{"score":1,"body_markdown":"In [YUI][1] [`Y.merge`][2] should get the job done:\r\n\r\n    Y.merge(obj1, obj2, obj3....) \r\n\r\n  [1]: http://en.wikipedia.org/wiki/Yahoo!_UI_Library\r\n  [2]: http://yuilibrary.com/yui/docs/yui/yui-merge.html\r\n"},{"score":177,"body_markdown":"Note that [`underscore.js`][1]&#39;s [`extend`-method][2] does this in a one-liner:\r\n\r\n    _.extend({name : &#39;moe&#39;}, {age : 50});\r\n    =&gt; {name : &#39;moe&#39;, age : 50}\r\n\r\n  [1]: http://underscorejs.org/\r\n  [2]: http://underscorejs.org/#extend\r\n"},{"score":12,"body_markdown":"Just if anyone is using [Google Closure Library][1]:\r\n\r\n    goog.require(&#39;goog.object&#39;);\r\n    var a = {&#39;a&#39;: 1, &#39;b&#39;: 2};\r\n    var b = {&#39;b&#39;: 3, &#39;c&#39;: 4};\r\n    goog.object.extend(a, b);\r\n    // Now object a == {&#39;a&#39;: 1, &#39;b&#39;: 3, &#39;c&#39;: 4};\r\n\r\n[Similar helper function exists for array][2]:\r\n\r\n    var a = [1, 2];\r\n    var b = [3, 4];\r\n    goog.array.extend(a, b); // Extends array &#39;a&#39;\r\n    goog.array.concat(a, b); // Returns concatenation of array &#39;a&#39; and &#39;b&#39;\r\n\r\n  [1]: http://closure-library.googlecode.com/svn/docs/closure_goog_object_object.js.html\r\n  [2]: http://closure-library.googlecode.com/svn/docs/closure_goog_array_array.js.html\r\n\r\n"},{"score":-1,"body_markdown":"    function extend()\r\n\t{ \r\n \t\tvar o = {}; \r\n \t\t\r\n\t\tfor (var i in arguments)\r\n\t\t{ \r\n  \t\t\tvar s = arguments[i]; \r\n  \t\t \r\n\t\t\tfor (var i in s)\r\n\t\t \t{ \r\n     \t\t\to[i] = s[i]; \r\n  \t\t\t} \r\n \t \t} \r\n\t \r\n\t \treturn o;\r\n\t}"},{"score":29,"body_markdown":"Just by the way, what you&#39;re all doing is overwriting properties, not merging...\r\n\r\nThis is how JavaScript objects area really merged: Only keys in the `to` object which are not objects themselves will be overwritten by `from`. Everything else will be ***really merged***. Of course you can change this behaviour to not overwrite anything which exists like only if `to[n] is undefined`, etc...:\r\n\r\n    var realMerge = function (to, from) {\r\n\r\n        for (n in from) {\r\n\r\n            if (typeof to[n] != &#39;object&#39;) {\r\n                to[n] = from[n];\r\n            } else if (typeof from[n] == &#39;object&#39;) {\r\n                to[n] = realMerge(to[n], from[n]);\r\n            }\r\n        }\r\n        return to;\r\n    };\r\n\r\nUsage:\r\n\r\n    var merged = realMerge(obj1, obj2);\r\n"},{"score":0,"body_markdown":"This merges `obj` into a &quot;default&quot; `def`. `obj` has precedence for anything that exists in both, since `obj` is copied into `def`. Note also that this is recursive.\r\n\r\n    function mergeObjs(def, obj) {\r\n        if (typeof obj == &#39;undefined&#39;) {\r\n            return def;\r\n        } else if (typeof def == &#39;undefined&#39;) {\r\n            return obj;\r\n        }\r\n        for (var i in obj) {\r\n            if (obj[i] != null &amp;&amp; obj[i].constructor == Object) {\r\n                def[i] = mergeObjs(def[i], obj[i]);\r\n            } else {\r\n                def[i] = obj[i];\r\n            }\r\n        }\r\n        return def;\r\n    }\r\n\r\n    a = {x : {y : [123]}}\r\n    b = {x : {z : 123}}\r\n    console.log(mergeObjs(a, b));\r\n    // {x: {y : [123], z : 123}}"},{"score":4,"body_markdown":"It&#39;s worth mentioning that the version from the [140byt.es collection][1] is solving the task within minimum space and is worth a try for this purpose:\r\n\r\nCode:\r\n\r\n    function m(a,b,c){for(c in b)b.hasOwnProperty(c)&amp;&amp;((typeof a[c])[0]==&#39;o&#39;?m(a[c],b[c]):a[c]=b[c])}\r\n\r\nUsage for your purpose:\r\n\r\n    m(obj1,obj2);\r\n\r\nHere&#39;s the [original Gist][2].\r\n\r\n  [1]: http://www.140byt.es/\r\n  [2]: https://gist.github.com/988478\r\n"},{"score":0,"body_markdown":"    A={a:1,b:function(){alert(9)}}\r\n    B={a:2,c:3}\r\n    A.merge = function(){for(var i in B){A[i]=B[i]}}\r\n    A.merge()\r\n\r\nResult is: {a:2,c:3,b:function()}"},{"score":28,"body_markdown":"Here&#39;s my stab which\r\n\r\n1. Supports deep merge\r\n2. Does not mutate arguments\r\n3. Takes any number of arguments\r\n4. Does not extend the object prototype\r\n5. Does not depend on another library ([jQuery][1], [MooTools][2], [Underscore.js][3], etc.)\r\n6. Includes check for hasOwnProperty\r\n7. Is short :)\r\n\r\n        /*\r\n            Recursively merge properties and return new object\r\n            obj1 &amp;lt;- obj2 [ &amp;lt;- ... ]\r\n        */\r\n        function merge () {\r\n            var dst = {}\r\n                ,src\r\n                ,p\r\n                ,args = [].splice.call(arguments, 0)\r\n            ;\r\n\r\n            while (args.length &gt; 0) {\r\n                src = args.splice(0, 1)[0];\r\n                if (toString.call(src) == &#39;[object Object]&#39;) {\r\n                    for (p in src) {\r\n                        if (src.hasOwnProperty(p)) {\r\n                            if (toString.call(src[p]) == &#39;[object Object]&#39;) {\r\n                                dst[p] = merge(dst[p] || {}, src[p]);\r\n                            } else {\r\n                                dst[p] = src[p];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n           return dst;\r\n        }\r\n\r\nExample:\r\n\r\n    a = {\r\n        &quot;p1&quot;: &quot;p1a&quot;,\r\n        &quot;p2&quot;: [\r\n            &quot;a&quot;,\r\n            &quot;b&quot;,\r\n            &quot;c&quot;\r\n        ],\r\n        &quot;p3&quot;: true,\r\n        &quot;p5&quot;: null,\r\n        &quot;p6&quot;: {\r\n            &quot;p61&quot;: &quot;p61a&quot;,\r\n            &quot;p62&quot;: &quot;p62a&quot;,\r\n            &quot;p63&quot;: [\r\n                &quot;aa&quot;,\r\n                &quot;bb&quot;,\r\n                &quot;cc&quot;\r\n            ],\r\n            &quot;p64&quot;: {\r\n                &quot;p641&quot;: &quot;p641a&quot;\r\n            }\r\n        }\r\n    };\r\n\r\n    b = {\r\n        &quot;p1&quot;: &quot;p1b&quot;,\r\n        &quot;p2&quot;: [\r\n            &quot;d&quot;,\r\n            &quot;e&quot;,\r\n            &quot;f&quot;\r\n        ],\r\n        &quot;p3&quot;: false,\r\n        &quot;p4&quot;: true,\r\n        &quot;p6&quot;: {\r\n            &quot;p61&quot;: &quot;p61b&quot;,\r\n            &quot;p64&quot;: {\r\n                &quot;p642&quot;: &quot;p642b&quot;\r\n            }\r\n        }\r\n    };\r\n\r\n    c = {\r\n        &quot;p1&quot;: &quot;p1c&quot;,\r\n        &quot;p3&quot;: null,\r\n        &quot;p6&quot;: {\r\n            &quot;p62&quot;: &quot;p62c&quot;,\r\n            &quot;p64&quot;: {\r\n                &quot;p643&quot;: &quot;p641c&quot;\r\n            }\r\n        }\r\n    };\r\n\r\n    d = merge(a, b, c);\r\n\r\n\r\n    /*\r\n        d = {\r\n            &quot;p1&quot;: &quot;p1c&quot;,\r\n            &quot;p2&quot;: [\r\n                &quot;d&quot;,\r\n                &quot;e&quot;,\r\n                &quot;f&quot;\r\n            ],\r\n            &quot;p3&quot;: null,\r\n            &quot;p5&quot;: null,\r\n            &quot;p6&quot;: {\r\n                &quot;p61&quot;: &quot;p61b&quot;,\r\n                &quot;p62&quot;: &quot;p62c&quot;,\r\n                &quot;p63&quot;: [\r\n                    &quot;aa&quot;,\r\n                    &quot;bb&quot;,\r\n                    &quot;cc&quot;\r\n                ],\r\n                &quot;p64&quot;: {\r\n                    &quot;p641&quot;: &quot;p641a&quot;,\r\n                    &quot;p642&quot;: &quot;p642b&quot;,\r\n                    &quot;p643&quot;: &quot;p641c&quot;\r\n                }\r\n            },\r\n            &quot;p4&quot;: true\r\n        };\r\n    */\r\n\r\n  [1]: http://en.wikipedia.org/wiki/JQuery\r\n  [2]: http://en.wikipedia.org/wiki/MooTools\r\n  [3]: https://en.wikipedia.org/wiki/Underscore.js\r\n"},{"score":0,"body_markdown":"You could assign every object a default merge (perhaps &#39;inherit&#39; a better name) method:\r\n\r\nIt should work with either objects or instantiated functions.\r\n\r\nThe below code handles overriding the merged values if so desired:\r\n\r\n    Object.prototype.merge = function(obj, override) {\r\n    // Don&#39;t override by default\r\n\r\n        for (var key in obj) {\r\n            var n = obj[key];\r\n            var t = this[key];\r\n            this[key] = (override &amp;&amp; t) ? n : t;\r\n        };\r\n\r\n    };\r\n\r\nTest data is below:\r\n\r\n    var Mammal = function () {\r\n        this.eyes = 2;\r\n        this.thinking_brain = false;\r\n        this.say = function () {\r\n        console.log(&#39;screaming like a mammal&#39;)};\r\n    }\r\n\r\n    var Human = function () {\r\n        this.thinking_brain = true;\r\n        this.say = function() {console.log(&#39;shouting like a human&#39;)};\r\n    }\r\n\r\n    john = new Human();\r\n\r\n    // Extend mammal, but do not override from mammal\r\n    john.merge(new Mammal());\r\n    john.say();\r\n\r\n    // Extend mammal and override from mammal\r\n    john.merge(new Mammal(), true);\r\n    john.say();\r\n"},{"score":2,"body_markdown":"My way:\r\n\r\n    function mergeObjects(defaults, settings) {\r\n\t\tObject.keys(defaults).forEach(function(key_default) {\r\n\t\t\tif (typeof settings[key_default] == &quot;undefined&quot;) {\r\n\t\t\t\tsettings[key_default] = defaults[key_default];\r\n\t\t\t} else if (isObject(defaults[key_default]) &amp;&amp; isObject(settings[key_default])) {\r\n\t\t\t\tmergeObjects(defaults[key_default], settings[key_default]);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfunction isObject(object) {\r\n\t\t\treturn Object.prototype.toString.call(object) === &#39;[object Object]&#39;;\r\n\t\t}\r\n\r\n\t\treturn settings;\r\n\t}\r\n\r\n:)"},{"score":1,"body_markdown":"I&#39;ve used Object.create() to keep the default settings (utilising \\__proto__ or Object.getPrototypeOf() ). \r\n\r\n    function myPlugin( settings ){\r\n        var defaults = {\r\n            &quot;keyName&quot;: [ &quot;string 1&quot;, &quot;string 2&quot; ]\r\n        }\r\n        var options = Object.create( defaults );\r\n        for (var key in settings) { options[key] = settings[key]; }\r\n    }\r\n    myPlugin( { &quot;keyName&quot;: [&quot;string 3&quot;, &quot;string 4&quot; ] } );\r\n\r\nThis way I can always &#39;concat()&#39; or &#39;push()&#39; later.\r\n\r\n    var newArray = options[&#39;keyName&#39;].concat( options.__proto__[&#39;keyName&#39;] );\r\n\r\n**Note**: You&#39;ll need to do a hasOwnProperty check before concatenation to avoid duplication."},{"score":84,"body_markdown":"Similar to jQuery extend(), you have the same function in [AngularJS][1]:\r\n\r\n    // Merge the &#39;options&#39; object into the &#39;settings&#39; object\r\n    var settings = {validate: false, limit: 5, name: &quot;foo&quot;};\r\n    var options  = {validate: true, name: &quot;bar&quot;};\r\n    angular.extend(settings, options);\r\n\r\n  [1]: http://en.wikipedia.org/wiki/AngularJS\r\n"},{"score":5,"body_markdown":"With [Underscore.js][1], to merge an array of objects do:\r\n\r\n    var arrayOfObjects = [ {a:1}, {b:2, c:3}, {d:4} ];\r\n    _(arrayOfObjects).reduce(function(memo, o) { return _(memo).extend(o); });\r\n\r\nIt results in:\r\n\r\n    Object {a: 1, b: 2, c: 3, d: 4}\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Underscore.js\r\n"},{"score":1,"body_markdown":"For those using [Node.js][1], there&#39;s an NPM module: [node.extend][2]\r\n\r\n# Install:\r\n\r\n    npm install node.extend\r\n\r\n# Usage:\r\n\r\n    var extend = require(&#39;node.extend&#39;);\r\n    var destObject = extend(true, {}, sourceObject);\r\n    // Where sourceObject is the object whose properties will be copied into another.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Node.js\r\n  [2]: https://www.npmjs.com/package/node.extend\r\n"},{"score":18,"body_markdown":"There&#39;s a library called [`deepmerge`][1] on [GitHub][2]: That seems to be getting some traction. It&#39;s a standalone, available through both the [npm][3] and bower package managers.\r\n\r\nI would be inclined to use or improve on this instead of copy-pasting code from answers.\r\n\r\n  [1]: https://github.com/nrf110/deepmerge\r\n  [2]: http://en.wikipedia.org/wiki/GitHub\r\n  [3]: https://en.wikipedia.org/wiki/Npm_(software)\r\n"},{"score":357,"body_markdown":"The [Harmony ECMAScript 2015 (ES6)][1] specifies [**`Object.assign`**][2] which will do this.\r\n\r\n    Object.assign(obj1, obj2);\r\n\r\nCurrent browser support is [getting better][3], but if you&#39;re developing for browsers that don&#39;t have support, you can use a [polyfill][4].\r\n\r\n\r\n  [1]: http://www.ecma-international.org/ecma-262/6.0/#sec-object.assign\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n  [3]:http://kangax.github.io/compat-table/es6/#test-Object_static_methods_Object.assign\r\n  [4]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill"},{"score":0,"body_markdown":"This solution creates a **new object** and is able to handle **multiple objects**.\r\n\r\nFurthermore, it is **recursive** and you can chose weather you **want** to **overwrite Values** and **Objects**.\r\n\r\n        function extendObjects() {\r\n        \r\n            var newObject        = {};\r\n            var overwriteValues  = false;\r\n            var overwriteObjects = false;\r\n            \r\n            for ( var indexArgument = 0; indexArgument &lt; arguments.length; indexArgument++ ) {\r\n                \r\n                if ( typeof arguments[indexArgument] !== &#39;object&#39; ) {\r\n                \r\n                    if ( arguments[indexArgument] == &#39;overwriteValues_True&#39; ) {\r\n                                          \r\n                        overwriteValues = true;            \r\n                    } else if ( arguments[indexArgument] == &#39;overwriteValues_False&#39; ) {\r\n                        \r\n                        overwriteValues = false;                             \r\n                    } else if ( arguments[indexArgument] == &#39;overwriteObjects_True&#39; ) {\r\n                    \r\n                        overwriteObjects = true;     \r\n                    } else if ( arguments[indexArgument] == &#39;overwriteObjects_False&#39; ) {\r\n                        \r\n                        overwriteObjects = false; \r\n                    }\r\n                \r\n                } else {\r\n                    \r\n                    extendObject( arguments[indexArgument], newObject, overwriteValues, overwriteObjects );\r\n                }\r\n                \r\n            }\r\n        \r\n            function extendObject( object, extendedObject, overwriteValues, overwriteObjects ) {\r\n                               \r\n                for ( var indexObject in object ) {\r\n                                          \r\n                    if ( typeof object[indexObject] === &#39;object&#39; ) {\r\n                                                  \r\n                        if ( typeof extendedObject[indexObject] === &quot;undefined&quot; || overwriteObjects ) {\r\n                            extendedObject[indexObject] = object[indexObject];\r\n                        }\r\n                        \r\n                        extendObject( object[indexObject], extendedObject[indexObject], overwriteValues, overwriteObjects );\r\n                        \r\n                    } else {\r\n                                        \r\n                        if ( typeof extendedObject[indexObject] === &quot;undefined&quot; || overwriteValues ) {\r\n                            extendedObject[indexObject] = object[indexObject];\r\n                        }\r\n                                                                \r\n                    }\r\n                               \r\n                }     \r\n                \r\n                return extendedObject;\r\n               \r\n            }\r\n        \r\n            return newObject;\r\n        }\r\n        \r\n        var object1           = { a : 1, b : 2, testArr : [888, { innArr : 1 }, 777 ], data : { e : 12, c : { lol : 1 }, rofl : { O : 3 } } };\r\n        var object2           = { a : 6, b : 9, data : { a : 17, b : 18, e : 13, rofl : { O : 99, copter : { mao : 1 } } }, hexa : { tetra : 66 } };\r\n        var object3           = { f : 13, g : 666, a : 333, data : { c : { xD : 45 } }, testArr : [888, { innArr : 3 }, 555 ]  };\r\n        \r\n        var newExtendedObject = extendObjects( &#39;overwriteValues_False&#39;, &#39;overwriteObjects_False&#39;, object1, object2, object3 );\r\n    \r\n\r\n**Contents of newExtendedObject:**\r\n\r\n    {&quot;a&quot;:1,&quot;b&quot;:2,&quot;testArr&quot;:[888,{&quot;innArr&quot;:1},777],&quot;data&quot;:{&quot;e&quot;:12,&quot;c&quot;:{&quot;lol&quot;:1,&quot;xD&quot;:45},&quot;rofl&quot;:{&quot;O&quot;:3,&quot;copter&quot;:{&quot;mao&quot;:1}},&quot;a&quot;:17,&quot;b&quot;:18},&quot;hexa&quot;:{&quot;tetra&quot;:66},&quot;f&quot;:13,&quot;g&quot;:666}\r\n\r\nFiddle: http://jsfiddle.net/o0gb2umb/\r\n"},{"score":36,"body_markdown":"The following two are probably a good starting point. lodash also has a customizer function for those special needs!\r\n\r\n`_.extend` (http://underscorejs.org/#extend) &lt;br/&gt;\r\n`_.merge` (https://lodash.com/docs#merge)\r\n\r\n"},{"score":0,"body_markdown":"Another method:\r\n\r\n    function concat_collection(obj1, obj2) {\r\n        var i;\r\n        var arr = new Array();\r\n\r\n        var len1 = obj1.length;\r\n        for (i=0; i&lt;len1; i++) {\r\n            arr.push(obj1[i]);\r\n        }\r\n\r\n        var len2 = obj2.length;\r\n        for (i=0; i&lt;len2; i++) {\r\n            arr.push(obj2[i]);\r\n        }\r\n\r\n        return arr;\r\n    }\r\n\r\n    var ELEMENTS = concat_collection(A,B);\r\n    for(var i = 0; i &lt; ELEMENTS.length; i++) {\r\n        alert(ELEMENTS[i].value);\r\n    }\r\n"},{"score":2,"body_markdown":"I use the following which is in pure JavaScript. It starts from the right-most argument and combines them all the way up to the first argument. There is no return value, only the first argument is modified and the left-most parameter (except the first one) has the highest weight on properties.\r\n\r\n    var merge = function() {\r\n      var il = arguments.length;\r\n\r\n      for (var i = il - 1; i &gt; 0; --i) {\r\n        for (var key in arguments[i]) {\r\n          if (arguments[i].hasOwnProperty(key)) {\r\n            arguments[0][key] = arguments[i][key];\r\n          }\r\n        }\r\n      }\r\n    };\r\n"},{"score":16,"body_markdown":"You can simply use jQuery **`extend`**\r\n\r\n    var obj1 = { val1: false, limit: 5, name: &quot;foo&quot; };\r\n    var obj2 = { val2: true, name: &quot;bar&quot; };\r\n\r\n    jQuery.extend(obj1, obj2);\r\n\r\nNow `obj1` contains all the values of `obj1` and `obj2`"},{"score":0,"body_markdown":"If you are using [Dojo Toolkit][1] then the best way to merge two object is using a mixin. \r\n\r\nBelow is the sample for Dojo Toolkit mixin:\r\n\r\n    // Dojo 1.7+ (AMD)\r\n    require([&quot;dojo/_base/lang&quot;], function(lang){\r\n      var a = { b:&quot;c&quot;, d:&quot;e&quot; };\r\n      lang.mixin(a, { d:&quot;f&quot;, g:&quot;h&quot; });\r\n      console.log(a); // b:c, d:f, g:h\r\n    });\r\n    \r\n    // Dojo &lt; 1.7\r\n    var a = { b:&quot;c&quot;, d:&quot;e&quot; };\r\n    dojo.mixin(a, { d:&quot;f&quot;, g:&quot;h&quot; });\r\n    console.log(a); // b:c, d:f, g:h\r\n\r\nFor more details, please *[mixin][2]*.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Dojo_Toolkit\r\n  [2]: http://dojotoolkit.org/reference-guide/1.7/dojo/mixin.html\r\n"},{"score":1,"body_markdown":"You can merge objects through following my method\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    \r\n    var obj1 = { food: &#39;pizza&#39;, car: &#39;ford&#39; };\r\n    var obj2 = { animal: &#39;dog&#39; };\r\n\r\n    var result = mergeObjects([obj1, obj2]);\r\n\r\n    console.log(result);\r\n    document.write(&quot;result: &lt;pre&gt;&quot; + JSON.stringify(result, 0, 3) + &quot;&lt;/pre&gt;&quot;);\r\n\r\n    function mergeObjects(objectArray) {\r\n        if (objectArray.length) {\r\n            var b = &quot;&quot;, i = -1;\r\n            while (objectArray[++i]) {\r\n                var str = JSON.stringify(objectArray[i]);\r\n                b += str.slice(1, str.length - 1);\r\n                if (objectArray[i + 1]) b += &quot;,&quot;;\r\n            }\r\n            return JSON.parse(&quot;{&quot; + b + &quot;}&quot;);\r\n        }\r\n        return {};\r\n    }\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":20,"body_markdown":"**Object.assign()**\r\n\r\n**ECMAScript 2015 (ES6)**\r\n\r\nThis is a new technology, part of the ECMAScript 2015 (ES6) standard.\r\nThis technology&#39;s specification has been finalized, but check the compatibility table for usage and implementation status in various browsers.\r\n\r\nThe Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.\r\n\r\n    var o1 = { a: 1 };\r\n    var o2 = { b: 2 };\r\n    var o3 = { c: 3 };\r\n    \r\n    var obj = Object.assign(o1, o2, o3);\r\n    console.log(obj); // { a: 1, b: 2, c: 3 }\r\n    console.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed."},{"score":42,"body_markdown":"# Merge properties of N objects in one line of code\n\nAn `Object.assign` method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need. (`IE` not supported)\n\n    var clone = Object.assign({}, obj);\n\n&gt;The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.\n\n[Read more...](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n\nThe __polyfill__ to support older browsers:\n\n    if (!Object.assign) {\n      Object.defineProperty(Object, &#39;assign&#39;, {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function(target) {\n          &#39;use strict&#39;;\n          if (target === undefined || target === null) {\n            throw new TypeError(&#39;Cannot convert first argument to object&#39;);\n          }\n    \n          var to = Object(target);\n          for (var i = 1; i &lt; arguments.length; i++) {\n            var nextSource = arguments[i];\n            if (nextSource === undefined || nextSource === null) {\n              continue;\n            }\n            nextSource = Object(nextSource);\n    \n            var keysArray = Object.keys(nextSource);\n            for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) {\n              var nextKey = keysArray[nextIndex];\n              var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n              if (desc !== undefined &amp;&amp; desc.enumerable) {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n          return to;\n        }\n      });\n    }"},{"score":5,"body_markdown":"You should use lodash&#39;s [defaultsDeep][1]\r\n\r\n    _.defaultsDeep({ &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39; } }, { &#39;user&#39;: { &#39;name&#39;: &#39;fred&#39;, &#39;age&#39;: 36 } });\r\n    // → { &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39;, &#39;age&#39;: 36 } }\r\n\r\n\r\n  [1]: https://lodash.com/docs#defaultsDeep"},{"score":0,"body_markdown":"A possible way to achieve this is the following.\r\n\r\n    if (!Object.prototype.merge){\r\n        Object.prototype.merge = function(obj){\r\n            var self = this;\r\n            Object.keys(obj).forEach(function(key){\r\n                self[key] = obj[key]\r\n            });\r\n        }\r\n    };\r\n\r\n\r\nI don&#39;t know if it&#39;s better then the other answers. In this method you add the `merge function` to `Objects` prototype. This way you can call     `obj1.merge(obj2);`\r\n\r\nNote : you should validate your argument to see if its an object and &#39;throw&#39; a proper `Error`. If not `Object.keys` will &#39;throw&#39; an &#39;Error&#39;"},{"score":0,"body_markdown":"Here what I used in my codebase to merge.\r\n\r\n    function merge(to, from) {\r\n      if (typeof to === &#39;object&#39; &amp;&amp; typeof from === &#39;object&#39;) {\r\n        for (var pro in from) {\r\n          if (from.hasOwnProperty(pro)) {\r\n            to[pro] = from[pro];\r\n          }\r\n        }\r\n      }\r\n      else{\r\n          throw &quot;Merge function can apply only on object&quot;;\r\n      }\r\n    }\r\n"},{"score":-2,"body_markdown":"If you need a deep merge that will also &quot;merge&quot; arrays by concatenating them in the result, then this ES6 function might be what you need:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function deepMerge(a, b) {\r\n        // If neither is an object, return one of them:\r\n        if (Object(a) !== a &amp;&amp; Object(b) !== b) return b || a;\r\n        // Replace remaining primitive by empty object/array\r\n        if (Object(a) !== a) a = Array.isArray(b) ? [] : {};\r\n        if (Object(b) !== b) b = Array.isArray(a) ? [] : {};\r\n        // Treat arrays differently:\r\n        if (Array.isArray(a) &amp;&amp; Array.isArray(b)) {\r\n            // Merging arrays is interpreted as concatenation of their deep clones:\r\n            return [...a.map(v =&gt; deepMerge(v)), ...b.map(v =&gt; deepMerge(v))];\r\n        } else {\r\n            // Get the keys that exist in either object\r\n            var keys = new Set([...Object.keys(a),...Object.keys(b)]);\r\n            // Recurse and assign to new object\r\n            return Object.assign({}, ...Array.from(keys,\r\n                key =&gt; ({ [key]: deepMerge(a[key], b[key]) }) ));\r\n        }\r\n    }\r\n\r\n    // Sample data for demo:\r\n    var a = {\r\n        groups: [{\r\n            group: [{\r\n                name: &#39;John&#39;,\r\n                age: 12\r\n            },{\r\n                name: &#39;Mary&#39;,\r\n                age: 20\r\n            }],\r\n            groupName: &#39;Pair&#39;\r\n        }],\r\n        config: {\r\n            color: &#39;blue&#39;,\r\n            range: &#39;far&#39;\r\n        }\r\n    };\r\n\r\n\r\n    var b = {\r\n        groups: [{\r\n            group: [{\r\n                name: &#39;Bill&#39;,\r\n                age: 15\r\n            }],\r\n            groupName: &#39;Loner&#39;\r\n        }],\r\n        config: {\r\n            range: &#39;close&#39;,\r\n            strength: &#39;average&#39;\r\n        }\r\n    };\r\n\r\n    var merged = deepMerge(a, b);\r\n\r\n    console.log(merged);\r\n\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper { max-height: 100% !important; top: 0; }\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nNote that if only one argument is passed to this function, it acts as a deep clone function."},{"score":53,"body_markdown":"You can use the [object spread syntax][1] to achieve this. It&#39;s a part of ES2018 and beyond.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const obj1 = { food: &#39;pizza&#39;, car: &#39;ford&#39; };\r\n    const obj2 = { animal: &#39;dog&#39; };\r\n\r\n    const obj3 = { ...obj1, ...obj2 };\r\n    console.log(obj3);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"},{"score":-1,"body_markdown":"You can do the following in EcmaScript2016\n\nCorrection: it&#39;s a stage 3 proposal, still it has always worked for me\n\n    const objA = {\n      attrA: &#39;hello&#39;,\n      attrB: true\n    }\n    \n    const objB = {\n      attrC: 2\n    }\n    \n    const mergedObj = {...objA, ...objB}"},{"score":1,"body_markdown":"The Merge Of JSON Compatible JavaScript Objects\r\n-----------------------------------------------\r\n\r\nI encourage the use and utilization of nondestructive methods that don&#39;t modify the original source, &#39;Object.assign&#39; is a *destructive method* and it also happens to be not so *production friendly* because it stops working on earlier browsers and you have no way of patching it cleanly, with an alternative.\r\n\r\nMerging JS Objects will always be out of reach, or incomplete, whatever the solution. But merging JSON compliant compatible objects is just one step away from being able to write a simple and portable piece of code of a nondestructive method of merging series of JS Objects into a returned master containing all the unique property-names and their corresponding values synthesized in a single master object for the intended purpose.\r\n\r\nHaving in mind that MSIE8 is the first browser to have added a native support for the JSON object is a great relief, and reusing the already existing technology, is always a welcomed opportunity.\r\n\r\nRestricting your code to JSON complant standard objects, is more of an advantage, than a restriction - since these objects can also be transmitted over the Internet. And of course for those who would like a deeper backward compatibility there&#39;s always a json plug., whose methods can easily be assigned to a JSON variable in the outer code without having to modify or rewrite the method in use.\r\n\r\n    function Merge( ){\r\n    \tvar a = [].slice.call( arguments ), i = 0;\r\n    \t\twhile( a[i] )a[i] = JSON.stringify( a[i++] ).slice( 1,-1 );\r\n    \t\treturn JSON.parse( &quot;{&quot;+ a.join() +&quot;}&quot; );\r\n    \t}\r\n\r\n(Of course one can always give it a more meaningful name, which I haven&#39;t decided yet; should probably name it JSONmerge)\r\n\r\nThe use case:\r\n\r\n    var master = Merge( obj1, obj2, obj3, ...objn );\r\n\r\nNow, contrary to the `Object.assign` this leaves all objects untouched and in their original state (in case you&#39;ve done something wrong and need to reorder the merging objects or be able to use them separately for some other operation before merging them again).\r\n\r\nTthe number of the Merge arguments is also limited *only* by the arguments length limit [which is huge]. \r\nThe natively supported JSON parse / stringify is already machine optimized, meaning: it should be faster than any scripted form of JS loop. \r\nThe iteration over given arguments, is being done using the `while` - proven to be the fastest loop in JS. \r\n\r\nIt doesn&#39;t harm to briefly mention the fact we already know that duplicate properties of the unique object labels (keys) will be overwritten by the later object containing the same key label, which means you are in control of which property is taking over the previous by simply ordering or reordering the arguments list. And the benefit of getting a clean and updated master object with no dupes as a final output.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    ;\r\n    var obj1 = {a:1}, obj2 = {b:2}, obj3 = {c:3}\r\n    ;\r\n    function Merge( ){\r\n        var a = [].slice.call( arguments ), i = 0;\r\n            while( a[i] )a[i] = JSON.stringify( a[i++] ).slice( 1,-1 );\r\n            return JSON.parse( &quot;{&quot;+ a.join() +&quot;}&quot; );\r\n        }\r\n    ;\r\n    var master = Merge( obj1, obj2, obj3 )\r\n    ;\r\n    console.log( JSON.stringify( master ) )\r\n    ;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":1,"body_markdown":"ES5 compatible native one-liner:\r\n\r\n    var merged = [obj1, obj2].reduce(function(a, o) { for(k in o) a[k] = o[k]; return a; }, {})"},{"score":13,"body_markdown":"**Merging objects is simple using `Object.assign` or the spread `...` operator **\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var obj1 = { food: &#39;pizza&#39;, car: &#39;ford&#39; }\r\n    var obj2 = { animal: &#39;dog&#39;, car: &#39;BMW&#39; }\r\n    var obj3 = {a: &quot;A&quot;}\r\n\r\n\r\n    var mergedObj = Object.assign(obj1,obj2,obj3)\r\n // or using the Spread operator (...)\r\nvar mergedObj = {...obj1,...obj2,...obj3}\r\n\r\n    console.log(mergedObj);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe objects are merged from right to left, this means that objects which have identical properties as the objects to their right will be overriden.\r\n\r\nIn this example `obj2.car` overrides `obj1.car`"},{"score":12,"body_markdown":"Wow.. this is the first StackOverflow post I&#39;ve seen with multiple pages. Apologies for adding another &quot;answer&quot;\r\n\r\n&lt;br /&gt;\r\n\r\n### ES5 &amp; Earlier\r\n\r\nThis method is for _ES5 &amp; Earlier_ - there are plenty of other answers addressing ES6. \r\n\r\nI did not see any *&quot;deep&quot;* object merging utilizing the [`arguments`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments) property. Here is my answer - **compact** &amp; **recursive**, allowing unlimited object arguments to be passed:\r\n\r\n```js\r\nfunction extend() {\r\n    for (var o = {}, i = 0; i &lt; arguments.length; i++) {\r\n        // Uncomment to skip arguments that are not objects (to prevent errors)\r\n        // if (arguments[i].constructor !== Object) continue;\r\n        for (var k in arguments[i]) {\r\n            if (arguments[i].hasOwnProperty(k)) {\r\n                o[k] = arguments[i][k].constructor === Object\r\n                    ? extend(o[k] || {}, arguments[i][k])\r\n                    : arguments[i][k];\r\n            }\r\n        }\r\n    }\r\n    return o;\r\n}\r\n```\r\n\r\n&lt;br /&gt;\r\n\r\n### Example\r\n\r\n&lt;!-- begin snippet: js hide: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    /**\r\n     * Extend objects\r\n     */\r\n    function extend() {\r\n        for (var o = {}, i = 0; i &lt; arguments.length; i++) {\r\n            for (var k in arguments[i]) {\r\n                if (arguments[i].hasOwnProperty(k)) {\r\n                    o[k] = arguments[i][k].constructor === Object\r\n                        ? extend(o[k] || {}, arguments[i][k])\r\n                        : arguments[i][k];\r\n                }\r\n            }\r\n        }\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Example\r\n     */\r\n    document.write(JSON.stringify(extend({\r\n        api: 1,\r\n        params: {\r\n            query: &#39;hello&#39;\r\n        }\r\n    }, {\r\n        params: {\r\n            query: &#39;there&#39;\r\n        }\r\n    })));\r\n    // outputs {&quot;api&quot;: 1, &quot;params&quot;: {&quot;query&quot;: &quot;there&quot;}}\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n&lt;br /&gt;\r\n\r\n_This answer is now but a drop in the ocean ..._"},{"score":0,"body_markdown":"We can crate a empty object, and combine them by `for-loop`:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var obj1 = {\r\n      id: &#39;1&#39;,\r\n      name: &#39;name&#39;\r\n    }\r\n\r\n    var obj2 = {\r\n      c: &#39;c&#39;,\r\n      d: &#39;d&#39;\r\n    }\r\n\r\n    var obj3 = {}\r\n\r\n    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }\r\n    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }\r\n\r\n\r\n    console.log( obj1, obj2, obj3)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":8,"body_markdown":"    var obj1 = { food: &#39;pizza&#39;, car: &#39;ford&#39; }\r\n    var obj2 = { animal: &#39;dog&#39; }\r\n    \r\n    // result\r\n    result: {food: &quot;pizza&quot;, car: &quot;ford&quot;, animal: &quot;dog&quot;}\r\n\r\n\r\n**Using jQuery.extend()** - [Link][1]\r\n\r\n    // Merge obj1 &amp; obj2 to result\r\n    var result1 = $.extend( {}, obj1, obj2 );\r\n\r\n**Using _.merge()** - [Link][2]\r\n\r\n    // Merge obj1 &amp; obj2 to result\r\n    var result2 = _.merge( {}, obj1, obj2 );\r\n\r\n**Using _.extend()** - [Link][3]\r\n\r\n    // Merge obj1 &amp; obj2 to result\r\n    var result3 = _.extend( {}, obj1, obj2 );\r\n\r\n**Using Object.assign() ECMAScript 2015 (ES6)** - [Link][4]\r\n\r\n    // Merge obj1 &amp; obj2 to result\r\n    var result4 = Object.assign( {}, obj1, obj2 );\r\n\r\nOutput of all\r\n\r\n    obj1: { animal: &#39;dog&#39; }\r\n    obj2: { food: &#39;pizza&#39;, car: &#39;ford&#39; }\r\n    result1: {food: &quot;pizza&quot;, car: &quot;ford&quot;, animal: &quot;dog&quot;}\r\n    result2: {food: &quot;pizza&quot;, car: &quot;ford&quot;, animal: &quot;dog&quot;}\r\n    result3: {food: &quot;pizza&quot;, car: &quot;ford&quot;, animal: &quot;dog&quot;}\r\n    result4: {food: &quot;pizza&quot;, car: &quot;ford&quot;, animal: &quot;dog&quot;}\r\n\r\n  [1]: https://api.jquery.com/jquery.extend/\r\n  [2]: https://lodash.com/docs/4.17.10#merge\r\n  [3]: https://underscorejs.org/#extend\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n\r\n\r\n"},{"score":0,"body_markdown":"With the following helper, you can merge two objects into one new object:\r\n\r\n\r\n    function extend(obj, src) {\r\n        for (var key in src) {\r\n            if (src.hasOwnProperty(key)) obj[key] = src[key];\r\n        }\r\n        return obj;\r\n    }\r\n    \r\n    // example\r\n    var a = { foo: true }, b = { bar: false };\r\n    var c = extend(a, b);\r\n    \r\n    console.log(c);\r\n    // { foo: true, bar: false }\r\n\r\nThis is typically useful when merging an options dict with the default settings in a function or a plugin.\r\n\r\nIf support for IE 8 is not required, you may use `Object.keys` for the same functionality instead:\r\n\r\n    function extend(obj, src) {\r\n        Object.keys(src).forEach(function(key) { obj[key] = src[key]; });\r\n        return obj;\r\n    }\r\n\r\nThis involves slightly less code and is a bit faster."},{"score":5,"body_markdown":"\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let obj1 = {a:1, b:2};\r\n    let obj2 = {c:3, d:4};\r\n    let merged = {...obj1, ...obj2};\r\nconsole.log(merged);\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":4,"body_markdown":"ES2018/TypeScript: Many answers are OK but I&#39;ve come up with a more elegant solution to this problem when you need to merge two objects **without overwriting overlapping object keys**.\r\n\r\nMy function also accepts **unlimited number of objects** to merge as function arguments:\r\n\r\n*(I&#39;m using TypeScript notation here, feel free to delete the `:object[]` type in the function argument if you&#39;re using plain JavaScript).*\r\n\r\n\r\n    const merge = (...objects: object[]) =&gt; {\r\n      return objects.reduce((prev, next) =&gt; {\r\n        Object.keys(prev).forEach(key =&gt; {\r\n          next[key] = { ...next[key], ...prev[key] }\r\n        })\r\n        return next\r\n      })\r\n    }"},{"score":1,"body_markdown":"*merge two object using **Object.assign** and **spread operator.***\r\n\r\n**Wrong way(Modify original object because targeting o1)**\r\n\r\n    var o1 = { X: 10 };\r\n    var o2 = { Y: 20 };\r\n    var o3 = { Z: 30 };\r\n    var merge = Object.assign(o1, o2, o3);\r\n    console.log(merge)  // {X:10, Y:20, Z:30}\r\n    console.log(o1)     // {X:10, Y:20, Z:30}\r\n\r\n**Right ways**\r\n\r\n  - Object.assign({}, o1, o2, o3) **==&gt;** targeting new object\r\n\r\n  - {...o1, ...o2, ...o3} **==&gt;** spreading objects\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var o1 = { X: 10 };\r\n    var o2 = { Y: 20 };\r\n    var o3 = { Z: 30 };\r\n\r\n    console.log(&#39;Does not modify original objects because target {}&#39;);\r\n    var merge = Object.assign({}, o1, o2, o3);\r\n    console.log(merge); // { X: 10, Y: 20, Z: 30 }\r\n    console.log(o1)\r\n\r\n    console.log(&#39;Does not modify original objects&#39;)\r\n    var spreadMerge = {...o1, ...o2, ...o3};\r\n    console.log(spreadMerge);\r\n    console.log(o1);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n    \r\n"},{"score":2,"body_markdown":"It seems like this should be all you need:\r\n\r\n    var obj1 = { food: &#39;pizza&#39;, car: &#39;ford&#39; }\r\n    var obj2 = { animal: &#39;dog&#39; }\r\n\r\n    var obj1 = { ...obj1, ...obj2 }\r\n\r\nAfter that obj1 should now have the following value:\r\n\r\n    {food: &quot;pizza&quot;, car: &quot;ford&quot;, animal: &quot;dog&quot;}"},{"score":2,"body_markdown":"**shallow**\r\n\r\n    var obj = { name : &quot;Jacob&quot; , address : [&quot;America&quot;] }\r\n    var obj2 = { name : &quot;Shaun&quot; , address : [&quot;Honk Kong&quot;] }\r\n    \r\n    var merged = Object.assign({} , obj,obj2 ); //shallow merge \r\n    obj2.address[0] = &quot;new city&quot;\r\n\r\nresult.address[0] is changed to &quot;new city&quot; , i.e merged object is also changed. This is the problem with shallow merge.\r\n\r\n\r\n**deep**\r\n\r\n  \r\n\r\n    var obj = { name : &quot;Jacob&quot; , address : [&quot;America&quot;] }\r\n    var obj2 = { name : &quot;Shaun&quot; , address : [&quot;Honk Kong&quot;] }\r\n    \r\n    var result = Object.assign({} , JSON.parse(JSON.stringify(obj)),JSON.parse(JSON.stringify(obj2)) )\r\n    \r\n    obj2.address[0] = &quot;new city&quot;\r\n\r\nresult.address[0] is not changed"},{"score":2,"body_markdown":"You can use `Object.assign` method. For example:\r\n\r\n```\r\nvar result = Object.assign(obj1, obj2);\r\n```\r\n\r\nAlso, note that it creates a shallow copy of the object."},{"score":4,"body_markdown":"&gt; Use Spread operator which follows the ES6 version\r\n\r\n    var obj1 = { food: &#39;pizza&#39;, car: &#39;ford&#39; }\r\n    var obj2 = { animal: &#39;dog&#39; }\r\n    let result = {...obj1,...obj2};\r\n    console.log(result)\r\n\r\n    output { food: &#39;pizza&#39;, car: &#39;ford&#39;, animal: &#39;dog&#39; }"},{"score":0,"body_markdown":"There are different ways to achieve this:\r\n\r\n    Object.assign(targetObj, sourceObj);\r\n\r\n    targetObj = {...targetObj, ...sourceObj};"},{"score":0,"body_markdown":"    Object.assign(TargetObject, Obj1, Obj2, ...);"}],"score":2655}