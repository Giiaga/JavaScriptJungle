{"body":"What is the most efficient way to clone a JavaScript object? I&#39;ve seen `obj = eval(uneval(o));` being used, but [that&#39;s non-standard and only supported by Firefox][1].&lt;br/&gt;&lt;br/&gt; I&#39;ve done things like `obj = JSON.parse(JSON.stringify(o));` but question the efficiency. &lt;br/&gt;&lt;br/&gt; I&#39;ve also seen recursive copying functions with various flaws.\r\n&lt;br /&gt;\r\nI&#39;m surprised no canonical solution exists.\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/uneval\r\n","title":"What is the most efficient way to deep clone an object in JavaScript?","answers":[{"score":331,"body_markdown":"If there wasn&#39;t any builtin one, you could try:\r\n\r\n    function clone(obj) {\r\n        if (obj === null || typeof (obj) !== &#39;object&#39; || &#39;isActiveClone&#39; in obj)\r\n            return obj;\r\n    \r\n        if (obj instanceof Date)\r\n            var temp = new obj.constructor(); //or new Date(obj);\r\n        else\r\n            var temp = obj.constructor();\r\n    \r\n        for (var key in obj) {\r\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n                obj[&#39;isActiveClone&#39;] = null;\r\n                temp[key] = clone(obj[key]);\r\n                delete obj[&#39;isActiveClone&#39;];\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n"},{"score":21,"body_markdown":"    function clone(obj)\r\n     { var clone = {};\r\n       clone.prototype = obj.prototype;\r\n       for (property in obj) clone[property] = obj[property];\r\n       return clone;\r\n     }"},{"score":4918,"body_markdown":"# Native deep cloning\r\n\r\nIt&#39;s called &quot;structured cloning&quot;, works experimentally in Node 11 and later, and hopefully will land in browsers. See [this answer](https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/10916838#10916838) for more details.\r\n\r\n# Fast cloning with data loss - JSON.parse/stringify\r\n\r\nIf you do not use `Date`s, functions, `undefined`, `Infinity`, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays or other complex types within your object, a very simple one liner to deep clone an object is:\r\n\r\n`JSON.parse(JSON.stringify(object))`\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const a = {\r\n      string: &#39;string&#39;,\r\n      number: 123,\r\n      bool: false,\r\n      nul: null,\r\n      date: new Date(),  // stringified\r\n      undef: undefined,  // lost\r\n      inf: Infinity,  // forced to &#39;null&#39;\r\n      re: /.*/,  // lost\r\n    }\r\n    console.log(a);\r\n    console.log(typeof a.date);  // Date object\r\n    const clone = JSON.parse(JSON.stringify(a));\r\n    console.log(clone);\r\n    console.log(typeof clone.date);  // result of .toISOString()\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nSee [Corban&#39;s answer](https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/5344074#5344074) for benchmarks.\r\n\r\n# Reliable cloning using a library\r\n\r\nSince cloning objects is not trivial (complex types, circular references, function etc.), most major libraries provide function to clone objects. **Don&#39;t reinvent the wheel** - if you&#39;re already using a library, check if it has an object cloning function. For example,\r\n\r\n* lodash - [`cloneDeep`](https://lodash.com/docs#cloneDeep); can be imported separately via the [lodash.clonedeep](https://www.npmjs.com/package/lodash.clonedeep) module and is probably your best choice if you&#39;re not already using a library that provides a deep cloning function\r\n* AngularJS - [`angular.copy`](https://docs.angularjs.org/api/ng/function/angular.copy)\r\n* jQuery - [`jQuery.extend(true, { }, oldObject)`](https://api.jquery.com/jquery.extend/#jQuery-extend-deep-target-object1-objectN); `.clone()` only clones DOM elements\r\n\r\n# ES6\r\n\r\nFor completeness, note that ES6 offers two shallow copy mechanisms: [`Object.assign()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) and the [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax).\r\nwhich copies values of all enumerable own properties from one object to another. For example:\r\n\r\n```\r\nvar A1 = {a: &quot;2&quot;};\r\nvar A2 = Object.assign({}, A1);\r\nvar A3 = {...A1};  // Spread Syntax\r\n```"},{"score":101,"body_markdown":"Code:\r\n\r\n    // extends &#39;from&#39; object with members from &#39;to&#39;. If &#39;to&#39; is null, a deep clone of &#39;from&#39; is returned\r\n    function extend(from, to)\r\n    {\r\n    \tif (from == null || typeof from != &quot;object&quot;) return from;\r\n    \tif (from.constructor != Object &amp;&amp; from.constructor != Array) return from;\r\n    \tif (from.constructor == Date || from.constructor == RegExp || from.constructor == Function ||\r\n    \t\tfrom.constructor == String || from.constructor == Number || from.constructor == Boolean)\r\n    \t\treturn new from.constructor(from);\r\n    \r\n    \tto = to || new from.constructor();\r\n    \r\n    \tfor (var name in from)\r\n    \t{\r\n    \t\tto[name] = typeof to[name] == &quot;undefined&quot; ? extend(from[name], null) : to[name];\r\n    \t}\r\n    \r\n    \treturn to;\r\n    }\r\n\r\nTest:\r\n\r\n    var obj =\r\n    {\r\n    \tdate: new Date(),\r\n    \tfunc: function(q) { return 1 + q; },\r\n    \tnum: 123,\r\n    \ttext: &quot;asdasd&quot;,\r\n    \tarray: [1, &quot;asd&quot;],\r\n    \tregex: new RegExp(/aaa/i),\r\n    \tsubobj:\r\n    \t{\r\n    \t\tnum: 234,\r\n    \t\ttext: &quot;asdsaD&quot;\r\n    \t}\r\n    }\r\n    \r\n    var clone = extend(obj);"},{"score":101,"body_markdown":"This is what I&#39;m using:\r\n\r\n    function cloneObject(obj) {\r\n        var clone = {};\r\n        for(var i in obj) {\r\n            if(typeof(obj[i])==&quot;object&quot; &amp;&amp; obj[i] != null)\r\n                clone[i] = cloneObject(obj[i]);\r\n            else\r\n                clone[i] = obj[i];\r\n        }\r\n        return clone;\r\n    }"},{"score":65,"body_markdown":"    var clone = function() {\r\n        var newObj = (this instanceof Array) ? [] : {};\r\n        for (var i in this) {\r\n            if (this[i] &amp;&amp; typeof this[i] == &quot;object&quot;) {\r\n                newObj[i] = this[i].clone();\r\n            }\r\n            else\r\n            {\r\n                newObj[i] = this[i];\r\n            }\r\n        }\r\n        return newObj;\r\n    }; \r\n\r\n\tObject.defineProperty( Object.prototype, &quot;clone&quot;, {value: clone, enumerable: false});"},{"score":12,"body_markdown":"    // obj target object, vals source object\r\n    var setVals = function (obj, vals) {\r\n        if (obj &amp;&amp; vals) {\r\n            for (var x in vals) {\r\n                if (vals.hasOwnProperty(x)) {\r\n                    if (obj[x] &amp;&amp; typeof vals[x] === &#39;object&#39;) {\r\n                        obj[x] = setVals(obj[x], vals[x]);\r\n                    } else {\r\n                        obj[x] = vals[x];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return obj;\r\n    };"},{"score":23,"body_markdown":"Crockford suggests (and I prefer) using this function:\r\n\r\n    function object(o) {\r\n    \tfunction F() {}\r\n    \tF.prototype = o;\r\n    \treturn new F();\r\n    }\r\n\r\n    var newObject = object(oldObject);\r\n\r\nIt&#39;s terse, works as expected and you don&#39;t need a library.\r\n\r\n----------\r\n\r\n**EDIT:**\r\n\r\nThis is a polyfill for `Object.create`, so you also can use this.\r\n\r\n    var newObject = Object.create(oldObject);\r\n\r\n**NOTE:**  If you use some of this, you may have problems with some iteration who use `hasOwnProperty`. Because, `create` create new empty object who inherits `oldObject`. But it is still useful and practical for cloning objects.\r\n\r\nFor exemple if  `oldObject.a = 5;`\r\n\r\n    newObject.a; // is 5\r\n\r\nbut:\r\n\r\n    oldObject.hasOwnProperty(a); // is true\r\n    newObject.hasOwnProperty(a); // is false\r\n"},{"score":17,"body_markdown":"There seems to be no ideal deep clone operator yet for array-like objects.  As the code below illustrates, John Resig&#39;s jQuery cloner turns arrays with non-numeric properties into objects that are not arrays, and RegDwight&#39;s JSON cloner drops the non-numeric properties. The following tests illustrate these points on multiple browsers:\r\n\r\n    function jQueryClone(obj) {\r\n       return jQuery.extend(true, {}, obj)\r\n    }\r\n    \r\n    function JSONClone(obj) {\r\n       return JSON.parse(JSON.stringify(obj))\r\n    }\r\n    \r\n    var arrayLikeObj = [[1, &quot;a&quot;, &quot;b&quot;], [2, &quot;b&quot;, &quot;a&quot;]];\r\n    arrayLikeObj.names = [&quot;m&quot;, &quot;n&quot;, &quot;o&quot;];\r\n    var JSONCopy = JSONClone(arrayLikeObj);\r\n    var jQueryCopy = jQueryClone(arrayLikeObj);\r\n\r\n    alert(&quot;Is arrayLikeObj an array instance?&quot; + (arrayLikeObj instanceof Array) +\r\n    \t  &quot;\\nIs the jQueryClone an array instance? &quot; + (jQueryCopy instanceof Array) +\r\n    \t  &quot;\\nWhat are the arrayLikeObj names? &quot; + arrayLikeObj.names +\r\n    \t  &quot;\\nAnd what are the JSONClone names? &quot; + JSONCopy.names)\r\n\r\n"},{"score":492,"body_markdown":"Assuming that you have only variables and not any functions in your object, you can  just use:\r\n\r\n\tvar newObject = JSON.parse(JSON.stringify(oldObject));\r\n"},{"score":2311,"body_markdown":"Checkout this benchmark: http://jsben.ch/#/bWfk9\r\n\r\nIn my previous tests where speed was a main concern I found \r\n\r\n    JSON.parse(JSON.stringify(obj))\r\n\r\nto be the slowest way to deep clone an object (it is slower than [jQuery.extend][1] with `deep` flag set true by 10-20%).\r\n\r\njQuery.extend is pretty fast when the `deep` flag is set to `false` (shallow clone). It is a good option, because it includes some extra logic for type validation and doesn&#39;t copy over undefined properties, etc., but this will also slow you down a little.\r\n\r\nIf you know the structure of the objects you are trying to clone or can avoid deep nested arrays you can write a simple `for (var i in obj)` loop to clone your object while checking hasOwnProperty and it will be much much faster than jQuery.\r\n\r\nLastly if you are attempting to clone a known object structure in a hot loop you can get MUCH MUCH MORE PERFORMANCE by simply in-lining the clone procedure and manually constructing the object.\r\n\r\nJavaScript trace engines suck at optimizing `for..in` loops and checking hasOwnProperty will slow you down as well. Manual clone when speed is an absolute must.\r\n\r\n    var clonedObject = {\r\n      knownProp: obj.knownProp,\r\n      ..\r\n    }\r\n\r\nBeware using the `JSON.parse(JSON.stringify(obj))` method on `Date` objects - `JSON.stringify(new Date())` returns a string representation of the date in ISO format, which `JSON.parse()` **doesn&#39;t** convert back to a `Date` object. [See this answer for more details][2].\r\n\r\nAdditionally, please note that, in Chrome 65 at least, native cloning is not the way to go. According to JSPerf, performing native cloning by creating a new function is nearly **800x** slower than using JSON.stringify which is incredibly fast all the way across the board.\r\n\r\n**[Update for ES6][3]**\r\n\r\nIf you are using Javascript ES6 try this native method for cloning or shallow copy.\r\n\r\n    Object.assign({}, obj);\r\n\r\n\r\n  [1]: https://api.jquery.com/jQuery.extend/\r\n  [2]: https://stackoverflow.com/questions/11491938/issues-with-date-when-using-json-stringify-and-json-parse/11491993#11491993\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"},{"score":3,"body_markdown":"I think that this is the best solution\tif you want to generalize your object cloning algorithm.  \r\nIt can be used with or without jQuery, although I recommend leaving jQuery&#39;s extend method out if you want you the cloned object to have the same &quot;class&quot; as the original one.\r\n\r\n\r\n\tfunction clone(obj){\r\n\t\tif(typeof(obj) == &#39;function&#39;)//it&#39;s a simple function\r\n\t\t\treturn obj;\r\n\t\t//of it&#39;s not an object (but could be an array...even if in javascript arrays are objects)\r\n\t\tif(typeof(obj) !=  &#39;object&#39; || obj.constructor.toString().indexOf(&#39;Array&#39;)!=-1)\r\n\t\t\tif(JSON != undefined)//if we have the JSON obj\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn JSON.parse(JSON.stringify(obj));\r\n\t\t\t\t}catch(err){\r\n\t\t\t\t\treturn JSON.parse(&#39;&quot;&#39;+JSON.stringify(obj)+&#39;&quot;&#39;);\r\n\t\t\t\t}\r\n\t\t\telse\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn eval(uneval(obj));\r\n\t\t\t\t}catch(err){\r\n\t\t\t\t\treturn eval(&#39;&quot;&#39;+uneval(obj)+&#39;&quot;&#39;);\r\n\t\t\t\t}\r\n        // I used to rely on jQuery for this, but the &quot;extend&quot; function returns\r\n\t\t//an object similar to the one cloned,\r\n\t\t//but that was not an instance (instanceof) of the cloned class\r\n\t\t/*\r\n\t\tif(jQuery != undefined)//if we use the jQuery plugin\r\n\t\t\treturn jQuery.extend(true,{},obj);\r\n\t\telse//we recursivley clone the object\r\n\t\t*/\r\n\t\treturn (function _clone(obj){\r\n\t\t\tif(obj == null || typeof(obj) != &#39;object&#39;)\r\n\t\t\t\treturn obj;\r\n\t\t\tfunction temp () {};\r\n\t\t\ttemp.prototype = obj;\r\n\t\t\tvar F = new temp;\r\n\t\t\tfor(var key in obj)\r\n\t\t\t\tF[key] = clone(obj[key]);\r\n\t\t\treturn F;\r\n\t\t})(obj);\t\t\t\r\n\t}\r\n"},{"score":14,"body_markdown":"This isn&#39;t generally the most efficient solution, but it does what I need. Simple test cases below...\r\n\r\n    function clone(obj, clones) {\r\n        // Makes a deep copy of &#39;obj&#39;. Handles cyclic structures by\r\n        // tracking cloned obj&#39;s in the &#39;clones&#39; parameter. Functions \r\n        // are included, but not cloned. Functions members are cloned.\r\n        var new_obj,\r\n            already_cloned,\r\n            t = typeof obj,\r\n            i = 0,\r\n            l,\r\n            pair; \r\n    \r\n        clones = clones || [];\r\n    \r\n        if (obj === null) {\r\n            return obj;\r\n        }\r\n\r\n        if (t === &quot;object&quot; || t === &quot;function&quot;) {\r\n\r\n            // check to see if we&#39;ve already cloned obj\r\n            for (i = 0, l = clones.length; i &lt; l; i++) {\r\n                pair = clones[i];\r\n                if (pair[0] === obj) {\r\n                    already_cloned = pair[1];\r\n                    break;\r\n                }\r\n            }\r\n        \r\n            if (already_cloned) {\r\n                return already_cloned; \r\n            } else {\r\n                if (t === &quot;object&quot;) { // create new object\r\n                    new_obj = new obj.constructor();\r\n                } else { // Just use functions as is\r\n                    new_obj = obj;\r\n                }\r\n\r\n                clones.push([obj, new_obj]); // keep track of objects we&#39;ve cloned\r\n\r\n                for (key in obj) { // clone object members\r\n                    if (obj.hasOwnProperty(key)) {\r\n                        new_obj[key] = clone(obj[key], clones);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new_obj || obj;\r\n    }\r\n\r\nCyclic array test...\r\n\r\n    a = []\r\n    a.push(&quot;b&quot;, &quot;c&quot;, a)\r\n    aa = clone(a)\r\n    aa === a //=&gt; false\r\n    aa[2] === a //=&gt; false\r\n    aa[2] === a[2] //=&gt; false\r\n    aa[2] === aa //=&gt; true\r\n\r\nFunction test...\r\n\r\n    f = new Function\r\n    f.a = a\r\n    ff = clone(f)\r\n    ff === f //=&gt; true\r\n    ff.a === a //=&gt; false"},{"score":4,"body_markdown":"This is the fastest method I have created that doesn&#39;t use the prototype, so it will maintain hasOwnProperty in the new object.\r\n\r\nThe solution is to iterate the top level properties of the original object, make two copies, delete each property from the original and then reset the original object and return the new copy. It only has to iterate as many times as top level properties. This saves all the `if` conditions to check if each property is a function, object, string, etc., and doesn&#39;t have to iterate each descendant property.\r\n\r\nThe only drawback is that the original object must be supplied with its original created namespace, in order to reset it.\r\n\r\n    copyDeleteAndReset:function(namespace,strObjName){\r\n        var obj = namespace[strObjName],\r\n        objNew = {},objOrig = {};\r\n        for(i in obj){\r\n            if(obj.hasOwnProperty(i)){\r\n                objNew[i] = objOrig[i] = obj[i];\r\n                delete obj[i];\r\n            }\r\n        }\r\n        namespace[strObjName] = objOrig;\r\n        return objNew;\r\n    }\r\n\r\n    var namespace = {};\r\n    namespace.objOrig = {\r\n        &#39;0&#39;:{\r\n            innerObj:{a:0,b:1,c:2}\r\n        }\r\n    }\r\n\r\n    var objNew = copyDeleteAndReset(namespace,&#39;objOrig&#39;);\r\n    objNew[&#39;0&#39;] = &#39;NEW VALUE&#39;;\r\n\r\n    console.log(objNew[&#39;0&#39;]) === &#39;NEW VALUE&#39;;\r\n    console.log(namespace.objOrig[&#39;0&#39;]) === innerObj:{a:0,b:1,c:2};\r\n\r\n"},{"score":54,"body_markdown":"I know this is an old post, but I thought this may be of some help to the next person who stumbles along.\r\n\r\nAs long as you don&#39;t assign an object to anything it maintains no reference in memory.  So to make an object that you want to share among other objects, you&#39;ll have to create a factory like so:\r\n\r\n    var a = function(){\r\n        return {\r\n            father:&#39;zacharias&#39;\r\n        };\r\n    },\r\n    b = a(),\r\n    c = a();\r\n    c.father = &#39;johndoe&#39;;\r\n    alert(b.father);\r\n"},{"score":48,"body_markdown":"If you&#39;re using it, the [Underscore.js][1] library has a [clone][2] method.\r\n\r\n    var newObject = _.clone(oldObject);\r\n\r\n  [1]: http://documentcloud.github.com/underscore/\r\n  [2]: http://documentcloud.github.com/underscore/#clone\r\n"},{"score":427,"body_markdown":"# Structured Cloning\r\n\r\nThe HTML standard includes [**an internal structured cloning/serialization algorithm**][1] that can create deep clones of objects. It is still limited to certain built-in types, but in addition to the few types supported by JSON it also supports Dates, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays, and probably more in the future. It also preserves references within the cloned data, allowing it to support cyclical and recursive structures that would cause errors for JSON.\r\n\r\n## Support in Node.js: Experimental &#128578;\r\n\r\nThe `v8` module in Node.js currently (as of Node 11) [exposes the structured serialization API directly](https://nodejs.org/api/all.html#v8_serialization_api), but this functionality is still marked as &quot;experimental&quot;, and subject to change or removal in future versions. If you&#39;re using a compatible version, cloning an object is as simple as:\r\n\r\n```lang-js\r\nconst v8 = require(&#39;v8&#39;);\r\n\r\nconst structuredClone = obj =&gt; {\r\n  return v8.deserialize(v8.serialize(obj));\r\n};\r\n```\r\n\r\n## Direct Support in Browsers: Maybe Eventually? &#128528;\r\n\r\nBrowsers do not currently provide a direct interface for the structured cloning algorithm, but a global `structuredClone()` function has been discussed in [whatwg/html#793 on GitHub](https://github.com/whatwg/html/issues/793). As currently proposed, using it for most purposes would be as simple as:\r\n\r\n```lang-js\r\nconst clone = structuredClone(original);\r\n```\r\n\r\nUnless this is shipped, browsers&#39; structured clone implementations are only exposed indirectly.\r\n\r\n## Asynchronous Workaround: Usable. &#128533;\r\n\r\nThe lower-overhead way to create a structured clone with existing APIs is to post the data through one port of a [MessageChannels][3]. The other port will emit a `message` event with a structured clone of the attached `.data`. Unfortunately, listening for these events is necessarily asynchronous, and the synchronous alternatives are less practical.\r\n\r\n```lang-js\r\nclass StructuredCloner {\r\n  constructor() {\r\n    this.pendingClones_ = new Map();\r\n    this.nextKey_ = 0;\r\n    \r\n    const channel = new MessageChannel();\r\n    this.inPort_ = channel.port1;\r\n    this.outPort_ = channel.port2;\r\n    \r\n    this.outPort_.onmessage = ({data: {key, value}}) =&gt; {\r\n      const resolve = this.pendingClones_.get(key);\r\n      resolve(value);\r\n      this.pendingClones_.delete(key);\r\n    };\r\n    this.outPort_.start();\r\n  }\r\n\r\n  cloneAsync(value) {\r\n    return new Promise(resolve =&gt; {\r\n      const key = this.nextKey_++;\r\n      this.pendingClones_.set(key, resolve);\r\n      this.inPort_.postMessage({key, value});\r\n    });\r\n  }\r\n}\r\n\r\nconst structuredCloneAsync = window.structuredCloneAsync =\r\n    StructuredCloner.prototype.cloneAsync.bind(new StructuredCloner);\r\n```\r\n\r\n### Example Use:\r\n\r\n```lang-js\r\nconst main = async () =&gt; {\r\n  const original = { date: new Date(), number: Math.random() };\r\n  original.self = original;\r\n\r\n  const clone = await structuredCloneAsync(original);\r\n\r\n  // They&#39;re different objects:\r\n  console.assert(original !== clone);\r\n  console.assert(original.date !== clone.date);\r\n\r\n  // They&#39;re cyclical:\r\n  console.assert(original.self === original);\r\n  console.assert(clone.self === clone);\r\n\r\n  // They contain equivalent values:\r\n  console.assert(original.number === clone.number);\r\n  console.assert(Number(original.date) === Number(clone.date));\r\n  \r\n  console.log(&quot;Assertions complete.&quot;);\r\n};\r\n\r\nmain();\r\n```\r\n\r\n## Synchronous Workarounds: Awful! &#129314;\r\n\r\nThere are no good options for creating structured clones synchronously. Here are a couple of impractical hacks instead.\r\n\r\n`history.pushState()` and `history.replaceState()` both create a structured clone of their first argument, and assign that value to `history.state`. You can use this to create a structured clone of any object like this:\r\n\r\n```lang-js\r\nconst structuredClone = obj =&gt; {\r\n  const oldState = history.state;\r\n  history.replaceState(obj, null);\r\n  const clonedObj = history.state;\r\n  history.replaceState(oldState, null);\r\n  return clonedObj;\r\n};\r\n```\r\n\r\n### Example Use:\r\n\r\n&lt;!-- begin snippet: js hide: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    &#39;use strict&#39;;\r\n\r\n    const main = () =&gt; {\r\n      const original = { date: new Date(), number: Math.random() };\r\n      original.self = original;\r\n    \r\n      const clone = structuredClone(original);\r\n      \r\n      // They&#39;re different objects:\r\n      console.assert(original !== clone);\r\n      console.assert(original.date !== clone.date);\r\n    \r\n      // They&#39;re cyclical:\r\n      console.assert(original.self === original);\r\n      console.assert(clone.self === clone);\r\n    \r\n      // They contain equivalent values:\r\n      console.assert(original.number === clone.number);\r\n      console.assert(Number(original.date) === Number(clone.date));\r\n      \r\n      console.log(&quot;Assertions complete.&quot;);\r\n    };\r\n\r\n    const structuredClone = obj =&gt; {\r\n      const oldState = history.state;\r\n      history.replaceState(obj, null);\r\n      const clonedObj = history.state;\r\n      history.replaceState(oldState, null);\r\n      return clonedObj;\r\n    };\r\n\r\n    main();\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThough synchronous, this can be extremely slow. It incurs all of the overhead associated with manipulating the browser history. Calling this method repeatedly can cause Chrome to become temporarily unresponsive.\r\n\r\nThe [`Notification` constructor](https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification) creates a structured clone of its associated data. It also attempts to display a browser notification to the user, but this will silently fail unless you have requested notification permission. In case you have the permission for other purposes, we&#39;ll immediately close the notification we&#39;ve created.\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const structuredClone = obj =&gt; {\r\n      const n = new Notification(&#39;&#39;, {data: obj, silent: true});\r\n      n.onshow = n.close.bind(n);\r\n      return n.data;\r\n    };\r\n\r\n\r\n### Example Use:\r\n\r\n&lt;!-- begin snippet: js hide: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    &#39;use strict&#39;;\r\n\r\n    const main = () =&gt; {\r\n      const original = { date: new Date(), number: Math.random() };\r\n      original.self = original;\r\n    \r\n      const clone = structuredClone(original);\r\n      \r\n      // They&#39;re different objects:\r\n      console.assert(original !== clone);\r\n      console.assert(original.date !== clone.date);\r\n    \r\n      // They&#39;re cyclical:\r\n      console.assert(original.self === original);\r\n      console.assert(clone.self === clone);\r\n    \r\n      // They contain equivalent values:\r\n      console.assert(original.number === clone.number);\r\n      console.assert(Number(original.date) === Number(clone.date));\r\n      \r\n      console.log(&quot;Assertions complete.&quot;);\r\n    };\r\n\r\n    const structuredClone = obj =&gt; {\r\n      const n = new Notification(&#39;&#39;, {data: obj, silent: true});\r\n      n.close();\r\n      return n.data;\r\n    };\r\n\r\n    main();\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel\r\n  [5]: https://developer.mozilla.org/en/DOM/window.postMessage\r\n"},{"score":21,"body_markdown":"Shallow copy one-liner ([ECMAScript 5th edition][1]):\r\n\r\n    var origin = { foo : {} };\r\n    var copy = Object.keys(origin).reduce(function(c,k){c[k]=origin[k];return c;},{});\r\n\r\n    console.log(origin, copy);\r\n    console.log(origin == copy); // false\r\n    console.log(origin.foo == copy.foo); // true\r\n\r\nAnd shallow copy one-liner ([ECMAScript 6th edition][2], 2015):\r\n\r\n    var origin = { foo : {} };\r\n    var copy = Object.assign({}, origin);\r\n\r\n    console.log(origin, copy);\r\n    console.log(origin == copy); // false\r\n    console.log(origin.foo == copy.foo); // true\r\n\r\n  [1]: https://en.wikipedia.org/wiki/ECMAScript#5th_Edition\r\n  [2]: https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015\r\n\r\n"},{"score":11,"body_markdown":"Here is a comprehensive clone() method that can clone any JavaScript object. It handles almost all the cases:\r\n\r\n    function clone(src, deep) {\r\n\r\n        var toString = Object.prototype.toString;\r\n        if (!src &amp;&amp; typeof src != &quot;object&quot;) {\r\n            // Any non-object (Boolean, String, Number), null, undefined, NaN\r\n            return src;\r\n        }\r\n\r\n        // Honor native/custom clone methods\r\n        if (src.clone &amp;&amp; toString.call(src.clone) == &quot;[object Function]&quot;) {\r\n            return src.clone(deep);\r\n        }\r\n\r\n        // DOM elements\r\n        if (src.nodeType &amp;&amp; toString.call(src.cloneNode) == &quot;[object Function]&quot;) {\r\n            return src.cloneNode(deep);\r\n        }\r\n\r\n        // Date\r\n        if (toString.call(src) == &quot;[object Date]&quot;) {\r\n            return new Date(src.getTime());\r\n        }\r\n\r\n        // RegExp\r\n        if (toString.call(src) == &quot;[object RegExp]&quot;) {\r\n            return new RegExp(src);\r\n        }\r\n\r\n        // Function\r\n        if (toString.call(src) == &quot;[object Function]&quot;) {\r\n\r\n            //Wrap in another method to make sure == is not true;\r\n            //Note: Huge performance issue due to closures, comment this :)\r\n            return (function(){\r\n                src.apply(this, arguments);\r\n            });\r\n        }\r\n\r\n        var ret, index;\r\n        //Array\r\n        if (toString.call(src) == &quot;[object Array]&quot;) {\r\n            //[].slice(0) would soft clone\r\n            ret = src.slice();\r\n            if (deep) {\r\n                index = ret.length;\r\n                while (index--) {\r\n                    ret[index] = clone(ret[index], true);\r\n                }\r\n            }\r\n        }\r\n        //Object\r\n        else {\r\n            ret = src.constructor ? new src.constructor() : {};\r\n            for (var prop in src) {\r\n                ret[prop] = deep\r\n                    ? clone(src[prop], true)\r\n                    : src[prop];\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n\r\n"},{"score":60,"body_markdown":"There’s a [library (called “clone”)](https://github.com/pvorb/node-clone), that does this quite well. It provides the most complete recursive cloning/copying of arbitrary objects that I know of. It also supports circular references, which is not covered by the other answers, yet.\r\n\r\nYou can [find it on npm](https://npmjs.org/package/clone), too. It can be used for the browser as well as Node.js.\r\n\r\nHere is an example on how to use it:\r\n\r\nInstall it with\r\n\r\n    npm install clone\r\n\r\nor package it with [Ender](https://github.com/ender-js/Ender).\r\n\r\n    ender build clone [...]\r\n\r\nYou can also download the source code manually.\r\n\r\nThen you can use it in your source code.\r\n\r\n    var clone = require(&#39;clone&#39;);\r\n    \r\n    var a = { foo: { bar: &#39;baz&#39; } };  // inital value of a\r\n    var b = clone(a);                 // clone a -&gt; b\r\n    a.foo.bar = &#39;foo&#39;;                // change a\r\n    \r\n    console.log(a);                   // { foo: { bar: &#39;foo&#39; } }\r\n    console.log(b);                   // { foo: { bar: &#39;baz&#39; } }\r\n\r\n(Disclaimer: I’m the author of the library.)"},{"score":42,"body_markdown":"Here&#39;s a version of ConroyP&#39;s answer above that works even if the constructor has required parameters:\r\n\r\n\t//If Object.create isn&#39;t already defined, we just do the simple shim,\r\n    //without the second argument, since that&#39;s all we need here\r\n\tvar object_create = Object.create;\r\n\tif (typeof object_create !== &#39;function&#39;) {\r\n\t\tobject_create = function(o) {\r\n\t\t\tfunction F() {}\r\n\t\t\tF.prototype = o;\r\n\t\t\treturn new F();\r\n\t\t};\r\n\t}\r\n\t\r\n    function deepCopy(obj) {\r\n        if(obj == null || typeof(obj) !== &#39;object&#39;){\r\n            return obj;\r\n        }\r\n        //make sure the returned object has the same prototype as the original\r\n        var ret = object_create(obj.constructor.prototype);\r\n        for(var key in obj){\r\n            ret[key] = deepCopy(obj[key]);\r\n        }\r\n        return ret;\r\n    }\r\n\r\nThis function is also available in my [simpleoo][1] library.\r\n\r\n**Edit:**\r\n\r\nHere&#39;s a more robust version (thanks to Justin McCandless this now supports cyclic references as well):\r\n\r\n    /**\r\n     * Deep copy an object (make copies of all its object properties, sub-properties, etc.)\r\n     * An improved version of http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\r\n     * that doesn&#39;t break if the constructor has required parameters\r\n     * \r\n     * It also borrows some code from http://stackoverflow.com/a/11621004/560114\r\n     */ \r\n    function deepCopy(src, /* INTERNAL */ _visited, _copiesVisited) {\r\n        if(src === null || typeof(src) !== &#39;object&#39;){\r\n            return src;\r\n        }\r\n        \r\n        //Honor native/custom clone methods\r\n        if(typeof src.clone == &#39;function&#39;){\r\n            return src.clone(true);\r\n        }\r\n        \r\n        //Special cases:\r\n        //Date\r\n        if(src instanceof Date){\r\n            return new Date(src.getTime());\r\n        }\r\n        //RegExp\r\n        if(src instanceof RegExp){\r\n            return new RegExp(src);\r\n        }\r\n        //DOM Element\r\n        if(src.nodeType &amp;&amp; typeof src.cloneNode == &#39;function&#39;){\r\n            return src.cloneNode(true);\r\n        }\r\n        \r\n        // Initialize the visited objects arrays if needed.\r\n        // This is used to detect cyclic references.\r\n        if (_visited === undefined){\r\n            _visited = [];\r\n            _copiesVisited = [];\r\n        }\r\n        \r\n        // Check if this object has already been visited\r\n        var i, len = _visited.length;\r\n        for (i = 0; i &lt; len; i++) {\r\n            // If so, get the copy we already made\r\n            if (src === _visited[i]) {\r\n                return _copiesVisited[i];\r\n            }\r\n        }\r\n        \r\n        //Array\r\n        if (Object.prototype.toString.call(src) == &#39;[object Array]&#39;) {\r\n            //[].slice() by itself would soft clone\r\n            var ret = src.slice();\r\n            \r\n            //add it to the visited array\r\n            _visited.push(src);\r\n            _copiesVisited.push(ret);\r\n            \r\n            var i = ret.length;\r\n            while (i--) {\r\n                ret[i] = deepCopy(ret[i], _visited, _copiesVisited);\r\n            }\r\n            return ret;\r\n        }\r\n        \r\n        //If we&#39;ve reached here, we have a regular object\r\n        \r\n        //make sure the returned object has the same prototype as the original\r\n        var proto = (Object.getPrototypeOf ? Object.getPrototypeOf(src): src.__proto__);\r\n        if (!proto) {\r\n            proto = src.constructor.prototype; //this line would probably only be reached by very old browsers \r\n        }\r\n        var dest = object_create(proto);\r\n        \r\n        //add this object to the visited array\r\n        _visited.push(src);\r\n        _copiesVisited.push(dest);\r\n        \r\n        for (var key in src) {\r\n            //Note: this does NOT preserve ES5 property attributes like &#39;writable&#39;, &#39;enumerable&#39;, etc.\r\n            //For an example of how this could be modified to do so, see the singleMixin() function\r\n            dest[key] = deepCopy(src[key], _visited, _copiesVisited);\r\n        }\r\n        return dest;\r\n    }\r\n\r\n    //If Object.create isn&#39;t already defined, we just do the simple shim,\r\n    //without the second argument, since that&#39;s all we need here\r\n    var object_create = Object.create;\r\n    if (typeof object_create !== &#39;function&#39;) {\r\n        object_create = function(o) {\r\n            function F() {}\r\n            F.prototype = o;\r\n            return new F();\r\n        };\r\n    }\r\n\r\n  [1]: https://github.com/mbrowne/simpleoo.js"},{"score":15,"body_markdown":"I have two good answers depending on whether your objective is to clone a &quot;plain old JavaScript object&quot; or not.\r\n\r\nLet&#39;s also assume that your intention is to create a complete clone with no prototype references back to the source object. If you&#39;re not interested in a complete clone, then you can use many of the Object.clone() routines provided in some of the other answers (Crockford&#39;s pattern).\r\n\r\nFor plain old JavaScript objects, a tried and true good way to clone an object in modern runtimes is quite simply:\r\n\r\n    var clone = JSON.parse(JSON.stringify(obj));\r\n\r\nNote that the source object must be a pure JSON object. This is to say, all of its nested properties must be scalars (like boolean, string, array, object, etc). Any functions or special objects like RegExp or Date will not be cloned.\r\n\r\nIs it efficient? Heck yes. We&#39;ve tried all kinds of cloning methods and this works best. I&#39;m sure some ninja could conjure up a faster method. But I suspect we&#39;re talking about marginal gains.\r\n\r\nThis approach is just simple and easy to implement. Wrap it into a convenience function and if you really need to squeeze out some gain, go for at a later time.\r\n\r\nNow, for non-plain JavaScript objects, there isn&#39;t a really simple answer.  In fact, there can&#39;t be because of the dynamic nature of JavaScript functions and inner object state. Deep cloning a JSON structure with functions inside requires you recreate those functions and their inner context. And JavaScript simply doesn&#39;t have a standardized way of doing that.\r\n\r\nThe correct way to do this, once again, is via a convenience method that you declare and reuse within your code. The convenience method can be endowed with some understanding of your own objects so you can make sure to properly recreate the graph within the new object.\r\n\r\nWe&#39;re written our own, but the best general approach I&#39;ve seen is covered here:\r\n\r\nhttp://davidwalsh.name/javascript-clone\r\n\r\nThis is the right idea. The author (David Walsh) has commented out the cloning of generalized functions. This is something you might choose to do, depending on your use case.\r\n\r\nThe main idea is that you need to special handle the instantiation of your functions (or prototypal classes, so to speak) on a per-type basis. Here, he&#39;s provided a few examples for RegExp and Date.\r\n\r\nNot only is this code brief, but it&#39;s also very readable. It&#39;s pretty easy to extend.\r\n\r\nIs this efficient? Heck yes. Given that the goal is to produce a true deep-copy clone, then you&#39;re going to have to walk the members of the source object graph. With this approach, you can tweak exactly which child members to treat and how to manually handle custom types.\r\n\r\nSo there you go. Two approaches. Both are efficient in my view.\r\n"},{"score":23,"body_markdown":"Lodash has a nice [_.cloneDeep(value)](http://lodash.com/docs#cloneDeep) method:\r\n\r\n\r\n    var objects = [{ &#39;a&#39;: 1 }, { &#39;b&#39;: 2 }];\r\n     \r\n    var deep = _.cloneDeep(objects);\r\n    console.log(deep[0] === objects[0]);\r\n    // =&gt; false\r\n\r\n"},{"score":4,"body_markdown":"There are a lot of answers, but none of them gave the desired effect I needed.  I wanted to utilize the power of jQuery&#39;s deep copy... However, when it runs into an array, it simply copies the reference to the array and deep copies the items in it.  To get around this, I made a nice little recursive function that will create a new array automatically.  \r\n\r\n(It even checks for kendo.data.ObservableArray if you want it to!  Though, make sure you make sure you call kendo.observable(newItem) if you want the Arrays to be observable again.) \r\n\r\nSo, to fully copy an existing item, you just do this:\r\n\r\n    var newItem = jQuery.extend(true, {}, oldItem);\r\n    createNewArrays(newItem);\r\n    \r\n    \r\n    function createNewArrays(obj) {\r\n        for (var prop in obj) {\r\n            if ((kendo != null &amp;&amp; obj[prop] instanceof kendo.data.ObservableArray) || obj[prop] instanceof Array) {\r\n                var copy = [];\r\n                $.each(obj[prop], function (i, item) {\r\n                    var newChild = $.extend(true, {}, item);\r\n                    createNewArrays(newChild);\r\n                    copy.push(newChild);\r\n                });\r\n                obj[prop] = copy;\r\n            }\r\n        }\r\n    }"},{"score":5,"body_markdown":"I usually use `var newObj = JSON.parse( JSON.stringify(oldObje) );` but, here&#39;s a more proper way:\r\n\r\n    var o = {};\r\n\r\n    var oo = Object.create(o);\r\n\r\n    (o === oo); // =&gt; false\r\n\r\nWatch legacy browsers!\r\n\r\n"},{"score":3,"body_markdown":"This is my version of object cloner. This is a stand-alone version of the jQuery method, with only few tweaks and adjustments. Check out the [fiddle][1]. I&#39;ve used a lot of jQuery until the day I realized that I&#39;d use only this function most of the time x_x.\r\n\r\nThe usage is the same as described into the jQuery API:\r\n\r\n - Non-deep clone: `extend(object_dest, object_source);`\r\n - Deep clone: `extend(true, object_dest, object_source);`\r\n\r\nOne extra function is used to define if object is proper to be cloned.\r\n\r\n    /**\r\n     * This is a quasi clone of jQuery&#39;s extend() function.\r\n     * by Romain WEEGER for wJs library - www.wexample.com\r\n     * @returns {*|{}}\r\n     */\r\n    function extend() {\r\n        // Make a copy of arguments to avoid JavaScript inspector hints.\r\n        var to_add, name, copy_is_array, clone,\r\n\r\n        // The target object who receive parameters\r\n        // form other objects.\r\n        target = arguments[0] || {},\r\n\r\n        // Index of first argument to mix to target.\r\n        i = 1,\r\n\r\n        // Mix target with all function arguments.\r\n        length = arguments.length,\r\n\r\n        // Define if we merge object recursively.\r\n        deep = false;\r\n\r\n        // Handle a deep copy situation.\r\n        if (typeof target === &#39;boolean&#39;) {\r\n            deep = target;\r\n\r\n            // Skip the boolean and the target.\r\n            target = arguments[ i ] || {};\r\n\r\n            // Use next object as first added.\r\n            i++;\r\n        }\r\n\r\n        // Handle case when target is a string or something (possible in deep copy)\r\n        if (typeof target !== &#39;object&#39; &amp;&amp; typeof target !== &#39;function&#39;) {\r\n            target = {};\r\n        }\r\n\r\n        // Loop trough arguments.\r\n        for (false; i &lt; length; i += 1) {\r\n\r\n            // Only deal with non-null/undefined values\r\n            if ((to_add = arguments[ i ]) !== null) {\r\n\r\n                // Extend the base object.\r\n                for (name in to_add) {\r\n\r\n                    // We do not wrap for loop into hasOwnProperty,\r\n                    // to access to all values of object.\r\n                    // Prevent never-ending loop.\r\n                    if (target === to_add[name]) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Recurse if we&#39;re merging plain objects or arrays.\r\n                    if (deep &amp;&amp; to_add[name] &amp;&amp; (is_plain_object(to_add[name]) || (copy_is_array = Array.isArray(to_add[name])))) {\r\n                        if (copy_is_array) {\r\n                            copy_is_array = false;\r\n                            clone = target[name] &amp;&amp; Array.isArray(target[name]) ? target[name] : [];\r\n                        }\r\n                        else {\r\n                            clone = target[name] &amp;&amp; is_plain_object(target[name]) ? target[name] : {};\r\n                        }\r\n\r\n                        // Never move original objects, clone them.\r\n                        target[name] = extend(deep, clone, to_add[name]);\r\n                    }\r\n\r\n                    // Don&#39;t bring in undefined values.\r\n                    else if (to_add[name] !== undefined) {\r\n                        target[name] = to_add[name];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * Check to see if an object is a plain object\r\n     * (created using &quot;{}&quot; or &quot;new Object&quot;).\r\n     * Forked from jQuery.\r\n     * @param obj\r\n     * @returns {boolean}\r\n     */\r\n    function is_plain_object(obj) {\r\n        // Not plain objects:\r\n        // - Any object or value whose internal [[Class]] property is not &quot;[object Object]&quot;\r\n        // - DOM nodes\r\n        // - window\r\n        if (obj === null || typeof obj !== &quot;object&quot; || obj.nodeType || (obj !== null &amp;&amp; obj === obj.window)) {\r\n            return false;\r\n        }\r\n        // Support: Firefox &lt;20\r\n        // The try/catch suppresses exceptions thrown when attempting to access\r\n        // the &quot;constructor&quot; property of certain host objects, i.e. |window.location|\r\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=814622\r\n        try {\r\n            if (obj.constructor &amp;&amp; !this.hasOwnProperty.call(obj.constructor.prototype, &quot;isPrototypeOf&quot;)) {\r\n                return false;\r\n            }\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n\r\n        // If the function hasn&#39;t returned already, we&#39;re confident that\r\n        // |obj| is a plain object, created by {} or constructed with new Object\r\n        return true;\r\n    }\r\n\r\n  [1]: http://jsfiddle.net/eyYJB/\r\n"},{"score":4,"body_markdown":"For future reference, the current draft of [ECMAScript 6][1] introduces [Object.assign][2] as a way of cloning objects. Example code would be:\r\n\r\n    var obj1 = { a: true, b: 1 };\r\n    var obj2 = Object.assign(obj1);\r\n    console.log(obj2); // { a: true, b: 1 }\r\n\r\nAt the time of writing [support is limited to Firefox 34 in browsers][3] so it’s not usable in production code just yet (unless you’re writing a Firefox extension of course).\r\n\r\n  [1]: https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015\r\n  [2]: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign\r\n  [3]: http://kangax.github.io/compat-table/es6/#Object.assign\r\n\r\n"},{"score":81,"body_markdown":"**Deep copy by performance:**\r\nRanked from best to worst\r\n\r\n- Reassignment &quot;=&quot; (string arrays, number arrays - only)\r\n- Slice (string arrays, number arrays - only)\r\n- Concatenation (string arrays, number arrays - only)\r\n- Custom function: for-loop or recursive copy\r\n- jQuery&#39;s $.extend\r\n- JSON.parse (string arrays, number arrays, object arrays - only)\r\n- [Underscore.js][1]&#39;s _.clone (string arrays, number arrays - only)\r\n- Lo-Dash&#39;s _.cloneDeep\r\n\r\n**Deep copy an array of strings or numbers (one level - no reference pointers):**\r\n\r\nWhen an array contains numbers and strings - functions like .slice(), .concat(), .splice(), the assignment operator &quot;=&quot;, and Underscore.js&#39;s clone function; will make a deep copy of the array&#39;s elements.\r\n\r\nWhere reassignment has the fastest performance:\r\n\r\n    var arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\r\n    var arr2 = arr1;\r\n    arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\r\n\r\nAnd .slice() has better performance than .concat(),\r\nhttp://jsperf.com/duplicate-array-slice-vs-concat/3\r\n\r\n    var arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];  // Becomes arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\r\n    var arr2a = arr1.slice(0);   // Becomes arr2a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] - deep copy\r\n    var arr2b = arr1.concat();   // Becomes arr2b = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] - deep copy\r\n\r\n**Deep copy an array of objects (two or more levels - reference pointers):**\r\n\r\n    var arr1 = [{object:&#39;a&#39;}, {object:&#39;b&#39;}];\r\n\r\nWrite a custom function (has faster performance than $.extend() or JSON.parse):\r\n\r\n    function copy(o) {\r\n       var out, v, key;\r\n       out = Array.isArray(o) ? [] : {};\r\n       for (key in o) {\r\n           v = o[key];\r\n           out[key] = (typeof v === &quot;object&quot; &amp;&amp; v !== null) ? copy(v) : v;\r\n       }\r\n       return out;\r\n    }\r\n\r\n    copy(arr1);\r\n\r\nUse third-party utility functions:\r\n\r\n    $.extend(true, [], arr1); // Jquery Extend\r\n    JSON.parse(arr1);\r\n    _.cloneDeep(arr1); // Lo-dash\r\n\r\nWhere jQuery&#39;s $.extend has better performance:\r\n\r\n * http://jsperf.com/js-deep-copy/2\r\n * http://jsperf.com/jquery-extend-vs-json-parse/2\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Underscore.js\r\n\r\n\r\n"},{"score":3,"body_markdown":"Use `Object.create()` to get the `prototype` and support for `instanceof`, and use a `for()` loop to get enumerable keys:\r\n\r\n    function cloneObject(source) {\r\n    \tvar key,value;\r\n    \tvar clone = Object.create(source);\r\n    \t\r\n    \tfor (key in source) {\r\n    \t\tif (source.hasOwnProperty(key) === true) {\r\n    \t\t\tvalue = source[key];\r\n    \t\t\t\r\n    \t\t\tif (value!==null &amp;&amp; typeof value===&quot;object&quot;) {\r\n    \t\t\t\tclone[key] = cloneObject(value);\r\n    \t\t\t} else {\r\n    \t\t\t\tclone[key] = value;\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \t\r\n    \treturn clone;\r\n    }"},{"score":2,"body_markdown":"Requires new-ish browsers, but...\r\n\r\nLet&#39;s extend the native Object and get a **real** `.extend()`;\r\n\r\n    Object.defineProperty(Object.prototype, &#39;extend&#39;, {\r\n        enumerable: false,\r\n        value: function(){\r\n            var that = this;\r\n\r\n            Array.prototype.slice.call(arguments).map(function(source){\r\n                var props = Object.getOwnPropertyNames(source),\r\n                    i = 0, l = props.length,\r\n                    prop;\r\n\r\n                for(; i &lt; l; ++i){\r\n                    prop = props[i];\r\n\r\n                    if(that.hasOwnProperty(prop) &amp;&amp; typeof(that[prop]) === &#39;object&#39;){\r\n                        that[prop] = that[prop].extend(source[prop]);\r\n                    }else{\r\n                        Object.defineProperty(that, prop, Object.getOwnPropertyDescriptor(source, prop));\r\n                    }\r\n                }\r\n            });\r\n\r\n            return this;\r\n        }\r\n    });\r\n\r\nJust pop that in prior to any code that uses .extend() on an object.\r\n\r\nExample:\r\n\r\n    var obj1 = {\r\n        node1: &#39;1&#39;,\r\n        node2: &#39;2&#39;,\r\n        node3: 3\r\n    };\r\n\r\n    var obj2 = {\r\n        node1: &#39;4&#39;,\r\n        node2: 5,\r\n        node3: &#39;6&#39;\r\n    };\r\n\r\n    var obj3 = ({}).extend(obj1, obj2);\r\n\r\n    console.log(obj3);\r\n    // Object {node1: &quot;4&quot;, node2: 5, node3: &quot;6&quot;}"},{"score":30,"body_markdown":"The following creates two instances of the same object. I found it and am using it currently. It&#39;s simple and easy to use.\r\n\r\n    var objToCreate = JSON.parse(JSON.stringify(cloneThis));\r\n"},{"score":11,"body_markdown":"Only when you can use [ECMAScript 6][1] or [transpilers][2].\r\n\r\nFeatures:\r\n\r\n - Won&#39;t trigger getter/setter while copying.\r\n - Preserves getter/setter.\r\n - Preserves prototype informations.\r\n - Works with both **object-literal** and **functional** [OO][3] writing styles.\r\n\r\nCode:\r\n\r\n    function clone(target, source){\r\n\r\n        for(let key in source){\r\n\r\n            // Use getOwnPropertyDescriptor instead of source[key] to prevent from trigering setter/getter.\r\n            let descriptor = Object.getOwnPropertyDescriptor(source, key);\r\n            if(descriptor.value instanceof String){\r\n                target[key] = new String(descriptor.value);\r\n            }\r\n            else if(descriptor.value instanceof Array){\r\n                target[key] = clone([], descriptor.value);\r\n            }\r\n            else if(descriptor.value instanceof Object){\r\n                let prototype = Reflect.getPrototypeOf(descriptor.value);\r\n                let cloneObject = clone({}, descriptor.value);\r\n                Reflect.setPrototypeOf(cloneObject, prototype);\r\n                target[key] = cloneObject;\r\n            }\r\n            else {\r\n                Object.defineProperty(target, key, descriptor);\r\n            }\r\n        }\r\n        let prototype = Reflect.getPrototypeOf(source);\r\n        Reflect.setPrototypeOf(target, prototype);\r\n        return target;\r\n    }\r\n\r\n  [1]: https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015\r\n  [2]: https://en.wikipedia.org/wiki/Source-to-source_compiler\r\n  [3]: https://en.wikipedia.org/wiki/Object-oriented_programming\r\n"},{"score":10,"body_markdown":"For the people who want to use the `JSON.parse(JSON.stringify(obj))` version, but without losing the Date objects, you can use the [second argument of `parse` method][1] to convert the strings back to Date:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function clone(obj) {\r\n      var regExp = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;\r\n      return JSON.parse(JSON.stringify(obj), function(k, v) {\r\n        if (typeof v === &#39;string&#39; &amp;&amp; regExp.test(v))\r\n          return new Date(v)\r\n        return v;\r\n      })\r\n    }\r\n\r\n    // usage:\r\n    var original = {\r\n     a: [1, null, undefined, 0, {a:null}, new Date()],\r\n     b: {\r\n       c(){ return 0 }\r\n     }\r\n    }\r\n\r\n    var cloned = clone(original)\r\n\r\n    console.log(cloned)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter\r\n"},{"score":155,"body_markdown":"# The efficient way to clone(not deep-clone) an object in one line of code\n\nAn [`Object.assign`][1] method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.\n\n    var clone = Object.assign({}, obj);\n\n&gt;The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.\n\n[Read more...](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n\nThe __polyfill__ to support older browsers:\n\n    if (!Object.assign) {\n      Object.defineProperty(Object, &#39;assign&#39;, {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function(target) {\n          &#39;use strict&#39;;\n          if (target === undefined || target === null) {\n            throw new TypeError(&#39;Cannot convert first argument to object&#39;);\n          }\n    \n          var to = Object(target);\n          for (var i = 1; i &lt; arguments.length; i++) {\n            var nextSource = arguments[i];\n            if (nextSource === undefined || nextSource === null) {\n              continue;\n            }\n            nextSource = Object(nextSource);\n    \n            var keysArray = Object.keys(nextSource);\n            for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) {\n              var nextKey = keysArray[nextIndex];\n              var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n              if (desc !== undefined &amp;&amp; desc.enumerable) {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n          return to;\n        }\n      });\n    }\n\n\n  [1]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"},{"score":3,"body_markdown":"As recursion is just too expensive for JavaScript, and most answers I have found are using recursion, while JSON approach will skip the non-JSON-convertible parts (Function, etc.). So I did a little research and found this trampoline technique to avoid it. Here&#39;s the code:\r\n\r\n    /*\r\n     * Trampoline to avoid recursion in JavaScript, see:\r\n     *     http://www.integralist.co.uk/posts/js-recursion.html\r\n     */\r\n    function trampoline() {\r\n        var func = arguments[0];\r\n        var args = [];\r\n        for (var i = 1; i &lt; arguments.length; i++) {\r\n            args[i - 1] = arguments[i];\r\n        }\r\n\r\n        var currentBatch = func.apply(this, args);\r\n        var nextBatch = [];\r\n\r\n        while (currentBatch &amp;&amp; currentBatch.length &gt; 0) {\r\n            currentBatch.forEach(function(eachFunc) {\r\n                var ret = eachFunc();\r\n                if (ret &amp;&amp; ret.length &gt; 0) {\r\n                    nextBatch = nextBatch.concat(ret);\r\n                }\r\n            });\r\n\r\n            currentBatch = nextBatch;\r\n            nextBatch = [];\r\n        }\r\n    };\r\n\r\n    /*\r\n     *  Deep clone an object using the trampoline technique.\r\n     *\r\n     *  @param target {Object} Object to clone\r\n     *  @return {Object} Cloned object.\r\n     */\r\n    function clone(target) {\r\n        if (typeof target !== &#39;object&#39;) {\r\n            return target;\r\n        }\r\n        if (target == null || Object.keys(target).length == 0) {\r\n            return target;\r\n        }\r\n\r\n        function _clone(b, a) {\r\n            var nextBatch = [];\r\n            for (var key in b) {\r\n                if (typeof b[key] === &#39;object&#39; &amp;&amp; b[key] !== null) {\r\n                    if (b[key] instanceof Array) {\r\n                        a[key] = [];\r\n                    }\r\n                    else {\r\n                        a[key] = {};\r\n                    }\r\n                    nextBatch.push(_clone.bind(null, b[key], a[key]));\r\n                }\r\n                else {\r\n                    a[key] = b[key];\r\n                }\r\n            }\r\n            return nextBatch;\r\n        };\r\n\r\n        var ret = target instanceof Array ? [] : {};\r\n        (trampoline.bind(null, _clone))(target, ret);\r\n        return ret;\r\n    };\r\n\r\nAlso see this gist:\r\n   https://gist.github.com/SeanOceanHu/7594cafbfab682f790eb\r\n"},{"score":3,"body_markdown":"**Cloning an object using today&#39;s JavaScript: [ECMAScript 2015][1]** (formerly known as ECMAScript&amp;nbsp;6)\r\n\r\n    var original = {a: 1};\r\n    \r\n    // Method 1: New object with original assigned.\r\n    var copy1 = Object.assign({}, original);\r\n    \r\n    // Method 2: New object with spread operator assignment.\r\n    var copy2 = {...original};\r\n\r\nOld browsers may not support ECMAScript 2015. A common solution is to use a JavaScript-to-JavaScript compiler like Babel to output an [ECMAScript 5][2] version of your JavaScript code.\r\n\r\nAs [pointed out by @jim-hall][3], **this is only a shallow copy**. Properties of properties are copied as a reference: changing one would change the value in the other object/instance.\r\n\r\n  [1]: https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015\r\n  [2]: https://en.wikipedia.org/wiki/ECMAScript#5th_Edition\r\n  [3]: https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-clone-an-object-in-javascript?page=2&amp;tab=oldest#comment60081951_36177142\r\n\r\n\r\n\r\n"},{"score":17,"body_markdown":"Just because I didn&#39;t see [AngularJS](http://en.wikipedia.org/wiki/AngularJS) mentioned and thought that people might want to know...\r\n\r\n[`angular.copy`](https://docs.angularjs.org/api/ng/function/angular.copy) also provides a method of deep copying objects and arrays."},{"score":5,"body_markdown":"Single-line ECMAScript 6 solution (special object types like Date/Regex not handled):\r\n\r\n    \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const clone = (o) =&gt;\r\n      typeof o === &#39;object&#39; &amp;&amp; o !== null ?      // only clone objects\r\n      (Array.isArray(o) ?                        // if cloning an array\r\n        o.map(e =&gt; clone(e)) :                   // clone each of its elements\r\n        Object.keys(o).reduce(                   // otherwise reduce every key in the object\r\n          (r, k) =&gt; (r[k] = clone(o[k]), r), {}  // and save its cloned value into a new object\r\n        )\r\n      ) :\r\n      o;                                         // return non-objects as is\r\n\r\n    var x = {\r\n      nested: {\r\n        name: &#39;test&#39;\r\n      }\r\n    };\r\n\r\n    var y = clone(x);\r\n\r\n    console.log(x.nested !== y.nested);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":6,"body_markdown":"I use the npm clone library.  Apparently it also works in the browser.\r\n\r\nhttps://www.npmjs.com/package/clone\r\n\r\n    let a = clone(b)"},{"score":11,"body_markdown":"## AngularJS\r\n\r\nWell if you&#39;re using angular you could do this too\r\n\r\n    var newObject = angular.copy(oldObject);"},{"score":1,"body_markdown":"This is a solution with recursion:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    obj = {\r\n      a: { b: { c: { d: [&#39;1&#39;, &#39;2&#39;] } } },\r\n      e: &#39;Saeid&#39;\r\n    }\r\n    const Clone = function (obj) {\r\n      \r\n      const container = Array.isArray(obj) ? [] : {}\r\n      const keys  = Object.keys(obj)\r\n       \r\n      for (let i = 0; i &lt; keys.length; i++) {\r\n        const key = keys[i]\r\n        if(typeof obj[key] == &#39;object&#39;) {\r\n          container[key] = Clone(obj[key])\r\n        }\r\n        else\r\n          container[key] = obj[key].slice()\r\n      }\r\n      \r\n      return container\r\n    }\r\n     console.log(Clone(obj))\r\n\r\n&lt;!-- end snippet --&gt;"},{"score":2,"body_markdown":"For future reference, one can use this code\r\n\r\nES6:\r\n\r\n    _clone: function(obj){\r\n\t\tlet newObj = {};\r\n\t\tfor(let i in obj){\r\n\t\t\tif(typeof(obj[i]) === &#39;object&#39; &amp;&amp; Object.keys(obj[i]).length){\r\n\t\t\t\tnewObj[i] = clone(obj[i]);\r\n\t\t\t} else{\r\n\t\t\t\tnewObj[i] = obj[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Object.assign({},newObj);\r\n\t}\r\n\r\nES5:\r\n\r\n    function clone(obj){\r\n\tlet newObj = {};\r\n\tfor(let i in obj){\r\n\t\tif(typeof(obj[i]) === &#39;object&#39; &amp;&amp; Object.keys(obj[i]).length){\r\n\t\t\tnewObj[i] = clone(obj[i]);\r\n\t\t} else{\r\n\t\t\tnewObj[i] = obj[i];\r\n\t\t}\r\n\t}\r\n\treturn Object.assign({},newObj);\r\n}\r\n\r\nE.g \r\n\r\n    var obj ={a:{b:1,c:3},d:4,e:{f:6}}\r\n    var xc = clone(obj);\r\n    console.log(obj); //{a:{b:1,c:3},d:4,e:{f:6}}\r\n    console.log(xc); //{a:{b:1,c:3},d:4,e:{f:6}}\r\n    \r\n    xc.a.b = 90;\r\n    console.log(obj); //{a:{b:1,c:3},d:4,e:{f:6}}\r\n    console.log(xc); //{a:{b:90,c:3},d:4,e:{f:6}}"},{"score":2,"body_markdown":"  \r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    class Handler {\r\n      static deepCopy (obj) {\r\n        if (Object.prototype.toString.call(obj) === &#39;[object Array]&#39;) {\r\n          const result = [];\r\n          \r\n          for (let i = 0, len = obj.length; i &lt; len; i++) {\r\n            result[i] = Handler.deepCopy(obj[i]);\r\n          }\r\n          return result;\r\n        } else if (Object.prototype.toString.call(obj) === &#39;[object Object]&#39;) {\r\n          const result = {};\r\n          for (let prop in obj) {\r\n            result[prop] = Handler.deepCopy(obj[prop]);\r\n          }\r\n          return result;\r\n        }\r\n        return obj;\r\n      }\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":57,"body_markdown":"`Cloning` an Object was always a concern in JS, but it was all about before ES6, I list different ways of copying an object in JavaScript below, imagine you have the Object below and would like to have a deep copy of that:\r\n\r\n    var obj = {a:1, b:2, c:3, d:4};\r\n\r\nThere are few ways to copy this object, without changing the origin:\r\n\r\n1) ES5+, Using a simple function to do the copy for you:\r\n\r\n    function deepCopyObj(obj) {\r\n        if (null == obj || &quot;object&quot; != typeof obj) return obj;\r\n        if (obj instanceof Date) {\r\n            var copy = new Date();\r\n            copy.setTime(obj.getTime());\r\n            return copy;\r\n        }\r\n        if (obj instanceof Array) {\r\n            var copy = [];\r\n            for (var i = 0, len = obj.length; i &lt; len; i++) {\r\n                copy[i] = cloneSO(obj[i]);\r\n            }\r\n            return copy;\r\n        }\r\n        if (obj instanceof Object) {\r\n            var copy = {};\r\n            for (var attr in obj) {\r\n                if (obj.hasOwnProperty(attr)) copy[attr] = cloneSO(obj[attr]);\r\n            }\r\n            return copy;\r\n        }\r\n        throw new Error(&quot;Unable to copy obj this object.&quot;);\r\n    }\r\n\r\n2) ES5+, using JSON.parse and JSON.stringify.\r\n\r\n    var  deepCopyObj = JSON.parse(JSON.stringify(obj));\r\n\r\n\r\n3) AngularJs: \r\n\r\n    var  deepCopyObj = angular.copy(obj);\r\n\r\n\r\n4) jQuery: \r\n\r\n    var deepCopyObj = jQuery.extend(true, {}, obj);\r\n\r\n5) UnderscoreJs &amp; Loadash: \r\n\r\n    var deepCopyObj = _.cloneDeep(obj); //latest version UndescoreJs makes shallow copy\r\n\r\nHope these help... \r\n"},{"score":2,"body_markdown":"Without touching the prototypical inheritance you may deep lone objects and arrays as follows;\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function objectClone(o){\r\n      var ot = Array.isArray(o);\r\n      return o !== null &amp;&amp; typeof o === &quot;object&quot; ? Object.keys(o)\r\n                                                         .reduce((r,k) =&gt; o[k] !== null &amp;&amp; typeof o[k] === &quot;object&quot; ? (r[k] = objectClone(o[k]),r)\r\n                                                                                                                    : (r[k] = o[k],r), ot ? [] : {})\r\n                                                 : o;\r\n    }\r\n    var obj = {a: 1, b: {c: 2, d: {e: 3, f: {g: 4, h: null}}}},\r\n        arr = [1,2,[3,4,[5,6,[7]]]],\r\n        nil = null,\r\n      clobj = objectClone(obj),\r\n      clarr = objectClone(arr),\r\n      clnil = objectClone(nil);\r\n    console.log(clobj, obj === clobj);\r\n    console.log(clarr, arr === clarr);\r\n    console.log(clnil, nil === clnil);\r\n    clarr[2][2][2] = &quot;seven&quot;;\r\n    console.log(arr, clarr);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":5,"body_markdown":"Lodash has a function that handles that for you like so.\r\n\r\n    var foo = {a: &#39;a&#39;, b: {c:&#39;d&#39;, e: {f: &#39;g&#39;}}};\r\n\r\n    var bar = _.cloneDeep(foo);\r\n    // bar = {a: &#39;a&#39;, b: {c:&#39;d&#39;, e: {f: &#39;g&#39;}}} \r\n\r\nRead the docs [here][1].\r\n\r\n\r\n  [1]: https://lodash.com/docs/#cloneDeep"},{"score":12,"body_markdown":"I disagree with the answer with the greatest votes [here][1]. A **Recursive Deep Clone** is **much faster** than the *JSON.parse(JSON.stringify(obj))* approach mentioned. \r\n\r\n - **Jsperf** ranks it number one here: https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5\r\n - **Jsben** from the answer above updated to show that a recursive deep clone beats all the others mentioned: http://jsben.ch/13YKQ\r\n\r\nAnd here&#39;s the function for quick reference:\r\n\r\n    function cloneDeep (o) {\r\n      let newO\r\n      let i\r\n    \r\n      if (typeof o !== &#39;object&#39;) return o\r\n    \r\n      if (!o) return o\r\n    \r\n      if (Object.prototype.toString.apply(o) === &#39;[object Array]&#39;) {\r\n        newO = []\r\n        for (i = 0; i &lt; o.length; i += 1) {\r\n          newO[i] = cloneDeep(o[i])\r\n        }\r\n        return newO\r\n      }\r\n    \r\n      newO = {}\r\n      for (i in o) {\r\n        if (o.hasOwnProperty(i)) {\r\n          newO[i] = cloneDeep(o[i])\r\n        }\r\n      }\r\n      return newO\r\n    }\r\n\r\n  [1]: https://stackoverflow.com/a/5344074/1110941\r\n"},{"score":1,"body_markdown":"As this question is having lot of attention and answers with reference to inbuilt features such as Object.assign or custom code to deep clone, i would like to share some libraries to deep clone, \r\n\r\n**1. esclone**\r\n\r\nnpm install --savedev esclone https://www.npmjs.com/package/esclone\r\n\r\nExample use in ES6:\r\n\r\n    import esclone from &quot;esclone&quot;;\r\n\r\n    const rockysGrandFather = {\r\n      name: &quot;Rockys grand father&quot;,\r\n      father: &quot;Don&#39;t know :(&quot;\r\n    };\r\n    const rockysFather = {\r\n      name: &quot;Rockys Father&quot;,\r\n      father: rockysGrandFather\r\n    };\r\n    \r\n    const rocky = {\r\n      name: &quot;Rocky&quot;,\r\n      father: rockysFather\r\n    };\r\n    \r\n    const rockyClone = esclone(rocky);\r\n\r\nExample use in ES5:\r\n\r\n    var esclone = require(&quot;esclone&quot;)\r\n    var foo = new String(&quot;abcd&quot;)\r\n    var fooClone = esclone.default(foo)\r\n    console.log(fooClone)\r\n    console.log(foo === fooClone)\r\n\r\n **2. deep copy**\r\n\r\nnpm install deep-copy\r\nhttps://www.npmjs.com/package/deep-copy\r\n\r\nExample:\r\n\r\n    var dcopy = require(&#39;deep-copy&#39;)\r\n     \r\n    // deep copy object \r\n    var copy = dcopy({a: {b: [{c: 5}]}})\r\n     \r\n    // deep copy array \r\n    var copy = dcopy([1, 2, {a: {b: 5}}])\r\n\r\n**3. clone-deep**\r\n\r\n$ npm install --save clone-deep\r\nhttps://www.npmjs.com/package/clone-deep\r\n\r\nExample:\r\n\r\n    var cloneDeep = require(&#39;clone-deep&#39;);\r\n     \r\n    var obj = {a: &#39;b&#39;};\r\n    var arr = [obj];\r\n     \r\n    var copy = cloneDeep(arr);\r\n    obj.c = &#39;d&#39;;\r\n     \r\n    console.log(copy);\r\n    //=&gt; [{a: &#39;b&#39;}] \r\n     \r\n    console.log(arr);\r\n\r\n"},{"score":5,"body_markdown":"There are so many ways to achieve this, but if you want to do this without any library, you can use the following:\r\n\r\n    const cloneObject = (oldObject) =&gt; {\r\n      let newObject = oldObject;\r\n      if (oldObject &amp;&amp; typeof oldObject === &#39;object&#39;) {\r\n        if(Array.isArray(oldObject)) {\r\n          newObject = [];\r\n        } else if (Object.prototype.toString.call(oldObject) === &#39;[object Date]&#39; &amp;&amp; !isNaN(oldObject)) {\r\n          newObject = new Date(oldObject.getTime());\r\n        } else {\r\n          newObject = {};\r\n          for (let i in oldObject) {\r\n            newObject[i] = cloneObject(oldObject[i]);\r\n          }\r\n        }\r\n    \r\n      }\r\n      return newObject;\r\n    }\r\n\r\nLet me know what you think."},{"score":7,"body_markdown":"I am late to answer this question, but I have an another way of cloning the object:\r\n\r\n       function cloneObject(obj) {\r\n            if (obj === null || typeof(obj) !== &#39;object&#39;)\r\n                return obj;\r\n            var temp = obj.constructor(); // changed\r\n            for (var key in obj) {\r\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n                    obj[&#39;isActiveClone&#39;] = null;\r\n                    temp[key] = cloneObject(obj[key]);\r\n                    delete obj[&#39;isActiveClone&#39;];\r\n                }\r\n            }\r\n            return temp;\r\n        }\r\n\r\n\r\n\r\n    var b = cloneObject({&quot;a&quot;:1,&quot;b&quot;:2});   // calling\r\nwhich is much better and faster then:\r\n\r\n    var a = {&quot;a&quot;:1,&quot;b&quot;:2};\r\n    var b = JSON.parse(JSON.stringify(a));  \r\n\r\nand\r\n\r\n\r\n    var a = {&quot;a&quot;:1,&quot;b&quot;:2};\r\n\r\n    // Deep copy\r\n    var newObject = jQuery.extend(true, {}, a);\r\nI have bench-marked the code and you can test the results [here][1]:\r\n\r\nand sharing the results:\r\n[![enter image description here][2]][2]\r\nReferences: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\r\n\r\n\r\n  [1]: http://jsben.ch/vyEky\r\n  [2]: https://i.stack.imgur.com/K8ztO.png"},{"score":4,"body_markdown":"Here is my way of deep cloning a object with `ES2015` default value and spread operator\r\n\r\n     const makeDeepCopy = (obj, copy = {}) =&gt; {\r\n      for (let item in obj) {\r\n        if (typeof obj[item] === &#39;object&#39;) {\r\n          makeDeepCopy(obj[item], copy)\r\n        }\r\n        if (obj.hasOwnProperty(item)) {\r\n          copy = {\r\n            ...obj\r\n          }\r\n        }\r\n      }\r\n      return copy\r\n    }\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const testObj = {\r\n      &quot;type&quot;: &quot;object&quot;,\r\n      &quot;properties&quot;: {\r\n        &quot;userId&quot;: {\r\n          &quot;type&quot;: &quot;string&quot;,\r\n          &quot;chance&quot;: &quot;guid&quot;\r\n        },\r\n        &quot;emailAddr&quot;: {\r\n          &quot;type&quot;: &quot;string&quot;,\r\n          &quot;chance&quot;: {\r\n            &quot;email&quot;: {\r\n              &quot;domain&quot;: &quot;fake.com&quot;\r\n            }\r\n          },\r\n          &quot;pattern&quot;: &quot;.+@fake.com&quot;\r\n        }\r\n      },\r\n      &quot;required&quot;: [\r\n        &quot;userId&quot;,\r\n        &quot;emailAddr&quot;\r\n      ]\r\n    }\r\n\r\n    const makeDeepCopy = (obj, copy = {}) =&gt; {\r\n      for (let item in obj) {\r\n        if (typeof obj[item] === &#39;object&#39;) {\r\n          makeDeepCopy(obj[item], copy)\r\n        }\r\n        if (obj.hasOwnProperty(item)) {\r\n          copy = {\r\n            ...obj\r\n          }\r\n        }\r\n      }\r\n      return copy\r\n    }\r\n\r\n    console.log(makeDeepCopy(testObj))\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":3,"body_markdown":"What about asynchronous object cloning done by a `Promise`?\r\n\r\n    async function clone(thingy /**/)\r\n    {\r\n        if(thingy instanceof Promise)\r\n        {\r\n            throw Error(&quot;This function cannot clone Promises.&quot;);\r\n        }\r\n        return thingy;\r\n    }"},{"score":3,"body_markdown":"Looking through this long list of answers nearly all the solutions have been covered except one that I am aware of. This is the list of VANILLA JS ways of deep cloning an object.\r\n\r\n1. JSON.parse(JSON.stringify( obj ) );\r\n\r\n2. Through history.state with pushState or replaceState\r\n\r\n3. Web Notifications API but this has the downside of asking the user for permissions.\r\n\r\n4. Doing your own recursive loop through the object to copy each level.\r\n\r\n5. The answer I didn&#39;t see -&gt; Using ServiceWorkers. The messages (objects) passed back and forth between the page and the ServiceWorker script will be deep clones of any object.\r\n"},{"score":6,"body_markdown":"ES 2017 example:\r\n\r\n    let objectToCopy = someObj;\r\n    let copyOfObject = {};\r\n    Object.defineProperties(copyOfObject, Object.getOwnPropertyDescriptors(objectToCopy));\r\n    // copyOfObject will now be the same as objectToCopy\r\n    "},{"score":5,"body_markdown":"In my experience, a recursive version vastly outperforms `JSON.parse(JSON.stringify(obj))`. Here is a modernized recursive deep object copy function which can fit on a single line:\r\n\r\n    function deepCopy(obj) {\r\n      return Object.keys(obj).reduce((v, d) =&gt; Object.assign(v, {\r\n        [d]: (obj[d].constructor === Object) ? deepCopy(obj[d]) : obj[d]\r\n      }), {});\r\n    }\r\n\r\nThis is performing around [40 times faster](https://www.measurethat.net/Benchmarks/ShowResult/25487) than the `JSON.parse...` method."},{"score":3,"body_markdown":"For a shallow copy there is a great, simple method introduced in ECMAScript2018 standard. It involves the use of *Spread Operator* :\r\n\r\n\r\n\r\n\r\n    let obj = {a : &quot;foo&quot;, b:&quot;bar&quot; , c:10 , d:true , e:[1,2,3] };\r\n\r\n    let objClone = { ...obj };\r\n\r\n\r\n\r\nI have tested it in Chrome browser, both objects are stored in different locations, so changing immediate child values in either will not change the other.  Though (in the example) changing a value in `e` will effect both copies.\r\n\r\nThis technique is very simple and straight forward. I consider this a true Best Practice for this question once and for all. \r\n"},{"score":4,"body_markdown":"Hope this helps.\r\n\r\n    function deepClone(obj) {\r\n        /*\r\n         * Duplicates an object \r\n         */\r\n      \r\n        var ret = null;\r\n        if (obj !== Object(obj)) { // primitive types\r\n            return obj;\r\n        }\r\n        if (obj instanceof String || obj instanceof Number || obj instanceof Boolean) { // string objecs\r\n            ret = obj; // for ex: obj = new String(&quot;Spidergap&quot;)\r\n        } else if (obj instanceof Date) { // date\r\n            ret = new obj.constructor();\r\n        } else\r\n            ret = Object.create(obj.constructor.prototype);\r\n    \r\n        var prop = null;\r\n        var allProps = Object.getOwnPropertyNames(obj); //gets non enumerables also\r\n    \r\n    \r\n        var props = {};\r\n        for (var i in allProps) {\r\n            prop = allProps[i];\r\n            props[prop] = false;\r\n        }\r\n    \r\n        for (i in obj) {\r\n            props[i] = i;\r\n        }\r\n    \r\n        //now props contain both enums and non enums \r\n        var propDescriptor = null;\r\n        var newPropVal = null; // value of the property in new object\r\n        for (i in props) {\r\n            prop = obj[i];\r\n            propDescriptor = Object.getOwnPropertyDescriptor(obj, i);\r\n    \r\n            if (Array.isArray(prop)) { //not backward compatible\r\n                prop = prop.slice(); // to copy the array\r\n            } else\r\n            if (prop instanceof Date == true) {\r\n                prop = new prop.constructor();\r\n            } else\r\n            if (prop instanceof Object == true) {\r\n                if (prop instanceof Function == true) { // function\r\n                    if (!Function.prototype.clone) {\r\n                        Function.prototype.clone = function() {\r\n                            var that = this;\r\n                            var temp = function tmp() {\r\n                                return that.apply(this, arguments);\r\n                            };\r\n                            for (var ky in this) {\r\n                                temp[ky] = this[ky];\r\n                            }\r\n                            return temp;\r\n                        }\r\n                    }\r\n                    prop = prop.clone();\r\n    \r\n                } else // normal object\t\r\n                {\r\n                    prop = deepClone(prop);\r\n                }\r\n    \r\n            }\r\n    \r\n            newPropVal = {\r\n                value: prop\r\n            };\r\n            if (propDescriptor) {\r\n                /*\r\n                 * If property descriptors are there, they must be copied\r\n                 */\r\n                newPropVal.enumerable = propDescriptor.enumerable;\r\n                newPropVal.writable = propDescriptor.writable;\r\n    \r\n            }\r\n            if (!ret.hasOwnProperty(i)) // when String or other predefined objects\r\n                Object.defineProperty(ret, i, newPropVal); // non enumerable\r\n    \r\n        }\r\n        return ret;\r\n    }\r\n\r\nhttps://github.com/jinujd/Javascript-Deep-Clone"},{"score":73,"body_markdown":"**Deep copying objects in JavaScript (I think the best and the simplest)**\r\n\r\n**1. Using JSON.parse(JSON.stringify(object));**\r\n\r\n    var obj = { \r\n      a: 1,\r\n      b: { \r\n        c: 2\r\n      }\r\n    }\r\n    var newObj = JSON.parse(JSON.stringify(obj));\r\n    obj.b.c = 20;\r\n    console.log(obj); // { a: 1, b: { c: 20 } }\r\n    console.log(newObj); // { a: 1, b: { c: 2 } } \r\n\r\n**2.Using created method**\r\n\r\n    function cloneObject(obj) {\r\n        var clone = {};\r\n        for(var i in obj) {\r\n            if(obj[i] != null &amp;&amp;  typeof(obj[i])==&quot;object&quot;)\r\n                clone[i] = cloneObject(obj[i]);\r\n            else\r\n                clone[i] = obj[i];\r\n        }\r\n        return clone;\r\n    }\r\n    \r\n    var obj = { \r\n      a: 1,\r\n      b: { \r\n        c: 2\r\n      }\r\n    }\r\n    var newObj = cloneObject(obj);\r\n    obj.b.c = 20;\r\n    \r\n    console.log(obj); // { a: 1, b: { c: 20 } }\r\n    console.log(newObj); // { a: 1, b: { c: 2 } } \r\n\r\n**3. Using Lo-Dash&#39;s _.cloneDeep** link [lodash][1]\r\n\r\n    var obj = { \r\n      a: 1,\r\n      b: { \r\n        c: 2\r\n      }\r\n    }\r\n    \r\n    var newObj = _.cloneDeep(obj);\r\n    obj.b.c = 20;\r\n    console.log(obj); // { a: 1, b: { c: 20 } }\r\n    console.log(newObj); // { a: 1, b: { c: 2 } } \r\n\r\n**4. Using Object.assign() method**\r\n\r\n\tvar obj = { \r\n      a: 1,\r\n      b: 2\r\n    }\r\n    \r\n    var newObj = _.clone(obj);\r\n    obj.b = 20;\r\n    console.log(obj); // { a: 1, b: 20 }\r\n    console.log(newObj); // { a: 1, b: 2 }  \r\n\r\n**BUT WRONG WHEN**\r\n\t\r\n    var obj = { \r\n      a: 1,\r\n      b: { \r\n        c: 2\r\n      }\r\n    }\r\n    \r\n    var newObj = Object.assign({}, obj);\r\n    obj.b.c = 20;\r\n    console.log(obj); // { a: 1, b: { c: 20 } }\r\n    console.log(newObj); // { a: 1, b: { c: 20 } } --&gt; WRONG\r\n\t// Note: Properties on the prototype chain and non-enumerable properties cannot be copied.\r\n\t\r\n**5.Using Underscore.js _.clone** link [Underscore.js][2]\r\n\r\n    var obj = { \r\n      a: 1,\r\n      b: 2\r\n    }\r\n    \r\n    var newObj = _.clone(obj);\r\n    obj.b = 20;\r\n    console.log(obj); // { a: 1, b: 20 }\r\n    console.log(newObj); // { a: 1, b: 2 }  \r\n\r\n**BUT WRONG WHEN**\r\n\r\n    var obj = { \r\n      a: 1,\r\n      b: { \r\n        c: 2\r\n      }\r\n    }\r\n    \r\n    var newObj = _.cloneDeep(obj);\r\n    obj.b.c = 20;\r\n    console.log(obj); // { a: 1, b: { c: 20 } }\r\n    console.log(newObj); // { a: 1, b: { c: 20 } } --&gt; WRONG\r\n    // (Create a shallow-copied clone of the provided plain object. Any nested objects or arrays will be copied by reference, not duplicated.)\r\n\r\n**JSBEN.CH Performance Benchmarking Playground 1~3 http://jsben.ch/KVQLd**\r\n[![Performance Deep copying objects in JavaScript][4]][4]\r\n\r\n\r\n  [1]: https://lodash.com/docs/4.17.10#cloneDeep\r\n  [2]: https://underscorejs.org/#clone\r\n  [4]: https://i.stack.imgur.com/Assgk.png"},{"score":2,"body_markdown":"When your object is nested and it contains data object, other structured object or some property object, etc then using `JSON.parse(JSON.stringify(object))` or `Object.assign({}, obj)` or `$.extend(true, {}, obj)` will not work. In that case use lodash. It is simple and easy..\r\n\r\n    var obj = {a: 25, b: {a: 1, b: 2}, c: new Date(), d: anotherNestedObject };\r\n    var A = _.cloneDeep(obj);\r\n\r\nNow A will be your new cloned of obj without any references.. "},{"score":2,"body_markdown":"if you find yourself doing this type of thing regular ( eg- creating undo redo functionality ) it might be worth looking into [Immutable.js][1]\r\n\r\n    const map1 = Immutable.fromJS( { a: 1, b: 2, c: { d: 3 } } );\r\n    const map2 = map1.setIn( [ &#39;c&#39;, &#39;d&#39; ], 50 );\r\n    \r\n    console.log( `${ map1.getIn( [ &#39;c&#39;, &#39;d&#39; ] ) } vs ${ map2.getIn( [ &#39;c&#39;, &#39;d&#39; ] ) }` ); // &quot;3 vs 50&quot;\r\n\r\nhttps://codepen.io/anon/pen/OBpqNE?editors=1111\r\n\r\n\r\n  [1]: https://facebook.github.io/immutable-js/"},{"score":6,"body_markdown":"&gt; In JavaScript, you can write your `deepCopy` method like \r\n\r\n    function deepCopy(src) {\r\n      let target = Array.isArray(src) ? [] : {};\r\n      for (let prop in src) {\r\n        let value = src[prop];\r\n        if(value &amp;&amp; typeof value === &#39;object&#39;) {\r\n          target[prop] = deepCopy(value);\r\n      } else {\r\n          target[prop] = value;\r\n      }\r\n     }\r\n        return target;\r\n    }\r\n\r\n "},{"score":-1,"body_markdown":"How about merging the &lt;i&gt;keys&lt;/i&gt; of the object with its &lt;i&gt;values&lt;/i&gt;?\r\n\r\n    function deepClone(o) {\r\n        var keys = Object.keys(o);\r\n        var values = Object.values(o);\r\n\r\n        var clone = {};\r\n\r\n        keys.forEach(function(key, i) {\r\n            clone[key] = typeof values[i] == &#39;object&#39; ? Object.create(values[i]) : values[i];\r\n        });\r\n\r\n        return clone;\r\n    }\r\n\r\n**Note:** *This method doesn&#39;t necessarily make shallow copies*, but it only copies with the depth of one inner-object, meaning that when you are given something like `{a: {b: {c: null}}}`, it will only clone the objects that are directly inside of them, so  `deepClone(a.b).c` is technically a reference to `a.b.c`, while `deepClone(a).b` is a clone, *not a reference*."},{"score":0,"body_markdown":"\r\n\r\n    function clone(obj) {\r\n        var copy;\r\n    \r\n        // Handle the 3 simple types, and null or undefined\r\n        if (null == obj || &quot;object&quot; != typeof obj) return obj;\r\n    \r\n        // Handle Date\r\n        if (obj instanceof Date) {\r\n            copy = new Date();\r\n            copy.setTime(obj.getTime());\r\n            return copy;\r\n        }\r\n    \r\n        // Handle Array\r\n        if (obj instanceof Array) {\r\n            copy = [];\r\n            for (var i = 0, len = obj.length; i &lt; len; i++) {\r\n                copy[i] = clone(obj[i]);\r\n            }\r\n            return copy;\r\n        }\r\n    \r\n        // Handle Object\r\n        if (obj instanceof Object) {\r\n            copy = {};\r\n            for (var attr in obj) {\r\n                if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\r\n            }\r\n            return copy;\r\n        }\r\n    \r\n        throw new Error(&quot;Unable to copy obj! Its type isn&#39;t supported.&quot;);\r\n    }\r\n\r\n\r\n   use the following method instead of `JSON.parse(JSON.stringify(obj))`  because \r\nit is slower than the following method \r\n\r\nhttps://stackoverflow.com/questions/728360/how-do-i-correctly-clone-a-javascript-object"},{"score":1,"body_markdown":"With the proposal of the new method [Object.fromEntries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) that is supported on newer versions of some browsers ([reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries#Browser_compatibility)). I want to contribute with the next recursive approach:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const obj = {\r\n      key1: {key11: &quot;key11&quot;, key12: &quot;key12&quot;, key13: {key131: 22}},\r\n      key2: {key21: &quot;key21&quot;, key22: &quot;key22&quot;},\r\n      key3: &quot;key3&quot;,\r\n      key4: [1,2,3, {key: &quot;value&quot;}]\r\n    }\r\n\r\n    const cloneObj = (obj) =&gt;\r\n    {\r\n        if (Object(obj) !== obj)\r\n           return obj;\r\n        else if (Array.isArray(obj))\r\n           return obj.map(cloneObj);\r\n\r\n        return Object.fromEntries(Object.entries(obj).map(\r\n            ([k,v]) =&gt; ([k, cloneObj(v)])\r\n        ));\r\n    }\r\n\r\n    // Clone the original object.\r\n    let newObj = cloneObj(obj);\r\n\r\n    // Make changes on the original object.\r\n    obj.key1.key11 = &quot;TEST&quot;;\r\n    obj.key3 = &quot;TEST&quot;;\r\n    obj.key1.key13.key131 = &quot;TEST&quot;;\r\n    obj.key4[1] = &quot;TEST&quot;;\r\n    obj.key4[3].key = &quot;TEST&quot;;\r\n\r\n    // Display both objects on the console.\r\n    console.log(&quot;Original object: &quot;, obj);\r\n    console.log(&quot;Cloned object: &quot;, newObj);\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console {background-color:black !important; color:lime;}\r\n    .as-console-wrapper {max-height:100% !important; top:0;}\r\n\r\n&lt;!-- end snippet --&gt;"},{"score":3,"body_markdown":"My scenario was a bit different. I had an object with nested objects as well as functions. Therefore, `Object.assign()` and `JSON.stringify()` were not solutions to my problem. Using third-party libraries was not an option for me neither.\r\n\r\nHence, I decided to make a simple function to use built-in methods to copy an object with its literal properties, its nested objects, and functions.\r\n\r\n    let deepCopy = (target, source) =&gt; {\r\n        Object.assign(target, source);\r\n        // check if there&#39;s any nested objects\r\n        Object.keys(source).forEach((prop) =&gt; {\r\n            /**\r\n              * assign function copies functions and\r\n              * literals (int, strings, etc...)\r\n              * except for objects and arrays, so:\r\n              */\r\n            if (typeof(source[prop]) === &#39;object&#39;) {\r\n                // check if the item is, in fact, an array\r\n                if (Array.isArray(source[prop])) {\r\n                    // clear the copied referenece of nested array\r\n                    target[prop] = Array();\r\n                    // iterate array&#39;s item and copy over\r\n                    source[prop].forEach((item, index) =&gt; {\r\n                        // array&#39;s items could be objects too!\r\n                        if (typeof(item) === &#39;object&#39;) {\r\n                            // clear the copied referenece of nested objects\r\n                            target[prop][index] = Object();\r\n                            // and re do the process for nested objects\r\n                            deepCopy(target[prop][index], item);\r\n                        } else {\r\n                            target[prop].push(item);\r\n                        }\r\n                    });\r\n                // otherwise, treat it as an object\r\n                } else {\r\n                    // clear the copied referenece of nested objects\r\n                    target[prop] = Object();\r\n                    // and re do the process for nested objects\r\n                    deepCopy(target[prop], source[prop]);\r\n                }\r\n            }\r\n        });\r\n    };\r\n\r\nHere&#39;s a test code:\r\n\r\n    let a = {\r\n        name: &#39;Human&#39;, \r\n        func: () =&gt; {\r\n            console.log(&#39;Hi!&#39;);\r\n        }, \r\n        prop: {\r\n            age: 21, \r\n            info: {\r\n                hasShirt: true, \r\n                hasHat: false\r\n            }\r\n        },\r\n        mark: [89, 92, { exam: [1, 2, 3] }]\r\n    };\r\n    \r\n    let b = Object();\r\n    \r\n    deepCopy(b, a);\r\n    \r\n    a.name = &#39;Alien&#39;;\r\n    a.func = () =&gt; { console.log(&#39;Wassup!&#39;); };\r\n    a.prop.age = 1024;\r\n    a.prop.info.hasShirt = false;\r\n    a.mark[0] = 87;\r\n    a.mark[1] = 91;\r\n    a.mark[2].exam = [4, 5, 6];\r\n    \r\n    console.log(a); // updated props\r\n    console.log(b);\r\n\r\nFor efficiency-related concerns, I believe this is the simplest and most efficient solution to the problem I had. I would appreciate any comments on this algorithm that could make it more efficient."},{"score":3,"body_markdown":"`Object.assign({},sourceObj)` only clones the object if their property is not having reference type key.\r\nex \r\n\r\n    obj={a:&quot;lol&quot;,b:[&quot;yes&quot;,&quot;no&quot;,&quot;maybe&quot;]}\r\n    clonedObj = Object.assign({},obj);\r\n    \r\n    clonedObj.b.push(&quot;skip&quot;)// changes will reflected to the actual obj as well because of its reference type.\r\n    obj.b //will also console =&gt; yes,no,maybe,skip\r\n\r\n\r\nSo for the deep cloning is not possible to achieve in this way.\r\n\r\nThe best solution that works is\r\n\r\n    var obj = Json.stringify(yourSourceObj)\r\n    var cloned = Json.parse(obj);\r\n\r\n"},{"score":2,"body_markdown":"This is my solution without using any library or native javascript function.\r\n\r\n    function deepClone(obj) {\r\n      if (typeof obj !== &quot;object&quot;) {\r\n        return obj;\r\n      } else {\r\n        let newObj =\r\n          typeof obj === &quot;object&quot; &amp;&amp; obj.length !== undefined ? [] : {};\r\n        for (let key in obj) {\r\n          if (key) {\r\n            newObj[key] = deepClone(obj[key]);\r\n          }\r\n        }\r\n        return newObj;\r\n      }\r\n    }"}],"score":5177}