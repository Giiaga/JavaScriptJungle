{"body":"Suppose I&#39;m familiar with developing client-side applications in [jQuery][2], but now I&#39;d like to start using [AngularJS][1]. Can you describe the paradigm shift that is necessary? Here are a few questions that might help you frame an answer:\r\n\r\n - How do I architect and design client-side web applications differently? What is the biggest difference?\r\n - What should I stop doing/using; What should I start doing/using instead?\r\n - Are there any server-side considerations/restrictions?\r\n\r\nI&#39;m not looking for a detailed comparison between `jQuery` and `AngularJS`.\r\n\r\n  [1]: http://angularjs.org/\r\n  [2]: http://jquery.com/","title":"&quot;Thinking in AngularJS&quot; if I have a jQuery background?","answers":[{"score":407,"body_markdown":"## Imperative → declarative\r\n\r\nIn jQuery, *selectors* are used to find [DOM][1] elements and then bind/register event handlers to them. When an event triggers, that (imperative) code executes to update/change the DOM.\r\n\r\nIn AngularJS, you want to think about **views** rather than DOM elements. Views are (declarative) HTML that contain AngularJS **directives**. Directives set up the event handlers behind the scenes for us and give us dynamic databinding. Selectors are rarely used, so the need for IDs (and some types of classes) is greatly diminished. Views are tied to **models** (via scopes). Views are a projection of the model. Events change models (that is, data, scope properties), and the views that project those models update &quot;automatically.&quot;\r\n\r\nIn AngularJS, think about models, rather than jQuery-selected DOM elements that hold your data. Think about views as projections of those models, rather than registering callbacks to manipulate what the user sees.\r\n\r\n## Separation of concerns\r\n\r\njQuery employs [unobtrusive JavaScript][2] - behavior (JavaScript) is separated from the structure (HTML).\r\n\r\nAngularJS uses **controllers** and directives (each of which can have their own controller, and/or compile and linking functions) to remove behavior from the view/structure (HTML).  Angular also has **services** and **filters** to help separate/organize your application.\r\n\r\nSee also https://stackoverflow.com/a/14346528/215945\r\n\r\n## Application design\r\n\r\nOne approach to designing an AngularJS application:\r\n\r\n 1. Think about your models. Create services or your own JavaScript objects for those models.\r\n 2. Think about how you want to present your models -- your views. Create HTML templates for each view, using the necessary directives to get dynamic databinding.\r\n 3. Attach a controller to each view (using ng-view and routing, or ng-controller). Have the controller find/get only whatever model data the view needs to do its job. Make controllers as thin as possible.\r\n\r\n## Prototypal inheritance\r\n\r\nYou can do a lot with jQuery without knowing about how JavaScript prototypal inheritance works. When developing AngularJS applications, you will avoid some common pitfalls if you have a good understanding of JavaScript inheritance. Recommended reading: https://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Document_Object_Model\r\n  [2]: http://en.wikipedia.org/wiki/Unobtrusive_JavaScript\r\n"},{"score":152,"body_markdown":"&gt; Can you describe the paradigm shift that is necessary?\r\n\r\n**Imperative vs Declarative**\r\n\r\nWith **jQuery** you tell the DOM what needs to happen, step by step. With **[AngularJS][1]** you describe what results you want but not how to do it. More on this [here][2]. Also, check out Mark Rajcok&#39;s answer.\r\n\r\n&gt; How do I architect and design client-side web apps differently? \r\n\r\nAngularJS is an entire client-side framework that uses the [MVC][3] pattern (check out their [graphical representation][4]). It greatly focuses on separation of concerns.\r\n\r\n&gt; What is the biggest difference? What should I stop doing/using; what should I start doing/using instead?\r\n\r\n**jQuery** is a library \r\n\r\n**AngularJS** is a beautiful client-side framework, highly testable, that combines tons of cool stuff such as MVC, [dependency injection][5], data binding and much more. \r\n\r\nIt focuses on [separation of concerns][6] and testing ([unit testing][7] and end-to-end testing), which facilitates test-driven development.\r\n\r\nThe best way to start is going through [their awesome tutorial][8]. You can go through the steps in a couple of hours; however, in case you want to master the concepts behind the scenes, they include a myriad of reference for further reading.\r\n\r\n&gt;  Are there any server-side considerations/restrictions?\r\n\r\nYou may use it on existing applications where you are already using pure jQuery. However, if you want to fully take advantage of the AngularJS features you may consider coding the server side using a [RESTful][9] approach.\r\n\r\nDoing so will allow you to leverage their [resource factory][10], which creates an abstraction of your server side RESTful [API][11] and makes server-side calls (get, save, delete, etc.) incredibly easy.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/AngularJS\r\n  [2]: https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming\r\n  [3]: http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\r\n  [4]: http://docs.angularjs.org/guide/concepts\r\n  [5]: http://en.wikipedia.org/wiki/Dependency_injection\r\n  [6]: http://en.wikipedia.org/wiki/Separation_of_concerns\r\n  [7]: http://en.wikipedia.org/wiki/Unit_testing\r\n  [8]: http://docs.angularjs.org/tutorial/\r\n  [9]: http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services\r\n  [10]: http://docs.angularjs.org/api/ngResource.$resource\r\n  [11]: http://en.wikipedia.org/wiki/Application_programming_interface\r\n"},{"score":7176,"body_markdown":"# 1. Don&#39;t design your page, and then change it with [DOM][1] manipulations\r\n\r\nIn jQuery, you design a page, and then you make it dynamic. This is because jQuery was designed for augmentation and has grown incredibly from that simple premise.\r\n\r\nBut in AngularJS, you must start from the ground up with your architecture in mind. Instead of starting by thinking &quot;I have this piece of the DOM and I want to make it do X&quot;, you have to start with what you want to accomplish, then go about designing your application, and then finally go about designing your view.\r\n\r\n# 2. Don&#39;t augment jQuery with AngularJS\r\n\r\nSimilarly, don&#39;t start with the idea that jQuery does X, Y, and Z, so I&#39;ll just add AngularJS on top of that for models and controllers. This is *really* tempting when you&#39;re just starting out, which is why I always recommend that new AngularJS developers don&#39;t use jQuery at all, at least until they get used to doing things the &quot;Angular Way&quot;.\r\n\r\nI&#39;ve seen many developers here and on the mailing list create these elaborate solutions with jQuery plugins of 150 or 200 lines of code that they then glue into AngularJS with a collection of callbacks and `$apply`s that are confusing and convoluted; but they eventually get it working! The problem is that in **most** cases that jQuery plugin could be rewritten in AngularJS in a fraction of the code, where suddenly everything becomes comprehensible and straightforward.\r\n\r\nThe bottom line is this: when solutioning, first &quot;think in AngularJS&quot;; if you can&#39;t think of a solution, ask the community; if after all of that there is no easy solution, *then* feel free to reach for the jQuery. But don&#39;t let jQuery become a crutch or you&#39;ll never master AngularJS.\r\n\r\n# 3. Always think in terms of architecture\r\n\r\nFirst know that [single-page applications][2] are *applications*. They&#39;re *not* webpages. So we need to think like a server-side developer *in addition* to thinking like a client-side developer. We have to think about how to divide our application into individual, extensible, testable components.\r\n\r\nSo then *how* do you do that? How do you &quot;think in AngularJS&quot;? Here are some general principles, contrasted with jQuery.\r\n\r\n## The view is the &quot;official record&quot;\r\n\r\nIn jQuery, we programmatically change the view. We could have a dropdown menu defined as a `ul` like so:\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;ul class=&quot;main-menu&quot;&gt;\r\n        &lt;li class=&quot;active&quot;&gt;\r\n            &lt;a href=&quot;#/home&quot;&gt;Home&lt;/a&gt;\r\n        &lt;/li&gt;\r\n        &lt;li&gt;\r\n            &lt;a href=&quot;#/menu1&quot;&gt;Menu 1&lt;/a&gt;\r\n            &lt;ul&gt;\r\n                &lt;li&gt;&lt;a href=&quot;#/sm1&quot;&gt;Submenu 1&lt;/a&gt;&lt;/li&gt;\r\n                &lt;li&gt;&lt;a href=&quot;#/sm2&quot;&gt;Submenu 2&lt;/a&gt;&lt;/li&gt;\r\n                &lt;li&gt;&lt;a href=&quot;#/sm3&quot;&gt;Submenu 3&lt;/a&gt;&lt;/li&gt;\r\n            &lt;/ul&gt;\r\n        &lt;/li&gt;\r\n        &lt;li&gt;\r\n            &lt;a href=&quot;#/home&quot;&gt;Menu 2&lt;/a&gt;\r\n        &lt;/li&gt;\r\n    &lt;/ul&gt;\r\n\r\nIn jQuery, in our application logic, we would activate it with something like:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $(&#39;.main-menu&#39;).dropdownMenu();\r\n\r\nWhen we just look at the view, it&#39;s not immediately obvious that there is any functionality here. For small applications, that&#39;s fine. But for non-trivial applications, things quickly get confusing and hard to maintain.\r\n\r\nIn AngularJS, though, the view is the official record of view-based functionality. Our `ul` declaration would look like this instead:\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;ul class=&quot;main-menu&quot; dropdown-menu&gt;\r\n        ...\r\n    &lt;/ul&gt;\r\n\r\nThese two do the same thing, but in the AngularJS version anyone looking at the template knows what&#39;s supposed to happen. Whenever a new member of the development team comes on board, she can look at this and then *know* that there is a directive called `dropdownMenu` operating on it; she doesn&#39;t need to intuit the right answer or sift through any code. The view told us what was supposed to happen. Much cleaner.\r\n\r\nDevelopers new to AngularJS often ask a question like: how do I find all links of a specific kind and add a directive onto them. The developer is always flabbergasted when we reply: you don&#39;t. But the reason you don&#39;t do that is that this is like half-jQuery, half-AngularJS, and no good. The problem here is that the developer is trying to &quot;do jQuery&quot; in the context of AngularJS. That&#39;s never going to work well. The view *is* the official record. Outside of a directive (more on this below), you never, ever, *never* change the DOM. And directives are applied *in the view*, so intent is clear.\r\n\r\nRemember: don&#39;t design, and then mark up. You must architect, and then design.\r\n\r\n## Data binding\r\n\r\nThis is by far one of the most awesome features of AngularJS and cuts out a lot of the need to do the kinds of DOM manipulations I mentioned in the previous section. AngularJS will automatically update your view so you don&#39;t have to! In jQuery, we respond to events and then update content. Something like:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $.ajax({\r\n      url: &#39;/myEndpoint.json&#39;,\r\n      success: function ( data, status ) {\r\n        $(&#39;ul#log&#39;).append(&#39;&lt;li&gt;Data Received!&lt;/li&gt;&#39;);\r\n      }\r\n    });\r\n\r\nFor a view that looks like this:\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;ul class=&quot;messages&quot; id=&quot;log&quot;&gt;\r\n    &lt;/ul&gt;\r\n\r\nApart from mixing concerns, we also have the same problems of signifying intent that I mentioned before. But more importantly, we had to manually reference and update a DOM node. And if we want to delete a log entry, we have to code against the DOM for that too. How do we test the logic apart from the DOM? And what if we want to change the presentation?\r\n\r\nThis a little messy and a trifle frail. But in AngularJS, we can do this:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    $http( &#39;/myEndpoint.json&#39; ).then( function ( response ) {\r\n        $scope.log.push( { msg: &#39;Data Received!&#39; } );\r\n    });\r\n\r\nAnd our view can look like this:\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;ul class=&quot;messages&quot;&gt;\r\n        &lt;li ng-repeat=&quot;entry in log&quot;&gt;{{ entry.msg }}&lt;/li&gt;\r\n    &lt;/ul&gt;\r\n\r\nBut for that matter, our view could look like this:\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;div class=&quot;messages&quot;&gt;\r\n        &lt;div class=&quot;alert&quot; ng-repeat=&quot;entry in log&quot;&gt;\r\n            {{ entry.msg }}\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n\r\nAnd now instead of using an unordered list, we&#39;re using Bootstrap alert boxes. And we never had to change the controller code! But more importantly, no matter *where* or *how* the log gets updated, the view will change too. Automatically. Neat!\r\n\r\nThough I didn&#39;t show it here, the data binding is two-way. So those log messages could also be editable in the view just by doing this: `&lt;input ng-model=&quot;entry.msg&quot; /&gt;`. And there was much rejoicing.\r\n\r\n## Distinct model layer\r\n\r\nIn jQuery, the DOM is kind of like the model. But in AngularJS, we have a separate model layer that we can manage in any way we want, completely independently from the view. This helps for the above data binding, maintains [separation of concerns][3], and introduces far greater testability. Other answers mentioned this point, so I&#39;ll just leave it at that.\r\n\r\n## Separation of concerns\r\n\r\nAnd all of the above tie into this over-arching theme: keep your concerns separate. Your view acts as the official record of what is supposed to happen (for the most part); your model represents your data; you have a service layer to perform reusable tasks; you do DOM manipulation and augment your view with directives; and you glue it all together with controllers. This was also mentioned in other answers, and the only thing I would add pertains to testability, which I discuss in another section below.\r\n\r\n## Dependency injection\r\n\r\nTo help us out with separation of concerns is [dependency injection][4] (DI). If you come from a server-side language (from [Java][5] to [PHP][6]) you&#39;re probably familiar with this concept already, but if you&#39;re a client-side guy coming from jQuery, this concept can seem anything from silly to superfluous to hipster. But it&#39;s not. :-)\r\n\r\nFrom a broad perspective, DI means that you can declare components very freely and then from any other component, just ask for an instance of it and it will be granted. You don&#39;t have to know about loading order, or file locations, or anything like that. The power may not immediately be visible, but I&#39;ll provide just one (common) example: testing.\r\n\r\nLet&#39;s say in our application, we require a service that implements server-side storage through a [REST][7] API and, depending on application state, local storage as well. When running tests on our controllers, we don&#39;t want to have to communicate with the server - we&#39;re testing the *controller*, after all. We can just add a mock service of the same name as our original component, and the injector will ensure that our controller gets the fake one automatically - our controller doesn&#39;t and needn&#39;t know the difference.\r\n\r\nSpeaking of testing...\r\n\r\n# 4. Test-driven development - *always*\r\n\r\nThis is really part of section 3 on architecture, but it&#39;s so important that I&#39;m putting it as its own top-level section.\r\n\r\nOut of all of the many jQuery plugins you&#39;ve seen, used, or written, how many of them had an accompanying test suite? Not very many because jQuery isn&#39;t very amenable to that. But AngularJS is.\r\n\r\nIn jQuery, the only way to test is often to create the component independently with a sample/demo page against which our tests can perform DOM manipulation. So then we have to develop a component separately and *then* integrate it into our application. How inconvenient! So much of the time, when developing with jQuery, we opt for iterative instead of test-driven development. And who could blame us?\r\n\r\nBut because we have separation of concerns, we can do test-driven development iteratively in AngularJS! For example, let&#39;s say we want a super-simple directive to indicate in our menu what our current route is. We can declare what we want in the view of our application:\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;a href=&quot;/hello&quot; when-active&gt;Hello&lt;/a&gt;\r\n\r\nOkay, now we can write a test for the non-existent `when-active` directive:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    it( &#39;should add &quot;active&quot; when the route changes&#39;, inject(function() {\r\n        var elm = $compile( &#39;&lt;a href=&quot;/hello&quot; when-active&gt;Hello&lt;/a&gt;&#39; )( $scope );\r\n\r\n        $location.path(&#39;/not-matching&#39;);\r\n        expect( elm.hasClass(&#39;active&#39;) ).toBeFalsey();\r\n\r\n        $location.path( &#39;/hello&#39; );\r\n        expect( elm.hasClass(&#39;active&#39;) ).toBeTruthy();\r\n    }));\r\n\r\nAnd when we run our test, we can confirm that it fails. Only now should we create our directive:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    .directive( &#39;whenActive&#39;, function ( $location ) {\r\n        return {\r\n            scope: true,\r\n            link: function ( scope, element, attrs ) {\r\n                scope.$on( &#39;$routeChangeSuccess&#39;, function () {\r\n                    if ( $location.path() == element.attr( &#39;href&#39; ) ) {\r\n                        element.addClass( &#39;active&#39; );\r\n                    }\r\n                    else {\r\n                        element.removeClass( &#39;active&#39; );\r\n                    }\r\n                });\r\n            }\r\n        };\r\n    });\r\n\r\nOur test now passes *and* our menu performs as requested. Our development is *both* iterative *and* test-driven. Wicked-cool.\r\n\r\n# 5. Conceptually, directives are *not* packaged jQuery\r\n\r\nYou&#39;ll often hear &quot;only do DOM manipulation in a directive&quot;. **This is a necessity.** Treat it with due deference!\r\n\r\nBut let&#39;s dive a little deeper...\r\n\r\nSome directives just decorate what&#39;s already in the view (think `ngClass`) and therefore sometimes do DOM manipulation straight away and then are basically done. But if a directive is like a &quot;widget&quot; and has a template, it should *also* respect separation of concerns. That is, the template *too* should remain largely independent from its implementation in the link and controller functions.\r\n\r\nAngularJS comes with an entire set of tools to make this very easy; with `ngClass` we can dynamically update the class; `ngModel` allows two-way data binding; `ngShow` and `ngHide` programmatically show or hide an element; and many more - including the ones we write ourselves. In other words, we can do all kinds of awesomeness *without* DOM manipulation. The less DOM manipulation, the easier directives are to test, the easier they are to style, the easier they are to change in the future, and the more re-usable and distributable they are.\r\n\r\nI see lots of developers new to AngularJS using directives as the place to throw a bunch of jQuery. In other words, they think &quot;since I can&#39;t do DOM manipulation in the controller, I&#39;ll take that code put it in a directive&quot;. While that certainly is much better, it&#39;s often *still wrong*.\r\n\r\nThink of the logger we programmed in section 3. Even if we put that in a directive, we *still* want to do it the &quot;Angular Way&quot;. It *still* doesn&#39;t take any DOM manipulation! There are lots of times when DOM manipulation is necessary, but it&#39;s a *lot* rarer than you think! Before doing DOM manipulation *anywhere* in your application, ask yourself if you really need to. There might be a better way.\r\n\r\nHere&#39;s a quick example that shows the pattern I see most frequently. We want a toggleable button. (Note: this example is a little contrived and a skosh verbose to represent more complicated cases that are solved in exactly the same way.)\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    .directive( &#39;myDirective&#39;, function () {\r\n        return {\r\n            template: &#39;&lt;a class=&quot;btn&quot;&gt;Toggle me!&lt;/a&gt;&#39;,\r\n            link: function ( scope, element, attrs ) {\r\n                var on = false;\r\n\r\n                $(element).click( function () {\r\n                    on = !on;\r\n                    $(element).toggleClass(&#39;active&#39;, on);\r\n                });\r\n            }\r\n        };\r\n    });\r\n\r\nThere are a few things wrong with this:\r\n\r\n1. First, jQuery was never necessary. There&#39;s nothing we did here that needed jQuery at all!\r\n2. Second, even if we already have jQuery on our page, there&#39;s no reason to use it here; we can simply use `angular.element` and our component will still work when dropped into a project that doesn&#39;t have jQuery.\r\n3. Third, even assuming jQuery *was* required for this directive to work, jqLite (`angular.element`) will *always* use jQuery if it was loaded! So we needn&#39;t use the `$` - we can just use `angular.element`.\r\n4. Fourth, closely related to the third, is that jqLite elements needn&#39;t be wrapped in `$` - the `element` that is passed to the `link` function would *already be* a jQuery element! \r\n5. And fifth, which we&#39;ve mentioned in previous sections, why are we mixing template stuff into our logic?\r\n\r\nThis directive can be rewritten (even for very complicated cases!) much more simply like so:\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    .directive( &#39;myDirective&#39;, function () {\r\n        return {\r\n            scope: true,\r\n            template: &#39;&lt;a class=&quot;btn&quot; ng-class=&quot;{active: on}&quot; ng-click=&quot;toggle()&quot;&gt;Toggle me!&lt;/a&gt;&#39;,\r\n            link: function ( scope, element, attrs ) {\r\n                scope.on = false;\r\n\r\n                scope.toggle = function () {\r\n                    scope.on = !scope.on;\r\n                };\r\n            }\r\n        };\r\n    });\r\n\r\nAgain, the template stuff is in the template, so you (or your users) can easily swap it out for one that meets any style necessary, and the **logic** never had to be touched. Reusability - boom!\r\n\r\nAnd there are still all those other benefits, like testing - it&#39;s easy! No matter what&#39;s in the template, the directive&#39;s internal API is never touched, so refactoring is easy. You can change the template as much as you want without touching the directive. And no matter what you change, your tests still pass.\r\n\r\nw00t!\r\n\r\nSo if directives aren&#39;t just collections of jQuery-like functions, what are they? Directives are actually **extensions of HTML**. If HTML doesn&#39;t do something you need it to do, you write a directive to do it for you, and then use it just as if it was part of HTML.\r\n\r\nPut another way, if AngularJS doesn&#39;t do something out of the box, think how the team would accomplish it to fit right in with `ngClick`, `ngClass`, et al.\r\n\r\n# Summary\r\n\r\nDon&#39;t even use jQuery. Don&#39;t even include it. It will hold you back. And when you come to a problem that you think you know how to solve in jQuery already, before you reach for the `$`, try to think about how to do it within the confines the AngularJS. If you don&#39;t know, ask! 19 times out of 20, the best way to do it doesn&#39;t need jQuery and to try to solve it with jQuery results in more work for you.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Document_Object_Model\r\n  [2]: http://en.wikipedia.org/wiki/Single-page_application\r\n  [3]: http://en.wikipedia.org/wiki/Separation_of_concerns\r\n  [4]: http://en.wikipedia.org/wiki/Dependency_injection\r\n  [5]: http://en.wikipedia.org/wiki/Java_%28programming_language%29\r\n  [6]: http://en.wikipedia.org/wiki/PHP\r\n  [7]: http://en.wikipedia.org/wiki/Representational_State_Transfer\r\n"},{"score":34,"body_markdown":"They&#39;re apples and oranges. You don&#39;t want to compare them. They&#39;re two different things. AngularJs has already jQuery lite built in which allows you to perform basic DOM manipulation without even including the full blown jQuery version. \r\n\r\njQuery is all about DOM manipulation. It solves all the cross browser pain otherwise you will have to deal with but it&#39;s not a framework that allows you to divide your app into components like AngularJS. \r\n\r\nA nice thing about AngularJs is that it allows you to separate/isolate the DOM manipulation in the directives.  There are built-in directives ready for you to use such as ng-click. You can create your own custom directives that will contain all your view logic or DOM manipulation so you don&#39;t end up mingle DOM manipulation code in the controllers or services that should take care of the business logic.\r\n\r\nAngular breaks down your app into \r\n- Controllers\r\n- Services\r\n- Views\r\n- etc.\r\n\r\nand there is one more thing, that&#39;s the directive. It&#39;s an attribute  you can attach to any DOM element and you can go nuts with jQuery within it without worrying about your jQuery ever conflicts with AngularJs components or messes up with its architecture. \r\n\r\nI heard from a meetup I attended, one of the founders of Angular said they worked really hard to separate out the DOM manipulation so do not try to include them back in. \r\n\r\n"},{"score":30,"body_markdown":"I find this question interesting, because my first serious exposure to JavaScript programming was [Node.js][1] and AngularJS. I never learned jQuery, and I guess that&#39;s a good thing, because I don&#39;t have to unlearn anything. In fact, I actively avoid jQuery solutions to my problems, and instead, solely look for an &quot;AngularJS way&quot; to solve them. So, I guess my answer to this question would essentially boil down to, &quot;think like someone who never learned jQuery&quot; and avoid any temptation to incorporate jQuery directly (obviously AngularJS uses it to some extent behind the scenes).\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Node.js\r\n"},{"score":45,"body_markdown":"jQuery is a DOM manipulation library.\r\n\r\nAngularJS is an MV* framework.\r\n\r\nIn fact, AngularJS is one of the few JavaScript MV* frameworks (many JavaScript MVC tools still fall under the category library).\r\n\r\nBeing a framework, it hosts your code and takes ownership of decisions about what to call and when!\r\n\r\nAngularJS itself includes a jQuery-lite edition within it. So for some basic DOM selection/manipulation, you really don&#39;t have to include the jQuery library (it saves many bytes to run on the network.)\r\n\r\nAngularJS has the concept of &quot;Directives&quot; for DOM manipulation and designing reusable UI components, so you should use it whenever you feel the need of doing DOM manipulation related stuff (directives are only place where you should write jQuery code while using AngularJS).\r\n\r\nAngularJS involves some learning curve (more than jQuery :-).\r\n\r\n--&gt;For any developer coming from jQuery background, my first advice would be to &quot;learn JavaScript as a first class language before jumping onto a rich framework like AngularJS!&quot;\r\nI learned the above fact the hard way.\r\n\r\nGood luck.\r\n"},{"score":61,"body_markdown":"jQuery: you think a lot about &#39;QUERYing the [DOM][1]&#39; for DOM elements and doing something.\r\n\r\nAngularJS: THE model is the truth, and you always think from that ANGLE.\r\n\r\nFor example, when you get data from THE server which you intend to display in some format in the DOM, in jQuery, you need to &#39;1. FIND&#39; where in the DOM you want to place this data, the &#39;2. UPDATE/APPEND&#39; it there by creating a new node or just setting its [innerHTML][2]. Then when you want to update this view, you then &#39;3. FIND&#39; the location and &#39;4. UPDATE&#39;. This cycle of find and update all done within the same context of getting and formatting data from server is gone in AngularJS.\r\n\r\nWith AngularJS you have your model (JavaScript objects you are already used to) and the value of the model tells you about the model (obviously) and about the view, and an operation on the model automatically propagates to the view, so you don&#39;t have to think about it. You will find yourself in AngularJS no longer finding things in the DOM.\r\n\r\nTo put in another way, in jQuery, you need to think about CSS selectors, that is, where is the `div` or `td` that has a class or attribute, etc., so that I can get their HTML or color or value, but in AngularJS, you will find yourself thinking like this: what model am I dealing with, I will set the model&#39;s value to true. You are not bothering yourself of whether the view reflecting this value is a checked box or resides in a `td` element (details you would have often needed to think about in jQuery).\r\n\r\nAnd with DOM manipulation in AngularJS, you find yourself adding directives and filters, which you can think of as valid HTML extensions.\r\n\r\nOne more thing you will experience in AngularJS: in jQuery you call the jQuery functions a lot, in AngularJS, AngularJS will call your functions, so AngularJS will &#39;tell you how to do things&#39;, but the benefits are worth it, so learning AngularJS usually means learning what AngularJS wants or the way AngularJS requires that you present your functions and it will call it accordingly. This is one of the things that makes AngularJS a framework rather than a library.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Document_Object_Model\r\n  [2]: http://www.tizag.com/javascriptT/javascript-innerHTML.php\r\n"},{"score":31,"body_markdown":"Listen to the podcast *[JavaScript Jabber: Episode #32][1]* that features the original creators of AngularJS: Misko Hevery &amp; Igor Minar. They talk a lot about what it&#39;s like to come to AngularJS from other JavaScript backgrounds, especially jQuery.\n\nOne of the points made in the podcast made a lot of things click for me with respects to your question:\n\n&gt;**MISKO**: [...] one of the things we thought about very hardly in Angular is, how do we provide lots of escape hatches so that you can get out and basically figure out a way out of this. So to us, the answer is this thing called “Directives”. **And with directives, you essentially become a regular little jQuery JavaScript, you can do whatever you want.**\n&gt;\n&gt; **IGOR**: So think of directive as the instruction to the compiler that tells it whenever you come across this certain element or this CSS in the template, and you keep this kind of code and that code is in charge of the element and everything below that element in the DOM tree.\n\nA transcript of the entire episode is available at the link provided above.\n\nSo, to directly answer your question: AngularJS is -very- opinionated and is a true MV* framework. However, you can still do all of the really cool stuff you know and love with jQuery inside of directives. It&#39;s not a matter of &quot;How do I do what I used to in jQuery?&quot; as much as it&#39;s a matter of &quot;How do I supplement AngularJS with all of the stuff I used to do in jQuery?&quot;\n\nIt&#39;s really two very different states of mind.\n\n  [1]: http://javascriptjabber.com/032-jsj-angular-js/\n"},{"score":69,"body_markdown":"&lt;h1&gt;jQuery&lt;/h1&gt;\r\n\r\njQuery makes ridiculously long JavaScript commands like `getElementByHerpDerp` shorter and cross-browser.\r\n\r\n&lt;h1&gt;AngularJS&lt;/h1&gt;\r\n\r\nAngularJS allows you to make your own HTML tags/attributes that do things which work well with dynamic web applications (since HTML was designed for static pages).\r\n\r\n&lt;h1&gt;Edit:&lt;/h1&gt;\r\n\r\nSaying &quot;I have a jQuery background how do I think in AngularJS?&quot; is like saying &quot;I have an HTML background how do I think in JavaScript?&quot; The fact that you&#39;re asking the question shows you most likely don&#39;t understand the fundamental purposes of these two resources. This is why I chose to answer the question by simply pointing out the fundamental difference rather than going through the list saying &quot;AngularJS makes use of directives whereas jQuery uses CSS selectors to make a jQuery object which does this and that etc....&quot;. This question does not require a lengthy answer.\r\n\r\njQuery is a way to make programming JavaScript in the browser easier. Shorter, cross-browser commands, etc.\r\n\r\nAngularJS extends HTML, so you don&#39;t have to put `&lt;div&gt;` all over the place just to make an application. It makes HTML actually work for applications rather than what it was designed for, which is static, educational web pages. It accomplishes this in a roundabout way using JavaScript, but fundamentally it is an extension of HTML, not JavaScript.\r\n"},{"score":84,"body_markdown":"To describe the &quot;paradigm shift&quot;, I think a short answer can suffice.\r\n\r\n## AngularJS changes the way you *find* elements\r\n\r\nIn **jQuery**, you typically  use **selectors** to find elements, and then wire them up:  \r\n`$(&#39;#id .class&#39;).click(doStuff);`\r\n\r\nIn **AngularJS**, you use **directives** to mark the elements directly, to wire them up:  \r\n`&lt;a ng-click=&quot;doStuff()&quot;&gt;`\r\n\r\nAngularJS doesn&#39;t need (or want) you to find elements using selectors - the primary difference between AngularJS&#39;s **jqLite** versus full-blown **jQuery** is that [jqLite does not support selectors](https://docs.angularjs.org/api/ng/function/angular.element).  \r\n\r\nSo when people say &quot;don&#39;t include jQuery at all&quot;, it&#39;s mainly because they don&#39;t want you to use selectors; they want you to learn to use directives instead. Direct, not select!\r\n"},{"score":184,"body_markdown":"# AngularJS vs. jQuery\r\n\r\nAngularJS and jQuery adopt very different ideologies. If you&#39;re coming from jQuery you may find some of the differences surprising. Angular may make you angry.\r\n\r\nThis is normal, you should push through. Angular is worth it.\r\n\r\n## The big difference (TLDR)\r\n\r\njQuery gives you a toolkit for selecting arbitrary bits of the DOM and making ad-hoc changes to them. You can do pretty much anything you like piece by piece.\r\n\r\nAngularJS instead gives you a **compiler**.\r\n\r\nWhat this means is that AngularJS reads your entire DOM from top to bottom and treats it as code, literally as instructions to the compiler. As it traverses the DOM, It looks for specific **directives** (compiler directives) that tell the AngularJS compiler how to behave and what to do. Directives are little objects full of JavaScript which can match against attributes, tags, classes or even comments. \r\n\r\nWhen the Angular compiler determines that a piece of the DOM matches a particular directive, it calls the directive function, passing it the DOM element, any attributes, the current $scope (which is a local variable store), and some other useful bits. These attributes may contain expressions which can be interpreted by the Directive, and which tell it how to render, and when it should redraw itself.\r\n\r\nDirectives can then in turn pull in additional Angular components such as controllers, services, etc. What comes out the bottom of the compiler is a fully formed web application, wired up and ready to go.\r\n\r\n**This means that Angular is Template Driven**. Your template drives the JavaScript, not the other way around. This is a radical reversal of roles, and the complete opposite of the unobtrusive JavaScript we have been writing for the last 10 years or so. This can take some getting used to.\r\n\r\nIf this sounds like it might be over-prescriptive and limiting, nothing could be farther from the truth. Because AngularJS treats your HTML as code, you get **HTML level granularity in your web application**. Everything is possible, and most things are surprisingly easy once you make a few conceptual leaps.\r\n\r\nLet&#39;s get down to the nitty gritty.\r\n\r\n## First up, Angular doesn&#39;t replace jQuery\r\n\r\nAngular and jQuery do different things. AngularJS gives you a set of tools to produce web applications. jQuery mainly gives you tools for modifying the DOM. If jQuery is present on your page, AngularJS will use it automatically. If it isn&#39;t, AngularJS ships with jQuery Lite, which is a cut down, but still perfectly usable version of jQuery.\r\n\r\nMisko likes jQuery and doesn&#39;t object to you using it. However you will find as you advance that you can get a pretty much all of your work done using a combination of scope, templates and directives, and you should prefer this workflow where possible because your code will be more discrete, more configurable, and more Angular.\r\n\r\nIf you do use jQuery, you shouldn&#39;t be sprinkling it all over the place. The correct place for DOM manipulation in AngularJS is in a directive. More on these later.\r\n\r\n\r\n\r\n## Unobtrusive JavaScript with Selectors vs. Declarative Templates\r\n\r\njQuery is typically applied unobtrusively. Your JavaScript code is linked in the header (or the footer), and this is the only place it is mentioned. We use selectors to pick out bits of the page and write plugins to modify those parts.\r\n\r\nThe JavaScript is in control. The HTML has a completely independent existence. Your HTML remains semantic even without JavaScript. Onclick attributes are very bad practice.\r\n\r\nOne of the first things your will notice about AngularJS is that **custom attributes are everywhere**. Your HTML will be littered with ng attributes, which are essentially onClick attributes on steroids. These are directives (compiler directives), and are one of the main ways in which the template is hooked to the model.\r\n\r\nWhen you first see this you might be tempted to write AngularJS off as old school intrusive JavaScript (like I did at first). In fact, AngularJS does not play by those rules. In AngularJS, your HTML5 is a template. It is compiled by AngularJS to produce your web page.\r\n\r\nThis is the first big difference. To jQuery, your web page is a DOM to be manipulated. To AngularJS, your HTML is code to be compiled. AngularJS reads in your whole web page and literally compiles it into a new web page using its built in compiler.\r\n\r\nYour template should be declarative; its meaning should be clear simply by reading it. We use custom attributes with meaningful names. We make up new HTML elements, again with meaningful names. A designer with minimal HTML knowledge and no coding skill can read your AngularJS template and understand what it is doing. He or she can make modifications. *This is the Angular way.*\r\n\r\n\r\n\r\n## The template is in the driving seat.\r\n\r\nOne of the first questions I asked myself when starting AngularJS and running through the tutorials is **&quot;Where is my code?&quot;**. I&#39;ve written no JavaScript, and yet I have all this behaviour. The answer is obvious. Because AngularJS compiles the DOM, AngularJS is treating your HTML as code. For many simple cases it&#39;s often sufficient to just write a template and let AngularJS compile it into an application for you.\r\n\r\nYour template drives your application. It&#39;s treated as a [DSL][1]. You write AngularJS components, and AngularJS will take care of pulling them in and making them available at the right time based on the structure of your template. This is very different to a standard [MVC][2] pattern, where the template is just for output.\r\n\r\nIt&#39;s more similar to [XSLT][3] than [Ruby on Rails][4] for example.\r\n\r\nThis is a radical inversion of control that takes some getting used to.\r\n\r\n**Stop trying to drive your application from your JavaScript. Let the template drive the application, and let AngularJS take care of wiring the components together. This also is the Angular way.**\r\n\r\n\r\n\r\n## Semantic HTML vs. Semantic Models\r\n\r\nWith jQuery your HTML page should contain semantic meaningful content. If the JavaScript is turned off (by a user or search engine) your content remains accessible.\r\n\r\nBecause AngularJS treats your HTML page as a template. The template is not supposed to be semantic as your content is typically stored in your model which ultimately comes from your API. AngularJS compiles your DOM with the model to produce a semantic web page.\r\n\r\n**Your HTML source is no longer semantic, instead, your API and compiled DOM are semantic.**\r\n\r\nIn AngularJS, meaning lives in the model, the HTML is just a template, for display only.\r\n\r\nAt this point you likely have all sorts of questions concerning [SEO][5] and accessibility, and rightly so. There are open issues here. Most screen readers will now parse JavaScript. Search engines can also index [AJAXed][6] content. Nevertheless, you will want to make sure you are using pushstate URLs and you have a decent sitemap. See here for a discussion of the issue: https://stackoverflow.com/a/23245379/687677\r\n\r\n\r\n\r\n## Separation of concerns (SOC) vs. MVC\r\n\r\n[Separation of concerns][7] (SOC) is a pattern that grew up over many years of web development for a variety of reasons including SEO, accessibility and browser incompatibility. It looks like this:\r\n\r\n1. HTML - Semantic meaning. The HTML should stand alone.\r\n2. CSS - Styling, without the CSS the page is still readable.\r\n3. JavaScript - Behaviour, without the script the content remains.\r\n\r\nAgain, AngularJS does not play by their rules. In a stroke, **AngularJS does away with a decade of received wisdom** and instead implements an MVC pattern in which the template is no longer semantic, not even a little bit.\r\n\r\nIt looks like this:\r\n\r\n1. Model - your models contains your semantic data. Models are usually [JSON][8] objects. Models exist as attributes of an object called $scope. You can also store handy utility functions on $scope which your templates can then access.\r\n2. View - Your views are written in HTML. The view is usually not semantic because your data lives in the model.\r\n3. Controller - Your controller is a JavaScript function which hooks the view to the model. Its function is to initialise $scope. Depending on your application, you may or may not need to create a controller. You can have many controllers on a page.\r\n\r\nMVC and SOC are not on opposite ends of the same scale, they are on completely different axes. SOC makes no sense in an AngularJS context. You have to forget it and move on.\r\n\r\nIf, like me, you lived through the browser wars, you might find this idea quite offensive. Get over it, it&#39;ll be worth it, I promise.\r\n\r\n\r\n\r\n## Plugins vs. Directives\r\n\r\n**Plugins extend jQuery. AngularJS Directives extend the capabilities of your browser.**\r\n\r\nIn jQuery we define plugins by adding functions to the jQuery.prototype. We then hook these into the DOM by selecting elements and calling the plugin on the result. The idea is to extend the capabilities of jQuery.\r\n\r\nFor example, if you want a carousel on your page, you might define an unordered list of figures, perhaps wrapped in a nav element. You might then write some jQuery to select the list on the page and restyle it as a gallery with timeouts to do the sliding animation.\r\n\r\nIn AngularJS, we define directives. A directive is a function which returns a JSON object. This object tells AngularJS what DOM elements to look for, and what changes to make to them. Directives are hooked in to the template using either attributes or elements, which you invent. The idea is to extend the capabilities of HTML with new attributes and elements.\r\n\r\n*The AngularJS way is to extend the capabilities of native looking HTML.* You should write HTML that looks like HTML, extended with custom attributes and elements.\r\n\r\nIf you want a carousel, just use a `&lt;carousel /&gt;` element, then define a directive to pull in a template, and make that sucker work.\r\n\r\n## Lots of small directives vs. big plugins with configuration switches\r\n\r\nThe tendency with jQuery is to write great big plugins like lightbox which we then configure by passing in numerous values and options.\r\n\r\nThis is a mistake in AngularJS.\r\n\r\nTake the example of a dropdown. When writing a dropdown plugin you might be tempted to code in click handlers, perhaps a function to add in a chevron which is either up or down, perhaps change the class of the unfolded element, show hide the menu, all helpful stuff.\r\n\r\nUntil you want to make a small change.\r\n\r\nSay you have a menu that you want to unfold on hover. Well now we have a problem. Our plugin has wired in our click handler for us, we&#39;re going to need to add a configuration option to make it behave differently in this specific case.\r\n\r\nIn AngularJS we write smaller directives. Our dropdown directive would be ridiculously small. It might maintain the folded state, and provide methods to fold(), unfold() or toggle(). These methods would simply update $scope.menu.visible which is a boolean holding the state.\r\n\r\nNow **in our template** we can wire this up:\r\n\r\n    &lt;a ng-click=&quot;toggle()&quot;&gt;Menu&lt;/a&gt;\r\n    &lt;ul ng-show=&quot;menu.visible&quot;&gt;\r\n      ...\r\n    &lt;/ul&gt;\r\n\r\nNeed to update on mouseover?\r\n\r\n\r\n    &lt;a ng-mouseenter=&quot;unfold()&quot; ng-mouseleave=&quot;fold()&quot;&gt;Menu&lt;/a&gt;\r\n    &lt;ul ng-show=&quot;menu.visible&quot;&gt;\r\n      ...\r\n    &lt;/ul&gt;\r\n\r\nThe template drives the application so we get HTML level granularity. If we want to make case by case exceptions, the template makes this easy.\r\n\r\n\r\n\r\n## Closure vs. $scope\r\n\r\nJQuery plugins are created in a closure. Privacy is maintained within that closure. It&#39;s up to you to maintain your scope chain within that closure. You only really have access to the set of DOM nodes passed in to the plugin by jQuery, plus any local variables defined in the closure and any globals you have defined. This means that plugins are quite self contained. This is a good thing, but can get restrictive when creating a whole application. Trying to pass data between sections of a dynamic page becomes a chore.\r\n\r\nAngularJS has $scope objects. These are special objects created and maintained by AngularJS in which you store your model. Certain directives will spawn a new $scope, which by default inherits from its wrapping $scope using JavaScript prototypical inheritance. The $scope object is accessible in the controller and the view.\r\n\r\nThis is the clever part. Because the structure of $scope inheritance roughly follows the structure of the DOM, elements have access to their own scope, and any containing scopes seamlessly, all the way up to the global $scope (which is not the same as the global scope).\r\n\r\nThis makes it much easier to pass data around, and to store data at an appropriate level. If a dropdown is unfolded, only the dropdown $scope needs to know about it. If the user updates their preferences, you might want to update the global $scope, and any nested scopes listening to the user preferences would automatically be alerted.\r\n\r\nThis might sound complicated, in fact, once you relax into it, it&#39;s like flying. You don&#39;t need to create the $scope object, AngularJS instantiates and configures it for you, correctly and appropriately based on your template hierarchy. AngularJS then makes it available to your component using the magic of dependency injection (more on this later).\r\n\r\n\r\n\r\n## Manual DOM changes vs. Data Binding\r\n\r\nIn jQuery you make all your DOM changes by hand. You construct new DOM elements programatically. If you have a JSON array and you want to put it to the DOM, you must write a function to generate the HTML and insert it.\r\n\r\nIn AngularJS you can do this too, but you are encouraged to make use of data binding. Change your model, and because the DOM is bound to it via a template your DOM will automatically update, no intervention required.\r\n\r\nBecause data binding is done from the template, using either an attribute or the curly brace syntax, it&#39;s super easy to do. There&#39;s little cognitive overhead associated with it so you&#39;ll find yourself doing it all the time.\r\n\r\n    &lt;input ng-model=&quot;user.name&quot; /&gt;\r\n\r\nBinds the input element to `$scope.user.name`. Updating the input will update the value in your current scope, and vice-versa.\r\n\r\nLikewise:\r\n\r\n    &lt;p&gt;\r\n      {{user.name}}\r\n    &lt;/p&gt;\r\n\r\nwill output the user name in a paragraph. It&#39;s a live binding, so if the `$scope.user.name` value is updated, the template will update too.\r\n\r\n\r\n\r\n## Ajax all of the time\r\n\r\nIn jQuery making an Ajax call is fairly simple, but it&#39;s still something you might think twice about. There&#39;s the added complexity to think about, and a fair chunk of script to maintain.\r\n\r\nIn AngularJS, Ajax is your default go-to solution and it happens all the time, almost without you noticing. You can include templates with ng-include. You can apply a template with the simplest custom directive. You can wrap an Ajax call in a service and create yourself a [GitHub][9] service, or a [Flickr][10] service, which you can access with astonishing ease.\r\n\r\n\r\n\r\n## Service Objects vs Helper Functions\r\n\r\nIn jQuery, if we want to accomplish a small non-dom related task such as pulling a feed from an API, we might write a little function to do that in our closure. That&#39;s a valid solution, but what if we  want to access that feed often? What if we want to reuse that code in another application?\r\n\r\nAngularJS gives us service objects.\r\n\r\nServices are simple objects that contain functions and data. They are always singletons, meaning there can never be more than one of them. Say we want to access the Stack Overflow API, we might write a `StackOverflowService` which defines methods for doing so.\r\n\r\nLet&#39;s say we have a shopping cart. We might define a ShoppingCartService which maintains our cart and contains methods for adding and removing items. Because the service is a singleton, and is shared by all other components, any object that needs to can write to the shopping cart and pull data from it. It&#39;s always the same cart.\r\n\r\nService objects are self-contained AngularJS components which we can use and reuse as we see fit. They are simple JSON objects containing functions and Data. They are always singletons, so if you store data on a service in one place, you can get that data out somewhere else just by requesting the same service.\r\n\r\n\r\n## [Dependency injection][11] (DI) vs. Instatiation - aka de-spaghettification\r\n\r\nAngularJS manages your dependencies for you. If you want an object, simply refer to it and AngularJS will get it for you.\r\n\r\nUntil you start to use this, it&#39;s hard to explain just what a massive time boon this is. Nothing like AngularJS DI exists inside jQuery.\r\n\r\nDI means that instead of writing your application and wiring it together, you instead define a library of components, each identified by a string.\r\n\r\nSay I have a component called &#39;FlickrService&#39; which defines methods for pulling JSON feeds from Flickr. Now, if I want to write a controller that can access Flickr, I just need to refer to the &#39;FlickrService&#39; by name when I declare the controller. AngularJS will take care of instantiating the component and making it available to my controller.\r\n\r\nFor example, here I define a service:\r\n\r\n    myApp.service(&#39;FlickrService&#39;, function() {\r\n      return {\r\n        getFeed: function() { // do something here }\r\n      }\r\n    });\r\n\r\nNow when I want to use that service I just refer to it by name like this:\r\n\r\n    myApp.controller(&#39;myController&#39;, [&#39;FlickrService&#39;, function(FlickrService) {\r\n      FlickrService.getFeed()\r\n    }]);\r\n\r\nAngularJS will recognise that a FlickrService object is needed to instantiate the controller, and will provide one for us.\r\n\r\nThis makes wiring things together very easy, and pretty much eliminates any tendency towards spagettification. We have a flat list of components, and AngularJS hands them to us one by one as and when we need them.\r\n\r\n\r\n\r\n## Modular service architecture\r\n\r\njQuery says very little about how you should organise your code. AngularJS has opinions.\r\n\r\nAngularJS gives you modules into which you can place your code. If you&#39;re writing a script that talks to Flickr for example, you might want to create a Flickr module to wrap all your Flickr related functions in. Modules can include other modules (DI). Your main application is usually a module, and this should include all the other modules your application will depend on.\r\n\r\nYou get simple code reuse, if you want to write another application based on Flickr, you can just include the Flickr module and voila, you have access to all your Flickr related functions in your new application.\r\n\r\nModules contain AngularJS components. **When we include a module, all the components in that module become available to us as a simple list identified by their unique strings**. We can then inject those components into each other using AngularJS&#39;s dependency injection mechanism.\r\n\r\n\r\n## To sum up\r\n\r\nAngularJS and jQuery are not enemies. It&#39;s possible to use jQuery within AngularJS very nicely. If you&#39;re using AngularJS well (templates, data-binding, $scope, directives, etc.) you will find you need a **lot** less jQuery than you might otherwise require.\r\n\r\nThe main thing to realise is that your template drives your application. Stop trying to write big plugins that do everything. Instead write little directives that do one thing, then write a simple template to wire them together.\r\n\r\nThink less about unobtrusive JavaScript, and instead think in terms of HTML extensions.\r\n\r\n\r\n\r\n## My little book\r\n\r\nI got so excited about AngularJS, I wrote a short book on it which you&#39;re very welcome to read online &lt;http://nicholasjohnson.com/angular-book/&gt;. I hope it&#39;s helpful.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Domain-specific_language\r\n  [2]: http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\r\n  [3]: http://en.wikipedia.org/wiki/XSLT\r\n  [4]: http://en.wikipedia.org/wiki/Ruby_on_Rails\r\n  [5]: http://en.wikipedia.org/wiki/Search_engine_optimization\r\n  [6]: http://en.wikipedia.org/wiki/Ajax_%28programming%29\r\n  [7]: http://en.wikipedia.org/wiki/Separation_of_concerns\r\n  [8]: http://en.wikipedia.org/wiki/JSON\r\n  [9]: http://en.wikipedia.org/wiki/GitHub\r\n  [10]: http://en.wikipedia.org/wiki/Flickr\r\n  [11]: http://en.wikipedia.org/wiki/Dependency_injection\r\n"},{"score":46,"body_markdown":"Those are some very nice, but lengthy answers.\r\n\r\nTo sum up my experiences:\r\n\r\n1. Controllers and providers (services, factories, etc.) are for modifying the data model, NOT HTML.\r\n2. HTML and directives define the layout and binding to the model.\r\n3. If you need to share data between controllers, create a service or factory - they are singletons that are shared across the application.\r\n4. If you need an HTML widget, create a directive.\r\n5. **If you have some data and are now trying to update HTML... STOP! update the model, and make sure your HTML is bound to the model.**\r\n"},{"score":20,"body_markdown":"As a JavaScript MV* beginner and purely focusing on the application architecture (not the server/client-side matters), I would certainly recommend the following resource (which I am surprised wasn&#39;t mentioned yet): [JavaScript Design Patterns][1], by Addy Osmani, as an introduction to different **JavaScript Design Patterns**. The terms used in this answer are taken from the linked document above. I&#39;m not going to repeat what was worded really well in the accepted answer. Instead, this answer links back to the **theoretical backgrounds** which power AngularJS (and other libraries).\r\n\r\nLike me, you will quickly realize that AngularJS (or [Ember.js][2], Durandal, &amp; other MV* frameworks for that matter) is one complex framework assembling many of the different JavaScript design patterns.\r\n\r\nI found it easier also, to test **(1)** native JavaScript code and **(2)** smaller libraries for each one of these patterns **separately** before diving into one global framework. This allowed me to better understand which crucial issues a framework adresses (because you are personally faced with the problem).\r\n\r\nFor example:\r\n\r\n - [JavaScript Object-oriented Programming](https://www.google.be/search?q=js+oop) (this is a Google search link). It is not a library, but certainly a prerequisite to any application programming. It taught me the native implementations of the **prototype, constructor, singleton &amp; decorator patterns**\r\n - [jQuery](http://jquery.com)/ [Underscore](http://underscorejs.org) for the **facade pattern** (like WYSIWYG&#39;s for manipulating the DOM)\r\n - [Prototype.js](http://prototypejs.org) for the **prototype/ constructor/ mixin pattern**\r\n - [RequireJS](http://requirejs.org)/ [Curl.js](https://github.com/cujojs/curl) for the **module pattern/ AMD**\r\n - [KnockoutJS](http://knockoutjs.com) for the **observable, publish/subscribe pattern**\r\n\r\nNB: This list is not complete, nor &#39;the best libraries&#39;; they just happen to be the libraries I used. These libraries also include more patterns, the ones mentioned are just their main focuses or original intents. If you feel something is missing from this list, please do mention it in the comments, and I will be glad to add it.\r\n\r\n  [1]: http://addyosmani.com/resources/essentialjsdesignpatterns/book/\r\n  [2]: http://en.wikipedia.org/wiki/Ember.js\r\n"},{"score":12,"body_markdown":"Actually, if you&#39;re using AngularJS, you don&#39;t need jQuery anymore. AngularJS itself has the binding and directive, which is a very good &quot;replacement&quot; for most things you can do with jQuery.\r\n\r\nI usually develop mobile applications using AngularJS and [Cordova][1]. The ONLY thing from jQuery I needed is the Selector.\r\n\r\nBy googling, I see that there is a standalone jQuery selector module out there. It&#39;s Sizzle. \r\n\r\nAnd I decided to make a tiny code snippet that help me quickly start a website using AngularJS with the power of jQuery Selector (using Sizzle).\r\n\r\nI shared my code here: https://github.com/huytd/Sizzular\r\n\r\n  [1]: http://en.wikipedia.org/wiki/PhoneGap\r\n"},{"score":23,"body_markdown":"**AngularJS and jQuery:**\r\n\r\nAngularJs and JQuery are completely different at every level except the JQLite functionality and you will see it once you start learning the AngularJs core features (I explained it below).\r\n\r\nAngularJs is a client side framework that offers to build the independent client side application. JQuery is a client side library that play around the DOM.\r\n\r\nAngularJs Cool Principle - If you want some changes on your UI think from model data change perspective. Change your data and UI will re-render itself. You need not to play around DOM each time unless and until it is hardly required and that should also be handled through Angular Directives.\r\n\r\nTo answer this question, I want to share my experience on the first enterprise application with AngularJS. These are the most awesome features that Angular provide where we start changing our jQuery mindset and we get the Angular like a framework and not the library.\r\n\r\n\r\n**Two-way data binding is amazing:** \r\nI had a grid with all functionality UPDATE, DELTE, INSERT. I have a data object that binds the grid&#39;s model using ng-repeat. You only need to write a single line of simple JavaScript code for delete and insert and that&#39;s it. grid automatically updates as the grid model changes instantly. Update functionality is real time, no code for it.\r\nYou feel amazing!!!\r\n\r\n**Reusable directives are super:**\r\nWrite directives in one place and use it throughout the application. OMG!!! I used these directive for paging, regex, validations, etc. It is really cool!\r\n\r\n**Routing is strong:**\r\nIt&#39;s up to your implementation how you want to use it, but it requires very few lines of code to route the request to specify HTML and controller (JavaScript)\r\n\r\n\r\n**Controllers are great:**\r\nControllers take care of their own HTML, but this separation works well for common functionality well as. If you want to call the same function on the click of a button on master HTML, just write the same function name in each controller and write individual code.\r\n\r\n**Plugins:**\r\nThere are many other similar features like showing an overlay in your app. You don&#39;t need to write code for it, just use an overlay plugin available as wc-overlay, and this will automatically take care of all [XMLHttpRequest][1] (XHR) requests.\r\n\r\n**Ideal for [RESTful][2] architecture:**\r\nBeing a complete frameworks makes AngularJS great to work with a RESTful architecture. To call REST CRUD APIs is very easier and \r\n\r\n  [1]: http://en.wikipedia.org/wiki/XMLHttpRequest\r\n  [2]: http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services\r\n\r\n**Services**: Write common codes using services and less code in controllers. Sevices can be used to share common functionalities among the controllers.\r\n\r\n**Extensibility**: Angular has extended the HTML directives using angular directives. Write expressions inside html and evaluate them on runtime. Create your own directives and services and use them in another project without any extra effort.\r\n"}],"score":4512}