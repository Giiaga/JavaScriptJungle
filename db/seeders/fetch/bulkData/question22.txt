{"body":"Why does Google prepend `while(1);` to their (private) JSON responses?\r\n\r\nFor example, here&#39;s a response while turning a calendar on and off in [Google Calendar][1]:\r\n\r\n```\r\nwhile (1);\r\n[\r\n  [&#39;u&#39;, [\r\n    [&#39;smsSentFlag&#39;, &#39;false&#39;],\r\n    [&#39;hideInvitations&#39;, &#39;false&#39;],\r\n    [&#39;remindOnRespondedEventsOnly&#39;, &#39;true&#39;],\r\n    [&#39;hideInvitations_remindOnRespondedEventsOnly&#39;, &#39;false_true&#39;],\r\n    [&#39;Calendar ID stripped for privacy&#39;, &#39;false&#39;],\r\n    [&#39;smsVerifiedFlag&#39;, &#39;true&#39;]\r\n  ]]\r\n]\r\n```\r\n\r\nI would assume this is to prevent people from doing an `eval()` on it, but all you&#39;d really have to do is replace the `while` and then you&#39;d be set. I would assume the eval prevention is to make sure people write safe JSON parsing code.\r\n\r\nI&#39;ve seen this used in a couple of other places, too, but a lot more so with Google (Mail, Calendar, Contacts, etc.) Strangely enough, [Google Docs][2] starts with `&amp;&amp;&amp;START&amp;&amp;&amp;` instead, and Google Contacts seems to start with `while(1); &amp;&amp;&amp;START&amp;&amp;&amp;`.\r\n\r\nWhat&#39;s going on here?\r\n\r\n  [1]: https://calendar.google.com/calendar/about/\r\n  [2]: https://www.google.com/docs/about/\r\n","title":"Why does Google prepend while(1); to their JSON responses?","answers":[{"score":376,"body_markdown":"This is to ensure some other site can&#39;t do nasty tricks to try to steal your data. For example, by [replacing the array constructor][1], then including this JSON URL via a `&lt;script&gt;` tag, a malicious third-party site could steal the data from the JSON response. By putting a `while(1);` at the start, the script will hang instead.\r\n\r\nA same-site request using XHR and a separate JSON parser, on the other hand, can easily ignore the `while(1);` prefix.\r\n\r\n  [1]: http://ejohn.org/blog/re-securing-json/"},{"score":82,"body_markdown":"**Note**: as of 2019, many of the old vulnerabilities that lead to the preventative measures discussed in this question are no longer an issue in modern browsers.  I&#39;ll leave the answer below as a historical curiosity, but really the whole topic has changed radically since 2010 (!!) when this was asked.\r\n\r\n&lt;hr&gt;\r\n\r\nIt prevents it from being used as the target of a simple `&lt;script&gt;` tag. (Well, it doesn&#39;t prevent it, but it makes it unpleasant.)  That way bad guys can&#39;t just put that script tag in their own site and rely on an active session to make it possible to fetch your content.\r\n\r\n*edit* &amp;mdash; note the comment (and other answers). The issue has to do with subverted built-in facilities, specifically the `Object` and `Array` constructors. Those can be altered such that otherwise innocuous JSON, when parsed, could trigger attacker code."},{"score":112,"body_markdown":"That would be to make it difficult for a third-party to insert the JSON response into an HTML document with the `&lt;script&gt;` tag. Remember that the `&lt;script&gt;` tag is exempt from the [Same Origin Policy][1].\r\n\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Same_origin_policy\r\n"},{"score":4368,"body_markdown":"It prevents [JSON hijacking](http://haacked.com/archive/2009/06/25/json-hijacking.aspx), a major JSON security issue that is formally [fixed][1] in all major browsers [since 2011][2] with ECMAScript 5.\r\n\r\nContrived example: say Google has a URL like `mail.google.com/json?action=inbox` which returns the first 50 messages of your inbox in JSON format. Evil websites on other domains can&#39;t make AJAX requests to get this data due to the same-origin policy, but they can include the URL via a `&lt;script&gt;` tag. The URL is visited with *your* cookies, and by [overriding the global array constructor or accessor methods](http://ejohn.org/blog/re-securing-json/) they can have a method called whenever an object (array or hash) attribute is set, allowing them to read the JSON content.\r\n\r\nThe `while(1);` or `&amp;&amp;&amp;BLAH&amp;&amp;&amp;` prevents this: an AJAX request at `mail.google.com` will have full access to the text content, and can strip it away. But a `&lt;script&gt;` tag insertion blindly executes the JavaScript without any processing, resulting in either an infinite loop or a syntax error.\r\n\r\nThis does not address the issue of [cross-site request forgery][3].\r\n\r\n\r\n  [1]: https://security.stackexchange.com/questions/155518/why-json-hijacking-attack-doesnt-work-in-modern-browsers-how-was-it-fixed\r\n  [2]: https://caniuse.com/#feat=es5\r\n  [3]: https://en.wikipedia.org/wiki/Cross-site_request_forgery"},{"score":595,"body_markdown":"It prevents disclosure of the response through JSON hijacking.\r\n\r\nIn theory, the content of HTTP responses are protected by the Same Origin Policy: pages from one domain cannot get any pieces of information from pages on the other domain (unless explicitly allowed).\r\n\r\nAn attacker can request pages on other domains on your behalf, e.g. by using a `&lt;script src=...&gt;` or `&lt;img&gt;` tag, but it can&#39;t get any information about the result (headers, contents).\r\n\r\nThus, if you visit an attacker&#39;s page, it couldn&#39;t read your email from gmail.com.\r\n\r\nExcept that when using a script tag to request JSON content, the JSON is executed as JavaScript in an attacker&#39;s controlled environment. If the attacker can replace the Array or Object constructor or some other method used during object construction, anything in the JSON would pass through the attacker&#39;s code, and be disclosed.  \r\n\r\nNote that this happens at the time the JSON is executed as JavaScript, not at the time it&#39;s parsed.\r\n\r\nThere are multiple countermeasures:\r\n\r\n# Making sure the JSON never executes\r\n\r\nBy placing a `while(1);` statement before the JSON data, Google makes sure that the JSON data is never executed as JavaScript.\r\n\r\nOnly a legitimate page could actually get the whole content, strip the `while(1);`, and parse the remainder as JSON.\r\n\r\nThings like `for(;;);` have been seen at Facebook for instance, with the same results.\r\n\r\n# Making sure the JSON is not valid JavaScript\r\n\r\nSimilarly, adding invalid tokens before the JSON, like `&amp;&amp;&amp;START&amp;&amp;&amp;`, makes sure that it is never executed.\r\n\r\n# Always return JSON with an Object on the outside\r\n\r\nThis is [OWASP recommended way](https://www.owasp.org/index.php/OWASP_AJAX_Security_Guidelines#Always_return_JSON_with_an_Object_on_the_outside) to protect from JSON hijacking and is the less intrusive one.\r\n\r\nSimilarly to the previous counter-measures, it makes sure that the JSON is never executed as JavaScript.\r\n\r\nA valid JSON object, when not enclosed by anything, is not valid in JavaScript:\r\n\r\n    eval(&#39;{&quot;foo&quot;:&quot;bar&quot;}&#39;)\r\n    // SyntaxError: Unexpected token :\r\n\r\nThis is however valid JSON:\r\n\r\n    JSON.parse(&#39;{&quot;foo&quot;:&quot;bar&quot;}&#39;)\r\n    // Object {foo: &quot;bar&quot;}\r\n\r\nSo, making sure you always return an Object at the top level of the response makes sure that the JSON is not valid JavaScript, while still being valid JSON.\r\n\r\nAs noted by @hvd in the comments, the empty object `{}` is valid JavaScript, and knowing the object is empty may itself be valuable information.\r\n\r\n# Comparison of above methods\r\n\r\nThe OWASP way is less intrusive, as it needs no client library changes, and transfers valid JSON. It is unsure whether past or future browser bugs could defeat this, however.  As noted by @oriadam, it is unclear whether data could be leaked in a parse error through an error handling or not (e.g. window.onerror).\r\n\r\nGoogle&#39;s way requires a client library in order for it to support automatic de-serialization and can be considered to be safer with regard to browser bugs.\r\n\r\nBoth methods require server side changes in order to avoid developers accidentally sending vulnerable JSON."},{"score":11,"body_markdown":"Since the `&lt;script&gt;` tag is exempted from the Same Origin Policy which is a security necessity in the web world, `while(1)` when added to the JSON response prevents misuse of it in the `&lt;script&gt;` tag. "},{"score":0,"body_markdown":"&gt; After authentication is in place, JSON hijacking protection can take a\r\n&gt; variety of forms. Google appends **while(1)** into their JSON data, so\r\n&gt; that if any malicious script evaluates it, the malicious script enters\r\n&gt; an infinite loop.\r\n\r\nReference: [Web Security Testing Cookbook: Systematic Techniques to Find Problems Fast](https://books.google.co.nz/books?id=VmrSJ3V-s_MC&amp;lpg=PA214&amp;ots=cXaR_XGXSH&amp;dq=google%20while(1)&amp;pg=PA214#v=onepage&amp;q=google%20while(1)&amp;f=false)\r\n\r\n"}],"score":4170}