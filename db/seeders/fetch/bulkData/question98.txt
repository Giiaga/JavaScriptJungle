{"body":"How can I determine whether a variable is a string or something else in JavaScript?","title":"Check if a variable is a string in JavaScript","answers":[{"score":1872,"body_markdown":"You can use `typeof` operator:\r\n\r\n    var booleanValue = true; \r\n    var numericalValue = 354;\r\n    var stringValue = &quot;This is a String&quot;;\r\n    var stringObject = new String( &quot;This is a String Object&quot; );\r\n    alert(typeof booleanValue) // displays &quot;boolean&quot;\r\n    alert(typeof numericalValue) // displays &quot;number&quot;\r\n    alert(typeof stringValue) // displays &quot;string&quot;\r\n    alert(typeof stringObject) // displays &quot;object&quot;\r\n\r\nExample from [this webpage][1]. (Example was slightly modified though).\r\n\r\nThis won&#39;t work as expected in the case of strings created with `new String()`, but this is seldom used and recommended against&lt;sup&gt;\\[1\\]\\[2\\]&lt;/sup&gt;. See the other answers for how to handle these, if you so desire.\r\n\r\n---\r\n\r\n1. The Google JavaScript Style Guide [says to never use primitive object wrappers](https://google.github.io/styleguide/jsguide.html#disallowed-features-wrapper-objects).\r\n2. Douglas Crockford [recommended that primitive object wrappers be deprecated](http://www.crockford.com/javascript/recommend.html).\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"},{"score":2050,"body_markdown":"This is what works for me:\r\n\r\n    if (typeof myVar === &#39;string&#39; || myVar instanceof String)\r\n    // it&#39;s a string\r\n    else\r\n    // it&#39;s something else"},{"score":32,"body_markdown":"Best way:\n\n    var s = &#39;String&#39;;\n    var a = [1,2,3];\n    var o = {key: &#39;val&#39;};\n    \n    (s.constructor === String) &amp;&amp; console.log(&#39;its a string&#39;);\n    (a.constructor === Array) &amp;&amp; console.log(&#39;its an array&#39;);\n    (o.constructor === Object) &amp;&amp; console.log(&#39;its an object&#39;);\n    (o.constructor === Number || s.constructor === Boolean) &amp;&amp; console.log(&#39;this won\\&#39;t run&#39;);\n\nEach of these has been constructed by its appropriate class function, like &quot;new Object()&quot; etc.\n\nAlso, Duck-Typing:\n&quot;If it looks like a duck, walks like a duck, and smells like a duck - it must be an Array&quot;\nMeaning, check its properties.\n\nHope this helps.\n\n### Edit; 12/05/2016\nRemember, you can always use combinations of approaches too. Here&#39;s an example of using an *inline map* of actions with *typeof*:\n\n    var type = { &#39;number&#39;: Math.sqrt.bind(Math), ... }[ typeof datum ];\n\nHere&#39;s a more &#39;real world&#39; example of using inline-maps:\n\n    function is(datum) {\n        var isnt = !{ null: true, undefined: true, &#39;&#39;: true, false: false, 0: false }[ datum ];\n        return !isnt;\n    }\n    console.log( is(0), is(false), is(undefined), ... );  // &gt;&gt; true true false\n\nThis function would use [ custom ] &quot;type-casting&quot; -- rather, &quot;type-/-value-mapping&quot; -- to figure out if a variable actually &quot;exists&quot;. Now you can split that nasty hair between `null` &amp; `0`!\n\nMany times *you don&#39;t even care about its type*. Another way to circumvent typing is combining Duck-Type sets:\n    \n    this.id = &quot;998&quot;;  // use a number or a string-equivalent\n    function get(id) {\n        if (!id || !id.toString) return;\n        if (id.toString() === this.id.toString()) http( id || +this.id );\n        // if (+id === +this.id) ...;\n    }\n\nBoth `Number.prototype` **and** `String.prototype` have a `.toString() method`. You just made sure that the string-equivalent of the number was the same, and then you made sure that you passed it into the `http` function as a `Number`. In other words, we didn&#39;t even *care* what its type was.\n\nHope that gives you more to work with :)"},{"score":180,"body_markdown":"Since 580+ people have voted for an incorrect answer, and 800+ have voted for a working but shotgun-style answer, I thought it might be worth redoing my answer in a simpler form that everybody can understand.\r\n\r\n    function isString(x) {\r\n      return Object.prototype.toString.call(x) === &quot;[object String]&quot;\r\n    }\r\n\r\nOr, inline (I have an UltiSnip setup for this):\r\n\r\n    Object.prototype.toString.call(myVar) === &quot;[object String]&quot;\r\n\r\nFYI, Pablo Santa Cruz&#39;s answer is wrong, because `typeof new String(&quot;string&quot;)` is `object`\r\n\r\nDRAX&#39;s answer is accurate and functional, and should be the correct answer (since Pablo Santa Cruz is most definitely incorrect, and I won&#39;t argue against the popular vote.)\r\n\r\nHowever, this answer is also definitely correct, and actually the best answer (except, perhaps, for the suggestion of using [lodash][1]/[underscore][2]). _disclaimer: I contributed to the lodash 4 codebase._\r\n\r\nMy original answer (which obviously flew right over a lot of heads) follows: \r\n\r\nI transcoded this from underscore.js:\r\n\r\n    [&#39;Arguments&#39;, &#39;Function&#39;, &#39;String&#39;, &#39;Number&#39;, &#39;Date&#39;, &#39;RegExp&#39;].forEach( \r\n        function(name) { \r\n            window[&#39;is&#39; + name] = function(obj) {\r\n                  return toString.call(obj) == &#39;[object &#39; + name + &#39;]&#39;;\r\n        }; \r\n    });\r\n\r\nThat will define isString, isNumber, etc.\r\n\r\n---\r\n\r\nIn Node.js, this can be implemented as a module:\r\n\r\n    module.exports = [\r\n      &#39;Arguments&#39;,\r\n      &#39;Function&#39;, \r\n      &#39;String&#39;, \r\n      &#39;Number&#39;, \r\n      &#39;Date&#39;, \r\n      &#39;RegExp&#39;\r\n    ].reduce( (obj, name) =&gt; {\r\n      obj[ &#39;is&#39; + name ] = x =&gt; toString.call(x) == &#39;[object &#39; + name + &#39;]&#39;;\r\n      return obj;\r\n    }, {});\r\n\r\n[edit]: `Object.prototype.toString.call(x)` works to delineate between functions and async functions as well:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const fn1 = () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve({}), 1000))\r\n    const fn2 = async () =&gt; ({})\r\n\r\n    console.log(&#39;fn1&#39;, Object.prototype.toString.call(fn1))\r\n    console.log(&#39;fn2&#39;, Object.prototype.toString.call(fn2))\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n[1]: https://lodash.com/\r\n[2]: http://underscorejs.org/"},{"score":6,"body_markdown":"I also found that this works fine too, and its a lot shorter than the other examples.\r\n\r\n    if (myVar === myVar + &#39;&#39;) {\r\n       //its string\r\n    } else {\r\n       //its something else\r\n    }\r\n\r\nBy concatenating on empty quotes it turns the value into a string. If &lt;code&gt;myVar&lt;/code&gt; is already a string then the if statement is successful."},{"score":84,"body_markdown":"I recommend using the built-in functions from **jQuery** or **lodash/Underscore**.  They&#39;re simpler to use and easier to read.\r\n\r\nEither function will handle the case DRAX mentioned...  that is, they *both* check if (A) the variable is a string literal or (B) it&#39;s an instance of the String object.  In either case, these functions correctly identify the value as being a string.\r\n\r\n**lodash / Underscore.js**\r\n\r\n    if(_.isString(myVar))\r\n       //it&#39;s a string\r\n    else\r\n       //it&#39;s something else\r\n\r\n**jQuery**\r\n\r\n    if($.type(myVar) === &quot;string&quot;)\r\n       //it&#39;s a string\r\n    else\r\n       //it&#39;s something else\r\n    \r\nSee [lodash Documentation for _.isString()][1] for more details.\r\n\r\nSee [jQuery Documentation for $.type()][2] for more details.\r\n\r\n\r\n  [1]: https://lodash.com/docs#isString\r\n  [2]: http://api.jquery.com/jQuery.type/\r\n"},{"score":36,"body_markdown":"    function isString (obj) {\r\n      return (Object.prototype.toString.call(obj) === &#39;[object String]&#39;);\r\n    }\r\n\r\n\r\nI saw that here:\r\n\r\nhttp://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/"},{"score":1,"body_markdown":"Just to expand on @DRAX&#39;s [answer][1], I&#39;d do this:\r\n\r\n    function isWhitespaceEmptyString(str)\r\n    {\r\n    \t//RETURN:\r\n    \t//\t\t= &#39;true&#39; if &#39;str&#39; is empty string, null, undefined, or consists of white-spaces only\r\n    \treturn str ? !(/\\S/.test(str)) : (str === &quot;&quot; || str === null || str === undefined);\r\n    }\r\n\r\nIt will account also for `null`s and `undefined` types, and it will take care of non-string types, such as `0`.\r\n\r\n\r\n  [1]: https://stackoverflow.com/a/9436948/670017"},{"score":3,"body_markdown":"A simple solution would be:\r\n\r\n    var x = &quot;hello&quot;\r\n\r\n    if(x === x.toString()){\r\n    // it&#39;s a string \r\n    }else{\r\n    // it isn&#39;t\r\n    }"},{"score":8,"body_markdown":"Taken from lodash:\r\n\r\n    function isString(val) {\r\n\t   return typeof val === &#39;string&#39; || ((!!val &amp;&amp; typeof val === &#39;object&#39;) &amp;&amp; Object.prototype.toString.call(val) === &#39;[object String]&#39;);\r\n    }\r\n\r\n    console.log(isString(&#39;hello world!&#39;)); // true\r\n    console.log(isString(new String(&#39;hello world&#39;))); // true\r\n"},{"score":3,"body_markdown":"\r\n    var a = new String(&#39;&#39;)\r\n    var b = &#39;&#39;\r\n    var c = []\r\n    \r\n    function isString(x) {\r\n      return x !== null &amp;&amp; x !== undefined &amp;&amp; x.constructor === String\r\n    }\r\n    \r\n    console.log(isString(a))\r\n    console.log(isString(b))\r\n    console.log(isString(c))\r\n\r\n"},{"score":5,"body_markdown":"If you work on the node.js environment, you can simply use the built-in function isString in utils.\r\n\r\n    const util = require(&#39;util&#39;);\r\n    if (util.isString(myVar)) {}\r\n\r\n\r\nEdit: as @Jehy mentioned, this is deprecated since v4."},{"score":-2,"body_markdown":"I&#39;m not sure if you mean knowing if it&#39;s a type `string` regardless of its contents, or whether it&#39;s contents is a number or string, regardless of its type.&lt;br&gt;&lt;br&gt;\r\nSo to know if its type is a string, that&#39;s already been answered.\r\n&lt;br&gt;\r\nBut to know based on its contents if its a string or a number, I would use this:\r\n\r\n\r\n    function isNumber(item) {\r\n        return (parseInt(item) + &#39;&#39;) === item;\r\n    }\r\n\r\nAnd for some examples:\r\n\r\n    isNumber(123);   //true\r\n    isNumber(&#39;123&#39;); //true\r\n    isNumber(&#39;123a&#39;);//false\r\n    isNumber(&#39;&#39;);    //false\r\n\r\n"},{"score":16,"body_markdown":"I like to use this simple solution:\r\n\r\n    \r\n\r\n    var myString = &quot;test&quot;;\r\n    if(myString.constructor === String)\r\n    {\r\n         //It&#39;s a string\r\n    }\r\n\r\n"},{"score":16,"body_markdown":"This is a great example of why performance matters:\r\n\r\nDoing something as simple as a test for a string can be expensive if not done correctly.\r\n\r\nFor example, if I wanted to write a function to test if something is a string, I could do it in one of two ways:\r\n\r\n1) `const isString = str =&gt; (Object.prototype.toString.call(str) === &#39;[object String]&#39;);`\r\n\r\n2) `const isString = str =&gt; ((typeof str === &#39;string&#39;) || (str instanceof String));`\r\n\r\nBoth of these are pretty straight forward, so what could possibly impact performance?  Generally speaking, function calls can be expensive, especially if you don&#39;t know what&#39;s happening inside. In the first example, there is a function call to Object&#39;s toString method.  In the second example, there are no function calls, as typeof and instanceof are operators. Operators are significantly faster than function calls.\r\n\r\nWhen the performance is tested, example 1 is 79% slower than example 2!\r\n\r\nSee the tests: https://jsperf.com/isstringtype\r\n"},{"score":4,"body_markdown":"The following method will check if any variable is a string (**including variables that do not exist**).\r\n\r\n    const is_string = value =&gt; {\r\n      try {\r\n        return typeof value() === &#39;string&#39;;\r\n      } catch (error) {\r\n        return false;\r\n      }\r\n    };\r\n    \r\n    let example = &#39;Hello, world!&#39;;\r\n    \r\n    console.log(is_string(() =&gt; example)); // true\r\n    console.log(is_string(() =&gt; variable_doesnt_exist)); // false"},{"score":2,"body_markdown":"This is good enough for me.\r\n\r\n**WARNING:** This is not a perfect solution.\r\nSee the bottom of my post.\r\n\r\n    Object.prototype.isString = function() { return false; };\r\n    String.prototype.isString = function() { return true; };\r\n\r\n    var isString = function(a) {\r\n      return (a !== null) &amp;&amp; (a !== undefined) &amp;&amp; a.isString();\r\n    };\r\n\r\nAnd you can use this like below.\r\n\r\n    //return false\r\n    isString(null);\r\n    isString(void 0);\r\n    isString(-123);\r\n    isString(0);\r\n    isString(true);\r\n    isString(false);\r\n    isString([]);\r\n    isString({});\r\n    isString(function() {});\r\n    isString(0/0);\r\n\r\n    //return true\r\n    isString(&quot;&quot;);\r\n    isString(new String(&quot;ABC&quot;));\r\n\r\n**WARNING:** This works incorrectly in the case:\r\n\r\n    //this is not a string\r\n    var obj = {\r\n        //but returns true lol\r\n        isString: function(){ return true; }\r\n    }\r\n\r\n    isString(obj) //should be false, but true"},{"score":22,"body_markdown":"I can&#39;t honestly see why one would not simply use `typeof` in this case:\r\n\r\n    if (typeof str === &#39;string&#39;) {\r\n      return 42;\r\n    }\r\n\r\nYes it will fail against object-wrapped strings (e.g. `new String(&#39;foo&#39;)`) but these are widely regarded as a bad practice and most modern development tools are likely to discourage their use. *(If you see one, just fix it!)*\r\n\r\nThe `Object.prototype.toString` trick is something that all front-end developers have been found guilty of doing one day in their careers but don&#39;t let it fool you by its polish of clever: it will break as soon as something monkey-patch the Object prototype:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const isString = thing =&gt; Object.prototype.toString.call(thing) === &#39;[object String]&#39;;\r\n\r\n    console.log(isString(&#39;foo&#39;));\r\n\r\n    Object.prototype.toString = () =&gt; 42;\r\n\r\n    console.log(isString(&#39;foo&#39;));\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":2,"body_markdown":"You can use this function to determine the type of anything:\r\n\r\n    var type = function(obj) {\r\n    \treturn Object.prototype.toString.apply(obj).replace(/\\[object (.+)\\]/i, &#39;$1&#39;).toLowerCase();\r\n    };\r\n\r\nTo check if a variable is a string:\r\n\r\n    type(&#39;my string&#39;) === &#39;string&#39; //true\r\n    type(new String(&#39;my string&#39;)) === &#39;string&#39; //true\r\n    type(`my string`) === &#39;string&#39; //true\r\n    type(12345) === &#39;string&#39; //false\r\n    type({}) === &#39;string&#39; // false\r\n\r\nhttps://codepen.io/patodiblasi/pen/NQXPwY?editors=0012\r\n\r\nTo check for other types:\r\n\r\n    type(null) //null\r\n    type(undefined) //undefined\r\n    type([]) //array\r\n    type({}) //object\r\n    type(function() {}) //function\r\n    type(123) //number\r\n    type(new Number(123)) //number\r\n    type(/some_regex/) //regexp\r\n    type(Symbol(&quot;foo&quot;)) //symbol\r\n\r\n"},{"score":7,"body_markdown":"I think that @customcommander solution should suffice in 90% of your cases:\r\n\r\n    typeof str === &#39;string&#39;\r\nShould serve you right (simply since normally there&#39;s no reason to have `new String(&#39;something&#39;)` in your code).\r\n\r\nIf you&#39;re interested in handling the `String` object as well (for example you expect some var from a 3rd party) then using lodash as @ClearCloud8 suggested seems like a clear, simple and elegant solution.\r\n\r\nI would however suggest to be cautious with libraries such as lodash due to their size. Instead of doing\r\n\r\n    import _ from &#39;lodash&#39;\r\n    ...\r\n    _.isString(myVar)\r\nWhich brings the whole huge lodash object, I&#39;d suggest something like:\r\n\r\n    import { isString as _isString } from &#39;lodash&#39;\r\n    ...\r\n    _isString(myVar)\r\nAnd with simple bundling you should be fine (I refer here to client code)."},{"score":4,"body_markdown":"I find this simple technique useful to type-check for **String** -\r\n\r\n    String(x) === x // true, if x is a string\r\n                    // false in every other case\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const test = x =&gt;\r\n      console.assert\r\n        ( String(x) === x\r\n        , `not a string: ${x}`\r\n        )\r\n\r\n    test(&quot;some string&quot;)\r\n    test(123)           // assertion failed\r\n    test(0)             // assertion failed\r\n    test(/some regex/)  // assertion failed\r\n    test([ 5, 6 ])      // assertion failed\r\n    test({ a: 1 })      // assertion failed\r\n    test(x =&gt; x + 1)    // assertion failed\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe same technique works for **Number** too -\r\n\r\n    Number(x) === x // true, if x is a number\r\n                    // false in every other case\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const test = x =&gt;\r\n      console.assert\r\n        ( Number(x) === x\r\n        , `not a number: ${x}`\r\n        )\r\n\r\n    test(&quot;some string&quot;) // assertion failed\r\n    test(123)           \r\n    test(0)             \r\n    test(/some regex/)  // assertion failed\r\n    test([ 5, 6 ])      // assertion failed\r\n    test({ a: 1 })      // assertion failed\r\n    test(x =&gt; x + 1)    // assertion failed\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nAnd for **RegExp** -\r\n\r\n    RegExp(x) === x // true, if x is a regexp\r\n                    // false in every other case\r\n\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const test = x =&gt;\r\n      console.assert\r\n        ( RegExp(x) === x\r\n        , `not a regexp: ${x}`\r\n        )\r\n\r\n    test(&quot;some string&quot;) // assertion failed\r\n    test(123)           // assertion failed\r\n    test(0)             // assertion failed\r\n    test(/some regex/)  \r\n    test([ 5, 6 ])      // assertion failed\r\n    test({ a: 1 })      // assertion failed\r\n    test(x =&gt; x + 1)    // assertion failed\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nSame for **Object** -\r\n\r\n    Object(x) === x // true, if x is an object\r\n                    // false in every other case\r\n\r\nNB, regexps, arrays, and functions are considered objects too.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const test = x =&gt;\r\n      console.assert\r\n        ( Object(x) === x\r\n        , `not an object: ${x}`\r\n        )\r\n\r\n    test(&quot;some string&quot;) // assertion failed\r\n    test(123)           // assertion failed\r\n    test(0)             // assertion failed\r\n    test(/some regex/)  \r\n    test([ 5, 6 ])      \r\n    test({ a: 1 })      \r\n    test(x =&gt; x + 1)    \r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nBut, checking for **Array** is a bit different -\r\n\r\n    Array.isArray(x) === x // true, if x is an array\r\n                           // false in every other case\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const test = x =&gt;\r\n      console.assert\r\n        ( Array.isArray(x)\r\n        , `not an array: ${x}`\r\n        )\r\n\r\n    test(&quot;some string&quot;) // assertion failed\r\n    test(123)           // assertion failed\r\n    test(0)             // assertion failed\r\n    test(/some regex/)  // assertion failed\r\n    test([ 5, 6 ])      \r\n    test({ a: 1 })      // assertion failed\r\n    test(x =&gt; x + 1)    // assertion failed\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThis technique does *not* work for **Functions** however -\r\n\r\n    Function(x) === x // always false\r\n\r\n\r\n"},{"score":2,"body_markdown":"A Typechecker helper:\r\n```\r\nfunction isFromType(variable, type){\r\n  if (typeof type == &#39;string&#39;) res = (typeof variable == type.toLowerCase())\r\n  else res = (variable.constructor == type)\r\n  return res\r\n}\r\n```\r\nusage:\r\n```\r\nisFromType(&#39;cs&#39;, &#39;string&#39;) //true\r\nisFromType(&#39;cs&#39;, String) //true\r\nisFromType([&#39;cs&#39;], Array) //true\r\nisFromType([&#39;cs&#39;], &#39;object&#39;) //false\r\n```\r\nAlso if you want it to be recursive(like Array that is an Object), you can use `instanceof`.\r\n\r\n(`[&#39;cs&#39;] instanceof Object //true`)"},{"score":15,"body_markdown":"    if (s &amp;&amp; typeof s.valueOf() === &quot;string&quot;) {\r\n      // s is a string\r\n    }\r\n\r\n\r\n\r\nWorks for both string literals `let s = &#39;blah&#39;` and for Object Strings `let s = new String(&#39;blah&#39;)`\r\n"},{"score":3,"body_markdown":"I&#39;m going to go a different route to the rest here, which try to tell if a variable is a specific, or a member of a specific set, of types.&lt;br&gt;\r\nJS is built on ducktyping; if something quacks like a string, we can and should use it like a string.\r\n\r\nIs `7` a string? Then why does `/\\d/.test(7)` work?&lt;br&gt;\r\nIs `{toString:()=&gt;(&#39;hello there&#39;)}` a string? Then why does `({toString:()=&gt;(&#39;hello there&#39;)}) + &#39;\\ngeneral kenobi!&#39;` work?&lt;br&gt;\r\nThese aren&#39;t questions about *should* the above work, the point is they do.\r\n\r\nSo I made a [`duckyString()` function](https://jsfiddle.net/o1sxzemg/)&lt;br&gt;\r\nBelow I test many cases not catered for by other answers. For each the code:\r\n\r\n - sets a string-like variable\r\n - runs an identical string operation on it and a real string to compare outputs (proving they can be treated like strings)\r\n - converts the string-like to a real string to show you `duckyString()` to normalise inputs for code that expects real strings\r\n\r\n&lt;!-- language-all: lang-js --&gt;\r\n\r\n    text = &#39;hello there&#39;;\r\n    out(text.replace(/e/g, &#39;E&#39;) + &#39; &#39; + &#39;hello there&#39;.replace(/e/g, &#39;E&#39;));\r\n    out(&#39;Is string? &#39; + duckyString(text) + &#39;\\t&quot;&#39; + duckyString(text, true) + &#39;&quot;\\n&#39;);\r\n    \r\n    text = new String(&#39;oh my&#39;);\r\n    out(text.toUpperCase() + &#39; &#39; + &#39;oh my&#39;.toUpperCase());\r\n    out(&#39;Is string? &#39; + duckyString(text) + &#39;\\t&quot;&#39; + duckyString(text, true) + &#39;&quot;\\n&#39;);\r\n    \r\n    text = 368;\r\n    out((text + &#39; is a big number&#39;) + &#39; &#39; + (&#39;368&#39; + &#39; is a big number&#39;));\r\n    out(&#39;Is string? &#39; + duckyString(text) + &#39;\\t&quot;&#39; + duckyString(text, true) + &#39;&quot;\\n&#39;);\r\n    \r\n    text = [&#39;\\uD83D&#39;, &#39;\\uDE07&#39;];\r\n    out(text[1].charCodeAt(0) + &#39; &#39; + &#39;&#128519;&#39;[1].charCodeAt(0));\r\n    out(&#39;Is string? &#39; + duckyString(text) + &#39;\\t&quot;&#39; + duckyString(text, true) + &#39;&quot;\\n&#39;);\r\n    \r\n    function Text() { this.math = 7; }; Text.prototype = {toString:function() { return this.math + 3 + &#39;&#39;; }}\r\n    text = new Text();\r\n    out(String.prototype.match.call(text, &#39;0&#39;) + &#39; &#39; + text.toString().match(&#39;0&#39;));\r\n    out(&#39;Is string? &#39; + duckyString(text) + &#39;\\t&quot;&#39; + duckyString(text, true) + &#39;&quot;\\n&#39;);\r\n\r\nThis is in the same vein as `!!x` as opposed to `x===true` and testing if something is array-*like* instead of necessitating an actual array.&lt;br&gt;\r\njQuery objects; are they arrays? No. Are they good enough? Yeah, you can run them through `Array.prototype` functions just fine.&lt;br&gt;\r\nIt&#39;s this flexibility that gives JS its power, and testing *for* strings specifically makes your code less interoperable.\r\n\r\nThe output of the above is:\r\n\r\n    hEllo thErE hEllo thErE\r\n    Is string? true\t&quot;hello there&quot;\r\n\r\n    OH MY OH MY\r\n    Is string? true\t&quot;oh my&quot;\r\n\r\n    368 is a big number 368 is a big number\r\n    Is string? true\t&quot;368&quot;\r\n\r\n    56839 56839\r\n    Is string? true\t&quot;&#128519;&quot;\r\n\r\n    0 0\r\n    Is string? true\t&quot;10&quot;\r\n\r\nSo, it&#39;s all about *why* you want to know if something&#39;s a string.&lt;br&gt;\r\nIf, like me, you arrived here from google and wanted to see if something was *string-like*, here&#39;s an answer.&lt;br&gt;\r\nIt isn&#39;t even expensive unless you&#39;re working with really long or deeply nested char arrays.&lt;br&gt;\r\nThis is because it is all if statements, no function calls like `.toString()`.&lt;br&gt;\r\n&lt;sub&gt;Except if you&#39;re trying to see if a char array with objects that only have `toString()`&#39;s or multi-byte characters, in which case there&#39;s no other way to check except to make the string, and count characters the bytes make up, respectively&lt;/sub&gt;\r\n\r\n    function duckyString(string, normalise, unacceptable) {\r\n        var type = null;\r\n        if (!unacceptable)\r\n            unacceptable = {};\r\n        if (string &amp;&amp; !unacceptable.chars &amp;&amp; unacceptable.to == null)\r\n            unacceptable.to = string.toString == Array.prototype.toString;\r\n\r\n        if (string == null)\r\n            ;\r\n\r\n        //tests if `string` just is a string\r\n        else if (\r\n            !unacceptable.is &amp;&amp;\r\n            (typeof string == &#39;string&#39; || string instanceof String)\r\n        )\r\n            type = &#39;is&#39;;\r\n\r\n        //tests if `string + &#39;&#39;` or `/./.test(string)` is valid\r\n        else if (\r\n            !unacceptable.to &amp;&amp;\r\n            string.toString &amp;&amp; typeof string.toString == &#39;function&#39; &amp;&amp; string.toString != Object.prototype.toString\r\n        )\r\n            type = &#39;to&#39;;\r\n\r\n        //tests if `[...string]` is valid\r\n        else if (\r\n            !unacceptable.chars &amp;&amp;\r\n            (string.length &gt; 0 || string.length == 0)\r\n        ) {\r\n            type = &#39;chars&#39;;\r\n            //for each char\r\n            for (var index = 0; type &amp;&amp; index &lt; string.length; ++index) {\r\n                var char = string[index];\r\n\r\n                //efficiently get its length\r\n                var length = ((duckyString(char, false, {to:true})) ?\r\n                    char :\r\n                    duckyString(char, true) || {}\r\n                ).length;\r\n\r\n                if (length == 1)\r\n                    continue;\r\n\r\n                //unicode surrogate-pair support\r\n                char = duckyString(char, true);\r\n                length = String.prototype[Symbol &amp;&amp; Symbol.iterator];\r\n                if (!(length = length &amp;&amp; length.call(char)) || length.next().done || !length.next().done)\r\n                    type = null;\r\n            }\r\n        }\r\n\r\n        //return true or false if they dont want to auto-convert to real string\r\n        if (!(type &amp;&amp; normalise))\r\n            //return truthy or falsy with &lt;type&gt;/null if they want why it&#39;s true\r\n            return (normalise == null) ? type != null : type;\r\n\r\n        //perform conversion\r\n        switch (type) {\r\n        case &#39;is&#39;:\r\n            return string;\r\n        case &#39;to&#39;:\r\n            return string.toString();\r\n        case &#39;chars&#39;:\r\n            return Array.from(string).join(&#39;&#39;);\r\n        }\r\n    }\r\n\r\nIncluded are options to\r\n\r\n - ask which method deemed it string-y\r\n - exclude methods of string-detection (eg if you dont like `.toString()`)\r\n\r\nHere are more tests because I&#39;m a completionist:\r\n\r\n    out(&#39;Edge-case testing&#39;)\r\n    function test(text, options) {\r\n    \tvar result = duckyString(text, false, options);\r\n        text = duckyString(text, true, options);\r\n    \tout(result + &#39; &#39; + ((result) ? &#39;&quot;&#39; + text + &#39;&quot;&#39; : text));\r\n    }\r\n    test(&#39;&#39;);\r\n    test(null);\r\n    test(undefined);\r\n    test(0);\r\n    test({length:0});\r\n    test({&#39;0&#39;:&#39;!&#39;, length:&#39;1&#39;});\r\n    test({});\r\n    test(window);\r\n    test(false);\r\n    test([&#39;hi&#39;]);\r\n    test([&#39;\\uD83D\\uDE07&#39;]);\r\n    test([[&#39;1&#39;], 2, new String(3)]);\r\n    test([[&#39;1&#39;], 2, new String(3)], {chars:true});\r\n\r\n - All negative cases seem to be accounted for\r\n - This should run on browsers &gt;= IE8\r\n - Char arrays with multiple bytes supported on browsers with string iterator support\r\n\r\nOutput:\r\n\r\n    Edge-case testing\r\n    is &quot;&quot;\r\n    null null\r\n    null null\r\n    to &quot;0&quot;\r\n    chars &quot;&quot;\r\n    chars &quot;!&quot;\r\n    null null\r\n    chars &quot;&quot;\r\n    to &quot;false&quot;\r\n    null null\r\n    chars &quot;&#128519;&quot;\r\n    chars &quot;123&quot;\r\n    to &quot;1,2,3&quot;"},{"score":7,"body_markdown":"# Performance\r\n\r\n\r\nToday 2020.09.17 I perform tests on MacOs HighSierra 10.13.6 on Chrome v85, Safari v13.1.2 and Firefox v80 for chosen solutions. \r\n\r\n\r\nResults\r\n-\r\n\r\nFor all browsers (and both test cases)\r\n\r\n* solutions `typeof||instanceof` (A, I) and `x===x+&#39;&#39;` (H) are fast/fastest\r\n* solution `_.isString` (lodash lib) is medium/fast\r\n* solutions B and K are slowest\r\n\r\n[![enter image description here][1]][1]\r\n\r\nUpdate: 2020.11.28 I update results for `x=123 Chrome` column - for solution `I` there was probably an error value before (=69M too low) - I use Chrome 86.0 to repeat tests.\r\n\r\nDetails\r\n-\r\n\r\nI perform 2 tests cases for solutions\r\n[A](https://stackoverflow.com/a/9436948/860099)\r\n[B](https://stackoverflow.com/a/17772086/860099)\r\n[C](https://stackoverflow.com/a/20958909/860099)\r\n[D](https://stackoverflow.com/a/20958909/860099)\r\n[E](https://stackoverflow.com/a/16215800/860099)\r\n[F](https://stackoverflow.com/a/42493631/860099)\r\n[G](https://stackoverflow.com/a/57443488/860099)\r\n[H](https://stackoverflow.com/a/19057360/860099)\r\n[I](https://stackoverflow.com/a/4059166/860099)\r\n[J](https://stackoverflow.com/a/28722301/860099)\r\n[K](https://stackoverflow.com/a/58892465/860099)\r\n[L](https://stackoverflow.com/a/9436948/860099)\r\n\r\n* when variable is string - you can run it [HERE](https://jsbench.me/whkf5hbrps/1)\r\n* when variable is NOT string - you can run it [HERE](https://jsbench.me/p0kf5vcq3c/1)\r\n\r\nBelow snippet presents differences between solutions\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // https://stackoverflow.com/a/9436948/860099\r\n    function A(x) {\r\n      return (typeof x == &#39;string&#39;) || (x instanceof String)\r\n    }\r\n\r\n    // https://stackoverflow.com/a/17772086/860099\r\n    function B(x) {\r\n      return Object.prototype.toString.call(x) === &quot;[object String]&quot;\r\n    }\r\n\r\n    // https://stackoverflow.com/a/20958909/860099\r\n    function C(x) {\r\n      return _.isString(x);\r\n    }\r\n\r\n    // https://stackoverflow.com/a/20958909/860099\r\n    function D(x) {\r\n      return $.type(x) === &quot;string&quot;;\r\n    }\r\n\r\n    // https://stackoverflow.com/a/16215800/860099\r\n    function E(x) {\r\n      return x?.constructor === String;\r\n    }\r\n\r\n    // https://stackoverflow.com/a/42493631/860099\r\n    function F(x){\r\n      return x?.charAt != null\r\n    }\r\n\r\n\r\n    // https://stackoverflow.com/a/57443488/860099\r\n    function G(x){\r\n      return String(x) === x\r\n    }\r\n\r\n    // https://stackoverflow.com/a/19057360/860099\r\n    function H(x){\r\n      return x === x + &#39;&#39;\r\n    }\r\n\r\n    // https://stackoverflow.com/a/4059166/860099\r\n    function I(x) {\r\n      return typeof x == &#39;string&#39;\r\n    }\r\n\r\n    // https://stackoverflow.com/a/28722301/860099\r\n    function J(x){\r\n      return x === x?.toString()\r\n    }\r\n\r\n    // https://stackoverflow.com/a/58892465/860099\r\n    function K(x){\r\n      return x &amp;&amp; typeof x.valueOf() === &quot;string&quot;\r\n    }\r\n\r\n    // https://stackoverflow.com/a/9436948/860099\r\n    function L(x) {\r\n      return x instanceof String\r\n    }\r\n\r\n    // ------------------\r\n    //     PRESENTATION\r\n    // ------------------\r\n\r\n    console.log(&#39;Solutions results for different inputs \\n\\n&#39;);\r\n    console.log(&quot;&#39;abc&#39; Str  &#39;&#39;  &#39; &#39; &#39;1&#39; &#39;0&#39;  1   0   {} [] true false null undef&quot;);\r\n\r\n    let tests = [ &#39;abc&#39;, new String(&quot;abc&quot;),&#39;&#39;,&#39; &#39;,&#39;1&#39;,&#39;0&#39;,1,0,{},[],true,false,null,undefined];\r\n\r\n    [A,B,C,D,E,F,G,H,I,J,K,L].map(f=&gt; {  \r\n    console.log(\r\n      `${f.name}   ` + tests.map(v=&gt; (1*!!f(v)) ).join`   `\r\n    )})\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js&quot; integrity=&quot;sha512-90vH1Z83AJY9DmlWa8WkjkV79yfS2n2Oxhsi2dZbIv0nC4E6m5AbH8Nh156kkM7JePmqD6tcZsfad1ueoaovww==&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;\r\n\r\n\r\n    This shippet only presents functions used in performance tests - it not perform tests itself!\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n\r\n\r\nAnd here are example results for chrome \r\n\r\n[![enter image description here][2]][2]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/cpaxI.png\r\n  [2]: https://i.stack.imgur.com/oCOIh.png"}],"score":1916}